import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-GEHV7EKW.js";

// node_modules/@hiyve/core/node_modules/@hiyve/rtc-client/dist/HumanSentimentAnalyser-B0jGsjJ0.js
var e = Object.defineProperty;
var t = (e20) => {
  throw TypeError(e20);
};
var n = (t2, n2) => {
  for (var r2 in n2) e(t2, r2, { get: n2[r2], enumerable: true });
};
var r = (t2, n2, r2) => ((t3, n3, r3) => n3 in t3 ? e(t3, n3, { enumerable: true, configurable: true, writable: true, value: r3 }) : t3[n3] = r3)(t2, "symbol" != typeof n2 ? n2 + "" : n2, r2);
var a = (e20, n2, r2) => n2.has(e20) || t("Cannot " + r2);
var i = (e20, t2, n2) => (a(e20, t2, "read from private field"), n2 ? n2.call(e20) : t2.get(e20));
var s = (e20, n2, r2) => n2.has(e20) ? t("Cannot add the same private member more than once") : n2 instanceof WeakSet ? n2.add(e20) : n2.set(e20, r2);
var o = (e20, t2, n2, r2) => (a(e20, t2, "write to private field"), t2.set(e20, n2), n2);
var l = {};
n(l, { Abs() {
  return Ue;
}, Acos() {
  return je;
}, Acosh() {
  return Ge;
}, AdadeltaOptimizer() {
  return Sp;
}, AdagradOptimizer() {
  return Ip;
}, AdamOptimizer() {
  return Ep;
}, AdamaxOptimizer() {
  return Tp;
}, Add() {
  return He;
}, AddN() {
  return Xe;
}, All() {
  return qe;
}, Any() {
  return Ze;
}, ArgMax() {
  return Ke;
}, ArgMin() {
  return Ye;
}, Asin() {
  return Je;
}, Asinh() {
  return Qe;
}, Atan() {
  return et;
}, Atan2() {
  return nt;
}, Atanh() {
  return tt;
}, AvgPool() {
  return rt;
}, AvgPool3D() {
  return it;
}, AvgPool3DGrad() {
  return st;
}, AvgPoolGrad() {
  return at;
}, BackendWasm() {
  return xD;
}, BatchMatMul() {
  return ot;
}, BatchToSpaceND() {
  return lt;
}, Bincount() {
  return ut;
}, BitwiseAnd() {
  return dt;
}, BroadcastArgs() {
  return ht;
}, BroadcastTo() {
  return ct;
}, Cast() {
  return pt;
}, Ceil() {
  return ft;
}, ClipByValue() {
  return mt;
}, Complex() {
  return At;
}, ComplexAbs() {
  return xt;
}, Concat() {
  return yt;
}, Conv2D() {
  return bt;
}, Conv2DBackpropFilter() {
  return gt;
}, Conv2DBackpropInput() {
  return vt;
}, Conv3D() {
  return wt;
}, Conv3DBackpropFilterV2() {
  return kt;
}, Conv3DBackpropInputV2() {
  return Nt;
}, Cos() {
  return Ct;
}, Cosh() {
  return $t;
}, CropAndResize() {
  return It;
}, Cumprod() {
  return Rt;
}, Cumsum() {
  return St;
}, DataStorage() {
  return _;
}, DenseBincount() {
  return Et;
}, DepthToSpace() {
  return Tt;
}, DepthwiseConv2dNative() {
  return Mt;
}, DepthwiseConv2dNativeBackpropFilter() {
  return Ot;
}, DepthwiseConv2dNativeBackpropInput() {
  return Ft;
}, Diag() {
  return Pt;
}, Dilation2D() {
  return zt;
}, Dilation2DBackpropFilter() {
  return _t;
}, Dilation2DBackpropInput() {
  return Vt;
}, Draw() {
  return Dt;
}, ENV() {
  return We;
}, Einsum() {
  return Lt;
}, Elu() {
  return Bt;
}, EluGrad() {
  return Ut;
}, Environment() {
  return ze;
}, Equal() {
  return Gt;
}, Erf() {
  return jt;
}, Exp() {
  return Ht;
}, ExpandDims() {
  return Xt;
}, Expm1() {
  return qt;
}, FFT() {
  return Zt;
}, Fill() {
  return Kt;
}, FlipLeftRight() {
  return Yt;
}, Floor() {
  return Jt;
}, FloorDiv() {
  return Qt;
}, FromPixels() {
  return ra;
}, FusedBatchNorm() {
  return en;
}, FusedConv2D() {
  return sa;
}, FusedDepthwiseConv2D() {
  return oa;
}, GPGPUContext() {
  return $$;
}, GatherNd() {
  return nn;
}, GatherV2() {
  return tn;
}, GraphModel() {
  return Fx;
}, Greater() {
  return rn;
}, GreaterEqual() {
  return an;
}, IFFT() {
  return on;
}, Identity() {
  return sn;
}, Imag() {
  return ln;
}, IsFinite() {
  return un;
}, IsInf() {
  return dn;
}, IsNan() {
  return cn;
}, KernelBackend() {
  return D;
}, LRN() {
  return Nn;
}, LRNGrad() {
  return Cn;
}, LeakyRelu() {
  return hn;
}, Less() {
  return pn;
}, LessEqual() {
  return fn;
}, LinSpace() {
  return mn;
}, Log() {
  return An;
}, Log1p() {
  return xn;
}, LogSoftmax() {
  return wn;
}, LogicalAnd() {
  return yn;
}, LogicalNot() {
  return bn;
}, LogicalOr() {
  return gn;
}, LogicalXor() {
  return vn;
}, LowerBound() {
  return kn;
}, MathBackendCPU() {
  return Wx;
}, MathBackendWebGL() {
  return LR;
}, MatrixBandPart() {
  return $n;
}, Max() {
  return Rn;
}, MaxPool() {
  return In;
}, MaxPool3D() {
  return Tn;
}, MaxPool3DGrad() {
  return Mn;
}, MaxPoolGrad() {
  return En;
}, MaxPoolWithArgmax() {
  return On;
}, Maximum() {
  return Sn;
}, Mean() {
  return Fn;
}, Min() {
  return Pn;
}, Minimum() {
  return zn;
}, MirrorPad() {
  return Vn;
}, Mod() {
  return _n;
}, MomentumOptimizer() {
  return Op;
}, Multinomial() {
  return Dn;
}, Multiply() {
  return Wn;
}, Neg() {
  return Ln;
}, NonMaxSuppressionV3() {
  return Un;
}, NonMaxSuppressionV4() {
  return jn;
}, NonMaxSuppressionV5() {
  return Gn;
}, NotEqual() {
  return Bn;
}, OP_SCOPE_SUFFIX() {
  return Di;
}, OneHot() {
  return Xn;
}, OnesLike() {
  return Hn;
}, Optimizer() {
  return Rp;
}, OptimizerConstructors() {
  return _f;
}, Pack() {
  return qn;
}, PadV2() {
  return Zn;
}, Pool() {
  return Kn;
}, Pow() {
  return Yn;
}, Prelu() {
  return Jn;
}, Prod() {
  return Qn;
}, RMSPropOptimizer() {
  return Fp;
}, RaggedGather() {
  return er;
}, RaggedRange() {
  return tr;
}, RaggedTensorToTensor() {
  return nr;
}, Range() {
  return rr;
}, Rank() {
  return ii;
}, Real() {
  return ar;
}, RealDiv() {
  return Wt;
}, Reciprocal() {
  return ir;
}, Reduction() {
  return qh;
}, Relu() {
  return sr;
}, Relu6() {
  return hr;
}, Reshape() {
  return or;
}, ResizeBilinear() {
  return dr;
}, ResizeBilinearGrad() {
  return cr;
}, ResizeNearestNeighbor() {
  return lr;
}, ResizeNearestNeighborGrad() {
  return ur;
}, Reverse() {
  return pr;
}, RotateWithOffset() {
  return aa;
}, Round() {
  return fr;
}, Rsqrt() {
  return mr;
}, SGDOptimizer() {
  return Mp;
}, ScatterNd() {
  return Ar;
}, SearchSorted() {
  return yr;
}, Select() {
  return br;
}, Selu() {
  return gr;
}, Sigmoid() {
  return Cr;
}, Sign() {
  return Nr;
}, Sin() {
  return wr;
}, Sinh() {
  return kr;
}, Slice() {
  return vr;
}, Softmax() {
  return Tr;
}, Softplus() {
  return $r;
}, SpaceToBatchND() {
  return Ir;
}, SparseFillEmptyRows() {
  return Mr;
}, SparseReshape() {
  return Or;
}, SparseSegmentMean() {
  return Fr;
}, SparseSegmentSum() {
  return Pr;
}, SparseToDense() {
  return zr;
}, SplitV() {
  return Er;
}, Sqrt() {
  return Rr;
}, Square() {
  return _r;
}, SquaredDifference() {
  return Vr;
}, StaticRegexReplace() {
  return Dr;
}, Step() {
  return na;
}, StridedSlice() {
  return Wr;
}, StringNGrams() {
  return Lr;
}, StringSplit() {
  return Br;
}, StringToHashBucketFast() {
  return Ur;
}, Sub() {
  return jr;
}, Sum() {
  return Sr;
}, Tan() {
  return Gr;
}, Tanh() {
  return Hr;
}, Tensor() {
  return ni;
}, TensorBuffer() {
  return Qa;
}, TensorScatterUpdate() {
  return xr;
}, Tile() {
  return Xr;
}, TopK() {
  return qr;
}, Transform() {
  return Zr;
}, Transpose() {
  return Kr;
}, Unique() {
  return Yr;
}, Unpack() {
  return Jr;
}, UnsortedSegmentSum() {
  return Qr;
}, UpperBound() {
  return ea;
}, Variable() {
  return ai;
}, WebGPUBackend() {
  return fW;
}, ZerosLike() {
  return ta;
}, o() {
  return ia;
}, abs() {
  return yo;
}, acos() {
  return bo;
}, acosh() {
  return go;
}, add() {
  return fo;
}, addN() {
  return vo;
}, all() {
  return wo;
}, any() {
  return ko;
}, argMax() {
  return No;
}, argMin() {
  return Co;
}, asin() {
  return $o;
}, asinh() {
  return Ro;
}, atan() {
  return So;
}, atan2() {
  return Io;
}, atanh() {
  return Eo;
}, avgPool() {
  return Xo;
}, avgPool3d() {
  return qo;
}, backend() {
  return cs;
}, backend_util() {
  return Uf;
}, basicLSTMCell() {
  return el;
}, batchNorm() {
  return rl;
}, batchNorm2d() {
  return al;
}, batchNorm3d() {
  return il;
}, batchNorm4d() {
  return sl;
}, batchToSpaceND() {
  return tl;
}, bincount() {
  return ol;
}, bitwiseAnd() {
  return ll;
}, booleanMaskAsync() {
  return Jc;
}, broadcastArgs() {
  return ul;
}, broadcastTo() {
  return dl;
}, broadcast_util() {
  return Fl;
}, browser() {
  return of;
}, buffer() {
  return uo;
}, cast() {
  return co;
}, ceil() {
  return cl;
}, clipByValue() {
  return pl;
}, clone() {
  return ho;
}, complex() {
  return Li;
}, concat() {
  return Zo;
}, concat1d() {
  return fl;
}, concat2d() {
  return ml;
}, concat3d() {
  return Al;
}, concat4d() {
  return xl;
}, conv1d() {
  return bl;
}, conv2d() {
  return yl;
}, conv2dTranspose() {
  return vl;
}, conv3d() {
  return wl;
}, conv3dTranspose() {
  return Nl;
}, copyRegisteredKernels() {
  return ba;
}, cos() {
  return Cl;
}, cosh() {
  return $l;
}, cosineWindow() {
  return sh;
}, cumprod() {
  return Rl;
}, cumsum() {
  return Sl;
}, customGrad() {
  return zu;
}, denseBincount() {
  return Il;
}, deprecationWarn() {
  return Zi;
}, depthToSpace() {
  return El;
}, depthwiseConv2d() {
  return Tl;
}, deregisterOp() {
  return tA;
}, device_util() {
  return Ii;
}, diag() {
  return Ml;
}, dilation2d() {
  return Ol;
}, disableDeprecationWarnings() {
  return qi;
}, dispose() {
  return ts;
}, disposeVariables() {
  return Ki;
}, div() {
  return Ao;
}, divNoNan() {
  return Ll;
}, dot() {
  return Bl;
}, dropout() {
  return ah;
}, einsum() {
  return Ul;
}, elu() {
  return jl;
}, enableDebugMode() {
  return Xi;
}, enableProdMode() {
  return Hi;
}, enclosingPowerOfTwo() {
  return ih;
}, engine() {
  return Yi;
}, ensureShape() {
  return Gl;
}, env() {
  return _e;
}, equal() {
  return _l;
}, erf() {
  return Hl;
}, euclideanNorm() {
  return du;
}, exp() {
  return cu;
}, expandDims() {
  return hu;
}, expm1() {
  return pu;
}, eye() {
  return mu;
}, fft() {
  return vc;
}, fill() {
  return hl;
}, findBackend() {
  return ls;
}, findBackendFactory() {
  return us;
}, floor() {
  return Au;
}, floorDiv() {
  return mo;
}, forceHalfFloat() {
  return UR;
}, fused() {
  return lh;
}, gather() {
  return xu;
}, gatherND() {
  return rh;
}, gather_util() {
  return mf;
}, getBackend() {
  return ss;
}, getGradient() {
  return pa;
}, getKernel() {
  return ha;
}, getKernelsForBackend() {
  return fa;
}, getThreadsCount() {
  return ED;
}, gpgpu_util() {
  return r$;
}, grad() {
  return Tu;
}, grads() {
  return Mu;
}, greater() {
  return yu;
}, greaterEqual() {
  return bu;
}, ifft() {
  return wc;
}, imag() {
  return gu;
}, image() {
  return mp;
}, inTopKAsync() {
  return oh;
}, io() {
  return zp;
}, irfft() {
  return kc;
}, isFinite() {
  return vu;
}, isInf() {
  return wu;
}, isNaN() {
  return ku;
}, keep() {
  return ns;
}, kernel_impls() {
  return Ym;
}, leakyRelu() {
  return Nu;
}, less() {
  return Cu;
}, lessEqual() {
  return $u;
}, linalg() {
  return Ap;
}, linspace() {
  return Ru;
}, loadGraphModel() {
  return Px;
}, loadGraphModelSync() {
  return zx;
}, localResponseNormalization() {
  return Su;
}, log() {
  return Iu;
}, log1p() {
  return Eu;
}, logSigmoid() {
  return Wu;
}, logSoftmax() {
  return Bu;
}, logSumExp() {
  return Uu;
}, logicalAnd() {
  return ju;
}, logicalNot() {
  return Gu;
}, logicalOr() {
  return Hu;
}, logicalXor() {
  return Xu;
}, losses() {
  return xp;
}, lowerBound() {
  return Ku;
}, matMul() {
  return Ko;
}, math() {
  return rf;
}, max() {
  return tu;
}, maxPool() {
  return Yu;
}, maxPool3d() {
  return Ju;
}, maxPoolWithArgmax() {
  return Qu;
}, maximum() {
  return ed;
}, mean() {
  return td;
}, memory() {
  return Ji;
}, meshgrid() {
  return ad;
}, min() {
  return nu;
}, minimum() {
  return id;
}, mirrorPad() {
  return sd;
}, mod() {
  return od;
}, moments() {
  return ld;
}, movingAverage() {
  return eh;
}, mul() {
  return xo;
}, multiRNNCell() {
  return ud;
}, multinomial() {
  return dd;
}, neg() {
  return _u;
}, nextFrame() {
  return Lf;
}, node() {
  return mX;
}, norm() {
  return uu;
}, notEqual() {
  return cd;
}, oneHot() {
  return hd;
}, ones() {
  return rd;
}, onesLike() {
  return pd;
}, op() {
  return Wi;
}, outerProduct() {
  return fd;
}, pad() {
  return md;
}, pad1d() {
  return Ad;
}, pad2d() {
  return xd;
}, pad3d() {
  return yd;
}, pad4d() {
  return bd;
}, pool() {
  return vd;
}, pow() {
  return ru;
}, prelu() {
  return wd;
}, print() {
  return po;
}, prod() {
  return kd;
}, profile() {
  return Qi;
}, raggedGather() {
  return Nd;
}, raggedRange() {
  return Cd;
}, raggedTensorToTensor() {
  return $d;
}, rand() {
  return Rd;
}, randomGamma() {
  return Xd;
}, randomNormal() {
  return qd;
}, randomStandardNormal() {
  return Zd;
}, randomUniform() {
  return Kd;
}, randomUniformInt() {
  return Yd;
}, range() {
  return Jd;
}, ready() {
  return is;
}, real() {
  return Qd;
}, reciprocal() {
  return ec;
}, registerBackend() {
  return ds;
}, registerGradient() {
  return Aa;
}, registerKernel() {
  return ma;
}, registerOp() {
  return Qm;
}, relu() {
  return tc;
}, relu6() {
  return nc;
}, removeBackend() {
  return os;
}, reshape() {
  return Ho;
}, reverse() {
  return rc;
}, reverse1d() {
  return ac;
}, reverse2d() {
  return ic;
}, reverse3d() {
  return sc;
}, reverse4d() {
  return oc;
}, rfft() {
  return Cc;
}, round() {
  return lc;
}, rsqrt() {
  return uc;
}, scalar() {
  return au;
}, scatterND() {
  return th;
}, scatter_util() {
  return _c;
}, searchSorted() {
  return Zu;
}, selu() {
  return dc;
}, separableConv2d() {
  return cc;
}, serialization() {
  return gp;
}, setBackend() {
  return as;
}, setPlatform() {
  return hs;
}, setThreadsCount() {
  return ID;
}, setWasmPath() {
  return CD;
}, setWasmPaths() {
  return $D;
}, setWebGLContext() {
  return kN;
}, setdiff1dAsync() {
  return hc;
}, shared() {
  return Lx;
}, sigmoid() {
  return Yo;
}, sign() {
  return pc;
}, signal() {
  return fp;
}, sin() {
  return fc;
}, sinh() {
  return mc;
}, slice() {
  return Jo;
}, slice1d() {
  return Ac;
}, slice2d() {
  return xc;
}, slice3d() {
  return yc;
}, slice4d() {
  return bc;
}, slice_util() {
  return xf;
}, softmax() {
  return gc;
}, softplus() {
  return Du;
}, spaceToBatchND() {
  return gd;
}, sparse() {
  return yp;
}, sparseToDense() {
  return nh;
}, spectral() {
  return pp;
}, split() {
  return Nc;
}, sqrt() {
  return iu;
}, square() {
  return su;
}, squaredDifference() {
  return $c;
}, squeeze() {
  return Rc;
}, stack() {
  return Sc;
}, step() {
  return Ic;
}, stridedSlice() {
  return Ec;
}, string() {
  return bp;
}, sub() {
  return Lu;
}, sum() {
  return ou;
}, sumOutType() {
  return fi;
}, tan() {
  return Tc;
}, tanh() {
  return Qo;
}, tensor() {
  return Ui;
}, tensor1d() {
  return Mc;
}, tensor2d() {
  return Oc;
}, tensor3d() {
  return Fc;
}, tensor4d() {
  return Pc;
}, tensor5d() {
  return zc;
}, tensor6d() {
  return Vc;
}, tensorScatterUpdate() {
  return Bc;
}, tensor_util() {
  return ci;
}, test_util() {
  return Id;
}, tidy() {
  return es;
}, tile() {
  return fu;
}, time() {
  return rs;
}, topk() {
  return Uc;
}, train() {
  return Df;
}, transpose() {
  return Qc;
}, truncatedNormal() {
  return jc;
}, unique() {
  return Gc;
}, unregisterGradient() {
  return ya;
}, unregisterKernel() {
  return xa;
}, unsortedSegmentSum() {
  return Hc;
}, unstack() {
  return Xc;
}, upcastType() {
  return pi;
}, upperBound() {
  return qc;
}, util() {
  return va;
}, valueAndGrad() {
  return Ou;
}, valueAndGrads() {
  return Fu;
}, variable() {
  return Zc;
}, variableGrads() {
  return Pu;
}, version() {
  return fX;
}, version_converter() {
  return Vx;
}, version_core() {
  return Vf;
}, version_cpu() {
  return cg;
}, version_wasm() {
  return TD;
}, version_webgl() {
  return BR;
}, webgl() {
  return jR;
}, webgl_util() {
  return xN;
}, webgpu_util() {
  return QD;
}, where() {
  return Dl;
}, whereAsync() {
  return Yc;
}, zeros() {
  return nd;
}, zerosLike() {
  return Wl;
} });
var u = Object.create;
var d = Object.defineProperty;
var c = Object.getOwnPropertyDescriptor;
var h = Object.getOwnPropertyNames;
var p = Object.getPrototypeOf;
var f = {}.hasOwnProperty;
var m = (e20, t2) => () => (t2 || e20((t2 = { exports: {} }).exports, t2), t2.exports);
var A = (e20, t2) => {
  for (var n2 in t2) d(e20, n2, { get: t2[n2], enumerable: true });
};
var x = (e20, t2, n2) => (n2 = null != e20 ? u(p(e20)) : {}, ((e21, t3, n3, r2) => {
  if (t3 && "object" == typeof t3 || "function" == typeof t3) for (let a2 of h(t3)) !f.call(e21, a2) && void 0 !== a2 && d(e21, a2, { get: () => t3[a2], enumerable: !(r2 = c(t3, a2)) || r2.enumerable });
  return e21;
})(e20 && e20.l ? n2 : d(n2, "default", { value: e20, enumerable: true }), e20));
var y = m((e20, t2) => {
  t2.exports = r2;
  var n2 = null;
  try {
    n2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch (si2) {
  }
  function r2(e21, t3, n3) {
    this.low = 0 | e21, this.high = 0 | t3, this.unsigned = !!n3;
  }
  function a2(e21) {
    return true === (e21 && e21.u);
  }
  Object.defineProperty(r2.prototype, "u", { value: true }), r2.isLong = a2;
  var i2 = {}, s2 = {};
  function o2(e21, t3) {
    var n3, r3, a3;
    return t3 ? (a3 = (e21 >>>= 0) >= 0 && 256 > e21) && (r3 = s2[e21]) ? r3 : (n3 = u2(e21, 0 > (0 | e21) ? -1 : 0, true), a3 && (s2[e21] = n3), n3) : (a3 = (e21 |= 0) >= -128 && 128 > e21) && (r3 = i2[e21]) ? r3 : (n3 = u2(e21, 0 > e21 ? -1 : 0, false), a3 && (i2[e21] = n3), n3);
  }
  function l2(e21, t3) {
    if (isNaN(e21)) return t3 ? y2 : x2;
    if (t3) {
      if (0 > e21) return y2;
      if (e21 >= f2) return k2;
    } else {
      if (-m2 >= e21) return N2;
      if (e21 + 1 >= m2) return w2;
    }
    return 0 > e21 ? l2(-e21, t3).neg() : u2(e21 % p2 | 0, e21 / p2 | 0, t3);
  }
  function u2(e21, t3, n3) {
    return new r2(e21, t3, n3);
  }
  r2.fromInt = o2, r2.fromNumber = l2, r2.fromBits = u2;
  var d2 = Math.pow;
  function c2(e21, t3, n3) {
    if (0 === e21.length) throw Error("empty string");
    if ("NaN" === e21 || "Infinity" === e21 || "+Infinity" === e21 || "-Infinity" === e21) return x2;
    if ("number" == typeof t3 ? (n3 = t3, t3 = false) : t3 = !!t3, 2 > (n3 = n3 || 10) || n3 > 36) throw RangeError("radix");
    var r3;
    if ((r3 = e21.indexOf("-")) > 0) throw Error("interior hyphen");
    if (0 === r3) return c2(e21.substring(1), t3, n3).neg();
    for (var a3 = l2(d2(n3, 8)), i3 = x2, s3 = 0; e21.length > s3; s3 += 8) {
      var o3 = Math.min(8, e21.length - s3), u3 = parseInt(e21.substring(s3, s3 + o3), n3);
      if (8 > o3) {
        var h3 = l2(d2(n3, o3));
        i3 = i3.mul(h3).add(l2(u3));
      } else i3 = (i3 = i3.mul(a3)).add(l2(u3));
    }
    return i3.unsigned = t3, i3;
  }
  function h2(e21, t3) {
    return "number" == typeof e21 ? l2(e21, t3) : "string" == typeof e21 ? c2(e21, t3) : u2(e21.low, e21.high, "boolean" == typeof t3 ? t3 : e21.unsigned);
  }
  r2.fromString = c2, r2.fromValue = h2;
  var p2 = 4294967296, f2 = p2 * p2, m2 = f2 / 2, A2 = o2(1 << 24), x2 = o2(0);
  r2.ZERO = x2;
  var y2 = o2(0, true);
  r2.UZERO = y2;
  var b2 = o2(1);
  r2.ONE = b2;
  var g2 = o2(1, true);
  r2.UONE = g2;
  var v2 = o2(-1);
  r2.NEG_ONE = v2;
  var w2 = u2(-1, 2147483647, false);
  r2.MAX_VALUE = w2;
  var k2 = u2(-1, -1, true);
  r2.MAX_UNSIGNED_VALUE = k2;
  var N2 = u2(0, -2147483648, false);
  r2.MIN_VALUE = N2;
  var C2 = r2.prototype;
  C2.toInt = function() {
    return this.unsigned ? this.low >>> 0 : this.low;
  }, C2.toNumber = function() {
    return this.unsigned ? (this.high >>> 0) * p2 + (this.low >>> 0) : this.high * p2 + (this.low >>> 0);
  }, C2.toString = function(e21) {
    if (2 > (e21 = e21 || 10) || e21 > 36) throw RangeError("radix");
    if (this.isZero()) return "0";
    if (this.isNegative()) {
      if (this.eq(N2)) {
        var t3 = l2(e21), n3 = this.div(t3), r3 = n3.mul(t3).sub(this);
        return n3.toString(e21) + r3.toInt().toString(e21);
      }
      return "-" + this.neg().toString(e21);
    }
    for (var a3 = l2(d2(e21, 6), this.unsigned), i3 = this, s3 = ""; ; ) {
      var o3 = i3.div(a3), u3 = (i3.sub(o3.mul(a3)).toInt() >>> 0).toString(e21);
      if ((i3 = o3).isZero()) return u3 + s3;
      for (; 6 > u3.length; ) u3 = "0" + u3;
      s3 = "" + u3 + s3;
    }
  }, C2.getHighBits = function() {
    return this.high;
  }, C2.getHighBitsUnsigned = function() {
    return this.high >>> 0;
  }, C2.getLowBits = function() {
    return this.low;
  }, C2.getLowBitsUnsigned = function() {
    return this.low >>> 0;
  }, C2.getNumBitsAbs = function() {
    if (this.isNegative()) return this.eq(N2) ? 64 : this.neg().getNumBitsAbs();
    for (var e21 = 0 != this.high ? this.high : this.low, t3 = 31; t3 > 0 && !(e21 & 1 << t3); t3--) ;
    return 0 != this.high ? t3 + 33 : t3 + 1;
  }, C2.isZero = function() {
    return 0 === this.high && 0 === this.low;
  }, C2.eqz = C2.isZero, C2.isNegative = function() {
    return !this.unsigned && 0 > this.high;
  }, C2.isPositive = function() {
    return this.unsigned || this.high >= 0;
  }, C2.isOdd = function() {
    return !(1 & ~this.low);
  }, C2.isEven = function() {
    return !(1 & this.low);
  }, C2.equals = function(e21) {
    return a2(e21) || (e21 = h2(e21)), (this.unsigned === e21.unsigned || this.high >>> 31 != 1 || e21.high >>> 31 != 1) && this.high === e21.high && this.low === e21.low;
  }, C2.eq = C2.equals, C2.notEquals = function(e21) {
    return !this.eq(e21);
  }, C2.neq = C2.notEquals, C2.ne = C2.notEquals, C2.lessThan = function(e21) {
    return 0 > this.comp(e21);
  }, C2.lt = C2.lessThan, C2.lessThanOrEqual = function(e21) {
    return 0 >= this.comp(e21);
  }, C2.lte = C2.lessThanOrEqual, C2.le = C2.lessThanOrEqual, C2.greaterThan = function(e21) {
    return this.comp(e21) > 0;
  }, C2.gt = C2.greaterThan, C2.greaterThanOrEqual = function(e21) {
    return this.comp(e21) >= 0;
  }, C2.gte = C2.greaterThanOrEqual, C2.ge = C2.greaterThanOrEqual, C2.compare = function(e21) {
    if (a2(e21) || (e21 = h2(e21)), this.eq(e21)) return 0;
    var t3 = this.isNegative(), n3 = e21.isNegative();
    return t3 && !n3 ? -1 : !t3 && n3 ? 1 : this.unsigned ? e21.high >>> 0 > this.high >>> 0 || e21.high === this.high && e21.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e21).isNegative() ? -1 : 1;
  }, C2.comp = C2.compare, C2.negate = function() {
    return !this.unsigned && this.eq(N2) ? N2 : this.not().add(b2);
  }, C2.neg = C2.negate, C2.add = function(e21) {
    a2(e21) || (e21 = h2(e21));
    var t3 = 0, n3 = 0, r3 = 0, i3 = 0;
    return r3 += (i3 += (65535 & this.low) + (65535 & e21.low)) >>> 16, n3 += (r3 += (this.low >>> 16) + (e21.low >>> 16)) >>> 16, t3 += (n3 += (65535 & this.high) + (65535 & e21.high)) >>> 16, t3 += (this.high >>> 16) + (e21.high >>> 16), u2((r3 &= 65535) << 16 | (i3 &= 65535), (t3 &= 65535) << 16 | (n3 &= 65535), this.unsigned);
  }, C2.subtract = function(e21) {
    return a2(e21) || (e21 = h2(e21)), this.add(e21.neg());
  }, C2.sub = C2.subtract, C2.multiply = function(e21) {
    if (this.isZero()) return x2;
    if (a2(e21) || (e21 = h2(e21)), n2) return u2(n2.mul(this.low, this.high, e21.low, e21.high), n2.get_high(), this.unsigned);
    if (e21.isZero()) return x2;
    if (this.eq(N2)) return e21.isOdd() ? N2 : x2;
    if (e21.eq(N2)) return this.isOdd() ? N2 : x2;
    if (this.isNegative()) return e21.isNegative() ? this.neg().mul(e21.neg()) : this.neg().mul(e21).neg();
    if (e21.isNegative()) return this.mul(e21.neg()).neg();
    if (this.lt(A2) && e21.lt(A2)) return l2(this.toNumber() * e21.toNumber(), this.unsigned);
    var t3 = 65535 & this.high, r3 = this.low >>> 16, i3 = 65535 & this.low, s3 = 65535 & e21.high, o3 = e21.low >>> 16, d3 = 65535 & e21.low, c3 = 0, p3 = 0, f3 = 0, m3 = 0;
    return f3 += (m3 += i3 * d3) >>> 16, p3 += (f3 += r3 * d3) >>> 16, f3 &= 65535, p3 += (f3 += i3 * o3) >>> 16, c3 += (p3 += t3 * d3) >>> 16, p3 &= 65535, c3 += (p3 += r3 * o3) >>> 16, p3 &= 65535, c3 += (p3 += i3 * s3) >>> 16, c3 += (this.high >>> 16) * d3 + t3 * o3 + r3 * s3 + i3 * (e21.high >>> 16), u2((f3 &= 65535) << 16 | (m3 &= 65535), (c3 &= 65535) << 16 | (p3 &= 65535), this.unsigned);
  }, C2.mul = C2.multiply, C2.divide = function(e21) {
    if (a2(e21) || (e21 = h2(e21)), e21.isZero()) throw Error("division by zero");
    var t3, r3, i3;
    if (n2) return this.unsigned || -2147483648 !== this.high || -1 !== e21.low || -1 !== e21.high ? u2((this.unsigned ? n2.div_u : n2.div_s)(this.low, this.high, e21.low, e21.high), n2.get_high(), this.unsigned) : this;
    if (this.isZero()) return this.unsigned ? y2 : x2;
    if (this.unsigned) {
      if (e21.unsigned || (e21 = e21.toUnsigned()), e21.gt(this)) return y2;
      if (e21.gt(this.shru(1))) return g2;
      i3 = y2;
    } else {
      if (this.eq(N2)) return e21.eq(b2) || e21.eq(v2) ? N2 : e21.eq(N2) ? b2 : (t3 = this.shr(1).div(e21).shl(1)).eq(x2) ? e21.isNegative() ? b2 : v2 : (r3 = this.sub(e21.mul(t3)), i3 = t3.add(r3.div(e21)));
      if (e21.eq(N2)) return this.unsigned ? y2 : x2;
      if (this.isNegative()) return e21.isNegative() ? this.neg().div(e21.neg()) : this.neg().div(e21).neg();
      if (e21.isNegative()) return this.div(e21.neg()).neg();
      i3 = x2;
    }
    for (r3 = this; r3.gte(e21); ) {
      t3 = Math.max(1, Math.floor(r3.toNumber() / e21.toNumber()));
      for (var s3 = Math.ceil(Math.log(t3) / Math.LN2), o3 = s3 > 48 ? d2(2, s3 - 48) : 1, c3 = l2(t3), p3 = c3.mul(e21); p3.isNegative() || p3.gt(r3); ) p3 = (c3 = l2(t3 -= o3, this.unsigned)).mul(e21);
      c3.isZero() && (c3 = b2), i3 = i3.add(c3), r3 = r3.sub(p3);
    }
    return i3;
  }, C2.div = C2.divide, C2.modulo = function(e21) {
    return a2(e21) || (e21 = h2(e21)), n2 ? u2((this.unsigned ? n2.rem_u : n2.rem_s)(this.low, this.high, e21.low, e21.high), n2.get_high(), this.unsigned) : this.sub(this.div(e21).mul(e21));
  }, C2.mod = C2.modulo, C2.rem = C2.modulo, C2.not = function() {
    return u2(~this.low, ~this.high, this.unsigned);
  }, C2.and = function(e21) {
    return a2(e21) || (e21 = h2(e21)), u2(this.low & e21.low, this.high & e21.high, this.unsigned);
  }, C2.or = function(e21) {
    return a2(e21) || (e21 = h2(e21)), u2(this.low | e21.low, this.high | e21.high, this.unsigned);
  }, C2.xor = function(e21) {
    return a2(e21) || (e21 = h2(e21)), u2(this.low ^ e21.low, this.high ^ e21.high, this.unsigned);
  }, C2.shiftLeft = function(e21) {
    return a2(e21) && (e21 = e21.toInt()), 0 == (e21 &= 63) ? this : 32 > e21 ? u2(this.low << e21, this.high << e21 | this.low >>> 32 - e21, this.unsigned) : u2(0, this.low << e21 - 32, this.unsigned);
  }, C2.shl = C2.shiftLeft, C2.shiftRight = function(e21) {
    return a2(e21) && (e21 = e21.toInt()), 0 == (e21 &= 63) ? this : 32 > e21 ? u2(this.low >>> e21 | this.high << 32 - e21, this.high >> e21, this.unsigned) : u2(this.high >> e21 - 32, 0 > this.high ? -1 : 0, this.unsigned);
  }, C2.shr = C2.shiftRight, C2.shiftRightUnsigned = function(e21) {
    if (a2(e21) && (e21 = e21.toInt()), 0 == (e21 &= 63)) return this;
    var t3 = this.high;
    return 32 > e21 ? u2(this.low >>> e21 | t3 << 32 - e21, t3 >>> e21, this.unsigned) : u2(32 === e21 ? t3 : t3 >>> e21 - 32, 0, this.unsigned);
  }, C2.shru = C2.shiftRightUnsigned, C2.shr_u = C2.shiftRightUnsigned, C2.toSigned = function() {
    return this.unsigned ? u2(this.low, this.high, false) : this;
  }, C2.toUnsigned = function() {
    return this.unsigned ? this : u2(this.low, this.high, true);
  }, C2.toBytes = function(e21) {
    return e21 ? this.toBytesLE() : this.toBytesBE();
  }, C2.toBytesLE = function() {
    var e21 = this.high, t3 = this.low;
    return [255 & t3, t3 >>> 8 & 255, t3 >>> 16 & 255, t3 >>> 24, 255 & e21, e21 >>> 8 & 255, e21 >>> 16 & 255, e21 >>> 24];
  }, C2.toBytesBE = function() {
    var e21 = this.high, t3 = this.low;
    return [e21 >>> 24, e21 >>> 16 & 255, e21 >>> 8 & 255, 255 & e21, t3 >>> 24, t3 >>> 16 & 255, t3 >>> 8 & 255, 255 & t3];
  }, r2.fromBytes = (e21, t3, n3) => n3 ? r2.fromBytesLE(e21, t3) : r2.fromBytesBE(e21, t3), r2.fromBytesLE = (e21, t3) => new r2(e21[0] | e21[1] << 8 | e21[2] << 16 | e21[3] << 24, e21[4] | e21[5] << 8 | e21[6] << 16 | e21[7] << 24, t3), r2.fromBytesBE = (e21, t3) => new r2(e21[4] << 24 | e21[5] << 16 | e21[6] << 8 | e21[7], e21[0] << 24 | e21[1] << 16 | e21[2] << 8 | e21[3], t3);
});
var b = m(() => {
});
var g = m(() => {
});
var v = m((e20, t2) => {
  !(function(e21, t3, n2) {
    function r2(e22) {
      var t4 = this, n3 = /* @__PURE__ */ (() => {
        var e23 = 4022871197;
        return (t5) => {
          t5 += "";
          for (var n4 = 0; t5.length > n4; n4++) {
            var r3 = 0.02519603282416938 * (e23 += t5.charCodeAt(n4));
            r3 -= e23 = r3 >>> 0, e23 = (r3 *= e23) >>> 0, e23 += 4294967296 * (r3 -= e23);
          }
          return 23283064365386963e-26 * (e23 >>> 0);
        };
      })();
      t4.next = () => {
        var e23 = 2091639 * t4.s0 + 23283064365386963e-26 * t4.c;
        return t4.s0 = t4.s1, t4.s1 = t4.s2, t4.s2 = e23 - (t4.c = 0 | e23);
      }, t4.c = 1, t4.s0 = n3(" "), t4.s1 = n3(" "), t4.s2 = n3(" "), t4.s0 -= n3(e22), 0 > t4.s0 && (t4.s0 += 1), t4.s1 -= n3(e22), 0 > t4.s1 && (t4.s1 += 1), t4.s2 -= n3(e22), 0 > t4.s2 && (t4.s2 += 1), n3 = null;
    }
    function a2(e22, t4) {
      return t4.c = e22.c, t4.s0 = e22.s0, t4.s1 = e22.s1, t4.s2 = e22.s2, t4;
    }
    function i2(e22, t4) {
      var n3 = new r2(e22), i3 = t4 && t4.state, s2 = n3.next;
      return s2.int32 = () => 4294967296 * n3.next() | 0, s2.double = () => s2() + 11102230246251565e-32 * (2097152 * s2() | 0), s2.quick = s2, i3 && ("object" == typeof i3 && a2(i3, n3), s2.state = () => a2(n3, {})), s2;
    }
    t3 && t3.exports ? t3.exports = i2 : n2 && n2.amd ? n2(() => i2) : this.alea = i2;
  })(0, "object" == typeof t2 && t2, "function" == typeof define && define);
});
var w = m((e20, t2) => {
  !(function(e21, t3, n2) {
    function r2(e22) {
      var t4 = this, n3 = "";
      t4.x = 0, t4.y = 0, t4.z = 0, t4.w = 0, t4.next = () => {
        var e23 = t4.x ^ t4.x << 11;
        return t4.x = t4.y, t4.y = t4.z, t4.z = t4.w, t4.w ^= t4.w >>> 19 ^ e23 ^ e23 >>> 8;
      }, e22 === (0 | e22) ? t4.x = e22 : n3 += e22;
      for (var r3 = 0; n3.length + 64 > r3; r3++) t4.x ^= 0 | n3.charCodeAt(r3), t4.next();
    }
    function a2(e22, t4) {
      return t4.x = e22.x, t4.y = e22.y, t4.z = e22.z, t4.w = e22.w, t4;
    }
    function i2(e22, t4) {
      var n3 = new r2(e22), i3 = t4 && t4.state, s2 = () => (n3.next() >>> 0) / 4294967296;
      return s2.double = () => {
        do {
          var e23 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e23);
        return e23;
      }, s2.int32 = n3.next, s2.quick = s2, i3 && ("object" == typeof i3 && a2(i3, n3), s2.state = () => a2(n3, {})), s2;
    }
    t3 && t3.exports ? t3.exports = i2 : n2 && n2.amd ? n2(() => i2) : this.xor128 = i2;
  })(0, "object" == typeof t2 && t2, "function" == typeof define && define);
});
var k = m((e20, t2) => {
  !(function(e21, t3, n2) {
    function r2(e22) {
      var t4 = this, n3 = "";
      t4.next = () => {
        var e23 = t4.x ^ t4.x >>> 2;
        return t4.x = t4.y, t4.y = t4.z, t4.z = t4.w, t4.w = t4.v, (t4.d = t4.d + 362437 | 0) + (t4.v = t4.v ^ t4.v << 4 ^ e23 ^ e23 << 1) | 0;
      }, t4.x = 0, t4.y = 0, t4.z = 0, t4.w = 0, t4.v = 0, e22 === (0 | e22) ? t4.x = e22 : n3 += e22;
      for (var r3 = 0; n3.length + 64 > r3; r3++) t4.x ^= 0 | n3.charCodeAt(r3), r3 == n3.length && (t4.d = t4.x << 10 ^ t4.x >>> 4), t4.next();
    }
    function a2(e22, t4) {
      return t4.x = e22.x, t4.y = e22.y, t4.z = e22.z, t4.w = e22.w, t4.v = e22.v, t4.d = e22.d, t4;
    }
    function i2(e22, t4) {
      var n3 = new r2(e22), i3 = t4 && t4.state, s2 = () => (n3.next() >>> 0) / 4294967296;
      return s2.double = () => {
        do {
          var e23 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e23);
        return e23;
      }, s2.int32 = n3.next, s2.quick = s2, i3 && ("object" == typeof i3 && a2(i3, n3), s2.state = () => a2(n3, {})), s2;
    }
    t3 && t3.exports ? t3.exports = i2 : n2 && n2.amd ? n2(() => i2) : this.xorwow = i2;
  })(0, "object" == typeof t2 && t2, "function" == typeof define && define);
});
var N = m((e20, t2) => {
  !(function(e21, t3, n2) {
    function r2(e22) {
      var t4 = this;
      t4.next = () => {
        var e23, n3, r3 = t4.x, a3 = t4.i;
        return e23 = r3[a3], n3 = (e23 ^= e23 >>> 7) ^ e23 << 24, n3 ^= (e23 = r3[a3 + 1 & 7]) ^ e23 >>> 10, n3 ^= (e23 = r3[a3 + 3 & 7]) ^ e23 >>> 3, n3 ^= (e23 = r3[a3 + 4 & 7]) ^ e23 << 7, e23 = r3[a3 + 7 & 7], r3[a3] = n3 ^= (e23 ^= e23 << 13) ^ e23 << 9, t4.i = a3 + 1 & 7, n3;
      }, ((e23, t5) => {
        var n3, r3 = [];
        if (t5 === (0 | t5)) r3[0] = t5;
        else for (t5 = "" + t5, n3 = 0; t5.length > n3; ++n3) r3[7 & n3] = r3[7 & n3] << 15 ^ t5.charCodeAt(n3) + r3[n3 + 1 & 7] << 13;
        for (; 8 > r3.length; ) r3.push(0);
        for (n3 = 0; 8 > n3 && 0 === r3[n3]; ++n3) ;
        for (8 == n3 && (r3[7] = -1), e23.x = r3, e23.i = 0, n3 = 256; n3 > 0; --n3) e23.next();
      })(t4, e22);
    }
    function a2(e22, t4) {
      return t4.x = e22.x.slice(), t4.i = e22.i, t4;
    }
    function i2(e22, t4) {
      null == e22 && (e22 = +/* @__PURE__ */ new Date());
      var n3 = new r2(e22), i3 = t4 && t4.state, s2 = () => (n3.next() >>> 0) / 4294967296;
      return s2.double = () => {
        do {
          var e23 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e23);
        return e23;
      }, s2.int32 = n3.next, s2.quick = s2, i3 && (i3.x && a2(i3, n3), s2.state = () => a2(n3, {})), s2;
    }
    t3 && t3.exports ? t3.exports = i2 : n2 && n2.amd ? n2(() => i2) : this.xorshift7 = i2;
  })(0, "object" == typeof t2 && t2, "function" == typeof define && define);
});
var C = m((e20, t2) => {
  !(function(e21, t3, n2) {
    function r2(e22) {
      var t4 = this;
      t4.next = () => {
        var e23, n3, r3 = t4.w, a3 = t4.X, i3 = t4.i;
        return t4.w = r3 = r3 + 1640531527 | 0, n3 = a3[i3 + 34 & 127], e23 = a3[i3 = i3 + 1 & 127], n3 ^= n3 << 13, e23 ^= e23 << 17, n3 = a3[i3] = (n3 ^= n3 >>> 15) ^ (e23 ^= e23 >>> 12), t4.i = i3, n3 + (r3 ^ r3 >>> 16) | 0;
      }, ((e23, t5) => {
        var n3, r3, a3, i3, s2, o2 = [], l2 = 128;
        for (t5 === (0 | t5) ? (r3 = t5, t5 = null) : (r3 = 0, l2 = Math.max(l2, (t5 += "\0").length)), a3 = 0, i3 = -32; l2 > i3; ++i3) t5 && (r3 ^= t5.charCodeAt((i3 + 32) % t5.length)), 0 === i3 && (s2 = r3), r3 ^= r3 << 10, r3 ^= r3 >>> 15, r3 ^= r3 << 4, r3 ^= r3 >>> 13, i3 >= 0 && (a3 = 0 == (n3 = o2[127 & i3] ^= r3 + (s2 = s2 + 1640531527 | 0)) ? a3 + 1 : 0);
        for (a3 >= 128 && (o2[127 & (t5 && t5.length || 0)] = -1), a3 = 127, i3 = 512; i3 > 0; --i3) r3 = o2[a3 + 34 & 127], n3 = o2[a3 = a3 + 1 & 127], r3 ^= r3 << 13, n3 ^= n3 << 17, o2[a3] = (r3 ^= r3 >>> 15) ^ (n3 ^= n3 >>> 12);
        e23.w = s2, e23.X = o2, e23.i = a3;
      })(t4, e22);
    }
    function a2(e22, t4) {
      return t4.i = e22.i, t4.w = e22.w, t4.X = e22.X.slice(), t4;
    }
    function i2(e22, t4) {
      null == e22 && (e22 = +/* @__PURE__ */ new Date());
      var n3 = new r2(e22), i3 = t4 && t4.state, s2 = () => (n3.next() >>> 0) / 4294967296;
      return s2.double = () => {
        do {
          var e23 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e23);
        return e23;
      }, s2.int32 = n3.next, s2.quick = s2, i3 && (i3.X && a2(i3, n3), s2.state = () => a2(n3, {})), s2;
    }
    t3 && t3.exports ? t3.exports = i2 : n2 && n2.amd ? n2(() => i2) : this.xor4096 = i2;
  })(0, "object" == typeof t2 && t2, "function" == typeof define && define);
});
var $ = m((e20, t2) => {
  !(function(e21, t3, n2) {
    function r2(e22) {
      var t4 = this, n3 = "";
      t4.next = () => {
        var e23 = t4.b, n4 = t4.c, r4 = t4.d, a3 = t4.a;
        return e23 = e23 << 25 ^ e23 >>> 7 ^ n4, n4 = n4 - r4 | 0, r4 = r4 << 24 ^ r4 >>> 8 ^ a3, a3 = a3 - e23 | 0, t4.b = e23 = e23 << 20 ^ e23 >>> 12 ^ n4, t4.c = n4 = n4 - r4 | 0, t4.d = r4 << 16 ^ n4 >>> 16 ^ a3, t4.a = a3 - e23 | 0;
      }, t4.a = 0, t4.b = 0, t4.c = -1640531527, t4.d = 1367130551, e22 === Math.floor(e22) ? (t4.a = e22 / 4294967296 | 0, t4.b = 0 | e22) : n3 += e22;
      for (var r3 = 0; n3.length + 20 > r3; r3++) t4.b ^= 0 | n3.charCodeAt(r3), t4.next();
    }
    function a2(e22, t4) {
      return t4.a = e22.a, t4.b = e22.b, t4.c = e22.c, t4.d = e22.d, t4;
    }
    function i2(e22, t4) {
      var n3 = new r2(e22), i3 = t4 && t4.state, s2 = () => (n3.next() >>> 0) / 4294967296;
      return s2.double = () => {
        do {
          var e23 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === e23);
        return e23;
      }, s2.int32 = n3.next, s2.quick = s2, i3 && ("object" == typeof i3 && a2(i3, n3), s2.state = () => a2(n3, {})), s2;
    }
    t3 && t3.exports ? t3.exports = i2 : n2 && n2.amd ? n2(() => i2) : this.tychei = i2;
  })(0, "object" == typeof t2 && t2, "function" == typeof define && define);
});
var R = m(() => {
});
var S = m((e20, t2) => {
  !(function(e21, n2, r2) {
    var a2, i2 = 256, s2 = "random", o2 = r2.pow(i2, 6), l2 = r2.pow(2, 52), u2 = 2 * l2, d2 = 255;
    function c2(t3, d3, c3) {
      var x2 = [], y2 = m2(f2((d3 = 1 == d3 ? { entropy: true } : d3 || {}).entropy ? [t3, A2(n2)] : t3 ?? (() => {
        try {
          var t4;
          return a2 && (t4 = a2.randomBytes) ? t4 = t4(i2) : (t4 = new Uint8Array(i2), (e21.crypto || e21.msCrypto).getRandomValues(t4)), A2(t4);
        } catch (x3) {
          var r3 = e21.navigator, s3 = r3 && r3.plugins;
          return [+/* @__PURE__ */ new Date(), e21, s3, e21.screen, A2(n2)];
        }
      })(), 3), x2), b2 = new h2(x2), g2 = () => {
        for (var e22 = b2.g(6), t4 = o2, n3 = 0; l2 > e22; ) e22 = (e22 + n3) * i2, t4 *= i2, n3 = b2.g(1);
        for (; e22 >= u2; ) e22 /= 2, t4 /= 2, n3 >>>= 1;
        return (e22 + n3) / t4;
      };
      return g2.int32 = () => 0 | b2.g(4), g2.quick = () => b2.g(4) / 4294967296, g2.double = g2, m2(A2(b2.S), n2), (d3.pass || c3 || ((e22, t4, n3, a3) => (a3 && (a3.S && p2(a3, b2), e22.state = () => p2(b2, {})), n3 ? (r2[s2] = e22, t4) : e22)))(g2, y2, "global" in d3 ? d3.global : this == r2, d3.state);
    }
    function h2(e22) {
      var t3, n3 = e22.length, r3 = this, a3 = 0, s3 = r3.i = r3.j = 0, o3 = r3.S = [];
      for (n3 || (e22 = [n3++]); i2 > a3; ) o3[a3] = a3++;
      for (a3 = 0; i2 > a3; a3++) o3[a3] = o3[s3 = d2 & s3 + e22[a3 % n3] + (t3 = o3[a3])], o3[s3] = t3;
      (r3.g = (e23) => {
        for (var t4, n4 = 0, a4 = r3.i, s4 = r3.j, o4 = r3.S; e23--; ) t4 = o4[a4 = d2 & a4 + 1], n4 = n4 * i2 + o4[d2 & (o4[a4] = o4[s4 = d2 & s4 + t4]) + (o4[s4] = t4)];
        return r3.i = a4, r3.j = s4, n4;
      })(i2);
    }
    function p2(e22, t3) {
      return t3.i = e22.i, t3.j = e22.j, t3.S = e22.S.slice(), t3;
    }
    function f2(e22, t3) {
      var n3, r3 = [], a3 = typeof e22;
      if (t3 && "object" == a3) for (n3 in e22) try {
        r3.push(f2(e22[n3], t3 - 1));
      } catch (i3) {
      }
      return r3.length ? r3 : "string" == a3 ? e22 : e22 + "\0";
    }
    function m2(e22, t3) {
      for (var n3, r3 = e22 + "", a3 = 0; r3.length > a3; ) t3[d2 & a3] = d2 & (n3 ^= 19 * t3[d2 & a3]) + r3.charCodeAt(a3++);
      return A2(t3);
    }
    function A2(e22) {
      return String.fromCharCode.apply(0, e22);
    }
    if (m2(r2.random(), n2), "object" == typeof t2 && t2.exports) {
      t2.exports = c2;
      try {
        a2 = R();
      } catch (x2) {
      }
    } else "function" == typeof define && define.amd ? define(() => c2) : r2["seed" + s2] = c2;
  })("undefined" != typeof self ? self : e20, [], Math);
});
var I = m((e20, t2) => {
  var n2 = v(), r2 = w(), a2 = k(), i2 = N(), s2 = C(), o2 = $(), l2 = S();
  l2.alea = n2, l2.xor128 = r2, l2.xorwow = a2, l2.xorshift7 = i2, l2.xor4096 = s2, l2.tychei = o2, t2.exports = l2;
});
var E = m(() => {
});
var T = m(() => {
});
var M = m(() => {
});
var O = m(() => {
});
var F = m(() => {
});
var P = m((e20, t2) => {
  var n2, r2 = (n2 = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (n2 = n2 || __filename), function(e21) {
    function t3() {
      return I2.buffer != V2 && H2(I2.buffer), D2;
    }
    function r3() {
      return I2.buffer != V2 && H2(I2.buffer), W2;
    }
    function a2() {
      return I2.buffer != V2 && H2(I2.buffer), L2;
    }
    function i2() {
      return I2.buffer != V2 && H2(I2.buffer), B2;
    }
    var s2, o2, l2, u2 = void 0 !== (e21 = e21 || {}) ? e21 : {};
    u2.ready = new Promise((e22, t4) => {
      s2 = e22, o2 = t4;
    }), "undefined" != typeof process && process.listeners && (l2 = { uncaughtException: process.listeners("uncaughtException"), unhandledRejection: process.listeners("unhandledRejection") });
    var d2, c2, h2, p2 = Object.assign({}, u2), f2 = (e22, t4) => {
      throw t4;
    }, m2 = "object" == typeof window, A2 = "function" == typeof importScripts, x2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, y2 = u2.ENVIRONMENT_IS_PTHREAD || false, b2 = "";
    function g2(e22) {
      return u2.locateFile ? u2.locateFile(e22, b2) : b2 + e22;
    }
    if (x2) {
      var v2 = E(), w2 = T();
      let e22;
      b2 = A2 ? w2.dirname(b2) + "/" : __dirname + "/", d2 = (e23, t4) => (e23 = oe2(e23) ? new URL(e23) : w2.normalize(e23), v2.readFileSync(e23, t4 ? void 0 : "utf8")), h2 = (e23) => {
        var t4 = d2(e23, true);
        return t4.buffer || (t4 = new Uint8Array(t4)), t4;
      }, c2 = (e23, t4, n3) => {
        e23 = oe2(e23) ? new URL(e23) : w2.normalize(e23), v2.readFile(e23, (e24, r4) => {
          e24 ? n3(e24) : t4(r4.buffer);
        });
      }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", (e23) => {
        if (!(e23 instanceof de2)) throw e23;
      }), process.on("unhandledRejection", (e23) => {
        throw e23;
      }), f2 = (e23, t4) => {
        if (J2()) throw process.exitCode = e23, t4;
        ((e24) => {
          e24 instanceof de2 || R2("exiting due to exception: " + e24);
        })(t4), process.exit(e23);
      }, u2.inspect = () => "[Emscripten Module object]";
      try {
        e22 = M();
      } catch (Ke2) {
        throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), Ke2;
      }
      global.Worker = e22.Worker;
    } else (m2 || A2) && (A2 ? b2 = self.location.href : "undefined" != typeof document && document.currentScript && (b2 = document.currentScript.src), void 0 !== n2 && n2 && (b2 = n2), b2 = 0 !== b2.indexOf("blob:") ? b2.substr(0, b2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", x2 || (d2 = (e22) => {
      var t4 = new XMLHttpRequest();
      return t4.open("GET", e22, false), t4.send(null), t4.responseText;
    }, A2 && (h2 = (e22) => {
      var t4 = new XMLHttpRequest();
      return t4.open("GET", e22, false), t4.responseType = "arraybuffer", t4.send(null), new Uint8Array(t4.response);
    }), c2 = (e22, t4, n3) => {
      var r4 = new XMLHttpRequest();
      r4.open("GET", e22, true), r4.responseType = "arraybuffer", r4.onload = () => {
        200 == r4.status || 0 == r4.status && r4.response ? t4(r4.response) : n3();
      }, r4.onerror = n3, r4.send(null);
    }));
    x2 && "undefined" == typeof performance && (global.performance = O().performance);
    var k2 = console.log.bind(console), N2 = console.warn.bind(console);
    x2 && (k2 = (e22) => v2.writeSync(1, e22 + "\n"), N2 = (e22) => v2.writeSync(2, e22 + "\n"));
    var C2, $2 = u2.print || k2, R2 = u2.printErr || N2;
    Object.assign(u2, p2), p2 = null, u2.quit && (f2 = u2.quit), u2.wasmBinary && (C2 = u2.wasmBinary);
    var S2 = u2.noExitRuntime || true;
    "object" != typeof WebAssembly && ie2("no native wasm support detected");
    var I2, P2, z2, V2, _2, D2, W2, L2, B2, U2 = false, j2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
    function G2(e22, t4, n3) {
      for (var r4 = (t4 >>>= 0) + n3, a3 = t4; e22[a3] && r4 > a3; ) ++a3;
      if (a3 - t4 > 16 && e22.buffer && j2) return j2.decode(e22.buffer instanceof SharedArrayBuffer ? e22.slice(t4, a3) : e22.subarray(t4, a3));
      for (var i3 = ""; a3 > t4; ) {
        var s3 = e22[t4++];
        if (128 & s3) {
          var o3 = 63 & e22[t4++];
          if (192 != (224 & s3)) {
            var l3 = 63 & e22[t4++];
            if (65536 > (s3 = 224 == (240 & s3) ? (15 & s3) << 12 | o3 << 6 | l3 : (7 & s3) << 18 | o3 << 12 | l3 << 6 | 63 & e22[t4++])) i3 += String.fromCharCode(s3);
            else {
              var u3 = s3 - 65536;
              i3 += String.fromCharCode(55296 | u3 >> 10, 56320 | 1023 & u3);
            }
          } else i3 += String.fromCharCode((31 & s3) << 6 | o3);
        } else i3 += String.fromCharCode(s3);
      }
      return i3;
    }
    function H2(e22) {
      V2 = e22, u2.HEAP8 = _2 = new Int8Array(e22), u2.HEAP16 = new Int16Array(e22), u2.HEAP32 = W2 = new Int32Array(e22), u2.HEAPU8 = D2 = new Uint8Array(e22), u2.HEAPU16 = new Uint16Array(e22), u2.HEAPU32 = L2 = new Uint32Array(e22), u2.HEAPF32 = new Float32Array(e22), u2.HEAPF64 = B2 = new Float64Array(e22);
    }
    y2 && (V2 = u2.buffer);
    var X2 = u2.INITIAL_MEMORY || 16777216;
    if (y2) I2 = u2.wasmMemory, V2 = u2.buffer;
    else if (u2.wasmMemory) I2 = u2.wasmMemory;
    else if (!((I2 = new WebAssembly.Memory({ initial: X2 / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer)) throw R2("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), x2 && R2("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), Error("bad memory");
    I2 && (V2 = I2.buffer), X2 = V2.byteLength, H2(V2);
    var q2, Z2 = [], K2 = [], Y2 = [];
    function J2() {
      return S2;
    }
    function Q2() {
      !y2 && Ae2(K2);
    }
    function ee2(e22) {
      Z2.unshift(e22);
    }
    function te2(e22) {
      Y2.unshift(e22);
    }
    var ne2, re2 = 0, ae2 = null;
    function ie2(e22) {
      u2.onAbort && u2.onAbort(e22), R2(e22 = "Aborted(" + e22 + ")"), U2 = true, z2 = 1, e22 += ". Build with -sASSERTIONS for more info.";
      var t4 = new WebAssembly.RuntimeError(e22);
      throw o2(t4), t4;
    }
    function se2(e22) {
      return e22.startsWith("data:application/octet-stream;base64,");
    }
    function oe2(e22) {
      return e22.startsWith("file://");
    }
    function le2(e22) {
      try {
        if (e22 == ne2 && C2) return new Uint8Array(C2);
        if (h2) return h2(e22);
        throw "both async and sync fetching of the wasm failed";
      } catch (Ke2) {
        ie2(Ke2);
      }
    }
    se2(ne2 = "tfjs-backend-wasm-threaded-simd.wasm") || (ne2 = g2(ne2));
    var ue2 = {};
    function de2(e22) {
      this.name = "ExitStatus", this.message = "Program terminated with exit(" + e22 + ")", this.status = e22;
    }
    function ce2(e22) {
      var t4 = me2.pthreads[e22];
      ((e23) => {
        e23 || ie2(void 0);
      })(t4), me2.returnWorkerToPool(t4);
    }
    function he2(e22) {
      var t4 = me2.getNewWorker();
      if (!t4) return 6;
      me2.runningWorkers.push(t4), me2.pthreads[e22.pthread_ptr] = t4, t4.pthread_ptr = e22.pthread_ptr;
      var n3 = { cmd: "run", start_routine: e22.startRoutine, arg: e22.arg, pthread_ptr: e22.pthread_ptr };
      return t4.runPthread = () => {
        x2 && t4.ref(), t4.postMessage(n3, e22.transferList), delete t4.runPthread;
      }, t4.loaded && t4.runPthread(), 0;
    }
    function pe2(e22) {
      if (y2) return Ne2(1, 1, e22);
      z2 = e22, J2() || (me2.terminateAllThreads(), u2.onExit && u2.onExit(e22), U2 = true), f2(e22, new de2(e22));
    }
    var fe2 = (e22, t4) => {
      if (z2 = e22, !t4 && y2) throw xe2(e22), "unwind";
      pe2(e22);
    }, me2 = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], pthreads: {}, init() {
      y2 ? me2.initWorker() : me2.initMainThread();
    }, initMainThread() {
      for (var e22 = 8; e22--; ) me2.allocateUnusedWorker();
    }, initWorker() {
      S2 = false;
    }, setExitStatus(e22) {
      z2 = e22;
    }, terminateAllThreads() {
      for (var e22 of Object.values(me2.pthreads)) me2.returnWorkerToPool(e22);
      for (var e22 of me2.unusedWorkers) e22.terminate();
      me2.unusedWorkers = [];
    }, returnWorkerToPool(e22) {
      var t4 = e22.pthread_ptr;
      delete me2.pthreads[t4], me2.unusedWorkers.push(e22), me2.runningWorkers.splice(me2.runningWorkers.indexOf(e22), 1), e22.pthread_ptr = 0, x2 && e22.unref(), Be2(t4);
    }, receiveObjectTransfer(e22) {
    }, threadInitTLS() {
      me2.tlsInitFunctions.forEach((e22) => e22());
    }, loadWasmModuleToWorker(e22, t4) {
      e22.onmessage = (n3) => {
        var r5 = n3.data, a4 = r5.cmd;
        if (e22.pthread_ptr && (me2.currentProxiedOperationCallerThread = e22.pthread_ptr), r5.targetThread && r5.targetThread != Pe2()) {
          var i3 = me2.pthreads[r5.targetThread];
          return i3 ? i3.postMessage(r5, r5.transferList) : R2('Internal error! Worker sent a message "' + a4 + '" to target pthread ' + r5.targetThread + ", but that thread no longer exists!"), void (me2.currentProxiedOperationCallerThread = void 0);
        }
        "processProxyingQueue" === a4 ? we2(r5.queue) : "spawnThread" === a4 ? he2(r5) : "cleanupThread" === a4 ? ce2(r5.thread) : "killThread" === a4 ? ((e23) => {
          var t5 = me2.pthreads[e23];
          delete me2.pthreads[e23], t5.terminate(), Be2(e23), me2.runningWorkers.splice(me2.runningWorkers.indexOf(t5), 1), t5.pthread_ptr = 0;
        })(r5.thread) : "cancelThread" === a4 ? ((e23) => {
          me2.pthreads[e23].postMessage({ cmd: "cancel" });
        })(r5.thread) : "loaded" === a4 ? (e22.loaded = true, x2 && e22.unref(), t4 && t4(e22), e22.runPthread && e22.runPthread()) : "print" === a4 ? $2("Thread " + r5.threadId + ": " + r5.text) : "printErr" === a4 ? R2("Thread " + r5.threadId + ": " + r5.text) : "alert" === a4 ? alert("Thread " + r5.threadId + ": " + r5.text) : "setimmediate" === r5.target ? e22.postMessage(r5) : "callHandler" === a4 ? u2[r5.handler](...r5.args) : a4 && R2("worker sent an unknown command " + a4), me2.currentProxiedOperationCallerThread = void 0;
      }, e22.onerror = (e23) => {
        throw R2("worker sent an error! " + e23.filename + ":" + e23.lineno + ": " + e23.message), e23;
      }, x2 && (e22.on("message", (t5) => {
        e22.onmessage({ data: t5 });
      }), e22.on("error", (t5) => {
        e22.onerror(t5);
      }), e22.on("detachedExit", () => {
      }));
      var r4 = [];
      for (var a3 of ["onExit", "onAbort", "print", "printErr"]) u2.hasOwnProperty(a3) && r4.push(a3);
      e22.postMessage({ cmd: "load", handlers: r4, urlOrBlob: u2.mainScriptUrlOrBlob || n2, wasmMemory: I2, wasmModule: P2 });
    }, allocateUnusedWorker() {
      var e22, t4 = g2("tfjs-backend-wasm-threaded-simd.worker.js");
      e22 = new Worker(t4), me2.unusedWorkers.push(e22);
    }, getNewWorker: () => (0 == me2.unusedWorkers.length && (me2.allocateUnusedWorker(), me2.loadWasmModuleToWorker(me2.unusedWorkers[0])), me2.unusedWorkers.pop()) };
    function Ae2(e22) {
      for (; e22.length > 0; ) e22.shift()(u2);
    }
    function xe2(e22) {
      if (y2) return Ne2(2, 0, e22);
      try {
        fe2(e22);
      } catch (Ke2) {
        ((e23) => {
          if (e23 instanceof de2 || "unwind" == e23) return z2;
          f2(1, e23);
        })(Ke2);
      }
    }
    u2.PThread = me2, u2.establishStackSpace = () => {
      var e22 = Pe2(), t4 = r3()[e22 + 52 >>> 2], n3 = r3()[e22 + 56 >>> 2];
      je2(t4, t4 - n3), He2(t4);
    };
    var ye2, be2 = [];
    function ge2(e22, t4, n3, r4) {
      return y2 ? Ne2(3, 1, e22, t4, n3, r4) : ve2(e22, t4, n3, r4);
    }
    function ve2(e22, t4, n3, r4) {
      if ("undefined" == typeof SharedArrayBuffer) return R2("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
      var a3 = [];
      if (y2 && 0 === a3.length) return ge2(e22, t4, n3, r4);
      var i3 = { startRoutine: n3, pthread_ptr: e22, arg: r4, transferList: a3 };
      return y2 ? (i3.cmd = "spawnThread", postMessage(i3, a3), 0) : he2(i3);
    }
    function we2(e22) {
      Atomics.store(r3(), e22 >> 2, 1), Pe2() && Le2(e22), Atomics.compareExchange(r3(), e22 >> 2, 1, 0);
    }
    function ke2(e22) {
      ke2.shown || (ke2.shown = {}), ke2.shown[e22] || (ke2.shown[e22] = 1, x2 && (e22 = "warning: " + e22), R2(e22));
    }
    function Ne2(e22, t4) {
      var n3 = arguments.length - 2, r4 = arguments;
      return ((e23) => {
        var t5 = Ge2(), n4 = e23();
        return He2(t5), n4;
      })(() => {
        for (var a3 = n3, s3 = Xe2(8 * a3), o3 = s3 >> 3, l3 = 0; n3 > l3; l3++) {
          var u3 = r4[2 + l3];
          i2()[o3 + l3 >>> 0] = u3;
        }
        return Ve2(e22, a3, s3, t4);
      });
    }
    u2.invokeEntryPoint = (e22, t4) => {
      var n3 = ((e23) => {
        var t5 = be2[e23];
        return t5 || (e23 >= be2.length && (be2.length = e23 + 1), be2[e23] = t5 = q2.get(e23)), t5;
      })(e22)(t4);
      J2() ? me2.setExitStatus(n3) : Ue2(n3);
    }, u2.executeNotifiedProxyingQueue = we2, ye2 = x2 ? () => {
      var e22 = process.hrtime();
      return 1e3 * e22[0] + e22[1] / 1e6;
    } : () => performance.timeOrigin + performance.now();
    var Ce2 = [];
    function $e2(e22) {
      try {
        return I2.grow(e22 - V2.byteLength + 65535 >>> 16), H2(I2.buffer), 1;
      } catch (Ke2) {
      }
    }
    function Re2(e22) {
      return y2 ? Ne2(4, 1, e22) : 52;
    }
    function Se2(e22, t4, n3, r4, a3) {
      return y2 ? Ne2(5, 1, e22, t4, n3, r4, a3) : 70;
    }
    var Ie2 = [null, [], []];
    function Ee2(e22, t4) {
      var n3 = Ie2[e22];
      0 === t4 || 10 === t4 ? ((1 === e22 ? $2 : R2)(G2(n3, 0)), n3.length = 0) : n3.push(t4);
    }
    function Te2(e22, n3, r4, i3) {
      if (y2) return Ne2(6, 1, e22, n3, r4, i3);
      for (var s3 = 0, o3 = 0; r4 > o3; o3++) {
        var l3 = a2()[n3 >>> 2], u3 = a2()[n3 + 4 >>> 2];
        n3 += 8;
        for (var d3 = 0; u3 > d3; d3++) Ee2(e22, t3()[l3 + d3 >>> 0]);
        s3 += u3;
      }
      return a2()[i3 >>> 2] = s3, 0;
    }
    function Me2(e22) {
      return u2["_" + e22];
    }
    me2.init();
    var Oe2 = [null, pe2, xe2, ge2, Re2, Se2, Te2], Fe2 = { h(e22) {
      ze2(e22, !A2, 1, !m2), me2.threadInitTLS();
    }, p(e22) {
      y2 ? postMessage({ cmd: "cleanupThread", thread: e22 }) : ce2(e22);
    }, N: ve2, C: () => 65536, $: () => true, I(e22, t4, n3, r4) {
      if (e22 == t4) setTimeout(() => we2(r4));
      else if (y2) postMessage({ targetThread: e22, cmd: "processProxyingQueue", queue: r4 });
      else {
        var a3 = me2.pthreads[e22];
        if (!a3) return;
        a3.postMessage({ cmd: "processProxyingQueue", queue: r4 });
      }
      return 1;
    }, T: (e22, t4, n3) => -1, abort() {
      ie2("");
    }, emscripten_check_blocking_allowed() {
      x2 || A2 || ke2("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
    }, emscripten_date_now: () => Date.now(), emscripten_get_heap_max: () => 4294901760, emscripten_get_now: ye2, emscripten_memcpy_big(e22, n3, r4) {
      t3().copyWithin(e22 >>> 0, n3 >>> 0, n3 + r4 >>> 0);
    }, emscripten_num_logical_cores: () => x2 ? F().cpus().length : navigator.hardwareConcurrency, emscripten_receive_on_main_thread_js(e22, t4, n3) {
      Ce2.length = t4;
      for (var r4 = n3 >> 3, a3 = 0; t4 > a3; a3++) Ce2[a3] = i2()[r4 + a3 >>> 0];
      return (0 > e22 ? ue2[-e22 - 1] : Oe2[e22]).apply(null, Ce2);
    }, emscripten_resize_heap(e22) {
      var n3 = t3().length;
      if (n3 >= (e22 >>>= 0)) return false;
      var r4 = 4294901760;
      if (e22 > r4) return false;
      let a3 = (e23, t4) => e23 + (t4 - e23 % t4) % t4;
      for (var i3 = 1; 4 >= i3; i3 *= 2) {
        var s3 = n3 * (1 + 0.2 / i3);
        if ($e2(Math.min(r4, a3(Math.max(e22, s3 = Math.min(s3, e22 + 100663296)), 65536)))) return true;
      }
      return false;
    }, emscripten_unwind_to_js_event_loop() {
      throw "unwind";
    }, exit: fe2, fd_close: Re2, fd_seek: Se2, fd_write: Te2, memory: I2 || u2.wasmMemory };
    (() => {
      var e22 = { env: Fe2, wasi_snapshot_preview1: Fe2 };
      function t4(e23, t5) {
        if (u2.asm = e23.exports, ((e24) => {
          me2.tlsInitFunctions.push(e24);
        })(u2.asm.M), q2 = u2.asm.O, ((e24) => {
          K2.unshift(e24);
        })(u2.asm.F), P2 = t5, !y2) {
          var n4 = me2.unusedWorkers.length;
          me2.unusedWorkers.forEach((e24) => {
            me2.loadWasmModuleToWorker(e24, () => {
              --n4 || (() => {
                if (re2--, u2.monitorRunDependencies && u2.monitorRunDependencies(re2), 0 == re2 && ae2) {
                  var e25 = ae2;
                  ae2 = null, e25();
                }
              })();
            });
          });
        }
      }
      function n3(e23) {
        t4(e23.instance, e23.module);
      }
      function r4(t5) {
        return (() => {
          if (!C2 && (m2 || A2)) {
            if ("function" == typeof fetch && !oe2(ne2)) return fetch(ne2, { credentials: "same-origin" }).then((e23) => {
              if (!e23.ok) throw "failed to load wasm binary file at '" + ne2 + "'";
              return e23.arrayBuffer();
            }).catch(() => le2(ne2));
            if (c2) return new Promise((e23, t6) => {
              c2(ne2, (t7) => {
                e23(new Uint8Array(t7));
              }, t6);
            });
          }
          return Promise.resolve().then(() => le2(ne2));
        })().then((t6) => WebAssembly.instantiate(t6, e22)).then((e23) => e23).then(t5, (e23) => {
          R2("failed to asynchronously prepare wasm: " + e23), ie2(e23);
        });
      }
      if (y2 || (re2++, u2.monitorRunDependencies && u2.monitorRunDependencies(re2)), u2.instantiateWasm) try {
        return u2.instantiateWasm(e22, t4);
      } catch (a3) {
        R2("Module.instantiateWasm callback failed with error: " + a3), o2(a3);
      }
      (C2 || "function" != typeof WebAssembly.instantiateStreaming || se2(ne2) || oe2(ne2) || x2 || "function" != typeof fetch ? r4(n3) : fetch(ne2, { credentials: "same-origin" }).then((t5) => WebAssembly.instantiateStreaming(t5, e22).then(n3, (e23) => (R2("wasm streaming compile failed: " + e23), R2("falling back to ArrayBuffer instantiation"), r4(n3))))).catch(o2);
    })(), u2.P = function() {
      return (u2.P = u2.asm.F).apply(null, arguments);
    }, u2.V = function() {
      return (u2.V = u2.asm.init).apply(null, arguments);
    }, u2._ = function() {
      return (u2._ = u2.asm.init_with_threads_count).apply(null, arguments);
    }, u2.D = function() {
      return (u2.D = u2.asm.get_threads_count).apply(null, arguments);
    }, u2.W = function() {
      return (u2.W = u2.asm.register_tensor).apply(null, arguments);
    }, u2.L = function() {
      return (u2.L = u2.asm.dispose_data).apply(null, arguments);
    }, u2.U = function() {
      return (u2.U = u2.asm.dispose).apply(null, arguments);
    }, u2.H = function() {
      return (u2.H = u2.asm.Abs).apply(null, arguments);
    }, u2.q = function() {
      return (u2.q = u2.asm.Acos).apply(null, arguments);
    }, u2.Z = function() {
      return (u2.Z = u2.asm.Acosh).apply(null, arguments);
    }, u2.K = function() {
      return (u2.K = u2.asm.Add).apply(null, arguments);
    }, u2.Y = function() {
      return (u2.Y = u2.asm.AddN).apply(null, arguments);
    }, u2.J = function() {
      return (u2.J = u2.asm.All).apply(null, arguments);
    }, u2.ee = function() {
      return (u2.ee = u2.asm.Any).apply(null, arguments);
    }, u2.te = function() {
      return (u2.te = u2.asm.ArgMax).apply(null, arguments);
    }, u2.re = function() {
      return (u2.re = u2.asm.ArgMin).apply(null, arguments);
    }, u2.ae = function() {
      return (u2.ae = u2.asm.Asin).apply(null, arguments);
    }, u2.ie = function() {
      return (u2.ie = u2.asm.Asinh).apply(null, arguments);
    }, u2.se = function() {
      return (u2.se = u2.asm.Atan).apply(null, arguments);
    }, u2.oe = function() {
      return (u2.oe = u2.asm.Atan2).apply(null, arguments);
    }, u2.ue = function() {
      return (u2.ue = u2.asm.Atanh).apply(null, arguments);
    }, u2.de = function() {
      return (u2.de = u2.asm.AvgPool).apply(null, arguments);
    }, u2.ce = function() {
      return (u2.ce = u2.asm.AvgPool3D).apply(null, arguments);
    }, u2.he = function() {
      return (u2.he = u2.asm.AvgPool3DGrad).apply(null, arguments);
    }, u2.pe = function() {
      return (u2.pe = u2.asm.AvgPoolGrad).apply(null, arguments);
    }, u2.fe = function() {
      return (u2.fe = u2.asm.BatchMatMul).apply(null, arguments);
    }, u2.me = function() {
      return (u2.me = u2.asm.Bincount).apply(null, arguments);
    }, u2.Ae = function() {
      return (u2.Ae = u2.asm.BitwiseAnd).apply(null, arguments);
    }, u2.xe = function() {
      return (u2.xe = u2.asm.Ceil).apply(null, arguments);
    }, u2.ye = function() {
      return (u2.ye = u2.asm.ClipByValue).apply(null, arguments);
    }, u2.be = function() {
      return (u2.be = u2.asm.Conv2D).apply(null, arguments);
    }, u2.ve = function() {
      return (u2.ve = u2.asm.Conv2DBackpropInput).apply(null, arguments);
    }, u2.we = function() {
      return (u2.we = u2.asm.Conv3D).apply(null, arguments);
    }, u2.ke = function() {
      return (u2.ke = u2.asm.Conv3DBackpropFilterV2).apply(null, arguments);
    }, u2.Ne = function() {
      return (u2.Ne = u2.asm.Conv3DBackpropInputV2).apply(null, arguments);
    }, u2.Ce = function() {
      return (u2.Ce = u2.asm.Cos).apply(null, arguments);
    }, u2.$e = function() {
      return (u2.$e = u2.asm.Cosh).apply(null, arguments);
    }, u2.Re = function() {
      return (u2.Re = u2.asm.CropAndResize).apply(null, arguments);
    }, u2.Se = function() {
      return (u2.Se = u2.asm.Cumprod).apply(null, arguments);
    }, u2.Ie = function() {
      return (u2.Ie = u2.asm.Cumsum).apply(null, arguments);
    }, u2.Ee = function() {
      return (u2.Ee = u2.asm.DenseBincount).apply(null, arguments);
    }, u2.Te = function() {
      return (u2.Te = u2.asm.DepthToSpace).apply(null, arguments);
    }, u2.Me = function() {
      return (u2.Me = u2.asm.DepthwiseConv2dNative).apply(null, arguments);
    }, u2.Oe = function() {
      return (u2.Oe = u2.asm.Diag).apply(null, arguments);
    }, u2.Fe = function() {
      return (u2.Fe = u2.asm.Dilation2D).apply(null, arguments);
    }, u2.Pe = function() {
      return (u2.Pe = u2.asm.Dilation2DBackpropFilter).apply(null, arguments);
    }, u2.ze = function() {
      return (u2.ze = u2.asm.Dilation2DBackpropInput).apply(null, arguments);
    }, u2.Ve = function() {
      return (u2.Ve = u2.asm.Elu).apply(null, arguments);
    }, u2._e = function() {
      return (u2._e = u2.asm.EluGrad).apply(null, arguments);
    }, u2.De = function() {
      return (u2.De = u2.asm.Equal).apply(null, arguments);
    }, u2.We = function() {
      return (u2.We = u2.asm.Erf).apply(null, arguments);
    }, u2.Le = function() {
      return (u2.Le = u2.asm.Exp).apply(null, arguments);
    }, u2.Be = function() {
      return (u2.Be = u2.asm.Expm1).apply(null, arguments);
    }, u2.Ue = function() {
      return (u2.Ue = u2.asm.FlipLeftRight).apply(null, arguments);
    }, u2.je = function() {
      return (u2.je = u2.asm.Floor).apply(null, arguments);
    }, u2.Ge = function() {
      return (u2.Ge = u2.asm.FloorDiv).apply(null, arguments);
    }, u2.He = function() {
      return (u2.He = u2.asm.FusedBatchNorm).apply(null, arguments);
    }, u2.Xe = function() {
      return (u2.Xe = u2.asm.FusedConv2D).apply(null, arguments);
    }, u2.qe = function() {
      return (u2.qe = u2.asm.FusedDepthwiseConv2D).apply(null, arguments);
    }, u2.Ze = function() {
      return (u2.Ze = u2.asm.Gather).apply(null, arguments);
    }, u2.Ke = function() {
      return (u2.Ke = u2.asm.GatherNd).apply(null, arguments);
    }, u2.Ye = function() {
      return (u2.Ye = u2.asm.Greater).apply(null, arguments);
    }, u2.Je = function() {
      return (u2.Je = u2.asm.GreaterEqual).apply(null, arguments);
    }, u2.Qe = function() {
      return (u2.Qe = u2.asm.IsFinite).apply(null, arguments);
    }, u2.et = function() {
      return (u2.et = u2.asm.IsInf).apply(null, arguments);
    }, u2.tt = function() {
      return (u2.tt = u2.asm.IsNan).apply(null, arguments);
    }, u2.nt = function() {
      return (u2.nt = u2.asm.LRN).apply(null, arguments);
    }, u2.rt = function() {
      return (u2.rt = u2.asm.LRNGrad).apply(null, arguments);
    }, u2.it = function() {
      return (u2.it = u2.asm.LeakyRelu).apply(null, arguments);
    }, u2.st = function() {
      return (u2.st = u2.asm.Less).apply(null, arguments);
    }, u2.ot = function() {
      return (u2.ot = u2.asm.LessEqual).apply(null, arguments);
    }, u2.ut = function() {
      return (u2.ut = u2.asm.LinSpace).apply(null, arguments);
    }, u2.dt = function() {
      return (u2.dt = u2.asm.Log).apply(null, arguments);
    }, u2.ct = function() {
      return (u2.ct = u2.asm.Log1p).apply(null, arguments);
    }, u2.ht = function() {
      return (u2.ht = u2.asm.LogicalAnd).apply(null, arguments);
    }, u2.ft = function() {
      return (u2.ft = u2.asm.LogicalNot).apply(null, arguments);
    }, u2.At = function() {
      return (u2.At = u2.asm.LogicalOr).apply(null, arguments);
    }, u2.xt = function() {
      return (u2.xt = u2.asm.LogicalXor).apply(null, arguments);
    }, u2.yt = function() {
      return (u2.yt = u2.asm.Max).apply(null, arguments);
    }, u2.bt = function() {
      return (u2.bt = u2.asm.MaxPool).apply(null, arguments);
    }, u2.vt = function() {
      return (u2.vt = u2.asm.MaxPool3D).apply(null, arguments);
    }, u2.wt = function() {
      return (u2.wt = u2.asm.MaxPool3DGrad).apply(null, arguments);
    }, u2.kt = function() {
      return (u2.kt = u2.asm.MaxPoolGrad).apply(null, arguments);
    }, u2.Nt = function() {
      return (u2.Nt = u2.asm.MaxPoolWithArgmax).apply(null, arguments);
    }, u2.Ct = function() {
      return (u2.Ct = u2.asm.Maximum).apply(null, arguments);
    }, u2.$t = function() {
      return (u2.$t = u2.asm.Mean).apply(null, arguments);
    }, u2.Rt = function() {
      return (u2.Rt = u2.asm.Min).apply(null, arguments);
    }, u2.St = function() {
      return (u2.St = u2.asm.Minimum).apply(null, arguments);
    }, u2.It = function() {
      return (u2.It = u2.asm.MirrorPad).apply(null, arguments);
    }, u2.Et = function() {
      return (u2.Et = u2.asm.Mod).apply(null, arguments);
    }, u2.Tt = function() {
      return (u2.Tt = u2.asm.Multinomial).apply(null, arguments);
    }, u2.Mt = function() {
      return (u2.Mt = u2.asm.Multiply).apply(null, arguments);
    }, u2.Ot = function() {
      return (u2.Ot = u2.asm.Neg).apply(null, arguments);
    }, u2.Ft = function() {
      return (u2.Ft = u2.asm.NonMaxSuppressionV3).apply(null, arguments);
    }, u2.Pt = function() {
      return (u2.Pt = u2.asm.NonMaxSuppressionV4).apply(null, arguments);
    }, u2.zt = function() {
      return (u2.zt = u2.asm.NonMaxSuppressionV5).apply(null, arguments);
    }, u2.Vt = function() {
      return (u2.Vt = u2.asm.NotEqual).apply(null, arguments);
    }, u2._t = function() {
      return (u2._t = u2.asm.OneHot).apply(null, arguments);
    }, u2.Dt = function() {
      return (u2.Dt = u2.asm.PadV2).apply(null, arguments);
    }, u2.Wt = function() {
      return (u2.Wt = u2.asm.Pow).apply(null, arguments);
    }, u2.Lt = function() {
      return (u2.Lt = u2.asm.Prelu).apply(null, arguments);
    }, u2.Bt = function() {
      return (u2.Bt = u2.asm.Prod).apply(null, arguments);
    }, u2.Ut = function() {
      return (u2.Ut = u2.asm.RealDiv).apply(null, arguments);
    }, u2.jt = function() {
      return (u2.jt = u2.asm.Reciprocal).apply(null, arguments);
    }, u2.Gt = function() {
      return (u2.Gt = u2.asm.Relu).apply(null, arguments);
    }, u2.Ht = function() {
      return (u2.Ht = u2.asm.Relu6).apply(null, arguments);
    }, u2.Xt = function() {
      return (u2.Xt = u2.asm.ResizeBilinear).apply(null, arguments);
    }, u2.qt = function() {
      return (u2.qt = u2.asm.ResizeBilinearGrad).apply(null, arguments);
    }, u2.Zt = function() {
      return (u2.Zt = u2.asm.ResizeNearestNeighbor).apply(null, arguments);
    }, u2.Kt = function() {
      return (u2.Kt = u2.asm.ResizeNearestNeighborGrad).apply(null, arguments);
    }, u2.Yt = function() {
      return (u2.Yt = u2.asm.Reverse).apply(null, arguments);
    }, u2.Jt = function() {
      return (u2.Jt = u2.asm.RotateWithOffset).apply(null, arguments);
    }, u2.Qt = function() {
      return (u2.Qt = u2.asm.Round).apply(null, arguments);
    }, u2.en = function() {
      return (u2.en = u2.asm.Rsqrt).apply(null, arguments);
    }, u2.tn = function() {
      return (u2.tn = u2.asm.ScatterNd).apply(null, arguments);
    }, u2.nn = function() {
      return (u2.nn = u2.asm.SearchSorted).apply(null, arguments);
    }, u2.rn = function() {
      return (u2.rn = u2.asm.SelectV2).apply(null, arguments);
    }, u2.an = function() {
      return (u2.an = u2.asm.Selu).apply(null, arguments);
    }, u2.sn = function() {
      return (u2.sn = u2.asm.Sigmoid).apply(null, arguments);
    }, u2.ln = function() {
      return (u2.ln = u2.asm.Sign).apply(null, arguments);
    }, u2.un = function() {
      return (u2.un = u2.asm.Sin).apply(null, arguments);
    }, u2.dn = function() {
      return (u2.dn = u2.asm.Sinh).apply(null, arguments);
    }, u2.cn = function() {
      return (u2.cn = u2.asm.Softmax).apply(null, arguments);
    }, u2.hn = function() {
      return (u2.hn = u2.asm.Softplus).apply(null, arguments);
    }, u2.pn = function() {
      return (u2.pn = u2.asm.SparseFillEmptyRows).apply(null, arguments);
    }, u2.fn = function() {
      return (u2.fn = u2.asm.SparseReshape).apply(null, arguments);
    }, u2.mn = function() {
      return (u2.mn = u2.asm.SparseSegmentReduction).apply(null, arguments);
    }, u2.An = function() {
      return (u2.An = u2.asm.SparseToDense).apply(null, arguments);
    }, u2.xn = function() {
      return (u2.xn = u2.asm.Sqrt).apply(null, arguments);
    }, u2.yn = function() {
      return (u2.yn = u2.asm.Square).apply(null, arguments);
    }, u2.bn = function() {
      return (u2.bn = u2.asm.SquaredDifference).apply(null, arguments);
    }, u2.gn = function() {
      return (u2.gn = u2.asm.Step).apply(null, arguments);
    }, u2.vn = function() {
      return (u2.vn = u2.asm.StridedSlice).apply(null, arguments);
    }, u2.wn = function() {
      return (u2.wn = u2.asm.Sub).apply(null, arguments);
    }, u2.kn = function() {
      return (u2.kn = u2.asm.Sum).apply(null, arguments);
    }, u2.Nn = function() {
      return (u2.Nn = u2.asm.Tan).apply(null, arguments);
    }, u2.Cn = function() {
      return (u2.Cn = u2.asm.Tanh).apply(null, arguments);
    }, u2.$n = function() {
      return (u2.$n = u2.asm.TensorScatterUpdate).apply(null, arguments);
    }, u2.Rn = function() {
      return (u2.Rn = u2.asm.Tile).apply(null, arguments);
    }, u2.Sn = function() {
      return (u2.Sn = u2.asm.TopK).apply(null, arguments);
    }, u2.In = function() {
      return (u2.In = u2.asm.Transform).apply(null, arguments);
    }, u2.En = function() {
      return (u2.En = u2.asm.Transpose).apply(null, arguments);
    }, u2.Tn = function() {
      return (u2.Tn = u2.asm.o).apply(null, arguments);
    }, u2.Mn = function() {
      return (u2.Mn = u2.asm.malloc).apply(null, arguments);
    }, u2.On = function() {
      return (u2.On = u2.asm.free).apply(null, arguments);
    }, u2.Fn = function() {
      return (u2.Fn = u2.asm.M).apply(null, arguments);
    };
    var Pe2 = u2.Pn = function() {
      return (Pe2 = u2.Pn = u2.asm.pthread_self).apply(null, arguments);
    };
    u2.zn = function() {
      return (u2.zn = u2.asm.Vn).apply(null, arguments);
    };
    var ze2 = u2._n = function() {
      return (ze2 = u2._n = u2.asm.Dn).apply(null, arguments);
    };
    u2.Wn = function() {
      return (u2.Wn = u2.asm.Ln).apply(null, arguments);
    }, u2.Bn = function() {
      return (u2.Bn = u2.asm.emscripten_main_thread_process_queued_calls).apply(null, arguments);
    }, u2.Un = function() {
      return (u2.Un = u2.asm.emscripten_main_browser_thread_id).apply(null, arguments);
    };
    var Ve2 = u2.jn = function() {
      return (Ve2 = u2.jn = u2.asm.emscripten_run_in_main_runtime_thread_js).apply(null, arguments);
    };
    u2.Gn = function() {
      return (u2.Gn = u2.asm.emscripten_dispatch_to_thread_).apply(null, arguments);
    };
    var _e2, De2, We2, Le2 = u2.Hn = function() {
      return (Le2 = u2.Hn = u2.asm.Xn).apply(null, arguments);
    }, Be2 = u2.qn = function() {
      return (Be2 = u2.qn = u2.asm.Zn).apply(null, arguments);
    }, Ue2 = u2.Kn = function() {
      return (Ue2 = u2.Kn = u2.asm.Yn).apply(null, arguments);
    }, je2 = u2.Jn = function() {
      return (je2 = u2.Jn = u2.asm.emscripten_stack_set_limits).apply(null, arguments);
    }, Ge2 = u2.stackSave = function() {
      return (Ge2 = u2.stackSave = u2.asm.stackSave).apply(null, arguments);
    }, He2 = u2.stackRestore = function() {
      return (He2 = u2.stackRestore = u2.asm.stackRestore).apply(null, arguments);
    }, Xe2 = u2.stackAlloc = function() {
      return (Xe2 = u2.stackAlloc = u2.asm.stackAlloc).apply(null, arguments);
    };
    function qe2(e22) {
      if (0 >= re2) {
        if (y2) return s2(u2), Q2(), void startWorker(u2);
        (() => {
          if (u2.preRun) for ("function" == typeof u2.preRun && (u2.preRun = [u2.preRun]); u2.preRun.length; ) ee2(u2.preRun.shift());
          Ae2(Z2);
        })(), re2 > 0 || (u2.setStatus ? (u2.setStatus("Running..."), setTimeout(() => {
          setTimeout(() => {
            u2.setStatus("");
          }, 1), t4();
        }, 1)) : t4());
      }
      function t4() {
        _e2 || (_e2 = true, u2.calledRun = true, !U2 && (Q2(), s2(u2), u2.onRuntimeInitialized && u2.onRuntimeInitialized(), (() => {
          if (!y2) {
            if (u2.postRun) for ("function" == typeof u2.postRun && (u2.postRun = [u2.postRun]); u2.postRun.length; ) te2(u2.postRun.shift());
            Ae2(Y2);
          }
        })()));
      }
    }
    if (u2.dynCall_iijjiiii = function() {
      return (u2.dynCall_iijjiiii = u2.asm.dynCall_iijjiiii).apply(null, arguments);
    }, u2.dynCall_jiji = function() {
      return (u2.dynCall_jiji = u2.asm.dynCall_jiji).apply(null, arguments);
    }, u2.keepRuntimeAlive = J2, u2.wasmMemory = I2, u2.cwrap = (e22, n3, r4, a3) => {
      var i3 = (r4 = r4 || []).every((e23) => "number" === e23 || "boolean" === e23);
      return "string" !== n3 && i3 && !a3 ? Me2(e22) : function() {
        return (function(e23, n4, r5, a4) {
          var i4, s3 = { string(e24) {
            var n5 = 0;
            if (null != e24 && 0 !== e24) {
              var r6 = 1 + (e24.length << 2);
              ((e25, n6, r7) => {
                ((e26, t4, n7, r8) => {
                  if (0 >= r8) return 0;
                  for (var a5 = (n7 >>>= 0) + r8 - 1, i5 = 0; e26.length > i5; ++i5) {
                    var s4 = e26.charCodeAt(i5);
                    if (55296 > s4 || s4 > 57343 || (s4 = 65536 + ((1023 & s4) << 10) | 1023 & e26.charCodeAt(++i5)), s4 > 127) if (s4 > 2047) if (s4 > 65535) {
                      if (n7 + 3 >= a5) break;
                      t4[n7++ >>> 0] = 240 | s4 >> 18, t4[n7++ >>> 0] = 128 | s4 >> 12 & 63, t4[n7++ >>> 0] = 128 | s4 >> 6 & 63, t4[n7++ >>> 0] = 128 | 63 & s4;
                    } else {
                      if (n7 + 2 >= a5) break;
                      t4[n7++ >>> 0] = 224 | s4 >> 12, t4[n7++ >>> 0] = 128 | s4 >> 6 & 63, t4[n7++ >>> 0] = 128 | 63 & s4;
                    }
                    else {
                      if (n7 + 1 >= a5) break;
                      t4[n7++ >>> 0] = 192 | s4 >> 6, t4[n7++ >>> 0] = 128 | 63 & s4;
                    }
                    else {
                      if (n7 >= a5) break;
                      t4[n7++ >>> 0] = s4;
                    }
                  }
                  t4[n7 >>> 0] = 0;
                })(e25, t3(), n6, r7);
              })(e24, n5 = Xe2(r6), r6);
            }
            return n5;
          }, array(e24) {
            var t4 = Xe2(e24.length);
            return ((e25, t5) => {
              (I2.buffer != V2 && H2(I2.buffer), _2).set(e25, t5 >>> 0);
            })(e24, t4), t4;
          } }, o3 = Me2(e23), l3 = [], u3 = 0;
          if (a4) for (var d3 = 0; a4.length > d3; d3++) {
            var c3 = s3[r5[d3]];
            c3 ? (0 === u3 && (u3 = Ge2()), l3[d3] = c3(a4[d3])) : l3[d3] = a4[d3];
          }
          return i4 = o3.apply(null, l3), 0 !== u3 && He2(u3), ((e24) => "string" === n4 ? ((e25) => (e25 >>>= 0) ? G2(t3(), e25, void 0) : "")(e24) : "boolean" === n4 ? !!e24 : e24)(i4);
        })(e22, n3, r4, arguments);
      };
    }, u2.ExitStatus = de2, u2.PThread = me2, ae2 = function e22() {
      _e2 || qe2(), _e2 || (ae2 = e22);
    }, u2.preInit) for ("function" == typeof u2.preInit && (u2.preInit = [u2.preInit]); u2.preInit.length > 0; ) u2.preInit.pop()();
    if (qe2(), l2 && (De2 = { uncaughtException: process.listeners("uncaughtException").filter((e22) => !l2.uncaughtException.indexOf(e22) > -1), unhandledRejection: process.listeners("unhandledRejection").filter((e22) => !l2.unhandledRejection.indexOf(e22) > -1) }), "undefined" != typeof WasmBackendModule) We2 = WasmBackendModule;
    else {
      if (void 0 === e21) throw Error("Could not find wasm module in post.js");
      We2 = e21;
    }
    if (De2) {
      var Ze2 = We2.U;
      We2.U = () => {
        Ze2(), De2.uncaughtException.forEach((e22) => {
          process.removeListener("uncaughtException", e22);
        }), De2.unhandledRejection.forEach((e22) => {
          process.removeListener("unhandledRejection", e22);
        });
      };
    }
    return e21.ready;
  });
  "object" == typeof e20 && "object" == typeof t2 ? t2.exports = r2 : "function" == typeof define && define.amd ? define([], () => r2) : "object" == typeof e20 && (e20.WasmBackendModuleThreadedSimd = r2);
});
var z = m((e20, t2) => {
  t2.exports.wasmWorkerContents = '"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};';
});
var V = m((e20, t2) => {
  var n2, r2 = (n2 = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (n2 = n2 || __filename), function(e21) {
    var t3, r3, a2, i2 = void 0 !== (e21 = e21 || {}) ? e21 : {};
    i2.ready = new Promise((e22, n3) => {
      t3 = e22, r3 = n3;
    }), "undefined" != typeof process && process.listeners && (a2 = { uncaughtException: process.listeners("uncaughtException"), unhandledRejection: process.listeners("unhandledRejection") });
    var s2, o2, l2, u2 = Object.assign({}, i2), d2 = "object" == typeof window, c2 = "function" == typeof importScripts, h2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, p2 = "";
    if (h2) {
      var f2 = E(), m2 = T();
      p2 = c2 ? m2.dirname(p2) + "/" : __dirname + "/", s2 = (e22, t4) => (e22 = L2(e22) ? new URL(e22) : m2.normalize(e22), f2.readFileSync(e22, t4 ? void 0 : "utf8")), l2 = (e22) => {
        var t4 = s2(e22, true);
        return t4.buffer || (t4 = new Uint8Array(t4)), t4;
      }, o2 = (e22, t4, n3) => {
        e22 = L2(e22) ? new URL(e22) : m2.normalize(e22), f2.readFile(e22, (e23, r4) => {
          e23 ? n3(e23) : t4(r4.buffer);
        });
      }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", (e22) => {
        if (!(e22 instanceof U2)) throw e22;
      }), process.on("unhandledRejection", (e22) => {
        throw e22;
      }), i2.inspect = () => "[Emscripten Module object]";
    } else (d2 || c2) && (c2 ? p2 = self.location.href : "undefined" != typeof document && document.currentScript && (p2 = document.currentScript.src), n2 && (p2 = n2), p2 = 0 !== p2.indexOf("blob:") ? p2.substr(0, p2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", s2 = (e22) => {
      var t4 = new XMLHttpRequest();
      return t4.open("GET", e22, false), t4.send(null), t4.responseText;
    }, c2 && (l2 = (e22) => {
      var t4 = new XMLHttpRequest();
      return t4.open("GET", e22, false), t4.responseType = "arraybuffer", t4.send(null), new Uint8Array(t4.response);
    }), o2 = (e22, t4, n3) => {
      var r4 = new XMLHttpRequest();
      r4.open("GET", e22, true), r4.responseType = "arraybuffer", r4.onload = () => {
        200 == r4.status || 0 == r4.status && r4.response ? t4(r4.response) : n3();
      }, r4.onerror = n3, r4.send(null);
    });
    var A2, x2 = i2.print || console.log.bind(console), y2 = i2.printErr || console.warn.bind(console);
    Object.assign(i2, u2), u2 = null, i2.wasmBinary && (A2 = i2.wasmBinary), "object" != typeof WebAssembly && D2("no native wasm support detected");
    var b2, g2, v2, w2, k2, N2 = false, C2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
    function $2(e22, t4, n3) {
      for (var r4 = (t4 >>>= 0) + n3, a3 = t4; e22[a3] && r4 > a3; ) ++a3;
      if (a3 - t4 > 16 && e22.buffer && C2) return C2.decode(e22.subarray(t4, a3));
      for (var i3 = ""; a3 > t4; ) {
        var s3 = e22[t4++];
        if (128 & s3) {
          var o3 = 63 & e22[t4++];
          if (192 != (224 & s3)) {
            var l3 = 63 & e22[t4++];
            if (65536 > (s3 = 224 == (240 & s3) ? (15 & s3) << 12 | o3 << 6 | l3 : (7 & s3) << 18 | o3 << 12 | l3 << 6 | 63 & e22[t4++])) i3 += String.fromCharCode(s3);
            else {
              var u3 = s3 - 65536;
              i3 += String.fromCharCode(55296 | u3 >> 10, 56320 | 1023 & u3);
            }
          } else i3 += String.fromCharCode((31 & s3) << 6 | o3);
        } else i3 += String.fromCharCode(s3);
      }
      return i3;
    }
    function R2(e22) {
      g2 = e22, i2.HEAP8 = v2 = new Int8Array(e22), i2.HEAP16 = new Int16Array(e22), i2.HEAP32 = new Int32Array(e22), i2.HEAPU8 = w2 = new Uint8Array(e22), i2.HEAPU16 = new Uint16Array(e22), i2.HEAPU32 = k2 = new Uint32Array(e22), i2.HEAPF32 = new Float32Array(e22), i2.HEAPF64 = new Float64Array(e22);
    }
    var S2 = [], I2 = [], M2 = [];
    function O2(e22) {
      S2.unshift(e22);
    }
    function F2(e22) {
      M2.unshift(e22);
    }
    var P2, z2, V2 = 0, _2 = null;
    function D2(e22) {
      i2.onAbort && i2.onAbort(e22), y2(e22 = "Aborted(" + e22 + ")"), N2 = true, e22 += ". Build with -sASSERTIONS for more info.";
      var t4 = new WebAssembly.RuntimeError(e22);
      throw r3(t4), t4;
    }
    function W2(e22) {
      return e22.startsWith("data:application/octet-stream;base64,");
    }
    function L2(e22) {
      return e22.startsWith("file://");
    }
    function B2(e22) {
      try {
        if (e22 == P2 && A2) return new Uint8Array(A2);
        if (l2) return l2(e22);
        throw "both async and sync fetching of the wasm failed";
      } catch (t4) {
        D2(t4);
      }
    }
    function U2(e22) {
      this.name = "ExitStatus", this.message = "Program terminated with exit(" + e22 + ")", this.status = e22;
    }
    function j2(e22) {
      for (; e22.length > 0; ) e22.shift()(i2);
    }
    function G2(e22) {
      try {
        return b2.grow(e22 - g2.byteLength + 65535 >>> 16), R2(b2.buffer), 1;
      } catch (t4) {
      }
    }
    W2(P2 = "tfjs-backend-wasm.wasm") || (z2 = P2, P2 = i2.locateFile ? i2.locateFile(z2, p2) : p2 + z2);
    var H2 = [null, [], []];
    function X2(e22, t4) {
      var n3 = H2[e22];
      0 === t4 || 10 === t4 ? ((1 === e22 ? x2 : y2)($2(n3, 0)), n3.length = 0) : n3.push(t4);
    }
    function q2(e22) {
      return i2["_" + e22];
    }
    var Z2 = { abort() {
      D2("");
    }, emscripten_get_heap_max: () => 4294901760, emscripten_memcpy_big(e22, t4, n3) {
      w2.copyWithin(e22 >>> 0, t4 >>> 0, t4 + n3 >>> 0);
    }, emscripten_resize_heap(e22) {
      var t4 = w2.length, n3 = 4294901760;
      if ((e22 >>>= 0) > n3) return false;
      let r4 = (e23, t5) => e23 + (t5 - e23 % t5) % t5;
      for (var a3 = 1; 4 >= a3; a3 *= 2) {
        var i3 = t4 * (1 + 0.2 / a3);
        if (G2(Math.min(n3, r4(Math.max(e22, i3 = Math.min(i3, e22 + 100663296)), 65536)))) return true;
      }
      return false;
    }, fd_close: (e22) => 52, fd_seek: (e22, t4, n3, r4, a3) => 70, fd_write(e22, t4, n3, r4) {
      for (var a3 = 0, i3 = 0; n3 > i3; i3++) {
        var s3 = k2[t4 >>> 2], o3 = k2[t4 + 4 >>> 2];
        t4 += 8;
        for (var l3 = 0; o3 > l3; l3++) X2(e22, w2[s3 + l3 >>> 0]);
        a3 += o3;
      }
      return k2[r4 >>> 2] = a3, 0;
    } };
    (() => {
      var e22 = { env: Z2, wasi_snapshot_preview1: Z2 };
      function t4(e23, t5) {
        i2.asm = e23.exports, R2((b2 = i2.asm.memory).buffer), ((e24) => {
          I2.unshift(e24);
        })(i2.asm.F), (() => {
          if (V2--, i2.monitorRunDependencies && i2.monitorRunDependencies(V2), 0 == V2 && _2) {
            var e24 = _2;
            _2 = null, e24();
          }
        })();
      }
      function n3(e23) {
        t4(e23.instance);
      }
      function a3(t5) {
        return (() => {
          if (!A2 && (d2 || c2)) {
            if ("function" == typeof fetch && !L2(P2)) return fetch(P2, { credentials: "same-origin" }).then((e23) => {
              if (!e23.ok) throw "failed to load wasm binary file at '" + P2 + "'";
              return e23.arrayBuffer();
            }).catch(() => B2(P2));
            if (o2) return new Promise((e23, t6) => {
              o2(P2, (t7) => {
                e23(new Uint8Array(t7));
              }, t6);
            });
          }
          return Promise.resolve().then(() => B2(P2));
        })().then((t6) => WebAssembly.instantiate(t6, e22)).then((e23) => e23).then(t5, (e23) => {
          y2("failed to asynchronously prepare wasm: " + e23), D2(e23);
        });
      }
      if (V2++, i2.monitorRunDependencies && i2.monitorRunDependencies(V2), i2.instantiateWasm) try {
        return i2.instantiateWasm(e22, t4);
      } catch (s3) {
        y2("Module.instantiateWasm callback failed with error: " + s3), r3(s3);
      }
      (A2 || "function" != typeof WebAssembly.instantiateStreaming || W2(P2) || L2(P2) || h2 || "function" != typeof fetch ? a3(n3) : fetch(P2, { credentials: "same-origin" }).then((t5) => WebAssembly.instantiateStreaming(t5, e22).then(n3, (e23) => (y2("wasm streaming compile failed: " + e23), y2("falling back to ArrayBuffer instantiation"), a3(n3))))).catch(r3);
    })(), i2.P = function() {
      return (i2.P = i2.asm.F).apply(null, arguments);
    }, i2.V = function() {
      return (i2.V = i2.asm.init).apply(null, arguments);
    }, i2._ = function() {
      return (i2._ = i2.asm.init_with_threads_count).apply(null, arguments);
    }, i2.D = function() {
      return (i2.D = i2.asm.get_threads_count).apply(null, arguments);
    }, i2.W = function() {
      return (i2.W = i2.asm.register_tensor).apply(null, arguments);
    }, i2.L = function() {
      return (i2.L = i2.asm.dispose_data).apply(null, arguments);
    }, i2.U = function() {
      return (i2.U = i2.asm.dispose).apply(null, arguments);
    }, i2.H = function() {
      return (i2.H = i2.asm.Abs).apply(null, arguments);
    }, i2.q = function() {
      return (i2.q = i2.asm.Acos).apply(null, arguments);
    }, i2.Z = function() {
      return (i2.Z = i2.asm.Acosh).apply(null, arguments);
    }, i2.K = function() {
      return (i2.K = i2.asm.Add).apply(null, arguments);
    }, i2.Y = function() {
      return (i2.Y = i2.asm.AddN).apply(null, arguments);
    }, i2.J = function() {
      return (i2.J = i2.asm.All).apply(null, arguments);
    }, i2.ee = function() {
      return (i2.ee = i2.asm.Any).apply(null, arguments);
    }, i2.te = function() {
      return (i2.te = i2.asm.ArgMax).apply(null, arguments);
    }, i2.re = function() {
      return (i2.re = i2.asm.ArgMin).apply(null, arguments);
    }, i2.ae = function() {
      return (i2.ae = i2.asm.Asin).apply(null, arguments);
    }, i2.ie = function() {
      return (i2.ie = i2.asm.Asinh).apply(null, arguments);
    }, i2.se = function() {
      return (i2.se = i2.asm.Atan).apply(null, arguments);
    }, i2.oe = function() {
      return (i2.oe = i2.asm.Atan2).apply(null, arguments);
    }, i2.ue = function() {
      return (i2.ue = i2.asm.Atanh).apply(null, arguments);
    }, i2.de = function() {
      return (i2.de = i2.asm.AvgPool).apply(null, arguments);
    }, i2.ce = function() {
      return (i2.ce = i2.asm.AvgPool3D).apply(null, arguments);
    }, i2.he = function() {
      return (i2.he = i2.asm.AvgPool3DGrad).apply(null, arguments);
    }, i2.pe = function() {
      return (i2.pe = i2.asm.AvgPoolGrad).apply(null, arguments);
    }, i2.fe = function() {
      return (i2.fe = i2.asm.BatchMatMul).apply(null, arguments);
    }, i2.me = function() {
      return (i2.me = i2.asm.Bincount).apply(null, arguments);
    }, i2.Ae = function() {
      return (i2.Ae = i2.asm.BitwiseAnd).apply(null, arguments);
    }, i2.xe = function() {
      return (i2.xe = i2.asm.Ceil).apply(null, arguments);
    }, i2.ye = function() {
      return (i2.ye = i2.asm.ClipByValue).apply(null, arguments);
    }, i2.be = function() {
      return (i2.be = i2.asm.Conv2D).apply(null, arguments);
    }, i2.ve = function() {
      return (i2.ve = i2.asm.Conv2DBackpropInput).apply(null, arguments);
    }, i2.we = function() {
      return (i2.we = i2.asm.Conv3D).apply(null, arguments);
    }, i2.ke = function() {
      return (i2.ke = i2.asm.Conv3DBackpropFilterV2).apply(null, arguments);
    }, i2.Ne = function() {
      return (i2.Ne = i2.asm.Conv3DBackpropInputV2).apply(null, arguments);
    }, i2.Ce = function() {
      return (i2.Ce = i2.asm.Cos).apply(null, arguments);
    }, i2.$e = function() {
      return (i2.$e = i2.asm.Cosh).apply(null, arguments);
    }, i2.Re = function() {
      return (i2.Re = i2.asm.CropAndResize).apply(null, arguments);
    }, i2.Se = function() {
      return (i2.Se = i2.asm.Cumprod).apply(null, arguments);
    }, i2.Ie = function() {
      return (i2.Ie = i2.asm.Cumsum).apply(null, arguments);
    }, i2.Ee = function() {
      return (i2.Ee = i2.asm.DenseBincount).apply(null, arguments);
    }, i2.Te = function() {
      return (i2.Te = i2.asm.DepthToSpace).apply(null, arguments);
    }, i2.Me = function() {
      return (i2.Me = i2.asm.DepthwiseConv2dNative).apply(null, arguments);
    }, i2.Oe = function() {
      return (i2.Oe = i2.asm.Diag).apply(null, arguments);
    }, i2.Fe = function() {
      return (i2.Fe = i2.asm.Dilation2D).apply(null, arguments);
    }, i2.Pe = function() {
      return (i2.Pe = i2.asm.Dilation2DBackpropFilter).apply(null, arguments);
    }, i2.ze = function() {
      return (i2.ze = i2.asm.Dilation2DBackpropInput).apply(null, arguments);
    }, i2.Ve = function() {
      return (i2.Ve = i2.asm.Elu).apply(null, arguments);
    }, i2._e = function() {
      return (i2._e = i2.asm.EluGrad).apply(null, arguments);
    }, i2.De = function() {
      return (i2.De = i2.asm.Equal).apply(null, arguments);
    }, i2.We = function() {
      return (i2.We = i2.asm.Erf).apply(null, arguments);
    }, i2.Le = function() {
      return (i2.Le = i2.asm.Exp).apply(null, arguments);
    }, i2.Be = function() {
      return (i2.Be = i2.asm.Expm1).apply(null, arguments);
    }, i2.Ue = function() {
      return (i2.Ue = i2.asm.FlipLeftRight).apply(null, arguments);
    }, i2.je = function() {
      return (i2.je = i2.asm.Floor).apply(null, arguments);
    }, i2.Ge = function() {
      return (i2.Ge = i2.asm.FloorDiv).apply(null, arguments);
    }, i2.He = function() {
      return (i2.He = i2.asm.FusedBatchNorm).apply(null, arguments);
    }, i2.Xe = function() {
      return (i2.Xe = i2.asm.FusedConv2D).apply(null, arguments);
    }, i2.qe = function() {
      return (i2.qe = i2.asm.FusedDepthwiseConv2D).apply(null, arguments);
    }, i2.Ze = function() {
      return (i2.Ze = i2.asm.Gather).apply(null, arguments);
    }, i2.Ke = function() {
      return (i2.Ke = i2.asm.GatherNd).apply(null, arguments);
    }, i2.Ye = function() {
      return (i2.Ye = i2.asm.Greater).apply(null, arguments);
    }, i2.Je = function() {
      return (i2.Je = i2.asm.GreaterEqual).apply(null, arguments);
    }, i2.Qe = function() {
      return (i2.Qe = i2.asm.IsFinite).apply(null, arguments);
    }, i2.et = function() {
      return (i2.et = i2.asm.IsInf).apply(null, arguments);
    }, i2.tt = function() {
      return (i2.tt = i2.asm.IsNan).apply(null, arguments);
    }, i2.nt = function() {
      return (i2.nt = i2.asm.LRN).apply(null, arguments);
    }, i2.rt = function() {
      return (i2.rt = i2.asm.LRNGrad).apply(null, arguments);
    }, i2.it = function() {
      return (i2.it = i2.asm.LeakyRelu).apply(null, arguments);
    }, i2.st = function() {
      return (i2.st = i2.asm.Less).apply(null, arguments);
    }, i2.ot = function() {
      return (i2.ot = i2.asm.LessEqual).apply(null, arguments);
    }, i2.ut = function() {
      return (i2.ut = i2.asm.LinSpace).apply(null, arguments);
    }, i2.dt = function() {
      return (i2.dt = i2.asm.Log).apply(null, arguments);
    }, i2.ct = function() {
      return (i2.ct = i2.asm.Log1p).apply(null, arguments);
    }, i2.ht = function() {
      return (i2.ht = i2.asm.LogicalAnd).apply(null, arguments);
    }, i2.ft = function() {
      return (i2.ft = i2.asm.LogicalNot).apply(null, arguments);
    }, i2.At = function() {
      return (i2.At = i2.asm.LogicalOr).apply(null, arguments);
    }, i2.xt = function() {
      return (i2.xt = i2.asm.LogicalXor).apply(null, arguments);
    }, i2.yt = function() {
      return (i2.yt = i2.asm.Max).apply(null, arguments);
    }, i2.bt = function() {
      return (i2.bt = i2.asm.MaxPool).apply(null, arguments);
    }, i2.vt = function() {
      return (i2.vt = i2.asm.MaxPool3D).apply(null, arguments);
    }, i2.wt = function() {
      return (i2.wt = i2.asm.MaxPool3DGrad).apply(null, arguments);
    }, i2.kt = function() {
      return (i2.kt = i2.asm.MaxPoolGrad).apply(null, arguments);
    }, i2.Nt = function() {
      return (i2.Nt = i2.asm.MaxPoolWithArgmax).apply(null, arguments);
    }, i2.Ct = function() {
      return (i2.Ct = i2.asm.Maximum).apply(null, arguments);
    }, i2.$t = function() {
      return (i2.$t = i2.asm.Mean).apply(null, arguments);
    }, i2.Rt = function() {
      return (i2.Rt = i2.asm.Min).apply(null, arguments);
    }, i2.St = function() {
      return (i2.St = i2.asm.Minimum).apply(null, arguments);
    }, i2.It = function() {
      return (i2.It = i2.asm.MirrorPad).apply(null, arguments);
    }, i2.Et = function() {
      return (i2.Et = i2.asm.Mod).apply(null, arguments);
    }, i2.Tt = function() {
      return (i2.Tt = i2.asm.Multinomial).apply(null, arguments);
    }, i2.Mt = function() {
      return (i2.Mt = i2.asm.Multiply).apply(null, arguments);
    }, i2.Ot = function() {
      return (i2.Ot = i2.asm.Neg).apply(null, arguments);
    }, i2.Ft = function() {
      return (i2.Ft = i2.asm.NonMaxSuppressionV3).apply(null, arguments);
    }, i2.Pt = function() {
      return (i2.Pt = i2.asm.NonMaxSuppressionV4).apply(null, arguments);
    }, i2.zt = function() {
      return (i2.zt = i2.asm.NonMaxSuppressionV5).apply(null, arguments);
    }, i2.Vt = function() {
      return (i2.Vt = i2.asm.NotEqual).apply(null, arguments);
    }, i2._t = function() {
      return (i2._t = i2.asm.OneHot).apply(null, arguments);
    }, i2.Dt = function() {
      return (i2.Dt = i2.asm.PadV2).apply(null, arguments);
    }, i2.Wt = function() {
      return (i2.Wt = i2.asm.Pow).apply(null, arguments);
    }, i2.Lt = function() {
      return (i2.Lt = i2.asm.Prelu).apply(null, arguments);
    }, i2.Bt = function() {
      return (i2.Bt = i2.asm.Prod).apply(null, arguments);
    }, i2.Ut = function() {
      return (i2.Ut = i2.asm.RealDiv).apply(null, arguments);
    }, i2.jt = function() {
      return (i2.jt = i2.asm.Reciprocal).apply(null, arguments);
    }, i2.Gt = function() {
      return (i2.Gt = i2.asm.Relu).apply(null, arguments);
    }, i2.Ht = function() {
      return (i2.Ht = i2.asm.Relu6).apply(null, arguments);
    }, i2.Xt = function() {
      return (i2.Xt = i2.asm.ResizeBilinear).apply(null, arguments);
    }, i2.qt = function() {
      return (i2.qt = i2.asm.ResizeBilinearGrad).apply(null, arguments);
    }, i2.Zt = function() {
      return (i2.Zt = i2.asm.ResizeNearestNeighbor).apply(null, arguments);
    }, i2.Kt = function() {
      return (i2.Kt = i2.asm.ResizeNearestNeighborGrad).apply(null, arguments);
    }, i2.Yt = function() {
      return (i2.Yt = i2.asm.Reverse).apply(null, arguments);
    }, i2.Jt = function() {
      return (i2.Jt = i2.asm.RotateWithOffset).apply(null, arguments);
    }, i2.Qt = function() {
      return (i2.Qt = i2.asm.Round).apply(null, arguments);
    }, i2.en = function() {
      return (i2.en = i2.asm.Rsqrt).apply(null, arguments);
    }, i2.tn = function() {
      return (i2.tn = i2.asm.ScatterNd).apply(null, arguments);
    }, i2.nn = function() {
      return (i2.nn = i2.asm.SearchSorted).apply(null, arguments);
    }, i2.rn = function() {
      return (i2.rn = i2.asm.SelectV2).apply(null, arguments);
    }, i2.an = function() {
      return (i2.an = i2.asm.Selu).apply(null, arguments);
    }, i2.sn = function() {
      return (i2.sn = i2.asm.Sigmoid).apply(null, arguments);
    }, i2.ln = function() {
      return (i2.ln = i2.asm.Sign).apply(null, arguments);
    }, i2.un = function() {
      return (i2.un = i2.asm.Sin).apply(null, arguments);
    }, i2.dn = function() {
      return (i2.dn = i2.asm.Sinh).apply(null, arguments);
    }, i2.cn = function() {
      return (i2.cn = i2.asm.Softmax).apply(null, arguments);
    }, i2.hn = function() {
      return (i2.hn = i2.asm.Softplus).apply(null, arguments);
    }, i2.pn = function() {
      return (i2.pn = i2.asm.SparseFillEmptyRows).apply(null, arguments);
    }, i2.fn = function() {
      return (i2.fn = i2.asm.SparseReshape).apply(null, arguments);
    }, i2.mn = function() {
      return (i2.mn = i2.asm.SparseSegmentReduction).apply(null, arguments);
    }, i2.An = function() {
      return (i2.An = i2.asm.SparseToDense).apply(null, arguments);
    }, i2.xn = function() {
      return (i2.xn = i2.asm.Sqrt).apply(null, arguments);
    }, i2.yn = function() {
      return (i2.yn = i2.asm.Square).apply(null, arguments);
    }, i2.bn = function() {
      return (i2.bn = i2.asm.SquaredDifference).apply(null, arguments);
    }, i2.gn = function() {
      return (i2.gn = i2.asm.Step).apply(null, arguments);
    }, i2.vn = function() {
      return (i2.vn = i2.asm.StridedSlice).apply(null, arguments);
    }, i2.wn = function() {
      return (i2.wn = i2.asm.Sub).apply(null, arguments);
    }, i2.kn = function() {
      return (i2.kn = i2.asm.Sum).apply(null, arguments);
    }, i2.Nn = function() {
      return (i2.Nn = i2.asm.Tan).apply(null, arguments);
    }, i2.Cn = function() {
      return (i2.Cn = i2.asm.Tanh).apply(null, arguments);
    }, i2.$n = function() {
      return (i2.$n = i2.asm.TensorScatterUpdate).apply(null, arguments);
    }, i2.Rn = function() {
      return (i2.Rn = i2.asm.Tile).apply(null, arguments);
    }, i2.Sn = function() {
      return (i2.Sn = i2.asm.TopK).apply(null, arguments);
    }, i2.In = function() {
      return (i2.In = i2.asm.Transform).apply(null, arguments);
    }, i2.En = function() {
      return (i2.En = i2.asm.Transpose).apply(null, arguments);
    }, i2.Tn = function() {
      return (i2.Tn = i2.asm.o).apply(null, arguments);
    }, i2.Mn = function() {
      return (i2.Mn = i2.asm.malloc).apply(null, arguments);
    }, i2.On = function() {
      return (i2.On = i2.asm.free).apply(null, arguments);
    }, i2.zn = function() {
      return (i2.zn = i2.asm.Vn).apply(null, arguments);
    };
    var K2, Y2, J2, Q2 = i2.stackSave = function() {
      return (Q2 = i2.stackSave = i2.asm.stackSave).apply(null, arguments);
    }, ee2 = i2.stackRestore = function() {
      return (ee2 = i2.stackRestore = i2.asm.stackRestore).apply(null, arguments);
    }, te2 = i2.stackAlloc = function() {
      return (te2 = i2.stackAlloc = i2.asm.stackAlloc).apply(null, arguments);
    };
    function ne2(e22) {
      function n3() {
        K2 || (K2 = true, i2.calledRun = true, !N2 && (j2(I2), t3(i2), i2.onRuntimeInitialized && i2.onRuntimeInitialized(), (() => {
          if (i2.postRun) for ("function" == typeof i2.postRun && (i2.postRun = [i2.postRun]); i2.postRun.length; ) F2(i2.postRun.shift());
          j2(M2);
        })()));
      }
      V2 > 0 || ((() => {
        if (i2.preRun) for ("function" == typeof i2.preRun && (i2.preRun = [i2.preRun]); i2.preRun.length; ) O2(i2.preRun.shift());
        j2(S2);
      })(), V2 > 0) || (i2.setStatus ? (i2.setStatus("Running..."), setTimeout(() => {
        setTimeout(() => {
          i2.setStatus("");
        }, 1), n3();
      }, 1)) : n3());
    }
    if (i2.dynCall_iijjiiii = function() {
      return (i2.dynCall_iijjiiii = i2.asm.dynCall_iijjiiii).apply(null, arguments);
    }, i2.dynCall_jiji = function() {
      return (i2.dynCall_jiji = i2.asm.dynCall_jiji).apply(null, arguments);
    }, i2.cwrap = (e22, t4, n3, r4) => {
      var a3 = (n3 = n3 || []).every((e23) => "number" === e23 || "boolean" === e23);
      return "string" !== t4 && a3 && !r4 ? q2(e22) : function() {
        return ((e23, t5, n4, r5) => {
          var a4, i3 = { string(e24) {
            var t6 = 0;
            if (null != e24 && 0 !== e24) {
              var n5 = 1 + (e24.length << 2);
              ((e25, t7, n6) => {
                ((e26, t8, n7, r6) => {
                  if (0 >= r6) return 0;
                  for (var a5 = (n7 >>>= 0) + r6 - 1, i4 = 0; e26.length > i4; ++i4) {
                    var s4 = e26.charCodeAt(i4);
                    if (55296 > s4 || s4 > 57343 || (s4 = 65536 + ((1023 & s4) << 10) | 1023 & e26.charCodeAt(++i4)), s4 > 127) if (s4 > 2047) if (s4 > 65535) {
                      if (n7 + 3 >= a5) break;
                      t8[n7++ >>> 0] = 240 | s4 >> 18, t8[n7++ >>> 0] = 128 | s4 >> 12 & 63, t8[n7++ >>> 0] = 128 | s4 >> 6 & 63, t8[n7++ >>> 0] = 128 | 63 & s4;
                    } else {
                      if (n7 + 2 >= a5) break;
                      t8[n7++ >>> 0] = 224 | s4 >> 12, t8[n7++ >>> 0] = 128 | s4 >> 6 & 63, t8[n7++ >>> 0] = 128 | 63 & s4;
                    }
                    else {
                      if (n7 + 1 >= a5) break;
                      t8[n7++ >>> 0] = 192 | s4 >> 6, t8[n7++ >>> 0] = 128 | 63 & s4;
                    }
                    else {
                      if (n7 >= a5) break;
                      t8[n7++ >>> 0] = s4;
                    }
                  }
                  t8[n7 >>> 0] = 0;
                })(e25, w2, t7, n6);
              })(e24, t6 = te2(n5), n5);
            }
            return t6;
          }, array(e24) {
            var t6 = te2(e24.length);
            return ((e25, t7) => {
              v2.set(e25, t7 >>> 0);
            })(e24, t6), t6;
          } }, s3 = q2(e23), o3 = [], l3 = 0;
          if (r5) for (var u3 = 0; r5.length > u3; u3++) {
            var d3 = i3[n4[u3]];
            d3 ? (0 === l3 && (l3 = Q2()), o3[u3] = d3(r5[u3])) : o3[u3] = r5[u3];
          }
          return a4 = s3.apply(null, o3), 0 !== l3 && ee2(l3), ((e24) => "string" === t5 ? ((e25) => (e25 >>>= 0) ? $2(w2, e25, void 0) : "")(e24) : "boolean" === t5 ? !!e24 : e24)(a4);
        })(e22, t4, n3, arguments);
      };
    }, _2 = function e22() {
      K2 || ne2(), K2 || (_2 = e22);
    }, i2.preInit) for ("function" == typeof i2.preInit && (i2.preInit = [i2.preInit]); i2.preInit.length > 0; ) i2.preInit.pop()();
    if (ne2(), a2 && (Y2 = { uncaughtException: process.listeners("uncaughtException").filter((e22) => !a2.uncaughtException.indexOf(e22) > -1), unhandledRejection: process.listeners("unhandledRejection").filter((e22) => !a2.unhandledRejection.indexOf(e22) > -1) }), void 0 !== e21) J2 = e21;
    else {
      if ("undefined" == typeof WasmBackendModuleThreadedSimd) throw Error("Could not find wasm module in post.js");
      J2 = WasmBackendModuleThreadedSimd;
    }
    if (Y2) {
      var re2 = J2.U;
      J2.U = () => {
        re2(), Y2.uncaughtException.forEach((e22) => {
          process.removeListener("uncaughtException", e22);
        }), Y2.unhandledRejection.forEach((e22) => {
          process.removeListener("unhandledRejection", e22);
        });
      };
    }
    return e21.ready;
  });
  "object" == typeof e20 && "object" == typeof t2 ? t2.exports = r2 : "function" == typeof define && define.amd ? define([], () => r2) : "object" == typeof e20 && (e20.WasmBackendModule = r2);
});
var _ = class {
  constructor(e20, t2) {
    this.backend = e20, this.dataMover = t2, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
  }
  get(e20) {
    return this.data.has(e20) || this.dataMover.moveData(this.backend, e20), this.data.get(e20);
  }
  set(e20, t2) {
    this.dataIdsCount++, this.data.set(e20, t2);
  }
  has(e20) {
    return this.data.has(e20);
  }
  delete(e20) {
    return this.dataIdsCount--, this.data.delete(e20);
  }
  numDataIds() {
    return this.dataIdsCount;
  }
};
var D = class {
  refCount(e20) {
    return W("refCount");
  }
  incRef(e20) {
    return W("incRef");
  }
  timerAvailable() {
    return true;
  }
  time(e20) {
    return W("time");
  }
  read(e20) {
    return W("read");
  }
  readSync(e20) {
    return W("readSync");
  }
  readToGPU(e20, t2) {
    return W("readToGPU");
  }
  numDataIds() {
    return W("numDataIds");
  }
  disposeData(e20, t2) {
    return W("disposeData");
  }
  write(e20, t2, n2) {
    return W("write");
  }
  move(e20, t2, n2, r2, a2) {
    return W("move");
  }
  createTensorFromGPUData(e20, t2, n2) {
    return W("createTensorFromGPUData");
  }
  memory() {
    return W("memory");
  }
  floatPrecision() {
    return W("floatPrecision");
  }
  epsilon() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }
  dispose() {
    return W("dispose");
  }
};
function W(e20) {
  throw Error(`'${e20}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
}
function L(e20) {
  let t2 = e20.length, n2 = 0;
  for (; t2 > 0; ) n2 = Math.random() * t2 | 0, t2--, G(e20, t2, n2);
}
function B(e20, t2) {
  if (e20.length !== t2.length) throw Error(`Array sizes must match to be shuffled together First array length was ${e20.length}Second array length was ${t2.length}`);
  let n2 = e20.length, r2 = 0;
  for (; n2 > 0; ) r2 = Math.random() * n2 | 0, n2--, G(e20, n2, r2), G(t2, n2, r2);
}
function U(e20, t2, n2) {
  return Math.max(e20, Math.min(t2, n2));
}
function j(e20) {
  return e20 % 2 == 0 ? e20 : e20 + 1;
}
function G(e20, t2, n2) {
  let r2 = e20[t2];
  e20[t2] = e20[n2], e20[n2] = r2;
}
function H(e20) {
  let t2 = 0;
  for (let n2 = 0; e20.length > n2; n2++) t2 += e20[n2];
  return t2;
}
function X(e20, t2) {
  let n2 = Math.random();
  return t2 * n2 + (1 - n2) * e20;
}
function q(e20, t2) {
  let n2 = 0;
  for (let r2 = 0; e20.length > r2; r2++) {
    let a2 = +e20[r2] - +t2[r2];
    n2 += a2 * a2;
  }
  return n2;
}
function Z(e20, t2) {
  if (!e20) throw Error("string" == typeof t2 ? t2 : t2());
}
function K(e20, t2, n2 = "") {
  Z(te(e20, t2), () => n2 + ` Shapes ${e20} and ${t2} must match`);
}
function Y(e20) {
  Z(null != e20, () => "The input to the tensor constructor must be a non-null value.");
}
function J(e20) {
  if (0 === e20.length) return 1;
  let t2 = e20[0];
  for (let n2 = 1; e20.length > n2; n2++) t2 *= e20[n2];
  return t2;
}
function Q(e20) {
  return 0 === e20.length;
}
function ee(e20, t2) {
  if (e20 === t2) return true;
  if (null == e20 || null == t2 || e20.length !== t2.length) return false;
  for (let n2 = 0; e20.length > n2; n2++) if (null !== e20[n2] && null !== t2[n2] && e20[n2] !== t2[n2]) return false;
  return true;
}
function te(e20, t2) {
  if (e20 === t2) return true;
  if (null == e20 || null == t2 || e20.length !== t2.length) return false;
  for (let n2 = 0; e20.length > n2; n2++) if (e20[n2] !== t2[n2]) return false;
  return true;
}
function ne(e20) {
  return e20 % 1 == 0;
}
function re(e20) {
  if (null != Math.tanh) return Math.tanh(e20);
  if (e20 === 1 / 0) return 1;
  if (e20 === -1 / 0) return -1;
  {
    let t2 = Math.exp(2 * e20);
    return (t2 - 1) / (t2 + 1);
  }
}
function ae(e20) {
  let t2 = Math.ceil(Math.sqrt(e20));
  return [t2, Math.ceil(e20 / t2)];
}
function ie(e20) {
  let t2 = new Uint32Array(e20);
  for (let n2 = 0; e20 > n2; ++n2) t2[n2] = n2;
  return L(t2), t2;
}
function se(e20, t2) {
  return t2 > e20.length ? e20 + " ".repeat(t2 - e20.length) : e20;
}
function oe(e20, t2 = (e21) => 0, n2, r2) {
  return new Promise((a2, i2) => {
    let s2 = 0, o2 = () => {
      if (e20()) return void a2();
      s2++;
      let l2 = t2(s2);
      null == n2 || n2 > s2 ? null != r2 ? r2(o2, l2) : setTimeout(o2, l2) : i2();
    };
    o2();
  });
}
function le(e20, t2) {
  let n2 = 1, r2 = -1;
  for (let i2 = 0; e20.length > i2; ++i2) if (0 > e20[i2]) {
    if (-1 === e20[i2]) {
      if (-1 !== r2) throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r2} and dim ${i2}`);
      r2 = i2;
    } else if (0 > e20[i2]) throw Error(`Shapes can not be < 0. Found ${e20[i2]} at dim ${i2}`);
  } else n2 *= e20[i2];
  if (-1 === r2) {
    if (t2 > 0 && t2 !== n2) throw Error(`Size(${t2}) must match the product of shape ${e20}`);
    return e20;
  }
  if (0 === n2) throw Error(`Cannot infer the missing size in [${e20}] when there are 0 elements`);
  if (t2 % n2 !== 0) throw Error(`The implicit shape can't be a fractional number. Got ${t2} / ${n2}`);
  let a2 = e20.slice();
  return a2[r2] = t2 / n2, a2;
}
function ue(e20, t2) {
  let n2 = t2.length;
  return Z((e20 = null == e20 ? t2.map((e21, t3) => t3) : [].concat(e20)).every((e21) => e21 >= -n2 && n2 > e21), () => `All values in axis param must be in range [-${n2}, ${n2}) but got axis ${e20}`), Z(e20.every((e21) => ne(e21)), () => "All values in axis param must be integers but got axis " + e20), e20.map((e21) => 0 > e21 ? n2 + e21 : e21);
}
function de(e20, t2) {
  let n2 = [], r2 = [], a2 = null == t2 || null != t2 && Array.isArray(t2) && 0 === t2.length ? null : ue(t2, e20).sort(), i2 = 0;
  for (let s2 = 0; e20.length > s2; ++s2) {
    if (null != a2) {
      if (a2[i2] === s2 && 1 !== e20[s2]) throw Error(`Can't squeeze axis ${s2} since its dim '${e20[s2]}' is not 1`);
      (null == a2[i2] || a2[i2] > s2) && 1 === e20[s2] && (n2.push(e20[s2]), r2.push(s2)), s2 >= a2[i2] && i2++;
    }
    1 !== e20[s2] && (n2.push(e20[s2]), r2.push(s2));
  }
  return { newShape: n2, keptDims: r2 };
}
function ce(e20, t2) {
  return he(e20, t2);
}
function he(e20, t2) {
  let n2 = null;
  if (null == e20 || "float32" === e20) n2 = new Float32Array(t2);
  else if ("int32" === e20) n2 = new Int32Array(t2);
  else if ("bool" === e20) n2 = new Uint8Array(t2);
  else {
    if ("string" !== e20) throw Error("Unknown data type " + e20);
    n2 = Array(t2);
  }
  return n2;
}
function pe(e20, t2) {
  for (let n2 = 0; e20.length > n2; n2++) {
    let r2 = e20[n2];
    if (isNaN(r2) || !isFinite(r2)) throw Error(`A tensor of type ${t2} being uploaded contains ${r2}.`);
  }
}
function fe(e20) {
  return "bool" === e20 || "complex64" === e20 || "float32" === e20 || "int32" === e20 || "string" === e20;
}
function me(e20, t2) {
  return !("complex64" === t2 || "float32" === t2 && "complex64" !== e20 || "int32" === t2 && "float32" !== e20 && "complex64" !== e20 || "bool" === t2 && "bool" === e20);
}
function Ae(e20) {
  if ("float32" === e20 || "int32" === e20) return 4;
  if ("complex64" === e20) return 8;
  if ("bool" === e20) return 1;
  throw Error("Unknown dtype " + e20);
}
function xe(e20) {
  if (null == e20) return 0;
  let t2 = 0;
  return e20.forEach((e21) => t2 += e21.length), t2;
}
function ye(e20) {
  return "string" == typeof e20 || e20 instanceof String;
}
function be(e20) {
  return "boolean" == typeof e20;
}
function ge(e20) {
  return "number" == typeof e20;
}
function ve(e20) {
  return Array.isArray(e20) ? ve(e20[0]) : e20 instanceof Float32Array ? "float32" : e20 instanceof Int32Array || e20 instanceof Uint8Array || e20 instanceof Uint8ClampedArray ? "int32" : ge(e20) ? "float32" : ye(e20) ? "string" : be(e20) ? "bool" : "float32";
}
function we(e20) {
  return !!(e20 && e20.constructor && e20.call && e20.apply);
}
function ke(e20, t2) {
  for (let n2 = t2; e20 > n2; ++n2) if (e20 % n2 === 0) return n2;
  return e20;
}
function Ne(e20) {
  let t2 = e20.length;
  if (2 > t2) return [];
  let n2 = Array(t2 - 1);
  n2[t2 - 2] = e20[t2 - 1];
  for (let r2 = t2 - 3; r2 >= 0; --r2) n2[r2] = n2[r2 + 1] * e20[r2 + 1];
  return n2;
}
function Ce(e20, t2, n2, r2 = false) {
  let a2 = [];
  if (1 === t2.length) {
    let i2 = t2[0] * (r2 ? 2 : 1);
    for (let t3 = 0; i2 > t3; t3++) a2[t3] = n2[e20 + t3];
  } else {
    let i2 = t2[0], s2 = t2.slice(1), o2 = s2.reduce((e21, t3) => e21 * t3) * (r2 ? 2 : 1);
    for (let t3 = 0; i2 > t3; t3++) a2[t3] = Ce(e20 + t3 * o2, s2, n2, r2);
  }
  return a2;
}
function $e(e20, t2, n2 = false) {
  if (0 === e20.length) return t2[0];
  let r2 = e20.reduce((e21, t3) => e21 * t3) * (n2 ? 2 : 1);
  if (0 === r2) return [];
  if (r2 !== t2.length) throw Error(`[${e20}] does not match the input size ${t2.length}${n2 ? " for a complex tensor" : ""}.`);
  return Ce(0, e20, t2, n2);
}
function Re(e20, t2) {
  if (Array.isArray(e20)) return e20;
  if ("float32" === t2) return e20 instanceof Float32Array ? e20 : new Float32Array(e20);
  if ("int32" === t2) return e20 instanceof Int32Array ? e20 : new Int32Array(e20);
  if ("bool" === t2 || "string" === t2) return Uint8Array.from(new Int32Array(e20));
  throw Error("Unknown dtype " + t2);
}
function Se(e20, t2) {
  let n2 = Ie(e20, t2);
  for (let r2 = 0; n2.length > r2; r2++) n2[r2] = 1;
  return n2;
}
function Ie(e20, t2) {
  if (null == t2 || "float32" === t2 || "complex64" === t2) return new Float32Array(e20);
  if ("int32" === t2) return new Int32Array(e20);
  if ("bool" === t2) return new Uint8Array(e20);
  throw Error("Unknown data type " + t2);
}
function Ee(e20, t2) {
  let n2 = e20.reduce((e21, t3) => e21 * t3, 1);
  if (null == t2 || "float32" === t2) return $e(e20, new Float32Array(n2));
  if ("int32" === t2) return $e(e20, new Int32Array(n2));
  if ("bool" === t2) return $e(e20, new Uint8Array(n2));
  throw Error("Unknown data type " + t2);
}
function Te(e20) {
  e20.forEach((t2) => {
    Z(Number.isInteger(t2) && t2 >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${e20}].`);
  });
}
function Me(e20, t2, n2) {
  if (0 === t2) return 0;
  if (1 === t2) return e20[0];
  let r2 = e20[e20.length - 1];
  for (let a2 = 0; e20.length - 1 > a2; ++a2) r2 += n2[a2] * e20[a2];
  return r2;
}
function Oe(e20, t2, n2) {
  if (0 === t2) return [];
  if (1 === t2) return [e20];
  let r2 = Array(t2);
  for (let a2 = 0; r2.length - 1 > a2; ++a2) r2[a2] = Math.floor(e20 / n2[a2]), e20 -= r2[a2] * n2[a2];
  return r2[r2.length - 1] = e20, r2;
}
function Fe(e20) {
  return e20 && e20.then && "function" == typeof e20.then;
}
var Pe = "tfjsflags";
var ze = class {
  constructor(e20) {
    this.global = e20, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = Ve, this.populateURLFlags();
  }
  setPlatform(e20, t2) {
    null != this.platform && (_e().getBool("IS_TEST") || _e().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e20}.`)), this.platformName = e20, this.platform = t2;
  }
  registerFlag(e20, t2, n2) {
    if (this.flagRegistry[e20] = { evaluationFn: t2, setHook: n2 }, null != this.urlFlags[e20]) {
      let t3 = this.urlFlags[e20];
      _e().getBool("IS_TEST") || _e().getBool("PROD") || console.warn(`Setting feature override from URL ${e20}: ${t3}.`), this.set(e20, t3);
    }
  }
  getAsync(e20) {
    return __async(this, null, function* () {
      return e20 in this.flags || (this.flags[e20] = yield this.evaluateFlag(e20)), this.flags[e20];
    });
  }
  get(e20) {
    if (e20 in this.flags) return this.flags[e20];
    let t2 = this.evaluateFlag(e20);
    if (Fe(t2)) throw Error(`Flag ${e20} cannot be synchronously evaluated. Please use getAsync() instead.`);
    return this.flags[e20] = t2, this.flags[e20];
  }
  getNumber(e20) {
    return this.get(e20);
  }
  getBool(e20) {
    return this.get(e20);
  }
  getString(e20) {
    return this.get(e20);
  }
  getFlags() {
    return this.flags;
  }
  get features() {
    return this.flags;
  }
  set(e20, t2) {
    if (null == this.flagRegistry[e20]) throw Error(`Cannot set flag ${e20} as it has not been registered.`);
    this.flags[e20] = t2, null != this.flagRegistry[e20].setHook && this.flagRegistry[e20].setHook(t2);
  }
  evaluateFlag(e20) {
    if (null == this.flagRegistry[e20]) throw Error(`Cannot evaluate flag '${e20}': no evaluation function found.`);
    return this.flagRegistry[e20].evaluationFn();
  }
  setFlags(e20) {
    this.flags = Object.assign({}, e20);
  }
  reset() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }
  populateURLFlags() {
    if (void 0 === this.global || void 0 === this.global.location || void 0 === this.global.location.search) return;
    let e20 = this.getQueryParams(this.global.location.search);
    Pe in e20 && e20[Pe].split(",").forEach((e21) => {
      let [t2, n2] = e21.split(":");
      this.urlFlags[t2] = ((e22, t3) => {
        let n3 = t3.toLowerCase();
        return "true" === n3 || "false" === n3 ? "true" === n3 : "" + +n3 === n3 ? +n3 : t3;
      })(0, n2);
    });
  }
};
function Ve(e20) {
  let t2 = {};
  return e20.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (e21, ...n2) => (((e22, t3, n3) => {
    e22[decodeURIComponent(t3)] = decodeURIComponent(n3 || "");
  })(t2, n2[0], n2[1]), n2.join("="))), t2;
}
function _e() {
  return We;
}
var De;
var We = null;
function Le() {
  if (null == De) {
    let e20;
    if ("undefined" != typeof window) e20 = window;
    else if ("undefined" != typeof global) e20 = global;
    else if ("undefined" != typeof process) e20 = process;
    else {
      if ("undefined" == typeof self) throw Error("Could not find a global object");
      e20 = self;
    }
    De = e20;
  }
  return De;
}
function Be(e20, t2) {
  let n2 = (() => {
    let e21 = Le();
    return null == e21.Qn && (e21.Qn = /* @__PURE__ */ new Map()), e21.Qn;
  })();
  if (n2.has(e20)) return n2.get(e20);
  {
    let r2 = t2();
    return n2.set(e20, r2), n2.get(e20);
  }
}
var Ue = "Abs";
var je = "Acos";
var Ge = "Acosh";
var He = "Add";
var Xe = "AddN";
var qe = "All";
var Ze = "Any";
var Ke = "ArgMax";
var Ye = "ArgMin";
var Je = "Asin";
var Qe = "Asinh";
var et = "Atan";
var tt = "Atanh";
var nt = "Atan2";
var rt = "AvgPool";
var at = "AvgPoolGrad";
var it = "AvgPool3D";
var st = "AvgPool3DGrad";
var ot = "BatchMatMul";
var lt = "BatchToSpaceND";
var ut = "Bincount";
var dt = "BitwiseAnd";
var ct = "BroadcastTo";
var ht = "BroadcastArgs";
var pt = "Cast";
var ft = "Ceil";
var mt = "ClipByValue";
var At = "Complex";
var xt = "ComplexAbs";
var yt = "Concat";
var bt = "Conv2D";
var gt = "Conv2DBackpropFilter";
var vt = "Conv2DBackpropInput";
var wt = "Conv3D";
var kt = "Conv3DBackpropFilterV2";
var Nt = "Conv3DBackpropInputV2";
var Ct = "Cos";
var $t = "Cosh";
var Rt = "Cumprod";
var St = "Cumsum";
var It = "CropAndResize";
var Et = "DenseBincount";
var Tt = "DepthToSpace";
var Mt = "DepthwiseConv2dNative";
var Ot = "DepthwiseConv2dNativeBackpropFilter";
var Ft = "DepthwiseConv2dNativeBackpropInput";
var Pt = "Diag";
var zt = "Dilation2D";
var Vt = "Dilation2DBackpropInput";
var _t = "Dilation2DBackpropFilter";
var Dt = "Draw";
var Wt = "RealDiv";
var Lt = "Einsum";
var Bt = "Elu";
var Ut = "EluGrad";
var jt = "Erf";
var Gt = "Equal";
var Ht = "Exp";
var Xt = "ExpandDims";
var qt = "Expm1";
var Zt = "FFT";
var Kt = "Fill";
var Yt = "FlipLeftRight";
var Jt = "Floor";
var Qt = "FloorDiv";
var en = "FusedBatchNorm";
var tn = "GatherV2";
var nn = "GatherNd";
var rn = "Greater";
var an = "GreaterEqual";
var sn = "Identity";
var on = "IFFT";
var ln = "Imag";
var un = "IsFinite";
var dn = "IsInf";
var cn = "IsNan";
var hn = "LeakyRelu";
var pn = "Less";
var fn = "LessEqual";
var mn = "LinSpace";
var An = "Log";
var xn = "Log1p";
var yn = "LogicalAnd";
var bn = "LogicalNot";
var gn = "LogicalOr";
var vn = "LogicalXor";
var wn = "LogSoftmax";
var kn = "LowerBound";
var Nn = "LRN";
var Cn = "LRNGrad";
var $n = "MatrixBandPart";
var Rn = "Max";
var Sn = "Maximum";
var In = "MaxPool";
var En = "MaxPoolGrad";
var Tn = "MaxPool3D";
var Mn = "MaxPool3DGrad";
var On = "MaxPoolWithArgmax";
var Fn = "Mean";
var Pn = "Min";
var zn = "Minimum";
var Vn = "MirrorPad";
var _n = "Mod";
var Dn = "Multinomial";
var Wn = "Multiply";
var Ln = "Neg";
var Bn = "NotEqual";
var Un = "NonMaxSuppressionV3";
var jn = "NonMaxSuppressionV4";
var Gn = "NonMaxSuppressionV5";
var Hn = "OnesLike";
var Xn = "OneHot";
var qn = "Pack";
var Zn = "PadV2";
var Kn = "Pool";
var Yn = "Pow";
var Jn = "Prelu";
var Qn = "Prod";
var er = "RaggedGather";
var tr = "RaggedRange";
var nr = "RaggedTensorToTensor";
var rr = "Range";
var ar = "Real";
var ir = "Reciprocal";
var sr = "Relu";
var or = "Reshape";
var lr = "ResizeNearestNeighbor";
var ur = "ResizeNearestNeighborGrad";
var dr = "ResizeBilinear";
var cr = "ResizeBilinearGrad";
var hr = "Relu6";
var pr = "Reverse";
var fr = "Round";
var mr = "Rsqrt";
var Ar = "ScatterNd";
var xr = "TensorScatterUpdate";
var yr = "SearchSorted";
var br = "Select";
var gr = "Selu";
var vr = "Slice";
var wr = "Sin";
var kr = "Sinh";
var Nr = "Sign";
var Cr = "Sigmoid";
var $r = "Softplus";
var Rr = "Sqrt";
var Sr = "Sum";
var Ir = "SpaceToBatchND";
var Er = "SplitV";
var Tr = "Softmax";
var Mr = "SparseFillEmptyRows";
var Or = "SparseReshape";
var Fr = "SparseSegmentMean";
var Pr = "SparseSegmentSum";
var zr = "SparseToDense";
var Vr = "SquaredDifference";
var _r = "Square";
var Dr = "StaticRegexReplace";
var Wr = "StridedSlice";
var Lr = "StringNGrams";
var Br = "StringSplit";
var Ur = "StringToHashBucketFast";
var jr = "Sub";
var Gr = "Tan";
var Hr = "Tanh";
var Xr = "Tile";
var qr = "TopK";
var Zr = "Transform";
var Kr = "Transpose";
var Yr = "Unique";
var Jr = "Unpack";
var Qr = "UnsortedSegmentSum";
var ea = "UpperBound";
var ta = "ZerosLike";
var na = "Step";
var ra = "FromPixels";
var aa = "RotateWithOffset";
var ia = "_FusedMatMul";
var sa = "FusedConv2D";
var oa = "FusedDepthwiseConv2D";
function la(...e20) {
  _e().getBool("IS_TEST") || _e().getBool("PROD") || console.warn(...e20);
}
function ua(...e20) {
  _e().getBool("IS_TEST") || _e().getBool("PROD") || console.log(...e20);
}
var da = Be("kernelRegistry", () => /* @__PURE__ */ new Map());
var ca = Be("gradRegistry", () => /* @__PURE__ */ new Map());
function ha(e20, t2) {
  let n2 = ga(e20, t2);
  return da.get(n2);
}
function pa(e20) {
  return ca.get(e20);
}
function fa(e20) {
  let t2 = da.entries(), n2 = [];
  for (; ; ) {
    let { done: r2, value: a2 } = t2.next();
    if (r2) break;
    let [i2, s2] = a2, [o2] = i2.split("_");
    o2 === e20 && n2.push(s2);
  }
  return n2;
}
function ma(e20) {
  let { kernelName: t2, backendName: n2 } = e20, r2 = ga(t2, n2);
  da.has(r2) && la(`The kernel '${t2}' for backend '${n2}' is already registered`), da.set(r2, e20);
}
function Aa(e20) {
  let { kernelName: t2 } = e20;
  ca.has(t2) && _e().getBool("DEBUG") && la(`Overriding the gradient for '${t2}'`), ca.set(t2, e20);
}
function xa(e20, t2) {
  let n2 = ga(e20, t2);
  if (!da.has(n2)) throw Error(`The kernel '${e20}' for backend '${t2}' is not registered`);
  da.delete(n2);
}
function ya(e20) {
  if (!ca.has(e20)) throw Error(`The gradient '${e20}' for backend is not registered`);
  ca.delete(e20);
}
function ba(e20, t2) {
  fa(e20).forEach((e21) => {
    ma(Object.assign({}, e21, { backendName: t2 }));
  });
}
function ga(e20, t2) {
  return `${t2}_${e20}`;
}
var va = {};
function wa(e20) {
  return e20 instanceof Float32Array || e20 instanceof Int32Array || e20 instanceof Uint8Array || e20 instanceof Uint8ClampedArray;
}
A(va, { arraysEqual() {
  return te;
}, arraysEqualWithNull() {
  return ee;
}, assert() {
  return Z;
}, assertNonNegativeIntegerDimensions() {
  return Te;
}, assertNonNull() {
  return Y;
}, assertShapesMatch() {
  return K;
}, bytesFromStringArray() {
  return xe;
}, bytesPerElement() {
  return Ae;
}, checkConversionForErrors() {
  return pe;
}, clamp() {
  return U;
}, computeStrides() {
  return Ne;
}, convertBackendValuesAndArrayBuffer() {
  return Re;
}, createScalarValue() {
  return Va;
}, createShuffledIndices() {
  return ie;
}, decodeString() {
  return Ba;
}, distSquared() {
  return q;
}, encodeString() {
  return La;
}, fetch() {
  return Wa;
}, fingerPrint64() {
  return za;
}, flatten() {
  return ja;
}, getArrayFromDType() {
  return he;
}, getTypedArrayFromDType() {
  return ce;
}, hasEncodingLoss() {
  return me;
}, hexToLong() {
  return Ca;
}, indexToLoc() {
  return Oe;
}, inferDtype() {
  return ve;
}, inferFromImplicitShape() {
  return le;
}, isBoolean() {
  return be;
}, isFunction() {
  return we;
}, isInt() {
  return ne;
}, isNumber() {
  return ge;
}, isPromise() {
  return Fe;
}, isScalarShape() {
  return Q;
}, isString() {
  return ye;
}, isTypedArray() {
  return Ua;
}, isValidDtype() {
  return fe;
}, locToIndex() {
  return Me;
}, makeOnesTypedArray() {
  return Se;
}, makeZerosNestedTypedArray() {
  return Ee;
}, makeZerosTypedArray() {
  return Ie;
}, nearestDivisor() {
  return ke;
}, nearestLargerEven() {
  return j;
}, now() {
  return Da;
}, parseAxisParam() {
  return ue;
}, randUniform() {
  return X;
}, repeatedTry() {
  return oe;
}, rightPad() {
  return se;
}, shuffle() {
  return L;
}, shuffleCombo() {
  return B;
}, sizeFromShape() {
  return J;
}, sizeToSquarishShape() {
  return ae;
}, squeezeShape() {
  return de;
}, sum() {
  return H;
}, swap() {
  return G;
}, tanh() {
  return re;
}, toNestedArray() {
  return $e;
}, toTypedArray() {
  return _a;
} });
var ka = x(y());
var Na = ka.default || ka;
function Ca(e20) {
  return Na.fromString(e20, true, 16);
}
var $a = Ca("c3a5c85c97cb3127");
var Ra = Ca("b492b66fbe98f273");
var Sa = Ca("9ae16a3b2f90404f");
function Ia(e20) {
  return e20.xor(e20.shru(47));
}
function Ea(e20, t2, n2) {
  let r2 = e20.slice(t2, t2 + n2);
  return Na.fromBytes(Array.from(r2), true, true);
}
function Ta(e20, t2) {
  return Ea(e20, t2, 8);
}
function Ma(e20, t2) {
  return Ea(e20, t2, 4);
}
function Oa(e20, t2) {
  return 0 === t2 ? e20 : e20.shru(t2).or(e20.shl(64 - t2));
}
function Fa(e20, t2, n2 = Ca("9ddfea08eb382d69")) {
  let r2 = e20.xor(t2).mul(n2);
  r2 = r2.xor(r2.shru(47));
  let a2 = t2.xor(r2).mul(n2);
  return a2 = a2.xor(a2.shru(47)), a2 = a2.mul(n2), a2;
}
function Pa(e20, t2, n2, r2) {
  return ((e21, t3, n3, r3, a2, i2) => {
    a2 = a2.add(e21), i2 = Oa(i2.add(a2).add(r3), 21);
    let s2 = a2;
    return a2 = (a2 = a2.add(t3)).add(n3), i2 = i2.add(Oa(a2, 44)), [a2.add(r3), i2.add(s2)];
  })(Ta(e20, t2), Ta(e20, t2 + 8), Ta(e20, t2 + 16), Ta(e20, t2 + 24), n2, r2);
}
function za(e20, t2 = e20.length) {
  let n2 = Na.fromNumber(81, true);
  if (32 >= t2) return t2 > 16 ? ((e21, t3 = e21.length) => {
    let n3 = Sa.add(2 * t3), r3 = Ta(e21, 0).mul(Ra), a3 = Ta(e21, 8), i3 = Ta(e21, t3 - 8).mul(n3), s3 = Ta(e21, t3 - 16).mul(Sa);
    return Fa(Oa(r3.add(a3), 43).add(Oa(i3, 30)).add(s3), r3.add(Oa(a3.add(Sa), 18)).add(i3), n3);
  })(e20, t2) : ((e21, t3 = e21.length) => {
    if (t3 >= 8) {
      let n3 = Sa.add(2 * t3), r3 = Ta(e21, 0).add(Sa), a3 = Ta(e21, t3 - 8);
      return Fa(Oa(a3, 37).mul(n3).add(r3), Oa(r3, 25).add(a3).mul(n3), n3);
    }
    if (t3 >= 4) {
      let n3 = Sa.add(2 * t3);
      return Fa(Ma(e21, 0).shl(3).add(t3), Ma(e21, t3 - 4), n3);
    }
    if (t3 > 0) {
      let n3 = t3 + (e21[t3 - 1] << 2);
      return Ia(Sa.mul(e21[0] + (e21[t3 >> 1] << 8)).xor($a.mul(n3))).mul(Sa);
    }
    return Sa;
  })(e20, t2);
  if (64 >= t2) return ((e21, t3 = e21.length) => {
    let n3 = Sa.add(2 * t3), r3 = Ta(e21, 0).mul(Sa), a3 = Ta(e21, 8), i3 = Ta(e21, t3 - 8).mul(n3), s3 = Ta(e21, t3 - 16).mul(Sa), o3 = Oa(r3.add(a3), 43).add(Oa(i3, 30)).add(s3), l3 = Fa(o3, r3.add(Oa(a3.add(Sa), 18)).add(i3), n3), u3 = Ta(e21, 16).mul(n3), d3 = Ta(e21, 24), c3 = o3.add(Ta(e21, t3 - 32)).mul(n3), h2 = l3.add(Ta(e21, t3 - 24)).mul(n3);
    return Fa(Oa(u3.add(d3), 43).add(Oa(c3, 30)).add(h2), u3.add(Oa(d3.add(r3), 18)).add(c3), n3);
  })(e20, t2);
  let r2 = n2, a2 = n2.mul(Ra).add(113), i2 = Ia(a2.mul(Sa).add(113)).mul(Sa), s2 = [Na.UZERO, Na.UZERO], o2 = [Na.UZERO, Na.UZERO];
  r2 = r2.mul(Sa).add(Ta(e20, 0));
  let l2 = 0, u2 = 64 * (t2 - 1 >> 6), d2 = u2 + (t2 - 1 & 63) - 63;
  do {
    r2 = Oa(r2.add(a2).add(s2[0]).add(Ta(e20, l2 + 8)), 37).mul(Ra), a2 = Oa(a2.add(s2[1]).add(Ta(e20, l2 + 48)), 42).mul(Ra), r2 = r2.xor(o2[1]), a2 = a2.add(s2[0]).add(Ta(e20, l2 + 40)), i2 = Oa(i2.add(o2[0]), 33).mul(Ra), s2 = Pa(e20, l2, s2[1].mul(Ra), r2.add(o2[0])), o2 = Pa(e20, l2 + 32, i2.add(o2[1]), a2.add(Ta(e20, l2 + 16))), [i2, r2] = [r2, i2], l2 += 64;
  } while (l2 !== u2);
  let c2 = Ra.add(i2.and(255).shl(1));
  return l2 = d2, o2[0] = o2[0].add(t2 - 1 & 63), s2[0] = s2[0].add(o2[0]), o2[0] = o2[0].add(s2[0]), r2 = Oa(r2.add(a2).add(s2[0]).add(Ta(e20, l2 + 8)), 37).mul(c2), a2 = Oa(a2.add(s2[1]).add(Ta(e20, l2 + 48)), 42).mul(c2), r2 = r2.xor(o2[1].mul(9)), a2 = a2.add(s2[0].mul(9).add(Ta(e20, l2 + 40))), i2 = Oa(i2.add(o2[0]), 33).mul(c2), s2 = Pa(e20, l2, s2[1].mul(c2), r2.add(o2[0])), o2 = Pa(e20, l2 + 32, i2.add(o2[1]), a2.add(Ta(e20, l2 + 16))), [i2, r2] = [r2, i2], Fa(Fa(s2[0], o2[0], c2).add(Ia(a2).mul($a)).add(i2), Fa(s2[1], o2[1], c2).add(r2), c2);
}
function Va(e20, t2) {
  return "string" === t2 ? La(e20) : _a([e20], t2);
}
function _a(e20, t2) {
  if ("string" === t2) throw Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(e20) && (e20 = ja(e20)), _e().getBool("DEBUG") && pe(e20, t2), ((e21, t3) => e21 instanceof Float32Array && "float32" === t3 || e21 instanceof Int32Array && "int32" === t3 || e21 instanceof Uint8Array && "bool" === t3)(e20, t2)) return e20;
  if (null == t2 || "float32" === t2 || "complex64" === t2) return new Float32Array(e20);
  if ("int32" === t2) return new Int32Array(e20);
  if ("bool" === t2) {
    let t3 = new Uint8Array(e20.length);
    for (let n2 = 0; t3.length > n2; ++n2) 0 !== Math.round(e20[n2]) && (t3[n2] = 1);
    return t3;
  }
  throw Error("Unknown data type " + t2);
}
function Da() {
  return _e().platform.now();
}
function Wa(e20, t2) {
  return _e().platform.fetch(e20, t2);
}
function La(e20, t2 = "utf-8") {
  return t2 = t2 || "utf-8", _e().platform.encode(e20, t2);
}
function Ba(e20, t2 = "utf-8") {
  return t2 = t2 || "utf-8", _e().platform.decode(e20, t2);
}
function Ua(e20) {
  return null != _e().platform.isTypedArray ? _e().platform.isTypedArray(e20) : wa(e20);
}
function ja(e20, t2 = [], n2 = false) {
  if (null == t2 && (t2 = []), "boolean" == typeof e20 || "number" == typeof e20 || "string" == typeof e20 || Fe(e20) || null == e20 || Ua(e20) && n2) t2.push(e20);
  else if (Array.isArray(e20) || Ua(e20)) for (let r2 = 0; e20.length > r2; ++r2) ja(e20[r2], t2, n2);
  else {
    let r2 = -1;
    for (let t3 of Object.keys(e20)) /^([1-9]+[0-9]*|0)$/.test(t3) && (r2 = Math.max(r2, +t3));
    for (let a2 = 0; r2 >= a2; a2++) ja(e20[a2], t2, n2);
  }
  return t2;
}
var Ga = class {
  constructor(e20, t2) {
    this.backendTimer = e20, this.logger = t2, null == t2 && (this.logger = new Xa());
  }
  profileKernel(e20, t2, n2) {
    let r2, a2, i2 = () => {
      r2 = n2();
    }, s2 = Da();
    if (this.backendTimer.timerAvailable()) a2 = this.backendTimer.time(i2);
    else {
      i2();
      for (let e21 of r2) e21.dataSync();
      a2 = Promise.resolve({ kernelMs: Da() - s2 });
    }
    if (_e().getBool("CHECK_COMPUTATION_FOR_ERRORS")) for (let o2 = 0; r2.length > o2; o2++) {
      let t3 = r2[o2];
      t3.data().then((n3) => {
        Ha(n3, t3.dtype, e20);
      });
    }
    return { kernelName: e20, outputs: r2, inputs: t2, timeMs: a2.then((e21) => e21.kernelMs), extraInfo: a2.then((e21) => null != e21.getExtraProfileInfo ? e21.getExtraProfileInfo() : "") };
  }
  logKernelProfile(e20) {
    let { kernelName: t2, outputs: n2, timeMs: r2, inputs: a2, extraInfo: i2 } = e20;
    n2.forEach((e21) => {
      Promise.all([e21.data(), r2, i2]).then((n3) => {
        this.logger.logKernelProfile(t2, e21, n3[0], n3[1], a2, n3[2]);
      });
    });
  }
};
function Ha(e20, t2, n2) {
  if ("float32" !== t2) return false;
  for (let r2 = 0; e20.length > r2; r2++) {
    let t3 = e20[r2];
    if (isNaN(t3) || !isFinite(t3)) return console.warn(`Found ${t3} in the result of '${n2}'`), true;
  }
  return false;
}
var Xa = class {
  logKernelProfile(e20, t2, n2, r2, a2, i2) {
    let s2 = "number" == typeof r2 ? se(r2 + "ms", 9) : r2.error, o2 = se(e20, 25), l2 = t2.rank, u2 = t2.size, d2 = se("" + t2.shape, 14), c2 = "";
    for (let h2 in a2) {
      let e21 = a2[h2];
      if (null != e21) {
        let n3 = e21.shape || t2.shape, r3 = n3.length;
        c2 += `${h2}: ${r3}D ${r3 > 0 ? n3 : ""} `;
      }
    }
    console.log(`%c${o2}	%c${s2}	%c${l2}D ${d2}	%c${u2}	%c${c2}	%c${i2}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
};
function qa(e20, t2, n2, r2) {
  let a2 = Ne(t2), i2 = ((e21, t3, n3, r3) => {
    let a3 = J(t3), i3 = r3[r3.length - 1], s3 = Array(i3).fill(0), o3 = t3.length, l3 = "complex64" === n3 ? Ja(e21) : e21;
    if (o3 > 1) for (let u2 = 0; a3 / i3 > u2; u2++) {
      let e22 = u2 * i3;
      for (let t4 = 0; i3 > t4; t4++) s3[t4] = Math.max(s3[t4], Za(l3[e22 + t4], 0, n3).length);
    }
    return s3;
  })(e20, t2, n2, a2), s2 = t2.length, o2 = Ya(e20, t2, n2, a2, i2), l2 = ["Tensor"];
  return r2 && (l2.push("  dtype: " + n2), l2.push("  rank: " + s2), l2.push(`  shape: [${t2}]`), l2.push("  values:")), l2.push(o2.map((e21) => "    " + e21).join("\n")), l2.join("\n");
}
function Za(e20, t2, n2) {
  let r2;
  return r2 = Array.isArray(e20) ? `${parseFloat(e20[0].toFixed(7))} + ${parseFloat(e20[1].toFixed(7))}j` : ye(e20) ? `'${e20}'` : "bool" === n2 ? Ka(e20) : "" + parseFloat(e20.toFixed(7)), se(r2, t2);
}
function Ka(e20) {
  return 0 === e20 ? "false" : "true";
}
function Ya(e20, t2, n2, r2, a2, i2 = true) {
  let s2 = "complex64" === n2 ? 2 : 1, o2 = t2[0], l2 = t2.length;
  if (0 === l2) return "complex64" === n2 ? [Za(Ja(e20)[0], 0, n2)] : "bool" === n2 ? [Ka(e20[0])] : ["" + e20[0]];
  if (1 === l2) {
    if (o2 > 20) {
      let t3 = Array.from(e20.slice(0, 3 * s2)), r3 = Array.from(e20.slice((o2 - 3) * s2, o2 * s2));
      return "complex64" === n2 && (t3 = Ja(t3), r3 = Ja(r3)), ["[" + t3.map((e21, t4) => Za(e21, a2[t4], n2)).join(", ") + ", ..., " + r3.map((e21, t4) => Za(e21, a2[o2 - 3 + t4], n2)).join(", ") + "]"];
    }
    return ["[" + ("complex64" === n2 ? Ja(e20) : Array.from(e20)).map((e21, t3) => Za(e21, a2[t3], n2)).join(", ") + "]"];
  }
  let u2 = t2.slice(1), d2 = r2.slice(1), c2 = r2[0] * s2, h2 = [];
  if (o2 > 20) {
    for (let t3 = 0; 3 > t3; t3++) {
      let r3 = t3 * c2;
      h2.push(...Ya(e20.slice(r3, r3 + c2), u2, n2, d2, a2, false));
    }
    h2.push("...");
    for (let t3 = o2 - 3; o2 > t3; t3++) {
      let r3 = t3 * c2;
      h2.push(...Ya(e20.slice(r3, r3 + c2), u2, n2, d2, a2, t3 === o2 - 1));
    }
  } else for (let m2 = 0; o2 > m2; m2++) {
    let t3 = m2 * c2;
    h2.push(...Ya(e20.slice(t3, t3 + c2), u2, n2, d2, a2, m2 === o2 - 1));
  }
  let p2 = 2 === l2 ? "," : "";
  h2[0] = "[" + (o2 > 0 ? h2[0] + p2 : "");
  for (let m2 = 1; h2.length - 1 > m2; m2++) h2[m2] = " " + h2[m2] + p2;
  let f2 = ",\n";
  for (let m2 = 2; l2 > m2; m2++) f2 += "\n";
  return h2[h2.length - 1] = " " + h2[h2.length - 1] + "]" + (i2 ? "" : f2), h2;
}
function Ja(e20) {
  let t2 = [];
  for (let n2 = 0; e20.length > n2; n2 += 2) t2.push([e20[n2], e20[n2 + 1]]);
  return t2;
}
var Qa = class {
  constructor(e20, t2, n2) {
    if (this.dtype = t2, this.shape = e20.slice(), this.size = J(e20), null != n2) {
      let e21 = n2.length;
      Z(e21 === this.size, () => `Length of values '${e21}' does not match the size inferred by the shape '${this.size}'.`);
    }
    if ("complex64" === t2) throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n2 || he(t2, this.size), this.strides = Ne(e20);
  }
  set(e20, ...t2) {
    0 === t2.length && (t2 = [0]), Z(t2.length === this.rank, () => `The number of provided coordinates (${t2.length}) must match the rank (${this.rank})`);
    let n2 = this.locToIndex(t2);
    this.values[n2] = e20;
  }
  get(...e20) {
    0 === e20.length && (e20 = [0]);
    let t2 = 0;
    for (let r2 of e20) {
      if (0 > r2 || r2 >= this.shape[t2]) throw Error(`Requested out of range element at ${e20}.   Buffer shape=${this.shape}`);
      t2++;
    }
    let n2 = e20[e20.length - 1];
    for (let r2 = 0; e20.length - 1 > r2; ++r2) n2 += this.strides[r2] * e20[r2];
    return this.values[n2];
  }
  locToIndex(e20) {
    if (0 === this.rank) return 0;
    if (1 === this.rank) return e20[0];
    let t2 = e20[e20.length - 1];
    for (let n2 = 0; e20.length - 1 > n2; ++n2) t2 += this.strides[n2] * e20[n2];
    return t2;
  }
  indexToLoc(e20) {
    if (0 === this.rank) return [];
    if (1 === this.rank) return [e20];
    let t2 = Array(this.shape.length);
    for (let n2 = 0; t2.length - 1 > n2; ++n2) t2[n2] = Math.floor(e20 / this.strides[n2]), e20 -= t2[n2] * this.strides[n2];
    return t2[t2.length - 1] = e20, t2;
  }
  get rank() {
    return this.shape.length;
  }
  toTensor() {
    return ei().makeTensor(this.values, this.shape, this.dtype);
  }
};
var ei = null;
var ti = null;
var ni = class {
  constructor(e20, t2, n2, r2) {
    this.kept = false, this.isDisposedInternal = false, this.shape = e20.slice(), this.dtype = t2 || "float32", this.size = J(e20), this.strides = Ne(e20), this.dataId = n2, this.id = r2, this.rankType = 5 > this.rank ? "" + this.rank : "higher";
  }
  get rank() {
    return this.shape.length;
  }
  buffer() {
    return __async(this, null, function* () {
      let e20 = yield this.data();
      return ti.buffer(this.shape, this.dtype, e20);
    });
  }
  bufferSync() {
    return ti.buffer(this.shape, this.dtype, this.dataSync());
  }
  array() {
    return __async(this, null, function* () {
      let e20 = yield this.data();
      return $e(this.shape, e20, "complex64" === this.dtype);
    });
  }
  arraySync() {
    return $e(this.shape, this.dataSync(), "complex64" === this.dtype);
  }
  data() {
    return __async(this, null, function* () {
      this.throwIfDisposed();
      let e20 = ei().read(this.dataId);
      if ("string" === this.dtype) {
        let n2 = yield e20;
        try {
          return n2.map((e21) => Ba(e21));
        } catch (t2) {
          throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return e20;
    });
  }
  dataToGPU(e20) {
    return this.throwIfDisposed(), ei().readToGPU(this.dataId, e20);
  }
  dataSync() {
    this.throwIfDisposed();
    let e20 = ei().readSync(this.dataId);
    if ("string" === this.dtype) try {
      return e20.map((e21) => Ba(e21));
    } catch (t2) {
      throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
    }
    return e20;
  }
  bytes() {
    return __async(this, null, function* () {
      this.throwIfDisposed();
      let e20 = yield ei().read(this.dataId);
      return "string" === this.dtype ? e20 : new Uint8Array(e20.buffer);
    });
  }
  dispose() {
    this.isDisposed || (this.kerasMask && this.kerasMask.dispose(), ei().disposeTensor(this), this.isDisposedInternal = true);
  }
  get isDisposed() {
    return this.isDisposedInternal;
  }
  throwIfDisposed() {
    if (this.isDisposed) throw Error("Tensor is disposed.");
  }
  print(e20 = false) {
    return ti.print(this, e20);
  }
  clone() {
    return this.throwIfDisposed(), ti.clone(this);
  }
  toString(e20 = false) {
    return qa(this.dataSync(), this.shape, this.dtype, e20);
  }
  cast(e20) {
    return this.throwIfDisposed(), ti.cast(this, e20);
  }
  variable(e20 = true, t2, n2) {
    return this.throwIfDisposed(), ei().makeVariable(this, e20, t2, n2);
  }
};
function ri() {
  return Be("Tensor", () => ni);
}
Object.defineProperty(ni, Symbol.hasInstance, { value(e20) {
  return !!e20 && null != e20.data && null != e20.dataSync && null != e20.throwIfDisposed;
} }), ri();
var ai = class extends ni {
  constructor(e20, t2, n2, r2) {
    super(e20.shape, e20.dtype, e20.dataId, r2), this.trainable = t2, this.name = n2;
  }
  assign(e20) {
    if (e20.dtype !== this.dtype) throw Error(`dtype of the new value (${e20.dtype}) and previous value (${this.dtype}) must match`);
    if (!te(e20.shape, this.shape)) throw Error(`shape of the new value (${e20.shape}) and previous value (${this.shape}) must match`);
    ei().disposeTensor(this), this.dataId = e20.dataId, ei().incRef(this, null);
  }
  dispose() {
    ei().disposeVariable(this), this.isDisposedInternal = true;
  }
};
Object.defineProperty(ai, Symbol.hasInstance, { value(e20) {
  return e20 instanceof ni && null != e20.assign && e20.assign instanceof Function;
} });
var ii;
var si;
var oi;
var li;
var ui;
var di;
var ci = {};
A(ci, { assertTypesMatch() {
  return yi;
}, getTensorsInContainer() {
  return gi;
}, isTensorInList() {
  return bi;
}, makeTypesMatch() {
  return xi;
} }), (si = ii || (ii = {})).R0 = "R0", si.R1 = "R1", si.R2 = "R2", si.R3 = "R3", si.R4 = "R4", si.R5 = "R5", si.R6 = "R6", ((e20) => {
  e20.float32 = "float32", e20.int32 = "int32", e20.bool = "int32", e20.complex64 = "complex64";
})(oi || (oi = {})), ((e20) => {
  e20.float32 = "float32", e20.int32 = "int32", e20.bool = "bool", e20.complex64 = "complex64";
})(li || (li = {})), ((e20) => {
  e20.float32 = "float32", e20.int32 = "float32", e20.bool = "float32", e20.complex64 = "complex64";
})(ui || (ui = {})), ((e20) => {
  e20.float32 = "complex64", e20.int32 = "complex64", e20.bool = "complex64", e20.complex64 = "complex64";
})(di || (di = {}));
var hi = { float32: ui, int32: oi, bool: li, complex64: di };
function pi(e20, t2) {
  if ("string" === e20 || "string" === t2) {
    if ("string" === e20 && "string" === t2) return "string";
    throw Error(`Can not upcast ${e20} with ${t2}`);
  }
  return hi[e20][t2];
}
function fi(e20) {
  return pi(e20, "int32");
}
function mi(e20) {
  return null != e20 && "object" == typeof e20 && "texture" in e20 && e20.texture instanceof WebGLTexture;
}
function Ai(e20) {
  return "undefined" != typeof GPUBuffer && null != e20 && "object" == typeof e20 && "buffer" in e20 && e20.buffer instanceof GPUBuffer;
}
function xi(e20, t2) {
  if (e20.dtype === t2.dtype) return [e20, t2];
  let n2 = pi(e20.dtype, t2.dtype);
  return [e20.cast(n2), t2.cast(n2)];
}
function yi(e20, t2) {
  Z(e20.dtype === t2.dtype, () => `The dtypes of the first(${e20.dtype}) and second(${t2.dtype}) input must match`);
}
function bi(e20, t2) {
  return t2.some((t3) => t3.id === e20.id);
}
function gi(e20) {
  let t2 = [];
  return vi(e20, t2, /* @__PURE__ */ new Set()), t2;
}
function vi(e20, t2, n2) {
  if (null == e20) return;
  if (e20 instanceof ni) return void t2.push(e20);
  if (!((e21) => Array.isArray(e21) || "object" == typeof e21)(e20)) return;
  let r2 = e20;
  for (let a2 in r2) {
    let e21 = r2[a2];
    n2.has(e21) || (n2.add(e21), vi(e21, t2, n2));
  }
}
function wi(e20) {
  return null != e20.kernelName;
}
var ki = class {
  constructor() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = false, this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null, get kernelNames() {
      return Array.from(new Set(this.kernels.map((e20) => e20.name)));
    } };
  }
  dispose() {
    for (let e20 in this.registeredVariables) this.registeredVariables[e20].dispose();
  }
};
var Ni = class e2 {
  constructor(e20) {
    this.ENV = e20, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new ki();
  }
  ready() {
    return __async(this, null, function* () {
      if (null != this.pendingBackendInit) return this.pendingBackendInit.then(() => {
      });
      if (null != this.backendInstance) return;
      let e20 = this.getSortedBackends();
      for (let t2 = 0; e20.length > t2; t2++) {
        let n2 = e20[t2];
        if (yield this.initializeBackend(n2).success) return void (yield this.setBackend(n2));
      }
      throw Error("Could not initialize any backends, all backend initializations failed.");
    });
  }
  get backend() {
    if (null != this.pendingBackendInit) throw Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
    if (null == this.backendInstance) {
      let { name: e20, asyncInit: t2 } = this.initializeBackendsAndReturnBest();
      if (t2) throw Error(`The highest priority backend '${e20}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      this.setBackend(e20);
    }
    return this.backendInstance;
  }
  backendNames() {
    return Object.keys(this.registryFactory);
  }
  findBackend(e20) {
    if (!(e20 in this.registry)) {
      if (!(e20 in this.registryFactory)) return null;
      {
        let { asyncInit: t2 } = this.initializeBackend(e20);
        if (t2) return null;
      }
    }
    return this.registry[e20];
  }
  findBackendFactory(e20) {
    return e20 in this.registryFactory ? this.registryFactory[e20].factory : null;
  }
  registerBackend(e20, t2, n2 = 1) {
    return e20 in this.registryFactory ? (la(e20 + " backend was already registered. Reusing existing backend factory."), false) : (this.registryFactory[e20] = { factory: t2, priority: n2 }, true);
  }
  setBackend(e20) {
    return __async(this, null, function* () {
      if (null == this.registryFactory[e20]) throw Error(`Backend name '${e20}' not found in registry`);
      if (this.backendName = e20, null == this.registry[e20]) {
        this.backendInstance = null;
        let { success: t2, asyncInit: n2 } = this.initializeBackend(e20);
        if (!(n2 ? yield t2 : t2)) return false;
      }
      return this.backendInstance = this.registry[e20], this.setupRegisteredKernels(), this.profiler = new Ga(this.backendInstance), true;
    });
  }
  setupRegisteredKernels() {
    fa(this.backendName).forEach((e20) => {
      null != e20.setupFunc && e20.setupFunc(this.backendInstance);
    });
  }
  disposeRegisteredKernels(e20) {
    fa(e20).forEach((t2) => {
      null != t2.disposeFunc && t2.disposeFunc(this.registry[e20]);
    });
  }
  initializeBackend(e20) {
    let t2 = this.registryFactory[e20];
    if (null == t2) throw Error(`Cannot initialize backend ${e20}, no registration found.`);
    try {
      let n2 = t2.factory();
      if (!n2 || n2 instanceof D || "function" != typeof n2.then) return this.registry[e20] = n2, { success: true, asyncInit: false };
      {
        let t3 = ++this.pendingBackendInitId, r2 = n2.then((n3) => t3 >= this.pendingBackendInitId && (this.registry[e20] = n3, this.pendingBackendInit = null, true)).catch((n3) => (this.pendingBackendInitId > t3 || (this.pendingBackendInit = null, la(`Initialization of backend ${e20} failed`), la(n3.stack || n3.message)), false));
        return this.pendingBackendInit = r2, { success: r2, asyncInit: true };
      }
    } catch (n2) {
      return la(`Initialization of backend ${e20} failed`), la(n2.stack || n2.message), { success: false, asyncInit: false };
    }
  }
  removeBackend(e20) {
    if (!(e20 in this.registryFactory)) throw Error(e20 + " backend not found in registry");
    this.backendName === e20 && null != this.pendingBackendInit && this.pendingBackendInitId++, e20 in this.registry && (this.disposeRegisteredKernels(e20), this.registry[e20].dispose(), delete this.registry[e20]), delete this.registryFactory[e20], this.backendName === e20 && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }
  getSortedBackends() {
    if (0 === Object.keys(this.registryFactory).length) throw Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort((e20, t2) => this.registryFactory[t2].priority - this.registryFactory[e20].priority);
  }
  initializeBackendsAndReturnBest() {
    let e20 = this.getSortedBackends();
    for (let t2 = 0; e20.length > t2; t2++) {
      let n2 = e20[t2], { success: r2, asyncInit: a2 } = this.initializeBackend(n2);
      if (a2 || r2) return { name: n2, asyncInit: a2 };
    }
    throw Error("Could not initialize any backends, all backend initializations failed.");
  }
  moveData(e20, t2) {
    let n2 = this.state.tensorInfo.get(t2), r2 = n2.backend, a2 = this.readSync(t2), i2 = r2.refCount(t2);
    r2.disposeData(t2, true), n2.backend = e20, e20.move(t2, a2, n2.shape, n2.dtype, i2), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }
  tidy(e20, t2) {
    let n2, r2 = null;
    if (null == t2) {
      if ("function" != typeof e20) throw Error("Please provide a function to tidy()");
      t2 = e20;
    } else {
      if ("string" != typeof e20 && !(e20 instanceof String)) throw Error("When calling with two arguments, the first argument to tidy() must be a string");
      if ("function" != typeof t2) throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      r2 = e20;
    }
    return this.scopedRun(() => this.startScope(r2), () => this.endScope(n2), () => (n2 = t2(), n2 instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n2));
  }
  scopedRun(e20, t2, n2) {
    e20();
    try {
      let e21 = n2();
      return t2(), e21;
    } catch (r2) {
      throw t2(), r2;
    }
  }
  nextTensorId() {
    return e2.nextTensorId++;
  }
  nextVariableId() {
    return e2.nextVariableId++;
  }
  clone(e20) {
    let t2 = $i.runKernel(sn, { x: e20 });
    return this.addTapeNode(this.state.activeScope.name, { x: e20 }, [t2], (e21) => ({ x() {
      return $i.runKernel(pt, { x: e21 }, { dtype: "float32" });
    } }), [], {}), t2;
  }
  runKernel(e20, t2, n2) {
    if (null == ha(e20, this.backendName)) throw Error(`Kernel '${e20}' not registered for backend '${this.backendName}'`);
    return this.runKernelFunc({ kernelName: e20, inputs: t2, attrs: n2 });
  }
  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }
  checkKernelForMemLeak(e20, t2, n2) {
    let r2 = this.backend.numDataIds(), a2 = 0;
    n2.forEach((e21) => {
      a2 += "complex64" === e21.dtype ? 3 : 1;
    });
    let i2 = r2 - t2 - a2 - this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
    if (i2 > 0) throw Error(`Backend '${this.backendName}' has an internal memory leak (${i2} data ids) after running '${e20}'`);
  }
  runKernelFunc(e20) {
    let t2, n2, r2 = [], a2 = this.isTapeOn(), i2 = this.state.numBytes, s2 = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    let o2, l2 = wi(e20) ? e20.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";
    if (wi(e20)) {
      let { kernelName: t3, inputs: i3, attrs: s3 } = e20, l3 = ha(t3, this.backendName);
      Z(null != l3, () => `Cannot find registered kernel '${t3}' for backend '${this.backendName}'`), n2 = () => {
        let e21 = this.backend.numDataIds();
        o2 = l3.kernelFunc({ inputs: i3, attrs: s3, backend: this.backend });
        let n3 = Array.isArray(o2) ? o2 : [o2];
        this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(t3, e21, n3);
        let u3 = n3.map((e22) => null != e22.rank ? e22 : this.makeTensorFromTensorInfo(e22));
        if (a2) {
          let e22 = this.getTensorsForGradient(t3, i3, u3);
          r2 = this.saveTensorsForBackwardMode(e22);
        }
        return u3;
      };
    } else {
      let { forwardFunc: t3 } = e20, i3 = (e21) => {
        a2 && (r2 = e21.map((e22) => this.keep(this.clone(e22))));
      };
      n2 = () => {
        let e21 = this.backend.numDataIds();
        o2 = this.tidy(() => t3(this.backend, i3));
        let n3 = Array.isArray(o2) ? o2 : [o2];
        return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(l2, e21, n3), n3;
      };
    }
    let u2, { inputs: d2, attrs: c2 } = e20, h2 = wi(e20) ? null : e20.backwardsFunc;
    return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
      this.ENV.getBool("DEBUG") || this.state.profiling ? (u2 = this.profiler.profileKernel(l2, d2, () => n2()), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(u2), t2 = u2.outputs) : t2 = n2();
    }), a2 && this.addTapeNode(l2, d2, t2, h2, r2, c2), this.state.profiling && this.state.activeProfile.kernels.push({ name: l2, bytesAdded: this.state.numBytes - i2, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - s2, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(d2).map((e21) => null != d2[e21] ? d2[e21].shape : null), outputShapes: t2.map((e21) => e21.shape), kernelTimeMs: u2.timeMs, extraInfo: u2.extraInfo }), Array.isArray(o2) ? t2 : t2[0];
  }
  saveTensorsForBackwardMode(e20) {
    return e20.map((e21) => this.keep(this.clone(e21)));
  }
  getTensorsForGradient(e20, t2, n2) {
    let r2 = pa(e20);
    if (null != r2) {
      let e21, a2 = r2.inputsToSave || [], i2 = r2.outputsToSave || [];
      r2.saveAllInputs ? (Z(Array.isArray(t2), () => "saveAllInputs is true, expected inputs to be an array."), e21 = Object.keys(t2).map((e22) => t2[e22])) : e21 = a2.map((e22) => t2[e22]);
      let s2 = n2.filter((e22, t3) => i2[t3]);
      return e21.concat(s2);
    }
    return [];
  }
  makeTensor(e20, t2, n2, r2) {
    if (null == e20) throw Error("Values passed to engine.makeTensor() are null");
    r2 = r2 || this.backend;
    let a2 = e20;
    "string" === (n2 = n2 || "float32") && ye(e20[0]) && (a2 = e20.map((e21) => La(e21)));
    let i2 = r2.write(a2, t2, n2), s2 = new ni(t2, n2, i2, this.nextTensorId());
    if (this.trackTensor(s2, r2), "string" === n2) {
      let e21 = this.state.tensorInfo.get(i2), t3 = xe(a2);
      this.state.numBytes += t3 - e21.bytes, e21.bytes = t3;
    }
    return s2;
  }
  makeTensorFromDataId(e20, t2, n2, r2) {
    return this.makeTensorFromTensorInfo({ dataId: e20, shape: t2, dtype: n2 = n2 || "float32" }, r2);
  }
  makeTensorFromTensorInfo(e20, t2) {
    let { dataId: n2, shape: r2, dtype: a2 } = e20, i2 = new ni(r2, a2, n2, this.nextTensorId());
    return this.trackTensor(i2, t2), i2;
  }
  makeVariable(e20, t2 = true, n2, r2) {
    n2 = n2 || "" + this.nextVariableId(), null != r2 && r2 !== e20.dtype && (e20 = e20.cast(r2));
    let a2 = new ai(e20, t2, n2, this.nextTensorId());
    if (null != this.state.registeredVariables[a2.name]) throw Error(`Variable with name ${a2.name} was already registered`);
    return this.state.registeredVariables[a2.name] = a2, this.incRef(a2, this.backend), a2;
  }
  trackTensor(e20, t2) {
    this.state.numTensors++, "string" === e20.dtype && this.state.numStringTensors++;
    let n2 = 0;
    "complex64" !== e20.dtype && "string" !== e20.dtype && (n2 = e20.size * Ae(e20.dtype)), this.state.numBytes += n2, this.state.tensorInfo.has(e20.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e20.dataId, { backend: t2 || this.backend, dtype: e20.dtype, shape: e20.shape, bytes: n2 })), e20 instanceof ai || this.track(e20);
  }
  incRef(e20, t2) {
    this.trackTensor(e20, t2), this.backend.incRef(e20.dataId);
  }
  removeDataId(e20, t2) {
    this.state.tensorInfo.has(e20) && this.state.tensorInfo.get(e20).backend === t2 && (this.state.tensorInfo.delete(e20), this.state.numDataBuffers--);
  }
  disposeTensor(e20) {
    if (!this.state.tensorInfo.has(e20.dataId)) return;
    let t2 = this.state.tensorInfo.get(e20.dataId);
    if (this.state.numTensors--, "string" === e20.dtype && (this.state.numStringTensors--, this.state.numBytes -= t2.bytes), "complex64" !== e20.dtype && "string" !== e20.dtype) {
      let t3 = e20.size * Ae(e20.dtype);
      this.state.numBytes -= t3;
    }
    t2.backend.disposeData(e20.dataId) && this.removeDataId(e20.dataId, t2.backend);
  }
  disposeVariables() {
    for (let e20 in this.state.registeredVariables) this.disposeVariable(this.state.registeredVariables[e20]);
  }
  disposeVariable(e20) {
    this.disposeTensor(e20), null != this.state.registeredVariables[e20.name] && delete this.state.registeredVariables[e20.name];
  }
  memory() {
    let e20 = this.backend.memory();
    return e20.numTensors = this.state.numTensors, e20.numDataBuffers = this.state.numDataBuffers, e20.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e20.unreliable = true, null == e20.reasons && (e20.reasons = []), e20.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e20;
  }
  profile(e20) {
    return __async(this, null, function* () {
      this.state.profiling = true;
      let t2 = this.state.numBytes, n2 = this.state.numTensors;
      this.state.activeProfile.kernels = [], this.state.activeProfile.result = yield e20(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((e21) => e21.totalBytesSnapshot)), this.state.activeProfile.newBytes = this.state.numBytes - t2, this.state.activeProfile.newTensors = this.state.numTensors - n2;
      for (let r2 of this.state.activeProfile.kernels) r2.kernelTimeMs = yield r2.kernelTimeMs, r2.extraInfo = yield r2.extraInfo;
      return this.state.activeProfile;
    });
  }
  isTapeOn() {
    return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
  }
  addTapeNode(e20, t2, n2, r2, a2, i2) {
    let s2 = { id: this.state.nextTapeNodeId++, kernelName: e20, inputs: t2, outputs: n2, saved: a2 }, o2 = pa(e20);
    null != o2 && (r2 = o2.gradFunc), null != r2 && (s2.gradient = (e21) => (e21 = e21.map((e22, t3) => {
      if (null == e22) {
        let e23 = n2[t3], r3 = Ie(e23.size, e23.dtype);
        return this.makeTensor(r3, e23.shape, e23.dtype);
      }
      return e22;
    }), r2(e21.length > 1 ? e21 : e21[0], a2, i2))), this.state.activeTape.push(s2);
  }
  keep(e20) {
    return e20.kept = true, e20;
  }
  startTape() {
    0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
  }
  endTape() {
    this.state.gradientDepth--;
  }
  startScope(e20) {
    let t2 = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
    e20 && (t2.name = e20), this.state.scopeStack.push(t2), this.state.activeScope = t2;
  }
  endScope(e20) {
    let t2 = gi(e20), n2 = new Set(t2.map((e21) => e21.id));
    for (let a2 = 0; this.state.activeScope.track.length > a2; a2++) {
      let e21 = this.state.activeScope.track[a2];
      !e21.kept && !n2.has(e21.id) && e21.dispose();
    }
    let r2 = this.state.scopeStack.pop();
    this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], t2.forEach((e21) => {
      !e21.kept && e21.scopeId === r2.id && this.track(e21);
    });
  }
  gradients(e20, t2, n2, r2 = false) {
    if (Z(t2.length > 0, () => "gradients() received an empty list of xs."), null != n2 && "float32" !== n2.dtype) throw Error(`dy must have 'float32' dtype, but has '${n2.dtype}'`);
    let a2 = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", e20));
    Z(a2 instanceof ni, () => "The result y returned by f() must be a tensor.");
    let i2 = ((e21, t3, n3) => {
      let r3 = {}, a3 = {};
      for (let l2 = 0; t3.length > l2; l2++) r3[t3[l2].id] = true;
      for (let l2 = 0; e21.length > l2; l2++) {
        let n4 = e21[l2], i4 = n4.inputs;
        for (let e22 in i4) {
          let s3 = i4[e22], o3 = false;
          for (let e23 = 0; t3.length > e23; e23++) if (r3[s3.id]) {
            n4.outputs.forEach((e24) => r3[e24.id] = true), o3 = true, a3[n4.id] = true;
            break;
          }
          if (o3) break;
        }
      }
      let i3 = {};
      i3[n3.id] = true;
      let s2 = {};
      for (let l2 = e21.length - 1; l2 >= 0; l2--) {
        let t4 = e21[l2], n4 = t4.inputs;
        for (let e22 = 0; t4.outputs.length > e22; e22++) if (i3[t4.outputs[e22].id]) {
          for (let e23 in n4) i3[n4[e23].id] = true, s2[t4.id] = true;
          break;
        }
      }
      let o2 = [];
      for (let l2 = 0; e21.length > l2; l2++) {
        let t4 = e21[l2];
        if (a3[t4.id] && s2[t4.id]) {
          let e22 = {};
          for (let a4 in t4.inputs) {
            let n5 = t4.inputs[a4];
            r3[n5.id] && (e22[a4] = n5);
          }
          let n4 = Object.assign({}, t4);
          n4.inputs = e22, n4.outputs = t4.outputs, o2.push(n4);
        }
      }
      return o2;
    })(this.state.activeTape, t2, a2);
    if (!r2 && 0 === i2.length && t2.length > 0) throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", () => {
      let e21 = {};
      e21[a2.id] = n2 ?? ((e22) => {
        let t3 = Se(J(e22), "float32");
        return $i.makeTensor(t3, e22, "float32");
      })(a2.shape), ((e22, t3, n3, r4) => {
        for (let a3 = t3.length - 1; a3 >= 0; a3--) {
          let i3 = t3[a3], s2 = [];
          if (i3.outputs.forEach((t4) => {
            let n4 = e22[t4.id];
            s2.push(null != n4 ? n4 : null);
          }), null == i3.gradient) throw Error(`Cannot compute gradient: gradient function not found for ${i3.kernelName}.`);
          let o2 = i3.gradient(s2);
          for (let t4 in i3.inputs) {
            if (!(t4 in o2)) throw Error(`Cannot backprop through input ${t4}. Available gradients found: ${Object.keys(o2)}.`);
            let a4 = n3(() => o2[t4]());
            if ("float32" !== a4.dtype) throw Error(`Error in gradient for op ${i3.kernelName}. The gradient of input ${t4} must have 'float32' dtype, but has '${a4.dtype}'`);
            let s3 = i3.inputs[t4];
            if (!te(a4.shape, s3.shape)) throw Error(`Error in gradient for op ${i3.kernelName}. The gradient of input '${t4}' has shape '${a4.shape}', which does not match the shape of the input '${s3.shape}'`);
            if (null == e22[s3.id]) e22[s3.id] = a4;
            else {
              let t5 = e22[s3.id];
              e22[s3.id] = r4(t5, a4), t5.dispose();
            }
          }
        }
      })(e21, i2, (e22) => this.tidy(e22), Ri);
      let r3 = t2.map((t3) => e21[t3.id]);
      return 0 === this.state.gradientDepth && (this.state.activeTape.forEach((e22) => {
        for (let t3 of e22.saved) t3.dispose();
      }), this.state.activeTape = null), { value: a2, grads: r3 };
    });
  }
  customGrad(e20) {
    return Z(we(e20), () => "The f passed in customGrad(f) must be a function."), (...t2) => {
      Z(t2.every((e21) => e21 instanceof ni), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      let n2, r2 = {};
      return t2.forEach((e21, t3) => {
        r2[t3] = e21;
      }), this.runKernelFunc({ forwardFunc(r3, a2) {
        return n2 = e20(...t2, a2), Z(n2.value instanceof ni, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), Z(we(n2.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), n2.value;
      }, backwardsFunc(e21, r3) {
        let a2 = n2.gradFunc(e21, r3), i2 = Array.isArray(a2) ? a2 : [a2];
        Z(i2.length === t2.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), Z(i2.every((e22) => e22 instanceof ni), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
        let s2 = {};
        return i2.forEach((e22, t3) => {
          s2[t3] = () => e22;
        }), s2;
      }, inputs: r2 });
    };
  }
  readSync(e20) {
    return this.state.tensorInfo.get(e20).backend.readSync(e20);
  }
  read(e20) {
    return this.state.tensorInfo.get(e20).backend.read(e20);
  }
  readToGPU(e20, t2) {
    return this.state.tensorInfo.get(e20).backend.readToGPU(e20, t2);
  }
  time(e20) {
    return __async(this, null, function* () {
      let t2 = Da(), n2 = yield this.backend.time(e20);
      return n2.wallMs = Da() - t2, n2;
    });
  }
  track(e20) {
    return null != this.state.activeScope && (e20.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e20)), e20;
  }
  get registeredVariables() {
    return this.state.registeredVariables;
  }
  reset() {
    this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new ki();
    for (let e20 in this.registry) this.disposeRegisteredKernels(e20), this.registry[e20].dispose(), delete this.registry[e20];
    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }
};
function Ci() {
  let e20 = Le();
  if (null == e20.er) {
    let t2 = new ze(e20);
    e20.er = new Ni(t2);
  }
  return ((e21) => {
    We = e21;
  })(e20.er.ENV), ((e21) => {
    ei = e21;
  })(() => e20.er), e20.er;
}
Ni.nextTensorId = 0, Ni.nextVariableId = 0;
var $i = Ci();
function Ri(e20, t2) {
  return $i.runKernel("Add", { a: e20, b: t2 });
}
var Si;
var Ii = {};
function Ei(e20) {
  Si = e20;
}
function Ti(e20) {
  if (void 0 !== Si) return Si;
  if (e20 || "undefined" != typeof navigator && null != navigator) {
    if (e20 || (e20 = navigator), "ReactNative" === e20.product) return true;
    let t2 = e20.userAgent || e20.vendor || ("undefined" != typeof window ? window.opera : "");
    return t2 ? /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t2.substr(0, 4)) : e20.userAgentData && e20.userAgentData.mobile;
  }
  return false;
}
function Mi() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}
A(Ii, { isBrowser() {
  return Mi;
}, isMobile() {
  return Ti;
}, mockIsMobile() {
  return Ei;
} });
var Oi = _e();
function Fi(e20, t2) {
  let n2 = e20;
  if (Ua(e20)) return "string" === t2 ? [] : [e20.length];
  if (mi(e20)) return [e20.height, e20.width * (e20.channels || "RGBA").length];
  if (Ai(e20)) return [e20.buffer.size / (null == t2 ? 4 : Ae(t2))];
  if (!Array.isArray(e20)) return [];
  let r2 = [];
  for (; Array.isArray(n2) || Ua(n2) && "string" !== t2; ) r2.push(n2.length), n2 = n2[0];
  return Array.isArray(e20) && _e().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && Pi(e20, r2, []), r2;
}
function Pi(e20, t2, n2) {
  if (n2 = n2 || [], !Array.isArray(e20) && !Ua(e20)) return void Z(0 === t2.length, () => `Element arr[${n2.join("][")}] is a primitive, but should be an array/TypedArray of ${t2[0]} elements`);
  Z(t2.length > 0, () => `Element arr[${n2.join("][")}] should be a primitive, but is an array of ${e20.length} elements`), Z(e20.length === t2[0], () => `Element arr[${n2.join("][")}] should have ${t2[0]} elements, but has ${e20.length} elements`);
  let r2 = t2.slice(1);
  for (let a2 = 0; e20.length > a2; ++a2) Pi(e20[a2], r2, n2.concat(a2));
}
function zi(e20, t2, n2, r2) {
  if ("string_or_numeric" !== e20) {
    if (null == e20) throw Error("Expected dtype cannot be null.");
    if ("numeric" !== e20 && e20 !== t2 || "numeric" === e20 && "string" === t2) throw Error(`Argument '${n2}' passed to '${r2}' must be ${e20} tensor, but got ${t2} tensor`);
  }
}
function Vi(e20, t2, n2, r2 = "numeric") {
  if (e20 instanceof ri()) return zi(r2, e20.dtype, t2, n2), e20;
  let a2 = ve(e20);
  if ("string" !== a2 && ["bool", "int32", "float32"].indexOf(r2) >= 0 && (a2 = r2), zi(r2, a2, t2, n2), null == e20 || !Ua(e20) && !Array.isArray(e20) && "number" != typeof e20 && "boolean" != typeof e20 && "string" != typeof e20) throw Error(`Argument '${t2}' passed to '${n2}' must be a Tensor or TensorLike, but got '${null == e20 ? "null" : e20.constructor.name}'`);
  let i2 = Fi(e20, a2);
  !Ua(e20) && !Array.isArray(e20) && (e20 = [e20]);
  let s2 = "string" !== a2 ? _a(e20, a2) : ja(e20, [], true);
  return $i.makeTensor(s2, i2, a2);
}
function _i(e20, t2, n2, r2 = "numeric") {
  if (!Array.isArray(e20)) throw Error(`Argument ${t2} passed to ${n2} must be a \`Tensor[]\` or \`TensorLike[]\``);
  return e20.map((e21, a2) => Vi(e21, `${t2}[${a2}]`, n2, r2));
}
Oi.registerFlag("DEBUG", () => false, (e20) => {
  e20 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Oi.registerFlag("IS_BROWSER", () => Mi()), Oi.registerFlag("IS_NODE", () => "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node), Oi.registerFlag("IS_CHROME", () => "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)), Oi.registerFlag("IS_SAFARI", () => "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor)), Oi.registerFlag("PROD", () => false), Oi.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => Oi.getBool("DEBUG")), Oi.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true), Oi.registerFlag("IS_TEST", () => false), Oi.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => Oi.getBool("DEBUG")), Oi.registerFlag("WRAP_TO_IMAGEBITMAP", () => false), Oi.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false), Oi.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);
var Di = "__op";
function Wi(e20) {
  let t2 = Object.keys(e20);
  if (1 !== t2.length) throw Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t2.length} keys.`);
  let n2 = t2[0], r2 = e20[n2];
  n2.endsWith("_") && (n2 = n2.substring(0, n2.length - 1)), n2 += Di;
  let a2 = (...e21) => {
    $i.startScope(n2);
    try {
      let t3 = r2(...e21);
      return Fe(t3) && console.error("Cannot return a Promise inside of tidy."), $i.endScope(t3), t3;
    } catch (t3) {
      throw $i.endScope(null), t3;
    }
  };
  return Object.defineProperty(a2, "name", { value: n2, configurable: true }), a2;
}
var Li = Wi({ complex_(e20, t2) {
  let n2 = Vi(e20, "real", "complex"), r2 = Vi(t2, "imag", "complex");
  return K(n2.shape, r2.shape, `real and imag shapes, ${n2.shape} and ${r2.shape}, must match in call to tf.complex().`), $i.runKernel(At, { real: n2, imag: r2 });
} });
function Bi(e20, t2, n2, r2) {
  if (null == r2) r2 = ve(e20);
  else if ("complex64" === r2) throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (Ai(e20) || mi(e20)) {
    if ("float32" !== r2 && "int32" !== r2) throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r2}.`);
    return $i.backend.createTensorFromGPUData(e20, t2 || n2, r2);
  }
  if (!Ua(e20) && !Array.isArray(e20) && "number" != typeof e20 && "boolean" != typeof e20 && "string" != typeof e20) throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (null != t2) {
    Te(t2);
    let e21 = J(t2), r3 = J(n2);
    Z(e21 === r3, () => `Based on the provided shape, [${t2}], the tensor should have ${e21} values but has ${r3}`);
    for (let a2 = 0; n2.length > a2; ++a2) {
      let e22 = a2 !== n2.length - 1 || n2[a2] !== J(t2.slice(a2));
      Z(n2[a2] === t2[a2] || !e22, () => `Error creating a new Tensor. Inferred shape (${n2}) does not match the provided shape (${t2}). `);
    }
  }
  return !Ua(e20) && !Array.isArray(e20) && (e20 = [e20]), t2 = t2 || n2, e20 = "string" !== r2 ? _a(e20, r2) : ja(e20, [], true), $i.makeTensor(e20, t2, r2);
}
function Ui(e20, t2, n2) {
  return Bi(e20, t2, Fi(e20, n2), n2);
}
var ji = { float32: 4, float16: 2, int32: 4, uint16: 2, uint8: 1, bool: 1, complex64: 8 };
var Gi = class e3 {
  static join(t2) {
    return new e3(t2).slice();
  }
  constructor(e20) {
    if (this.shards = [], this.previousShardIndex = 0, null == e20 || (e20 instanceof Array || (e20 = [e20]), 0 === (e20 = e20.map((e21) => Ua(e21) ? e21.buffer : e21)).length)) return;
    this.bufferUniformSize = e20[0].byteLength;
    let t2 = 0;
    for (let n2 = 0; e20.length > n2; n2++) {
      let r2 = e20[n2];
      n2 !== e20.length - 1 && r2.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
      let a2 = t2 + r2.byteLength;
      this.shards.push({ buffer: r2, start: t2, end: a2 }), t2 = a2;
    }
    0 === this.shards.length && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end;
  }
  slice(e20 = 0, t2 = this.byteLength) {
    if (0 === this.shards.length) return new ArrayBuffer(0);
    if (e20 = isNaN(+e20) ? 0 : e20, t2 = isNaN(+t2) ? 0 : t2, (e20 = Math.max(0, e20)) >= (t2 = Math.min(this.byteLength, t2))) return new ArrayBuffer(0);
    let n2 = this.findShardForByte(e20);
    if (-1 === n2) throw Error("Could not find start shard for byte " + e20);
    let r2 = new ArrayBuffer(t2 - e20), a2 = new Uint8Array(r2), i2 = 0;
    for (let s2 = n2; this.shards.length > s2; s2++) {
      let n3 = this.shards[s2], r3 = e20 + i2 - n3.start, o2 = i2, l2 = new Uint8Array(n3.buffer, r3, Math.min(t2, n3.end) - n3.start - r3);
      if (a2.set(l2, o2), i2 += l2.length, n3.end > t2) break;
    }
    return r2;
  }
  findShardForByte(e20) {
    if (0 === this.shards.length || 0 > e20 || e20 >= this.byteLength) return -1;
    if (null != this.bufferUniformSize) return this.previousShardIndex = Math.floor(e20 / this.bufferUniformSize), this.previousShardIndex;
    function t2(t3) {
      return t3.start > e20 ? -1 : t3.end > e20 ? 0 : 1;
    }
    if (0 === t2(this.shards[this.previousShardIndex])) return this.previousShardIndex;
    let n2 = ((e21, t3) => {
      let n3 = 0, r2 = e21.length;
      for (; r2 >= n3; ) {
        let a2 = Math.floor((r2 - n3) / 2) + n3, i2 = t3(e21[a2]);
        if (0 === i2) return a2;
        0 > i2 ? r2 = a2 : n3 = a2 + 1;
      }
      return -1;
    })(this.shards, t2);
    return -1 === n2 ? -1 : (this.previousShardIndex = n2, this.previousShardIndex);
  }
};
function Hi() {
  _e().set("PROD", true);
}
function Xi() {
  _e().set("DEBUG", true);
}
function qi() {
  _e().set("DEPRECATION_WARNINGS_ENABLED", false), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}
function Zi(e20) {
  _e().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(e20 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function Ki() {
  $i.disposeVariables();
}
function Yi() {
  return $i;
}
function Ji() {
  return $i.memory();
}
function Qi(e20) {
  return $i.profile(e20);
}
function es(e20, t2) {
  return $i.tidy(e20, t2);
}
function ts(e20) {
  gi(e20).forEach((e21) => e21.dispose());
}
function ns(e20) {
  return $i.keep(e20);
}
function rs(e20) {
  return $i.time(e20);
}
function as(e20) {
  return $i.setBackend(e20);
}
function is() {
  return $i.ready();
}
function ss() {
  return $i.backendName;
}
function os(e20) {
  $i.removeBackend(e20);
}
function ls(e20) {
  return $i.findBackend(e20);
}
function us(e20) {
  return $i.findBackendFactory(e20);
}
function ds(e20, t2, n2 = 1) {
  return $i.registerBackend(e20, t2, n2);
}
function cs() {
  return $i.backend;
}
function hs(e20, t2) {
  _e().setPlatform(e20, t2);
}
function ps(e20, t2) {
  return __async(this, null, function* () {
    let n2 = [], r2 = [], a2 = Array.isArray(e20) ? e20.map((e21) => e21.name) : Object.keys(e20);
    for (let i2 = 0; a2.length > i2; ++i2) {
      let s2 = a2[i2], o2 = Array.isArray(e20) ? e20[i2].tensor : e20[s2];
      if ("float32" !== o2.dtype && "int32" !== o2.dtype && "bool" !== o2.dtype && "string" !== o2.dtype && "complex64" !== o2.dtype) throw Error(`Unsupported dtype in weight '${s2}': ${o2.dtype}`);
      let l2 = { name: s2, shape: o2.shape, dtype: o2.dtype };
      if ("string" === o2.dtype) {
        let e21 = new Promise((e22) => __async(null, null, function* () {
          let t3 = yield o2.bytes(), n3 = t3.reduce((e23, t4) => e23 + t4.length, 0) + 4 * t3.length, r3 = new Uint8Array(n3), a3 = 0;
          for (let i3 = 0; t3.length > i3; i3++) {
            let e23 = t3[i3], n4 = new Uint8Array(new Uint32Array([e23.length]).buffer);
            r3.set(n4, a3), a3 += 4, r3.set(e23, a3), a3 += e23.length;
          }
          e22(r3);
        }));
        r2.push(e21);
      } else r2.push(o2.data());
      null != t2 && (l2.group = t2), n2.push(l2);
    }
    return { data: gs(yield Promise.all(r2)), specs: n2 };
  });
}
function fs(e20, t2) {
  let n2 = new Gi(e20), r2 = {}, a2 = 0;
  for (let i2 of t2) {
    let e21 = ms(i2, (e22, t3) => n2.slice(a2 + e22, a2 + t3));
    r2[i2.name] = xs(i2, n2.slice(a2, a2 + e21)), a2 += e21;
  }
  return r2;
}
function ms(e20, t2) {
  let n2, r2 = J(e20.shape);
  if ("quantization" in e20) n2 = ji[e20.quantization.dtype];
  else {
    if ("string" === e20.dtype) {
      let e21 = 0;
      for (let n3 = 0; r2 > n3; n3++) e21 += 4 + new Uint32Array(t2(e21, e21 + 4))[0];
      return e21;
    }
    n2 = ji[e20.dtype];
  }
  return r2 * n2;
}
function As(e20, t2) {
  return __async(this, null, function* () {
    let n2, r2 = J(e20.shape);
    if ("quantization" in e20) n2 = ji[e20.quantization.dtype];
    else {
      if ("string" === e20.dtype) {
        let e21 = 0;
        for (let n3 = 0; r2 > n3; n3++) e21 += 4 + new Uint32Array(yield t2(e21, e21 + 4))[0];
        return e21;
      }
      n2 = ji[e20.dtype];
    }
    return r2 * n2;
  });
}
function xs(e20, t2) {
  let n2, r2 = e20.name, a2 = e20.dtype, i2 = e20.shape, s2 = J(i2), o2 = 0;
  if ("quantization" in e20) {
    let i3 = e20.quantization;
    if ("uint8" === i3.dtype || "uint16" === i3.dtype) {
      if (!("min" in i3) || !("scale" in i3)) throw Error(`Weight ${e20.name} with quantization ${i3.dtype} doesn't have corresponding metadata min and scale.`);
    } else {
      if ("float16" !== i3.dtype) throw Error(`Weight ${e20.name} has unknown quantization dtype ${i3.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
      if ("float32" !== a2) throw Error(`Weight ${e20.name} is quantized with ${i3.dtype} which only supports weights of type float32 not ${a2}.`);
    }
    let l2 = ji[i3.dtype], u2 = "uint8" === i3.dtype ? new Uint8Array(t2) : new Uint16Array(t2);
    if ("float32" === a2) if ("uint8" === i3.dtype || "uint16" === i3.dtype) {
      n2 = new Float32Array(u2.length);
      for (let e21 = 0; u2.length > e21; e21++) n2[e21] = u2[e21] * i3.scale + i3.min;
    } else {
      if ("float16" !== i3.dtype) throw Error(`Unsupported quantization type ${i3.dtype} for weight type float32.`);
      n2 = (() => {
        let e21 = (() => {
          let e22 = (e23) => {
            let t5 = e23 << 13, n4 = 0;
            for (; !(8388608 & t5); ) n4 -= 8388608, t5 <<= 1;
            return t5 &= -8388609, n4 += 947912704, t5 | n4;
          }, t4 = new Uint32Array(2048);
          t4[0] = 0;
          for (let n4 = 1; 1024 > n4; n4++) t4[n4] = e22(n4);
          for (let n4 = 1024; 2048 > n4; n4++) t4[n4] = 939524096 + (n4 - 1024 << 13);
          return t4;
        })(), t3 = (() => {
          let e22 = new Uint32Array(64);
          e22[0] = 0, e22[31] = 1199570944, e22[32] = 2147483648, e22[63] = 3347054592;
          for (let t4 = 1; 31 > t4; t4++) e22[t4] = t4 << 23;
          for (let t4 = 33; 63 > t4; t4++) e22[t4] = 2147483648 + (t4 - 32 << 23);
          return e22;
        })(), n3 = (() => {
          let e22 = new Uint32Array(64);
          for (let t4 = 0; 64 > t4; t4++) e22[t4] = 1024;
          return e22[0] = e22[32] = 0, e22;
        })();
        return (r3) => {
          let a3 = new ArrayBuffer(4 * r3.length), i4 = new Uint32Array(a3);
          for (let s3 = 0; r3.length > s3; s3++) {
            let a4 = r3[s3];
            i4[s3] = e21[n3[a4 >> 10] + (1023 & a4)] + t3[a4 >> 10];
          }
          return new Float32Array(a3);
        };
      })()(u2);
    }
    else {
      if ("int32" !== a2) throw Error(`Unsupported dtype in weight '${r2}': ${a2}`);
      if ("uint8" !== i3.dtype && "uint16" !== i3.dtype) throw Error(`Unsupported quantization type ${i3.dtype} for weight type int32.`);
      n2 = new Int32Array(u2.length);
      for (let e21 = 0; u2.length > e21; e21++) n2[e21] = Math.round(u2[e21] * i3.scale + i3.min);
    }
    o2 += s2 * l2;
  } else if ("string" === a2) {
    let r3 = J(e20.shape);
    n2 = [];
    for (let e21 = 0; r3 > e21; e21++) {
      let e22 = new Uint32Array(t2.slice(o2, o2 + 4))[0];
      o2 += 4;
      let r4 = new Uint8Array(t2.slice(o2, o2 + e22));
      n2.push(r4), o2 += e22;
    }
  } else {
    let e21 = ji[a2];
    if ("float32" === a2) n2 = new Float32Array(t2);
    else if ("int32" === a2) n2 = new Int32Array(t2);
    else {
      if ("bool" !== a2) {
        if ("complex64" === a2) {
          n2 = new Float32Array(t2);
          let e22 = new Float32Array(n2.length / 2), r3 = new Float32Array(n2.length / 2);
          for (let t3 = 0; e22.length > t3; t3++) e22[t3] = n2[2 * t3], r3[t3] = n2[2 * t3 + 1];
          let a3 = Ui(e22, i2, "float32"), s3 = Ui(r3, i2, "float32"), o3 = Li(a3, s3);
          return a3.dispose(), s3.dispose(), o3;
        }
        throw Error(`Unsupported dtype in weight '${r2}': ${a2}`);
      }
      n2 = new Uint8Array(t2);
    }
    o2 += s2 * e21;
  }
  return Ui(n2, i2, a2);
}
function ys(e20, t2, n2) {
  return __async(this, null, function* () {
    let r2 = new Uint8Array(t2);
    for (; n2 > r2.byteLength; ) {
      let { done: t3, value: a2 } = yield e20.read();
      if (t3 && null == a2) throw Error(`Reader is done but ${n2 - r2.byteLength} bytes are still expected`);
      let i2 = new Uint8Array(r2.length + a2.byteLength);
      i2.set(r2, 0), i2.set(new Uint8Array(a2), r2.length), r2 = i2;
    }
    return r2.buffer;
  });
}
function bs(e20, t2) {
  return __async(this, null, function* () {
    let n2 = {}, r2 = e20.getReader(), a2 = new ArrayBuffer(0);
    for (let i2 of t2) {
      let e21 = yield As(i2, (e22, t4) => __async(null, null, function* () {
        return a2 = yield ys(r2, a2, t4), a2.slice(e22, t4);
      }));
      a2 = yield ys(r2, a2, e21);
      let t3 = a2.slice(0, e21);
      a2 = a2.slice(e21);
      let s2 = xs(i2, t3);
      if (n2[i2.name] = s2, "webgpu" === ss()) {
        let e22 = cs();
        "uploadToGPU" in e22 && J(s2.shape) >= _e().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD") && e22.uploadToGPU(s2.dataId);
      }
    }
    return n2;
  });
}
function gs(e20) {
  if (null === e20) throw Error("Invalid input value: " + JSON.stringify(e20));
  let t2 = 0, n2 = [];
  e20.forEach((e21) => {
    if (t2 += e21.byteLength, n2.push(e21.byteLength === e21.buffer.byteLength ? e21 : new e21.constructor(e21)), !(e21 instanceof Float32Array || e21 instanceof Int32Array || e21 instanceof Uint8Array)) throw Error("Unsupported TypedArray subtype: " + e21.constructor.name);
  });
  let r2 = new Uint8Array(t2), a2 = 0;
  return n2.forEach((e21) => {
    r2.set(new Uint8Array(e21.buffer), a2), a2 += e21.byteLength;
  }), r2.buffer;
}
var vs = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
function ws(e20) {
  return vs ? Buffer.byteLength(e20, "utf8") : new Blob([e20]).size;
}
function ks(e20) {
  return Gi.join(e20);
}
function Ns(e20) {
  for (e20 = e20.trim(); e20.endsWith("/"); ) e20 = e20.slice(0, e20.length - 1);
  let t2 = e20.split("/");
  return t2[t2.length - 1];
}
function Cs(e20, t2) {
  let n2 = { modelTopology: e20.modelTopology, format: e20.format, generatedBy: e20.generatedBy, convertedBy: e20.convertedBy, weightsManifest: t2 };
  return null != e20.signature && (n2.signature = e20.signature), null != e20.userDefinedMetadata && (n2.userDefinedMetadata = e20.userDefinedMetadata), null != e20.modelInitializer && (n2.modelInitializer = e20.modelInitializer), null != e20.initializerSignature && (n2.initializerSignature = e20.initializerSignature), null != e20.trainingConfig && (n2.trainingConfig = e20.trainingConfig), n2;
}
function $s(e20, t2, n2) {
  let r2 = { modelTopology: e20.modelTopology, format: e20.format, generatedBy: e20.generatedBy, convertedBy: e20.convertedBy };
  if (null != e20.trainingConfig && (r2.trainingConfig = e20.trainingConfig), null != e20.weightsManifest) {
    if (!t2) throw Error("modelJSON has weightsManifest but weightSpecs is null");
    if (!n2) throw Error("modelJSON has weightsManifest but weightData is null");
    r2.weightSpecs = t2, r2.weightData = n2;
  }
  return null != e20.signature && (r2.signature = e20.signature), null != e20.userDefinedMetadata && (r2.userDefinedMetadata = e20.userDefinedMetadata), null != e20.modelInitializer && (r2.modelInitializer = e20.modelInitializer), null != e20.initializerSignature && (r2.initializerSignature = e20.initializerSignature), r2;
}
function Rs(e20, t2) {
  return __async(this, null, function* () {
    let n2, r2;
    return null != e20.weightsManifest && ([n2, r2] = yield t2(e20.weightsManifest)), $s(e20, n2, r2);
  });
}
function Ss(e20) {
  if (e20.modelTopology instanceof ArrayBuffer) throw Error("Expected JSON model topology, received ArrayBuffer.");
  return { dateSaved: /* @__PURE__ */ new Date(), modelTopologyType: "JSON", modelTopologyBytes: null == e20.modelTopology ? 0 : ws(JSON.stringify(e20.modelTopology)), weightSpecsBytes: null == e20.weightSpecs ? 0 : ws(JSON.stringify(e20.weightSpecs)), weightDataBytes: null == e20.weightData ? 0 : new Gi(e20.weightData).byteLength };
}
function Is(e20) {
  let t2 = [];
  for (let n2 of e20) t2.push(...n2.weights);
  return t2;
}
var Es = class e4 {
  constructor() {
    this.saveRouters = [], this.loadRouters = [];
  }
  static getInstance() {
    return null == e4.instance && (e4.instance = new e4()), e4.instance;
  }
  static registerSaveRouter(t2) {
    e4.getInstance().saveRouters.push(t2);
  }
  static registerLoadRouter(t2) {
    e4.getInstance().loadRouters.push(t2);
  }
  static getSaveHandlers(t2) {
    return e4.getHandlers(t2, "save");
  }
  static getLoadHandlers(t2, n2) {
    return e4.getHandlers(t2, "load", n2);
  }
  static getHandlers(t2, n2, r2) {
    let a2 = [];
    return ("load" === n2 ? e4.getInstance().loadRouters : e4.getInstance().saveRouters).forEach((e20) => {
      let n3 = e20(t2, r2);
      null !== n3 && a2.push(n3);
    }), a2;
  }
};
var Ts = (e20) => Es.registerSaveRouter(e20);
var Ms = (e20) => Es.registerLoadRouter(e20);
var Os = (e20) => Es.getSaveHandlers(e20);
var Fs = (e20, t2) => Es.getLoadHandlers(e20, t2);
var Ps = "tensorflowjs";
var zs = "models_store";
var Vs = "model_info_store";
function _s() {
  if (!_e().getBool("IS_BROWSER")) throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  let e20 = "undefined" == typeof window ? self : window, t2 = e20.indexedDB || e20.mozIndexedDB || e20.webkitIndexedDB || e20.msIndexedDB || e20.shimIndexedDB;
  if (null == t2) throw Error("The current browser does not appear to support IndexedDB.");
  return t2;
}
function Ds(e20) {
  let t2 = e20.result;
  t2.createObjectStore(zs, { keyPath: "modelPath" }), t2.createObjectStore(Vs, { keyPath: "modelPath" });
}
var Ws = class {
  constructor(e20) {
    if (this.indexedDB = _s(), null == e20 || !e20) throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = e20;
  }
  save(e20) {
    return __async(this, null, function* () {
      if (e20.modelTopology instanceof ArrayBuffer) throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      return this.databaseAction(this.modelPath, e20);
    });
  }
  load() {
    return __async(this, null, function* () {
      return this.databaseAction(this.modelPath);
    });
  }
  databaseAction(e20, t2) {
    return new Promise((e21, n2) => {
      let r2 = this.indexedDB.open(Ps, 1);
      r2.onupgradeneeded = () => Ds(r2), r2.onsuccess = () => {
        let a2 = r2.result;
        if (null == t2) {
          let t3 = a2.transaction(zs, "readonly"), r3 = t3.objectStore(zs).get(this.modelPath);
          r3.onsuccess = () => {
            if (null == r3.result) return a2.close(), n2(Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
            e21(r3.result.modelArtifacts);
          }, r3.onerror = (e22) => (a2.close(), n2(r3.error)), t3.oncomplete = () => a2.close();
        } else {
          t2.weightData = Gi.join(t2.weightData);
          let r3, s2, o2 = Ss(t2), l2 = a2.transaction(Vs, "readwrite"), u2 = l2.objectStore(Vs);
          try {
            r3 = u2.put({ modelPath: this.modelPath, modelArtifactsInfo: o2 });
          } catch (i2) {
            return n2(i2);
          }
          r3.onsuccess = () => {
            s2 = a2.transaction(zs, "readwrite");
            let r4, i2 = s2.objectStore(zs);
            try {
              r4 = i2.put({ modelPath: this.modelPath, modelArtifacts: t2, modelArtifactsInfo: o2 });
            } catch (d2) {
              return n2(d2);
            }
            r4.onsuccess = () => e21({ modelArtifactsInfo: o2 }), r4.onerror = (e22) => {
              u2 = l2.objectStore(Vs);
              let t3 = u2.delete(this.modelPath);
              t3.onsuccess = () => (a2.close(), n2(r4.error)), t3.onerror = (e23) => (a2.close(), n2(r4.error));
            };
          }, r3.onerror = (e22) => (a2.close(), n2(r3.error)), l2.oncomplete = () => {
            null == s2 ? a2.close() : s2.oncomplete = () => a2.close();
          };
        }
      }, r2.onerror = (e22) => n2(r2.error);
    });
  }
};
Ws.URL_SCHEME = "indexeddb://";
var Ls = (e20) => _e().getBool("IS_BROWSER") && !Array.isArray(e20) && e20.startsWith(Ws.URL_SCHEME) ? ((e21) => new Ws(e21))(e20.slice(Ws.URL_SCHEME.length)) : null;
Es.registerSaveRouter(Ls), Es.registerLoadRouter(Ls);
var Bs = "/";
var Us = "tensorflowjs_models";
var js = "info";
var Gs = "model_topology";
var Hs = "weight_specs";
var Xs = "weight_data";
var qs = "model_metadata";
function Zs(e20) {
  return { info: [Us, e20, js].join(Bs), topology: [Us, e20, Gs].join(Bs), weightSpecs: [Us, e20, Hs].join(Bs), weightData: [Us, e20, Xs].join(Bs), modelMetadata: [Us, e20, qs].join(Bs) };
}
function Ks(e20) {
  for (let t2 of Object.values(e20)) window.localStorage.removeItem(t2);
}
function Ys(e20) {
  let t2 = e20.split(Bs);
  if (3 > t2.length) throw Error("Invalid key format: " + e20);
  return t2.slice(1, t2.length - 1).join(Bs);
}
var Js = class {
  constructor(e20) {
    if (!_e().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, null == e20 || !e20) throw Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = e20, this.keys = Zs(this.modelPath);
  }
  save(e20) {
    return __async(this, null, function* () {
      if (e20.modelTopology instanceof ArrayBuffer) throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      {
        let n2 = JSON.stringify(e20.modelTopology), r2 = JSON.stringify(e20.weightSpecs), a2 = Ss(e20), i2 = Gi.join(e20.weightData);
        try {
          return this.LS.setItem(this.keys.info, JSON.stringify(a2)), this.LS.setItem(this.keys.topology, n2), this.LS.setItem(this.keys.weightSpecs, r2), this.LS.setItem(this.keys.weightData, ((e21) => {
            if (vs) return Buffer.from(e21).toString("base64");
            let t2 = new Uint8Array(e21), n3 = "";
            for (let r3 = 0, a3 = t2.length; a3 > r3; r3++) n3 += String.fromCharCode(t2[r3]);
            return btoa(n3);
          })(i2)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({ format: e20.format, generatedBy: e20.generatedBy, convertedBy: e20.convertedBy, signature: null != e20.signature ? e20.signature : void 0, userDefinedMetadata: null != e20.userDefinedMetadata ? e20.userDefinedMetadata : void 0, modelInitializer: null != e20.modelInitializer ? e20.modelInitializer : void 0, initializerSignature: null != e20.initializerSignature ? e20.initializerSignature : void 0, trainingConfig: null != e20.trainingConfig ? e20.trainingConfig : void 0 })), { modelArtifactsInfo: a2 };
        } catch (t2) {
          throw Ks(this.keys), Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a2.modelTopologyBytes}, weightSpecsBytes=${a2.weightSpecsBytes}, weightDataBytes=${a2.weightDataBytes}.`);
        }
      }
    });
  }
  load() {
    return __async(this, null, function* () {
      let e20 = JSON.parse(this.LS.getItem(this.keys.info));
      if (null == e20) throw Error(`In local storage, there is no model with name '${this.modelPath}'`);
      if ("JSON" !== e20.modelTopologyType) throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      let t2 = {}, n2 = JSON.parse(this.LS.getItem(this.keys.topology));
      if (null == n2) throw Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
      t2.modelTopology = n2;
      let r2 = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
      if (null == r2) throw Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
      t2.weightSpecs = r2;
      let a2 = this.LS.getItem(this.keys.modelMetadata);
      if (null != a2) {
        let e21 = JSON.parse(a2);
        t2.format = e21.format, t2.generatedBy = e21.generatedBy, t2.convertedBy = e21.convertedBy, null != e21.signature && (t2.signature = e21.signature), null != e21.userDefinedMetadata && (t2.userDefinedMetadata = e21.userDefinedMetadata), null != e21.modelInitializer && (t2.modelInitializer = e21.modelInitializer), null != e21.initializerSignature && (t2.initializerSignature = e21.initializerSignature), null != e21.trainingConfig && (t2.trainingConfig = e21.trainingConfig);
      }
      let i2 = this.LS.getItem(this.keys.weightData);
      if (null == i2) throw Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
      return t2.weightData = ((e21) => {
        if (vs) {
          let t4 = Buffer.from(e21, "base64");
          return t4.buffer.slice(t4.byteOffset, t4.byteOffset + t4.byteLength);
        }
        let t3 = atob(e21), n3 = new Uint8Array(t3.length);
        for (let r3 = 0; t3.length > r3; ++r3) n3.set([t3.charCodeAt(r3)], r3);
        return n3.buffer;
      })(i2), t2;
    });
  }
};
Js.URL_SCHEME = "localstorage://";
var Qs = (e20) => _e().getBool("IS_BROWSER") && !Array.isArray(e20) && e20.startsWith(Js.URL_SCHEME) ? ((e21) => new Js(e21))(e20.slice(Js.URL_SCHEME.length)) : null;
Es.registerSaveRouter(Qs), Es.registerLoadRouter(Qs);
var eo;
var to = "://";
var no = class e5 {
  constructor() {
    this.managers = {};
  }
  static getInstance() {
    return null == e5.instance && (e5.instance = new e5()), e5.instance;
  }
  static registerManager(t2, n2) {
    Z(null != t2, () => "scheme must not be undefined or null."), t2.endsWith(to) && (t2 = t2.slice(0, t2.indexOf(to))), Z(t2.length > 0, () => "scheme must not be an empty string.");
    let r2 = e5.getInstance();
    Z(null == r2.managers[t2], () => `A model store manager is already registered for scheme '${t2}'.`), r2.managers[t2] = n2;
  }
  static getManager(t2) {
    let n2 = e5.getInstance().managers[t2];
    if (null == n2) throw Error(`Cannot find model manager for scheme '${t2}'`);
    return n2;
  }
  static getSchemes() {
    return Object.keys(e5.getInstance().managers);
  }
};
function ro(e20) {
  if (-1 === e20.indexOf(to)) throw Error("The url string provided does not contain a scheme. Supported schemes are: " + no.getSchemes().join(","));
  return { scheme: e20.split(to)[0], path: e20.split(to)[1] };
}
function ao(e20, t2, n2 = false) {
  return __async(this, null, function* () {
    Z(e20 !== t2, () => `Old path and new path are the same: '${e20}'`);
    let r2 = Es.getLoadHandlers(e20);
    Z(r2.length > 0, () => `Copying failed because no load handler is found for source URL ${e20}.`), Z(2 > r2.length, () => `Copying failed because more than one (${r2.length}) load handlers for source URL ${e20}.`);
    let a2 = r2[0], i2 = Es.getSaveHandlers(t2);
    Z(i2.length > 0, () => `Copying failed because no save handler is found for destination URL ${t2}.`), Z(2 > i2.length, () => `Copying failed because more than one (${r2.length}) save handlers for destination URL ${t2}.`);
    let s2 = i2[0], o2 = ro(e20).scheme, l2 = ro(e20).path, u2 = o2 === ro(e20).scheme, d2 = yield a2.load();
    n2 && u2 && (yield no.getManager(o2).removeModel(l2));
    let c2 = yield s2.save(d2);
    return n2 && !u2 && (yield no.getManager(o2).removeModel(l2)), c2.modelArtifactsInfo;
  });
}
function io() {
  return __async(this, null, function* () {
    let e20 = no.getSchemes(), t2 = {};
    for (let n2 of e20) {
      let e21 = yield no.getManager(n2).listModels();
      for (let r2 in e21) t2[n2 + to + r2] = e21[r2];
    }
    return t2;
  });
}
function so(e20) {
  return __async(this, null, function* () {
    let t2 = ro(e20);
    return no.getManager(t2.scheme).removeModel(t2.path);
  });
}
function oo(e20, t2) {
  return __async(this, null, function* () {
    return ao(e20, t2, false);
  });
}
function lo(e20, t2) {
  return __async(this, null, function* () {
    return ao(e20, t2, true);
  });
}
if (_e().get("IS_BROWSER")) {
  _e().setPlatform("browser", new class {
    constructor() {
      this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = false;
    }
    fetch(e20, t2) {
      return fetch(e20, t2);
    }
    now() {
      return performance.now();
    }
    encode(e20, t2) {
      if ("utf-8" !== t2 && "utf8" !== t2) throw Error("Browser's encoder only supports utf-8, but got " + t2);
      return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(e20);
    }
    decode(e20, t2) {
      return new TextDecoder(t2).decode(e20);
    }
    setTimeoutCustom(e20, t2) {
      "undefined" != typeof window && _e().getBool("USE_SETTIMEOUTCUSTOM") ? (this.functionRefs.push(e20), setTimeout(() => {
        window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
      }, t2), this.hasEventListener || (this.hasEventListener = true, window.addEventListener("message", (e21) => {
        e21.source === window && e21.data.name === this.messageName && (e21.stopPropagation(), (0, this.functionRefs[e21.data.index])(), this.handledMessageCount++, this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [], this.handledMessageCount = 0));
      }, true))) : setTimeout(e20, t2);
    }
    isTypedArray(e20) {
      return wa(e20);
    }
  }());
  try {
    no.registerManager(Js.URL_SCHEME, new class {
      constructor() {
        Z(_e().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), Z("undefined" == typeof window || void 0 !== window.localStorage, () => "Current browser does not appear to support localStorage"), this.LS = window.localStorage;
      }
      listModels() {
        return __async(this, null, function* () {
          let e20 = {}, t2 = Us + Bs, n2 = Bs + js;
          for (let r2 = 0; this.LS.length > r2; ++r2) {
            let a2 = this.LS.key(r2);
            a2.startsWith(t2) && a2.endsWith(n2) && (e20[Ys(a2)] = JSON.parse(this.LS.getItem(a2)));
          }
          return e20;
        });
      }
      removeModel(e20) {
        return __async(this, null, function* () {
          e20 = ((e21) => e21.startsWith(Js.URL_SCHEME) ? e21.slice(Js.URL_SCHEME.length) : e21)(e20);
          let t2 = Zs(e20);
          if (null == this.LS.getItem(t2.info)) throw Error(`Cannot find model at path '${e20}'`);
          let n2 = JSON.parse(this.LS.getItem(t2.info));
          return Ks(t2), n2;
        });
      }
    }());
  } catch (si2) {
  }
  try {
    no.registerManager(Ws.URL_SCHEME, new class {
      constructor() {
        this.indexedDB = _s();
      }
      listModels() {
        return __async(this, null, function* () {
          return new Promise((e20, t2) => {
            let n2 = this.indexedDB.open(Ps, 1);
            n2.onupgradeneeded = () => Ds(n2), n2.onsuccess = () => {
              let r2 = n2.result, a2 = r2.transaction(Vs, "readonly"), i2 = a2.objectStore(Vs).getAll();
              i2.onsuccess = () => {
                let t3 = {};
                for (let e21 of i2.result) t3[e21.modelPath] = e21.modelArtifactsInfo;
                e20(t3);
              }, i2.onerror = (e21) => (r2.close(), t2(i2.error)), a2.oncomplete = () => r2.close();
            }, n2.onerror = (e21) => t2(n2.error);
          });
        });
      }
      removeModel(e20) {
        return __async(this, null, function* () {
          return e20 = ((e21) => e21.startsWith(Ws.URL_SCHEME) ? e21.slice(Ws.URL_SCHEME.length) : e21)(e20), new Promise((t2, n2) => {
            let r2 = this.indexedDB.open(Ps, 1);
            r2.onupgradeneeded = () => Ds(r2), r2.onsuccess = () => {
              let a2, i2 = r2.result, s2 = i2.transaction(Vs, "readwrite"), o2 = s2.objectStore(Vs), l2 = o2.get(e20);
              l2.onsuccess = () => {
                if (null == l2.result) return i2.close(), n2(Error(`Cannot find model with path '${e20}' in IndexedDB.`));
                {
                  let r3 = o2.delete(e20), s3 = () => {
                    a2 = i2.transaction(zs, "readwrite");
                    let r4 = a2.objectStore(zs).delete(e20);
                    r4.onsuccess = () => t2(l2.result.modelArtifactsInfo), r4.onerror = (e21) => n2(l2.error);
                  };
                  r3.onsuccess = s3, r3.onerror = (e21) => (s3(), i2.close(), n2(l2.error));
                }
              }, l2.onerror = (e21) => (i2.close(), n2(l2.error)), s2.oncomplete = () => {
                null == a2 ? i2.close() : a2.oncomplete = () => i2.close();
              };
            }, r2.onerror = (e21) => n2(r2.error);
          });
        });
      }
    }());
  } catch (si2) {
  }
}
function uo(e20, t2 = "float32", n2) {
  return t2 = t2 || "float32", Te(e20), new Qa(e20, t2, n2);
}
_e().get("IS_NODE") && !_e().get("IS_BROWSER") && _e().setPlatform("node", new class {
  constructor() {
    this.util = g(), this.textEncoder = new this.util.TextEncoder();
  }
  fetch(e20, t2) {
    return null != _e().global.fetch ? _e().global.fetch(e20, t2) : (null == eo && (eo = b()), eo(e20, t2));
  }
  now() {
    let e20 = process.hrtime();
    return 1e3 * e20[0] + e20[1] / 1e6;
  }
  encode(e20, t2) {
    if ("utf-8" !== t2 && "utf8" !== t2) throw Error("Node built-in encoder only supports utf-8, but got " + t2);
    return this.textEncoder.encode(e20);
  }
  decode(e20, t2) {
    return 0 === e20.length ? "" : new this.util.TextDecoder(t2).decode(e20);
  }
  isTypedArray(e20) {
    return this.util.types.isFloat32Array(e20) || this.util.types.isInt32Array(e20) || this.util.types.isUint8Array(e20) || this.util.types.isUint8ClampedArray(e20);
  }
}());
var co = Wi({ cast_(e20, t2) {
  let n2 = Vi(e20, "x", "cast");
  if (!fe(t2)) throw Error("Failed to cast to unknown dtype " + t2);
  if ("string" === t2 && "string" !== n2.dtype || "string" !== t2 && "string" === n2.dtype) throw Error("Only strings can be casted to strings");
  return $i.runKernel(pt, { x: n2 }, { dtype: t2 });
} });
var ho = Wi({ clone_(e20) {
  let t2 = { x: Vi(e20, "x", "clone", "string_or_numeric") };
  return $i.runKernel(sn, t2);
} });
function po(e20, t2 = false) {
  console.log(e20.toString(t2));
}
Ci(), ti = { buffer: uo, cast: co, clone: ho, print: po };
var fo = Wi({ add_(e20, t2) {
  let n2 = Vi(e20, "a", "add"), r2 = Vi(t2, "b", "add");
  return [n2, r2] = xi(n2, r2), $i.runKernel("Add", { a: n2, b: r2 });
} });
var mo = Wi({ floorDiv_(e20, t2) {
  let n2 = Vi(e20, "a", "floorDiv"), r2 = Vi(t2, "b", "floorDiv");
  return [n2, r2] = xi(n2, r2), $i.runKernel(Qt, { a: n2, b: r2 });
} });
var Ao = Wi({ div_(e20, t2) {
  let n2 = Vi(e20, "a", "div"), r2 = Vi(t2, "b", "div");
  return [n2, r2] = xi(n2, r2), "int32" === n2.dtype && "int32" === r2.dtype ? mo(n2, r2) : $i.runKernel(Wt, { a: n2, b: r2 }, {});
} });
var xo = Wi({ mul_(e20, t2) {
  let n2 = Vi(e20, "a", "mul"), r2 = Vi(t2, "b", "mul");
  return [n2, r2] = xi(n2, r2), $i.runKernel(Wn, { a: n2, b: r2 });
} });
var yo = Wi({ abs_(e20) {
  let t2 = Vi(e20, "x", "abs");
  return $i.runKernel("complex64" === t2.dtype ? xt : "Abs", { x: t2 });
} });
var bo = Wi({ acos_(e20) {
  let t2 = { x: Vi(e20, "x", "acos") };
  return $i.runKernel(je, t2);
} });
var go = Wi({ acosh_(e20) {
  let t2 = { x: Vi(e20, "x", "acosh") };
  return $i.runKernel(Ge, t2);
} });
var vo = Wi({ addN_(e20) {
  Z(Array.isArray(e20), () => "The argument passed to tf.addN() must be a list of tensors"), Z(e20.length >= 1, () => "Must pass at least one tensor to tf.addN(), but got " + e20.length);
  let t2 = e20.map((e21, t3) => Vi(e21, "tensors" + t3, "addN")), n2 = t2[0];
  return t2.forEach((e21) => {
    if (e21.dtype !== n2.dtype) throw Error("All tensors passed to tf.addN() must have the same dtype");
  }), t2.forEach((e21) => {
    if (!te(e21.shape, n2.shape)) throw Error("All tensors passed to tf.addN() must have the same shape");
  }), $i.runKernel(Xe, t2);
} });
var wo = Wi({ all_(e20, t2 = null, n2 = false) {
  let r2 = { x: Vi(e20, "x", "all", "bool") };
  return $i.runKernel("All", r2, { axis: t2, keepDims: n2 });
} });
var ko = Wi({ any_(e20, t2 = null, n2 = false) {
  let r2 = { x: Vi(e20, "x", "any", "bool") };
  return $i.runKernel("Any", r2, { axis: t2, keepDims: n2 });
} });
var No = Wi({ argMax_(e20, t2 = 0) {
  let n2 = { x: Vi(e20, "x", "argMax") };
  return $i.runKernel(Ke, n2, { axis: t2 });
} });
var Co = Wi({ argMin_(e20, t2 = 0) {
  let n2 = { x: Vi(e20, "x", "argMin") };
  return $i.runKernel(Ye, n2, { axis: t2 });
} });
var $o = Wi({ asin_(e20) {
  let t2 = { x: Vi(e20, "x", "asin") };
  return $i.runKernel(Je, t2);
} });
var Ro = Wi({ asinh_(e20) {
  let t2 = { x: Vi(e20, "x", "asinh") };
  return $i.runKernel(Qe, t2);
} });
var So = Wi({ atan_(e20) {
  let t2 = { x: Vi(e20, "x", "atan") };
  return $i.runKernel(et, t2);
} });
var Io = Wi({ atan2_(e20, t2) {
  let n2 = Vi(e20, "a", "atan2"), r2 = Vi(t2, "b", "atan2");
  return [n2, r2] = xi(n2, r2), $i.runKernel(nt, { a: n2, b: r2 });
} });
var Eo = Wi({ atanh_(e20) {
  let t2 = { x: Vi(e20, "x", "atanh") };
  return $i.runKernel(tt, t2);
} });
function To(e20, t2, n2, r2, a2 = "NHWC", i2) {
  return Fo(e20, [...t2, e20[3]], n2, i2, r2, null, null, jo(a2));
}
function Mo(e20, t2, n2, r2, a2, i2, s2 = "channelsLast") {
  let o2, [l2, u2] = Vo(t2);
  if ("channelsLast" === s2) o2 = [l2, u2, e20[3], e20[3]];
  else {
    if ("channelsFirst" !== s2) throw Error("Unknown dataFormat " + s2);
    o2 = [l2, u2, e20[1], e20[1]];
  }
  return Fo(e20, o2, n2, r2, a2, i2, false, s2);
}
function Oo(e20, t2, n2, r2, a2, i2, s2 = "NDHWC") {
  let o2, l2, [u2, d2, c2] = _o(t2);
  if ("NDHWC" === s2) l2 = "channelsLast", o2 = [u2, d2, c2, e20[4], e20[4]];
  else {
    if ("NCDHW" !== s2) throw Error("Unknown dataFormat " + s2);
    l2 = "channelsFirst", o2 = [u2, d2, c2, e20[1], e20[1]];
  }
  return Po(e20, o2, n2, r2, a2, false, l2, i2);
}
function Fo(e20, t2, n2, r2, a2, i2, s2 = false, o2 = "channelsLast") {
  let [l2, u2, d2, c2] = [-1, -1, -1, -1];
  if ("channelsLast" === o2) [l2, u2, d2, c2] = e20;
  else {
    if ("channelsFirst" !== o2) throw Error("Unknown dataFormat " + o2);
    [l2, c2, u2, d2] = e20;
  }
  let h2, [p2, f2, , m2] = t2, [A2, x2] = Vo(n2), [y2, b2] = Vo(r2), g2 = Do(p2, y2), v2 = Do(f2, b2), { padInfo: w2, outHeight: k2, outWidth: N2 } = ((e21, t3, n3, r3, a3, i3, s3, o3, l3) => {
    let u3, d3, c3;
    if ("number" == typeof e21) {
      u3 = { top: e21, bottom: e21, left: e21, right: e21, type: 0 === e21 ? "VALID" : "NUMBER" };
      let a4 = ((e22, t4, n4, r4, a5) => {
        null == r4 && (r4 = zo(e22, t4, n4));
        let i4 = e22[1];
        return [Wo((e22[0] - t4 + 2 * r4) / n4 + 1, a5), Wo((i4 - t4 + 2 * r4) / n4 + 1, a5)];
      })([t3, n3], i3, r3, e21, o3);
      d3 = a4[0], c3 = a4[1];
    } else if ("same" === e21) {
      d3 = Math.ceil(t3 / r3), c3 = Math.ceil(n3 / a3);
      let e22 = Math.max(0, (d3 - 1) * r3 + i3 - t3), o4 = Math.max(0, (c3 - 1) * a3 + s3 - n3), l4 = Math.floor(e22 / 2), h3 = e22 - l4, p3 = Math.floor(o4 / 2);
      u3 = { top: l4, bottom: h3, left: p3, right: o4 - p3, type: "SAME" };
    } else if ("valid" === e21) u3 = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, d3 = Math.ceil((t3 - i3 + 1) / r3), c3 = Math.ceil((n3 - s3 + 1) / a3);
    else {
      if ("object" != typeof e21) throw Error("Unknown padding parameter: " + e21);
      {
        let h3 = "channelsLast" === l3 ? e21[1][0] : e21[2][0], p3 = "channelsLast" === l3 ? e21[1][1] : e21[2][1], f3 = "channelsLast" === l3 ? e21[2][0] : e21[3][0], m3 = "channelsLast" === l3 ? e21[2][1] : e21[3][1];
        u3 = { top: h3, bottom: p3, left: f3, right: m3, type: 0 === h3 && 0 === p3 && 0 === f3 && 0 === m3 ? "VALID" : "EXPLICIT" }, d3 = Wo((t3 - i3 + h3 + p3) / r3 + 1, o3), c3 = Wo((n3 - s3 + f3 + m3) / a3 + 1, o3);
      }
    }
    return { padInfo: u3, outHeight: d3, outWidth: c3 };
  })(a2, u2, d2, A2, x2, g2, v2, i2, o2), C2 = s2 ? m2 * c2 : m2;
  return "channelsFirst" === o2 ? h2 = [l2, C2, k2, N2] : "channelsLast" === o2 && (h2 = [l2, k2, N2, C2]), { batchSize: l2, dataFormat: o2, inHeight: u2, inWidth: d2, inChannels: c2, outHeight: k2, outWidth: N2, outChannels: C2, padInfo: w2, strideHeight: A2, strideWidth: x2, filterHeight: p2, filterWidth: f2, effectiveFilterHeight: g2, effectiveFilterWidth: v2, dilationHeight: y2, dilationWidth: b2, inShape: e20, outShape: h2, filterShape: t2 };
}
function Po(e20, t2, n2, r2, a2, i2 = false, s2 = "channelsLast", o2) {
  let [l2, u2, d2, c2, h2] = [-1, -1, -1, -1, -1];
  if ("channelsLast" === s2) [l2, u2, d2, c2, h2] = e20;
  else {
    if ("channelsFirst" !== s2) throw Error("Unknown dataFormat " + s2);
    [l2, h2, u2, d2, c2] = e20;
  }
  let p2, [f2, m2, A2, , x2] = t2, [y2, b2, g2] = _o(n2), [v2, w2, k2] = _o(r2), N2 = Do(f2, v2), C2 = Do(m2, w2), $2 = Do(A2, k2), { padInfo: R2, outDepth: S2, outHeight: I2, outWidth: E2 } = ((e21, t3, n3, r3, a3, i3, s3, o3, l3, u3, d3) => {
    let c3, h3, p3, f3;
    if ("valid" === e21 && (e21 = 0), "number" == typeof e21) {
      c3 = { top: e21, bottom: e21, left: e21, right: e21, front: e21, back: e21, type: 0 === e21 ? "VALID" : "NUMBER" };
      let m3 = ((e22, t4, n4, r4, a4, i4) => {
        null == a4 && (a4 = zo(e22, t4[0], r4[0]));
        let s4 = [0, 0, 0, 1];
        for (let o4 = 0; 3 > o4; o4++) e22[o4] + 2 * a4 >= t4[o4] && (s4[o4] = Wo((e22[o4] - t4[o4] + 2 * a4) / r4[o4] + 1, i4));
        return s4;
      })([t3, n3, r3, 1], [o3, l3, u3], 0, [a3, i3, s3], e21, d3);
      h3 = m3[0], p3 = m3[1], f3 = m3[2];
    } else {
      if ("same" !== e21) throw Error("Unknown padding parameter: " + e21);
      {
        h3 = Math.ceil(t3 / a3), p3 = Math.ceil(n3 / i3), f3 = Math.ceil(r3 / s3);
        let e22 = (h3 - 1) * a3 + o3 - t3, d4 = (p3 - 1) * i3 + l3 - n3, m3 = (f3 - 1) * s3 + u3 - r3, A3 = Math.floor(e22 / 2), x3 = e22 - A3, y3 = Math.floor(d4 / 2), b3 = d4 - y3, g3 = Math.floor(m3 / 2);
        c3 = { top: y3, bottom: b3, left: g3, right: m3 - g3, front: A3, back: x3, type: "SAME" };
      }
    }
    return { padInfo: c3, outDepth: h3, outHeight: p3, outWidth: f3 };
  })(a2, u2, d2, c2, y2, b2, g2, N2, C2, $2, o2), T2 = i2 ? x2 * h2 : x2;
  return "channelsFirst" === s2 ? p2 = [l2, T2, S2, I2, E2] : "channelsLast" === s2 && (p2 = [l2, S2, I2, E2, T2]), { batchSize: l2, dataFormat: s2, inDepth: u2, inHeight: d2, inWidth: c2, inChannels: h2, outDepth: S2, outHeight: I2, outWidth: E2, outChannels: T2, padInfo: R2, strideDepth: y2, strideHeight: b2, strideWidth: g2, filterDepth: f2, filterHeight: m2, filterWidth: A2, effectiveFilterDepth: N2, effectiveFilterHeight: C2, effectiveFilterWidth: $2, dilationDepth: v2, dilationHeight: w2, dilationWidth: k2, inShape: e20, outShape: p2, filterShape: t2 };
}
function zo(e20, t2, n2, r2 = 1) {
  let a2 = Do(t2, r2);
  return Math.floor((e20[0] * (n2 - 1) - n2 + a2) / 2);
}
function Vo(e20) {
  return "number" == typeof e20 ? [e20, e20, e20] : 2 === e20.length ? [e20[0], e20[1], 1] : e20;
}
function _o(e20) {
  return "number" == typeof e20 ? [e20, e20, e20] : e20;
}
function Do(e20, t2) {
  return t2 > 1 ? e20 + (e20 - 1) * (t2 - 1) : e20;
}
function Wo(e20, t2) {
  if (!t2) return Math.trunc(e20);
  switch (t2) {
    case "round":
      return Math.round(e20);
    case "ceil":
      return Math.ceil(e20);
    case "floor":
      return Math.floor(e20);
    default:
      throw Error("Unknown roundingMode " + t2);
  }
}
function Lo(e20) {
  let [t2, n2, r2] = Vo(e20);
  return 1 === t2 && 1 === n2 && 1 === r2;
}
function Bo(e20, t2) {
  return Lo(e20) || Lo(t2);
}
function Uo(e20) {
  return Vo(e20).every((e21) => e21 > 0);
}
function jo(e20) {
  if ("NHWC" === e20) return "channelsLast";
  if ("NCHW" === e20) return "channelsFirst";
  throw Error("Unknown dataFormat " + e20);
}
function Go(e20, t2, n2) {
  if (null != n2) {
    if ("string" == typeof t2) throw Error(`Error in ${e20}: pad must be an integer when using dimRoundingMode ${n2} but got pad ${t2}.`);
    if ("number" == typeof t2) Z(ne(t2), () => `Error in ${e20}: pad must be an integer when using dimRoundingMode ${n2} but got pad ${t2}.`);
    else {
      if ("object" != typeof t2) throw Error(`Error in ${e20}: Unknown padding parameter: ${t2}`);
      t2.forEach((t3) => {
        t3.forEach((t4) => {
          Z(ne(t4), () => `Error in ${e20}: pad must be an integer when using dimRoundingMode ${n2} but got pad ${t4}.`);
        });
      });
    }
  }
}
var Ho = Wi({ reshape_(e20, t2) {
  let n2 = { x: Vi(e20, "x", "reshape", "string_or_numeric") };
  return $i.runKernel(or, n2, { shape: t2 });
} });
var Xo = Wi({ avgPool_(e20, t2, n2, r2, a2) {
  let i2 = Vi(e20, "x", "avgPool", "float32");
  Z(Bo(n2, 1), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${n2} and dilations '1'`);
  let s2 = i2, o2 = false;
  3 === i2.rank && (o2 = true, s2 = Ho(i2, [1, i2.shape[0], i2.shape[1], i2.shape[2]])), Z(4 === s2.rank, () => `Error in avgPool: x must be rank 4 but got rank ${s2.rank}.`), Go("avgPool", r2, a2);
  let l2 = $i.runKernel(rt, { x: s2 }, { filterSize: t2, strides: n2, pad: r2, dimRoundingMode: a2 });
  return l2 = co(l2, i2.dtype), o2 ? Ho(l2, [l2.shape[1], l2.shape[2], l2.shape[3]]) : l2;
} });
var qo = Wi({ avgPool3d_(e20, t2, n2, r2, a2, i2 = "NDHWC") {
  let s2 = Vi(e20, "x", "avgPool3d", "float32"), o2 = s2, l2 = false;
  4 === s2.rank && (l2 = true, o2 = Ho(s2, [1, s2.shape[0], s2.shape[1], s2.shape[2], s2.shape[3]])), Z(5 === o2.rank, () => `Error in avgPool3d: x must be rank 5 but got rank ${o2.rank}.`), Z("NDHWC" === i2, () => "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + i2), Z("number" == typeof n2 && n2 > 0 || Array.isArray(n2) && n2[0] > 0 && n2[1] > 0 && n2[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${n2}'`), Go("avgPool3d", r2, a2);
  let u2 = $i.runKernel(it, { x: o2 }, { filterSize: t2, strides: n2, pad: r2, dimRoundingMode: a2, dataFormat: i2 });
  return u2 = co(u2, o2.dtype), l2 ? Ho(u2, [u2.shape[1], u2.shape[2], u2.shape[3], u2.shape[4]]) : u2;
} });
var Zo = Wi({ concat_(e20, t2 = 0) {
  Z(e20.length >= 1, () => "Pass at least one tensor to concat");
  let n2 = _i(e20, "tensors", "concat", "string_or_numeric");
  return "complex64" === n2[0].dtype && n2.forEach((e21) => {
    if ("complex64" !== e21.dtype) throw Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${e21.dtype}. `);
  }), 1 === n2.length ? ho(n2[0]) : $i.runKernel(yt, n2, { axis: t2 });
} });
var Ko = Wi({ matMul_(e20, t2, n2 = false, r2 = false) {
  let a2 = Vi(e20, "a", "matMul"), i2 = Vi(t2, "b", "matMul");
  return [a2, i2] = xi(a2, i2), $i.runKernel(ot, { a: a2, b: i2 }, { transposeA: n2, transposeB: r2 });
} });
var Yo = Wi({ sigmoid_(e20) {
  let t2 = { x: Vi(e20, "x", "sigmoid", "float32") };
  return $i.runKernel(Cr, t2);
} });
var Jo = Wi({ slice_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "slice", "string_or_numeric");
  if (0 === r2.rank) throw Error("Slicing scalar is not possible");
  return $i.runKernel(vr, { x: r2 }, { begin: t2, size: n2 });
} });
var Qo = Wi({ tanh_(e20) {
  let t2 = { x: Vi(e20, "x", "tanh", "float32") };
  return $i.runKernel(Hr, t2);
} });
var el = Wi({ basicLSTMCell_(e20, t2, n2, r2, a2, i2) {
  let s2 = Vi(e20, "forgetBias", "basicLSTMCell"), o2 = Vi(t2, "lstmKernel", "basicLSTMCell"), l2 = Vi(n2, "lstmBias", "basicLSTMCell"), u2 = Vi(r2, "data", "basicLSTMCell"), d2 = Vi(a2, "c", "basicLSTMCell"), c2 = Vi(i2, "h", "basicLSTMCell"), h2 = Zo([u2, c2], 1), p2 = Ko(h2, o2), f2 = fo(p2, l2), m2 = f2.shape[1] / 4, A2 = [f2.shape[0], m2], x2 = Jo(f2, [0, 0], A2), y2 = Jo(f2, [0, m2], A2), b2 = Jo(f2, [0, 2 * m2], A2), g2 = Jo(f2, [0, 3 * m2], A2), v2 = fo(xo(Yo(x2), Qo(y2)), xo(d2, Yo(fo(s2, b2))));
  return [v2, xo(Qo(v2), Yo(g2))];
} });
var tl = Wi({ batchToSpaceND_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "batchToSpaceND"), a2 = t2.reduce((e21, t3) => e21 * t3);
  return Z(r2.rank >= 1 + t2.length, () => `input rank is ${r2.rank} but should be > than blockShape.length ${t2.length}`), Z(n2.length === t2.length, () => `crops.length is ${n2.length} but should be equal to blockShape.length  ${t2.length}`), Z(r2.shape[0] % a2 === 0, () => `input tensor batch is ${r2.shape[0]} but is not divisible by the product of the elements of blockShape ${t2.join(" * ")} === ${a2}`), $i.runKernel(lt, { x: r2 }, { blockShape: t2, crops: n2 });
} });
function nl(e20) {
  let t2;
  return t2 = 0 === e20.rank || 1 === e20.rank ? Ho(e20, [1, 1, 1, e20.size]) : 2 === e20.rank ? Ho(e20, [1, 1, e20.shape[0], e20.shape[1]]) : 3 === e20.rank ? Ho(e20, [1, e20.shape[0], e20.shape[1], e20.shape[2]]) : e20, t2;
}
var rl = Wi({ batchNorm_(e20, t2, n2, r2, a2, i2) {
  null == i2 && (i2 = 1e-3);
  let s2, o2, l2 = Vi(e20, "x", "batchNorm"), u2 = Vi(t2, "mean", "batchNorm"), d2 = Vi(n2, "variance", "batchNorm");
  null != a2 && (s2 = Vi(a2, "scale", "batchNorm")), null != r2 && (o2 = Vi(r2, "offset", "batchNorm")), Z(u2.rank === d2.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), Z(null == o2 || u2.rank === o2.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), Z(null == s2 || u2.rank === s2.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  let c2 = { x: nl(l2), scale: s2, offset: o2, mean: u2, variance: d2 }, h2 = $i.runKernel(en, c2, { varianceEpsilon: i2 });
  return Ho(h2, l2.shape);
} });
var al = Wi({ batchNorm2d_(e20, t2, n2, r2, a2, i2) {
  let s2, o2, l2 = Vi(e20, "x", "batchNorm"), u2 = Vi(t2, "mean", "batchNorm"), d2 = Vi(n2, "variance", "batchNorm");
  return null != a2 && (s2 = Vi(a2, "scale", "batchNorm")), null != r2 && (o2 = Vi(r2, "offset", "batchNorm")), Z(2 === l2.rank, () => `Error in batchNorm2D: x must be rank 2 but got rank ${l2.rank}.`), Z(2 === u2.rank || 1 === u2.rank, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u2.rank}.`), Z(2 === d2.rank || 1 === d2.rank, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${d2.rank}.`), null != s2 && Z(2 === s2.rank || 1 === s2.rank, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${s2.rank}.`), null != o2 && Z(2 === o2.rank || 1 === o2.rank, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o2.rank}.`), rl(l2, u2, d2, o2, s2, i2);
} });
var il = Wi({ batchNorm3d_(e20, t2, n2, r2, a2, i2) {
  let s2, o2, l2 = Vi(e20, "x", "batchNorm"), u2 = Vi(t2, "mean", "batchNorm"), d2 = Vi(n2, "variance", "batchNorm");
  return null != a2 && (s2 = Vi(a2, "scale", "batchNorm")), null != r2 && (o2 = Vi(r2, "offset", "batchNorm")), Z(3 === l2.rank, () => `Error in batchNorm3D: x must be rank 3 but got rank ${l2.rank}.`), Z(3 === u2.rank || 1 === u2.rank, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u2.rank}.`), Z(3 === d2.rank || 1 === d2.rank, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${d2.rank}.`), null != s2 && Z(3 === s2.rank || 1 === s2.rank, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${s2.rank}.`), null != o2 && Z(3 === o2.rank || 1 === o2.rank, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o2.rank}.`), rl(l2, u2, d2, o2, s2, i2);
} });
var sl = Wi({ batchNorm4d_(e20, t2, n2, r2, a2, i2) {
  let s2, o2, l2 = Vi(e20, "x", "batchNorm"), u2 = Vi(t2, "mean", "batchNorm"), d2 = Vi(n2, "variance", "batchNorm");
  return null != a2 && (s2 = Vi(a2, "scale", "batchNorm")), null != r2 && (o2 = Vi(r2, "offset", "batchNorm")), Z(4 === l2.rank, () => `Error in batchNorm4D: x must be rank 4 but got rank ${l2.rank}.`), Z(4 === u2.rank || 1 === u2.rank, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u2.rank}.`), Z(4 === d2.rank || 1 === d2.rank, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${d2.rank}.`), null != s2 && Z(4 === s2.rank || 1 === s2.rank, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${s2.rank}.`), null != o2 && Z(4 === o2.rank || 1 === o2.rank, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o2.rank}.`), rl(l2, u2, d2, o2, s2, i2);
} });
var ol = Wi({ bincount_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "bincount"), a2 = Vi(t2, "weights", "bincount");
  return Z("int32" === r2.dtype, () => "Error in bincount: input dtype must be int32, but got " + r2.dtype), Z(n2 >= 0, () => `size must be non-negative, but got ${n2}.`), Z(a2.size === r2.size || 0 === a2.size, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r2.shape}, weights shape: ${a2.shape}.`), $i.runKernel(ut, { x: r2, weights: a2 }, { size: n2 });
} });
var ll = Wi({ bitwiseAnd_(e20, t2) {
  let n2 = Vi(e20, "x", "bitwiseAnd"), r2 = Vi(t2, "y", "bitwiseAnd");
  if (!te(n2.shape, r2.shape)) throw Error(`BitwiseAnd: Tensors must have the same shape. x: ${n2.shape}, y: ${r2.shape}`);
  if ("int32" !== n2.dtype || "int32" !== r2.dtype) throw Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n2.dtype} and type of y: ${r2.dtype}`);
  return $i.runKernel(dt, { a: n2, b: r2 });
} });
var ul = Wi({ broadcastArgs_(e20, t2) {
  let n2 = Vi(e20, "s0", "broadcastArgs", "int32"), r2 = Vi(t2, "s1", "broadcastArgs", "int32");
  if (1 !== n2.rank) throw Error("broadcastArgs(): first input must be a vector (rank=1). Has rank " + n2.rank);
  if (1 !== r2.rank) throw Error("broadcastArgs(): second input must be a vector (rank=1). Has rank " + r2.rank);
  return $i.runKernel(ht, { s0: n2, s1: r2 });
} });
var dl = Wi({ broadcastTo_(e20, t2) {
  let n2 = Vi(e20, "broadcastTo", "x"), r2 = n2.shape;
  if (Te(t2), n2.rank > t2.length) throw Error(`broadcastTo(): shape.length=${t2.length} < input.rank=${n2.rank}.`);
  if (t2.length > n2.rank) {
    let e21 = n2.shape.slice();
    for (; t2.length > e21.length; ) e21.unshift(1);
    n2 = Ho(n2, e21);
  }
  let a2 = n2.shape, i2 = Array.from(t2);
  for (let s2 = t2.length - 1; s2 >= 0; s2--) if (a2[s2] === t2[s2]) i2[s2] = 1;
  else if (1 !== n2.shape[s2]) throw Error(`broadcastTo(): [${r2}] cannot be broadcast to [${t2}].`);
  return 0 === i2.map((e21, t3) => e21 > 1 ? t3 : -1).filter((e21) => e21 >= 0).length ? ho(n2) : $i.runKernel(Xr, { x: n2 }, { reps: i2 });
} });
var cl = Wi({ ceil_(e20) {
  let t2 = { x: Vi(e20, "x", "ceil", "float32") };
  return $i.runKernel(ft, t2);
} });
function hl(e20, t2, n2) {
  return Te(e20), n2 = n2 || ve(t2), $i.runKernel(Kt, {}, { shape: e20, value: t2, dtype: n2 });
}
var pl = Wi({ clipByValue_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "clipByValue");
  return Z(n2 >= t2, () => `Error in clip: min (${t2}) must be less than or equal to max (${n2}).`), t2 === n2 ? hl(r2.shape, t2, r2.dtype) : $i.runKernel(mt, { x: r2 }, { clipValueMin: t2, clipValueMax: n2 });
} });
var fl = Wi({ concat1d_(e20) {
  return Zo(e20, 0);
} });
var ml = Wi({ concat2d_(e20, t2) {
  return Zo(e20, t2);
} });
var Al = Wi({ concat3d_(e20, t2) {
  return Zo(e20, t2);
} });
var xl = Wi({ concat4d_(e20, t2) {
  return Zo(e20, t2);
} });
var yl = Wi({ conv2d_(e20, t2, n2, r2, a2 = "NHWC", i2 = [1, 1], s2) {
  let o2 = Vi(e20, "x", "conv2d", "float32"), l2 = Vi(t2, "filter", "conv2d", "float32"), u2 = o2, d2 = false;
  3 === o2.rank && (d2 = true, u2 = Ho(o2, [1, o2.shape[0], o2.shape[1], o2.shape[2]])), Z(4 === u2.rank, () => `Error in conv2d: input must be rank 4, but got rank ${u2.rank}.`), Z(4 === l2.rank, () => `Error in conv2d: filter must be rank 4, but got rank ${l2.rank}.`), Go("conv2d", r2, s2);
  let c2 = "NHWC" === a2 ? u2.shape[3] : u2.shape[1];
  Z(c2 === l2.shape[2], () => `Error in conv2d: depth of input (${c2}) must match input depth for filter ${l2.shape[2]}.`), Z(Bo(n2, i2), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n2} and dilations '${i2}'`), Z(Uo(i2), () => "Error in conv2D: Dilated rates should be larger than 0."), Z(Uo(n2), () => "Error in conv2D: Strides should be larger than 0.");
  let h2 = $i.runKernel(bt, { x: u2, filter: l2 }, { strides: n2, pad: r2, dataFormat: a2, dilations: i2, dimRoundingMode: s2 });
  return d2 ? Ho(h2, [h2.shape[1], h2.shape[2], h2.shape[3]]) : h2;
} });
var bl = Wi({ conv1d_(e20, t2, n2, r2, a2 = "NWC", i2 = 1, s2) {
  let o2 = Vi(e20, "x", "conv1d"), l2 = Vi(t2, "filter", "conv1d"), u2 = o2, d2 = false;
  2 === o2.rank && (d2 = true, u2 = Ho(o2, [1, o2.shape[0], o2.shape[1]])), Z(3 === u2.rank, () => `Error in conv1d: input must be rank 3, but got rank ${u2.rank}.`), Z(3 === l2.rank, () => `Error in conv1d: filter must be rank 3, but got rank ${l2.rank}.`), Go("conv1d", r2, s2), Z(u2.shape[2] === l2.shape[1], () => `Error in conv1d: depth of input (${u2.shape[2]}) must match input depth for filter ${l2.shape[1]}.`), Z(Bo(n2, i2), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${n2} and dilation '${i2}'`), Z(Uo(i2), () => "Error in conv1D: Dilated rates should be larger than 0."), Z(Uo(n2), () => "Error in conv1D: Stride should be larger than 0."), Z("NWC" === a2, () => `Error in conv1d: got dataFormat of ${a2} but only NWC is currently supported.`);
  let c2 = Ho(l2, [1, l2.shape[0], l2.shape[1], l2.shape[2]]), h2 = Ho(u2, [u2.shape[0], 1, u2.shape[1], u2.shape[2]]), p2 = yl(h2, c2, [1, n2], r2, "NHWC", [1, i2], s2);
  return Ho(p2, d2 ? [p2.shape[2], p2.shape[3]] : [p2.shape[0], p2.shape[2], p2.shape[3]]);
} });
var gl = Wi({ conv2DBackpropInput_(e20, t2, n2, r2, a2, i2 = "NHWC", s2) {
  Z(e20.length === t2.rank, () => `Length of inShape (${e20.length}) and rank of dy (${t2.rank}) must match`);
  let o2 = e20, l2 = t2, u2 = false;
  3 === t2.rank && (u2 = true, l2 = Ho(t2, [1, t2.shape[0], t2.shape[1], t2.shape[2]]), o2 = [1, e20[0], e20[1], e20[2]]), Z(4 === o2.length, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${o2.length}.`), Z(4 === l2.rank, () => "Error in conv2dDerInput: dy must be rank 4, but got rank " + l2.rank), Z(4 === n2.rank, () => "Error in conv2dDerInput: filter must be rank 4, but got rank " + n2.rank);
  let d2 = "NHWC" === i2 ? o2[3] : o2[1], c2 = "NHWC" === i2 ? l2.shape[3] : l2.shape[1];
  Z(d2 === n2.shape[2], () => `Error in conv2dDerInput: depth of input (${d2}) must match input depth for filter ${n2.shape[2]}.`), Z(c2 === n2.shape[3], () => `Error in conv2dDerInput: depth of output (${c2}) must match output depth for filter ${n2.shape[3]}.`), Go("conv2dDerInput", a2, s2);
  let h2 = $i.runKernel(vt, { dy: l2, filter: n2 }, { strides: r2, pad: a2, dataFormat: i2, dimRoundingMode: s2, inputShape: o2 });
  return u2 ? Ho(h2, [h2.shape[1], h2.shape[2], h2.shape[3]]) : h2;
} });
var vl = Wi({ conv2dTranspose_(e20, t2, n2, r2, a2, i2) {
  let s2 = Vi(e20, "x", "conv2dTranspose"), o2 = Vi(t2, "filter", "conv2dTranspose");
  return gl(n2, s2, o2, r2, a2, "NHWC", i2);
} });
var wl = Wi({ conv3d_(e20, t2, n2, r2, a2 = "NDHWC", i2 = [1, 1, 1]) {
  let s2 = Vi(e20, "x", "conv3d"), o2 = Vi(t2, "filter", "conv3d"), l2 = s2, u2 = false;
  4 === s2.rank && (u2 = true, l2 = Ho(s2, [1, s2.shape[0], s2.shape[1], s2.shape[2], s2.shape[3]])), Z(5 === l2.rank, () => `Error in conv3d: input must be rank 5, but got rank ${l2.rank}.`), Z(5 === o2.rank, () => `Error in conv3d: filter must be rank 5, but got rank ${o2.rank}.`), Z(l2.shape[4] === o2.shape[3], () => `Error in conv3d: depth of input (${l2.shape[4]}) must match input depth for filter ${o2.shape[3]}.`), Z(Bo(n2, i2), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${n2} and dilations '${i2}'`), Z("NDHWC" === a2, () => `Error in conv3d: got dataFormat of ${a2} but only NDHWC is currently supported.`), Z(Uo(i2), () => "Error in conv3D: Dilated rates should be larger than 0."), Z(Uo(n2), () => "Error in conv3D: Strides should be larger than 0.");
  let d2 = $i.runKernel(wt, { x: l2, filter: o2 }, { strides: n2, pad: r2, dataFormat: a2, dilations: i2 });
  return u2 ? Ho(d2, [d2.shape[1], d2.shape[2], d2.shape[3], d2.shape[4]]) : d2;
} });
var kl = Wi({ conv3DBackpropInput_(e20, t2, n2, r2, a2) {
  Z(e20.length === t2.rank, () => `Length of inShape (${e20.length}) and rank of dy (${t2.rank}) must match`);
  let i2 = e20, s2 = t2, o2 = false;
  4 === t2.rank && (o2 = true, s2 = Ho(t2, [1, t2.shape[0], t2.shape[1], t2.shape[2], t2.shape[3]]), i2 = [1, e20[0], e20[1], e20[2], e20[3]]);
  let l2 = i2[4], u2 = s2.shape[4];
  Z(5 === i2.length, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${i2.length}.`), Z(5 === s2.rank, () => "Error in conv3dDerInput: dy must be rank 5, but got rank " + s2.rank), Z(5 === n2.rank, () => "Error in conv3dDerInput: filter must be rank 5, but got rank " + n2.rank), Z(l2 === n2.shape[3], () => `Error in conv3dDerInput: depth of input (${l2}) must match input depth for filter ${n2.shape[3]}.`), Z(u2 === n2.shape[4], () => `Error in conv3dDerInput: depth of output (${u2}) must match output depth for filter ${n2.shape[4]}.`);
  let d2 = $i.runKernel(Nt, { dy: s2, filter: n2 }, { pad: a2, strides: r2, inputShape: i2 });
  return o2 ? Ho(d2, [d2.shape[1], d2.shape[2], d2.shape[3], d2.shape[4]]) : d2;
} });
var Nl = Wi({ conv3dTranspose_(e20, t2, n2, r2, a2) {
  let i2 = Vi(e20, "x", "conv3dTranspose"), s2 = Vi(t2, "filter", "conv3dTranspose");
  return kl(n2, i2, s2, r2, a2);
} });
var Cl = Wi({ cos_(e20) {
  let t2 = { x: Vi(e20, "x", "cos", "float32") };
  return $i.runKernel("Cos", t2);
} });
var $l = Wi({ cosh_(e20) {
  let t2 = { x: Vi(e20, "x", "cosh", "float32") };
  return $i.runKernel($t, t2);
} });
var Rl = Wi({ cumprod_(e20, t2 = 0, n2 = false, r2 = false) {
  let a2 = { x: Vi(e20, "x", "cumprod") };
  return $i.runKernel(Rt, a2, { axis: t2, exclusive: n2, reverse: r2 });
} });
var Sl = Wi({ cumsum_(e20, t2 = 0, n2 = false, r2 = false) {
  let a2 = { x: Vi(e20, "x", "cumsum") };
  return $i.runKernel(St, a2, { axis: t2, exclusive: n2, reverse: r2 });
} });
var Il = Wi({ denseBincount_(e20, t2, n2, r2 = false) {
  let a2 = Vi(e20, "x", "denseBincount"), i2 = Vi(t2, "weights", "denseBincount");
  return Z("int32" === a2.dtype, () => "Error in denseBincount: input dtype must be int32, but got " + a2.dtype), Z(2 >= a2.rank, () => `Error in denseBincount: input must be at most rank 2, but got rank ${a2.rank}.`), Z(n2 >= 0, () => `size must be non-negative, but got ${n2}.`), Z(i2.size === a2.size || 0 === i2.size, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a2.shape}, weights shape: ${i2.shape}.`), $i.runKernel(Et, { x: a2, weights: i2 }, { size: n2, binaryOutput: r2 });
} });
var El = Wi({ depthToSpace_(e20, t2, n2 = "NHWC") {
  let r2 = Vi(e20, "x", "depthToSpace", "float32"), a2 = "NHWC" === n2 ? r2.shape[1] : r2.shape[2], i2 = "NHWC" === n2 ? r2.shape[2] : r2.shape[3], s2 = "NHWC" === n2 ? r2.shape[3] : r2.shape[1];
  return Z(t2 > 1, () => "blockSize should be > 1 for depthToSpace, but was: " + t2), Z(a2 * t2 >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${a2} and ${t2}  for depthToSpace with input shape
    ${r2.shape}`), Z(i2 * t2 >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${i2} and ${t2} for depthToSpace with input shape
        ${r2.shape}`), Z(s2 % (t2 * t2) === 0, () => `Dimension size must be evenly divisible by ${t2 * t2} but is ${s2} for depthToSpace with input shape ${r2.shape}`), $i.runKernel(Tt, { x: r2 }, { blockSize: t2, dataFormat: n2 });
} });
var Tl = Wi({ depthwiseConv2d_(e20, t2, n2, r2, a2 = "NHWC", i2 = [1, 1], s2) {
  let o2 = Vi(e20, "x", "depthwiseConv2d", "float32"), l2 = Vi(t2, "filter", "depthwiseConv2d", "float32"), u2 = o2, d2 = false;
  3 === o2.rank && (d2 = true, u2 = Ho(o2, [1, o2.shape[0], o2.shape[1], o2.shape[2]])), Z(4 === u2.rank, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${u2.rank}.`), Z(4 === l2.rank, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${l2.rank}.`);
  let c2 = "NHWC" === a2 ? u2.shape[3] : u2.shape[1];
  Z(c2 === l2.shape[2], () => `Error in depthwiseConv2d: number of input channels (${c2}) must match the inChannels dimension in filter ${l2.shape[2]}.`), Go("depthwiseConv2d", r2, s2);
  let h2 = $i.runKernel(Mt, { x: u2, filter: l2 }, { strides: n2, pad: r2, dataFormat: a2, dilations: i2, dimRoundingMode: s2 });
  return d2 ? Ho(h2, [h2.shape[1], h2.shape[2], h2.shape[3]]) : h2;
} });
var Ml = Wi({ diag_(e20) {
  let t2 = { x: Vi(e20, "x", "diag") };
  return $i.runKernel(Pt, t2);
} });
var Ol = Wi({ dilation2d_(e20, t2, n2, r2, a2 = [1, 1], i2 = "NHWC") {
  let s2 = Vi(e20, "x", "dilation2d"), o2 = Vi(t2, "filter", "dilation2d");
  Z(3 === s2.rank || 4 === s2.rank, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${s2.rank}.`), Z(3 === o2.rank, () => `Error in dilation2d: filter must be rank 3, but got rank ${o2.rank}.`), Z("NHWC" === i2, () => "Error in dilation2d: Only NHWC is currently supported, but got dataFormat of " + i2);
  let l2 = s2, u2 = false;
  3 === s2.rank && (l2 = Ho(s2, [1, s2.shape[0], s2.shape[1], s2.shape[2]]), u2 = true), Z(l2.shape[3] === o2.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${l2.shape[3]} vs ${o2.shape[2]}`);
  let d2 = $i.runKernel(zt, { x: l2, filter: o2 }, { strides: n2, pad: r2, dilations: a2 });
  return u2 ? Ho(d2, [d2.shape[1], d2.shape[2], d2.shape[3]]) : d2;
} });
var Fl = {};
function Pl(e20, t2) {
  let n2 = e20.length, r2 = [];
  for (let a2 = 0; n2 > a2; a2++) {
    let i2 = n2 - 1 - a2;
    (t2[t2.length - 1 - a2] || 1) > 1 && 1 === (e20[i2] || 1) && r2.unshift(i2);
  }
  return r2;
}
function zl(e20, t2) {
  let n2 = [];
  for (let r2 = 0; t2.length > r2; r2++) {
    let a2 = e20[e20.length - r2 - 1], i2 = t2.length - r2 - 1;
    (null == a2 || 1 === a2 && t2[i2] > 1) && n2.unshift(i2);
  }
  return n2;
}
function Vl(e20, t2) {
  let n2 = Math.max(e20.length, t2.length), r2 = Array(n2);
  for (let a2 = 0; n2 > a2; a2++) {
    let i2 = e20[e20.length - a2 - 1];
    null == i2 && (i2 = 1);
    let s2 = t2[t2.length - a2 - 1];
    if (null == s2 && (s2 = 1), 1 === i2) r2[n2 - a2 - 1] = s2;
    else if (1 === s2) r2[n2 - a2 - 1] = i2;
    else {
      if (i2 !== s2) throw Error(`Operands could not be broadcast together with shapes ${e20} and ${t2}.`);
      r2[n2 - a2 - 1] = i2;
    }
  }
  return r2;
}
A(Fl, { assertAndGetBroadcastShape() {
  return Vl;
}, getBroadcastDims() {
  return Pl;
}, getReductionAxes() {
  return zl;
} });
var _l = Wi({ equal_(e20, t2) {
  let n2 = Vi(e20, "a", "equal", "string_or_numeric"), r2 = Vi(t2, "b", "equal", "string_or_numeric");
  return [n2, r2] = xi(n2, r2), Vl(n2.shape, r2.shape), $i.runKernel(Gt, { a: n2, b: r2 });
} });
var Dl = Wi({ where_(e20, t2, n2) {
  let r2 = Vi(t2, "a", "where"), a2 = Vi(n2, "b", "where"), i2 = Vi(e20, "condition", "where", "bool"), s2 = Vl(Vl(i2.shape, r2.shape), a2.shape), o2 = dl(i2, s2), l2 = dl(r2, s2), u2 = dl(a2, s2);
  return $i.runKernel(br, { condition: o2, t: l2, e: u2 });
} });
var Wl = Wi({ zerosLike_(e20) {
  let t2 = { x: Vi(e20, "x", "zerosLike") };
  return $i.runKernel(ta, t2);
} });
var Ll = Wi({ divNoNan_(e20, t2) {
  let n2 = Vi(e20, "a", "div"), r2 = Vi(t2, "b", "div");
  [n2, r2] = xi(n2, r2);
  let a2 = Ao(n2, r2), i2 = Wl(a2), s2 = _l(r2, i2);
  return Dl(s2, i2, a2);
} });
var Bl = Wi({ dot_(e20, t2) {
  let n2 = Vi(e20, "t1", "dot"), r2 = Vi(t2, "t2", "dot");
  Z(!(1 !== n2.rank && 2 !== n2.rank || 1 !== r2.rank && 2 !== r2.rank), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${n2.rank} and ${r2.rank}.`);
  let a2 = 1 === n2.rank ? n2.size : n2.shape[1], i2 = 1 === r2.rank ? r2.size : r2.shape[0];
  if (Z(a2 === i2, () => `Error in dot: inner dimensions of inputs must match, but got ${a2} and ${i2}.`), 1 === n2.rank && 1 === r2.rank) {
    let e21 = Ho(n2, [1, -1]), t3 = Ho(r2, [-1, 1]), a3 = Ko(e21, t3);
    return Ho(a3, []);
  }
  if (1 === n2.rank && 2 === r2.rank) {
    let e21 = Ho(n2, [1, -1]), t3 = Ho(r2, [r2.shape[0], r2.shape[1]]), a3 = Ko(e21, t3);
    return Ho(a3, [a3.size]);
  }
  if (2 === n2.rank && 1 === r2.rank) {
    let e21 = Ho(r2, [-1, 1]), t3 = Ko(n2, e21);
    return Ho(t3, [t3.size]);
  }
  {
    let e21 = Ho(r2, [r2.shape[0], r2.shape[1]]);
    return Ko(n2, e21);
  }
} });
var Ul = Wi({ einsum_(e20, ...t2) {
  let n2 = t2.map((e21, t3) => Vi(e21, "tensors" + t3, "einsum"));
  return $i.runKernel(Lt, n2, { equation: e20 });
} });
var jl = Wi({ elu_(e20) {
  let t2 = { x: Vi(e20, "x", "elu", "float32") };
  return $i.runKernel("Elu", t2);
} });
var Gl = Wi({ ensureShape_(e20, t2) {
  let n2 = Vi(e20, "x", "ensureShape", "string_or_numeric");
  if (!ee(n2.shape, t2)) throw Error(`EnsureShape: Shape of tensor ${n2.shape} is not compatible with expected shape ${t2}`);
  return e20;
} });
var Hl = Wi({ erf_(e20) {
  let t2 = Vi(e20, "x", "erf");
  return Z("int32" === t2.dtype || "float32" === t2.dtype, () => "Input dtype must be `int32` or `float32`."), "int32" === t2.dtype && (t2 = co(t2, "float32")), $i.runKernel("Erf", { x: t2 });
} });
function Xl(e20, t2) {
  for (let n2 = 0; e20.length > n2; ++n2) if (e20[e20.length - n2 - 1] !== t2 - 1 - n2) return false;
  return true;
}
function ql(e20, t2, n2) {
  let r2 = e20.length + t2.length, a2 = [], i2 = 0, s2 = 0;
  for (let o2 = 0; r2 > o2; o2++) -1 === n2.indexOf(o2) ? a2.push(e20[i2++]) : a2.push(t2[s2++]);
  return a2;
}
function Zl(e20, t2) {
  let n2 = [], r2 = e20.length;
  for (let a2 = 0; r2 > a2; a2++) -1 === t2.indexOf(a2) && n2.push(e20[a2]);
  return [n2, t2.map((t3) => e20[t3])];
}
function Kl(e20, t2) {
  return ql(e20, t2.map((e21) => 1), t2);
}
function Yl(e20, t2, n2) {
  Z(Xl(t2, n2), () => `${e20} supports only inner-most axes for now. Got axes ${t2} and rank-${n2} input.`);
}
function Jl(e20, t2) {
  if (Xl(e20, t2)) return null;
  let n2 = [];
  for (let r2 = 0; t2 > r2; ++r2) -1 === e20.indexOf(r2) && n2.push(r2);
  return e20.forEach((e21) => n2.push(e21)), n2;
}
function Ql(e20) {
  return e20.map((e21, t2) => [t2, e21]).sort((e21, t2) => e21[1] - t2[1]).map((e21) => e21[0]);
}
function eu(e20, t2) {
  let n2 = [];
  for (let r2 = t2 - e20; t2 > r2; ++r2) n2.push(r2);
  return n2;
}
var tu = Wi({ max_(e20, t2 = null, n2 = false) {
  let r2 = { x: Vi(e20, "x", "max") };
  return $i.runKernel("Max", r2, { reductionIndices: t2, keepDims: n2 });
} });
var nu = Wi({ min_(e20, t2 = null, n2 = false) {
  let r2 = { x: Vi(e20, "x", "min") };
  return $i.runKernel("Min", r2, { axis: t2, keepDims: n2 });
} });
var ru = Wi({ pow_(e20, t2) {
  let n2 = Vi(e20, "base", "pow"), r2 = Vi(t2, "exp", "pow");
  return [n2, r2] = xi(n2, r2), $i.runKernel("Pow", { a: n2, b: r2 });
} });
function au(e20, t2) {
  if ((Ua(e20) && "string" !== t2 || Array.isArray(e20)) && "complex64" !== t2) throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === t2 && Ua(e20) && !(e20 instanceof Uint8Array)) throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Bi(e20, [], [], t2);
}
var iu = Wi({ sqrt_(e20) {
  let t2 = { x: Vi(e20, "x", "sqrt", "float32") };
  return $i.runKernel(Rr, t2);
} });
var su = Wi({ square_(e20) {
  let t2 = Vi(e20, "x", "square");
  return $i.runKernel("Square", { x: t2 }, {});
} });
var ou = Wi({ sum_(e20, t2 = null, n2 = false) {
  let r2 = Vi(e20, "x", "sum");
  return "bool" === r2.dtype && (r2 = co(r2, "int32")), $i.runKernel("Sum", { x: r2 }, { axis: t2, keepDims: n2 });
} });
function lu(e20, t2, n2 = null) {
  if (0 === e20.rank) return yo(e20);
  if (1 !== e20.rank && null === n2) return lu(Ho(e20, [-1]), t2, n2);
  if (1 === e20.rank || "number" == typeof n2 || Array.isArray(n2) && 1 === n2.length) {
    if (1 === t2) return ou(yo(e20), n2);
    if (t2 === 1 / 0) return tu(yo(e20), n2);
    if (t2 === -1 / 0) return nu(yo(e20), n2);
    if ("euclidean" === t2 || 2 === t2) return iu(ou(ru(yo(e20), au(2, "int32")), n2));
    throw Error("Error in norm: invalid ord value: " + t2);
  }
  if (Array.isArray(n2) && 2 === n2.length) {
    if (1 === t2) return tu(ou(yo(e20), n2[0]), n2[1] - 1);
    if (t2 === 1 / 0) return tu(ou(yo(e20), n2[1]), n2[0]);
    if (t2 === -1 / 0) return nu(ou(yo(e20), n2[1]), n2[0]);
    if ("fro" === t2 || "euclidean" === t2) return iu(ou(su(e20), n2));
    throw Error("Error in norm: invalid ord value: " + t2);
  }
  throw Error("Error in norm: invalid axis: " + n2);
}
var uu = Wi({ norm_(e20, t2 = "euclidean", n2 = null, r2 = false) {
  let a2 = lu(e20 = Vi(e20, "x", "norm"), t2, n2), i2 = a2.shape;
  if (r2) {
    let t3 = ue(n2, e20.shape);
    i2 = Kl(a2.shape, t3);
  }
  return Ho(a2, i2);
} });
var du = Wi({ euclideanNorm_(e20, t2 = null, n2 = false) {
  return uu(e20, "euclidean", t2, n2);
} });
var cu = Wi({ exp_(e20) {
  let t2 = { x: Vi(e20, "x", "exp") };
  return $i.runKernel("Exp", t2);
} });
var hu = Wi({ expandDims_(e20, t2 = 0) {
  let n2 = Vi(e20, "x", "expandDims", "string_or_numeric");
  return Z(n2.rank >= t2, () => "Axis must be <= rank of the tensor"), $i.runKernel(Xt, { input: n2 }, { dim: t2 });
} });
var pu = Wi({ expm1_(e20) {
  let t2 = { x: Vi(e20, "x", "expm1") };
  return $i.runKernel(qt, t2);
} });
var fu = Wi({ tile_(e20, t2) {
  let n2 = Vi(e20, "x", "tile", "string_or_numeric");
  return Z(n2.rank === t2.length, () => `Error in transpose: rank of input ${n2.rank} must match length of reps ${t2}.`), $i.runKernel(Xr, { x: n2 }, { reps: t2 });
} });
var mu = Wi({ eye_(e20, t2, n2, r2 = "float32") {
  null == t2 && (t2 = e20);
  let a2 = uo([e20, t2], r2), i2 = e20 > t2 ? t2 : e20;
  for (let o2 = 0; i2 > o2; ++o2) a2.set(1, o2, o2);
  let s2 = Ho(a2.toTensor(), [e20, t2]);
  if (null == n2) return s2;
  if (1 === n2.length) return fu(hu(s2, 0), [n2[0], 1, 1]);
  if (2 === n2.length) return fu(hu(hu(s2, 0), 0), [n2[0], n2[1], 1, 1]);
  if (3 === n2.length) return fu(hu(hu(hu(s2, 0), 0), 0), [n2[0], n2[1], n2[2], 1, 1]);
  throw Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n2.length}D.`);
} });
var Au = Wi({ floor_(e20) {
  let t2 = { x: Vi(e20, "x", "floor", "float32") };
  return $i.runKernel(Jt, t2);
} });
var xu = Wi({ gather_(e20, t2, n2 = 0, r2 = 0) {
  let a2 = Vi(e20, "x", "gather"), i2 = Vi(t2, "indices", "gather", "int32");
  return $i.runKernel(tn, { x: a2, indices: i2 }, { axis: n2, batchDims: r2 });
} });
var yu = Wi({ greater_(e20, t2) {
  let n2 = Vi(e20, "a", "greater", "string_or_numeric"), r2 = Vi(t2, "b", "greater", "string_or_numeric");
  return [n2, r2] = xi(n2, r2), Vl(n2.shape, r2.shape), $i.runKernel(rn, { a: n2, b: r2 });
} });
var bu = Wi({ greaterEqual_(e20, t2) {
  let n2 = Vi(e20, "a", "greaterEqual", "string_or_numeric"), r2 = Vi(t2, "b", "greaterEqual", "string_or_numeric");
  return [n2, r2] = xi(n2, r2), Vl(n2.shape, r2.shape), $i.runKernel(an, { a: n2, b: r2 });
} });
var gu = Wi({ imag_(e20) {
  let t2 = { input: Vi(e20, "input", "imag") };
  return $i.runKernel(ln, t2);
} });
var vu = Wi({ isFinite_(e20) {
  let t2 = { x: Vi(e20, "x", "isFinite") };
  return $i.runKernel(un, t2);
} });
var wu = Wi({ isInf_(e20) {
  let t2 = { x: Vi(e20, "x", "isInf") };
  return $i.runKernel(dn, t2);
} });
var ku = Wi({ isNaN_(e20) {
  let t2 = { x: Vi(e20, "x", "isNaN") };
  return $i.runKernel(cn, t2);
} });
var Nu = Wi({ leakyRelu_(e20, t2 = 0.2) {
  let n2 = { x: Vi(e20, "x", "leakyRelu") };
  return $i.runKernel(hn, n2, { alpha: t2 });
} });
var Cu = Wi({ less_(e20, t2) {
  let n2 = Vi(e20, "a", "less", "string_or_numeric"), r2 = Vi(t2, "b", "less", "string_or_numeric");
  return [n2, r2] = xi(n2, r2), Vl(n2.shape, r2.shape), $i.runKernel(pn, { a: n2, b: r2 });
} });
var $u = Wi({ lessEqual_(e20, t2) {
  let n2 = Vi(e20, "a", "lessEqual", "string_or_numeric"), r2 = Vi(t2, "b", "lessEqual", "string_or_numeric");
  return [n2, r2] = xi(n2, r2), Vl(n2.shape, r2.shape), $i.runKernel(fn, { a: n2, b: r2 });
} });
function Ru(e20, t2, n2) {
  if (0 >= n2) throw Error("The number of values should be positive.");
  return $i.runKernel(mn, {}, { start: e20, stop: t2, num: n2 });
}
var Su = Wi({ localResponseNormalization_(e20, t2 = 5, n2 = 1, r2 = 1, a2 = 0.5) {
  let i2 = Vi(e20, "x", "localResponseNormalization");
  Z(4 === i2.rank || 3 === i2.rank, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i2.rank}.`), Z(ne(t2), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t2}.`);
  let s2 = i2, o2 = false;
  3 === i2.rank && (o2 = true, s2 = Ho(i2, [1, i2.shape[0], i2.shape[1], i2.shape[2]]));
  let l2 = $i.runKernel("LRN", { x: s2 }, { depthRadius: t2, bias: n2, alpha: r2, beta: a2 });
  return o2 ? Ho(l2, [l2.shape[1], l2.shape[2], l2.shape[3]]) : l2;
} });
var Iu = Wi({ log_(e20) {
  let t2 = { x: Vi(e20, "x", "log", "float32") };
  return $i.runKernel("Log", t2);
} });
var Eu = Wi({ log1p_(e20) {
  let t2 = { x: Vi(e20, "x", "log1p") };
  return $i.runKernel(xn, t2);
} });
function Tu(e20) {
  return Z(we(e20), () => "The f passed in grad(f) must be a function"), (t2, n2) => {
    let r2 = Vi(t2, "x", "tf.grad", "string_or_numeric"), a2 = null != n2 ? Vi(n2, "dy", "tf.grad") : null;
    return $i.tidy(() => {
      let { value: t3, grads: n3 } = $i.gradients(() => e20(r2), [r2], a2);
      return null != a2 && K(t3.shape, a2.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), Vu(n3), n3[0];
    });
  };
}
function Mu(e20) {
  return Z(we(e20), () => "The f passed in grads(f) must be a function"), (t2, n2) => {
    Z(Array.isArray(t2), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
    let r2 = _i(t2, "args", "tf.grads", "string_or_numeric"), a2 = null != n2 ? Vi(n2, "dy", "tf.grads") : null;
    return $i.tidy(() => {
      let { value: t3, grads: n3 } = $i.gradients(() => e20(...r2), r2, a2);
      return null != a2 && K(t3.shape, a2.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), Vu(n3), n3;
    });
  };
}
function Ou(e20) {
  return Z(we(e20), () => "The f passed in valueAndGrad(f) must be a function"), (t2, n2) => {
    Z(t2 instanceof ni, () => "The x passed in valueAndGrad(f)(x) must be a tensor"), Z(null == n2 || n2 instanceof ni, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
    let { grads: r2, value: a2 } = $i.gradients(() => e20(t2), [t2], n2);
    return Vu(r2), { grad: r2[0], value: a2 };
  };
}
function Fu(e20) {
  return Z(we(e20), () => "The f passed in valueAndGrads(f) must be a function"), (t2, n2) => {
    Z(Array.isArray(t2) && t2.every((e21) => e21 instanceof ni), () => "The args passed in valueAndGrads(f)(args) must be array of tensors"), Z(null == n2 || n2 instanceof ni, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
    let r2 = $i.gradients(() => e20(...t2), t2, n2);
    return null != n2 && K(r2.value.shape, n2.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), Vu(r2.grads), r2;
  };
}
function Pu(e20, t2) {
  Z(we(e20), () => "The f passed in variableGrads(f) must be a function"), Z(null == t2 || Array.isArray(t2) && t2.every((e21) => e21 instanceof ai), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
  let n2 = null != t2;
  if (!n2) {
    t2 = [];
    for (let e21 in $i.registeredVariables) t2.push($i.registeredVariables[e21]);
  }
  let r2 = n2 ? t2.filter((e21) => !e21.trainable) : null, a2 = t2.length;
  Z((t2 = t2.filter((e21) => e21.trainable)).length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${a2} variables is trainable.`);
  let { value: i2, grads: s2 } = $i.gradients(e20, t2, null, true);
  Z(s2.some((e21) => null != e21), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), Z(0 === i2.rank, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i2.rank} tensor`);
  let o2 = {};
  return t2.forEach((e21, t3) => {
    null != s2[t3] && (o2[e21.name] = s2[t3]);
  }), null != r2 && r2.forEach((e21) => o2[e21.name] = null), { value: i2, grads: o2 };
}
function zu(e20) {
  return $i.customGrad(e20);
}
function Vu(e20) {
  if (e20.filter((e21) => null == e21).length > 0) throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
}
var _u = Wi({ neg_(e20) {
  let t2 = { x: Vi(e20, "x", "neg") };
  return $i.runKernel("Neg", t2);
} });
var Du = Wi({ softplus_(e20) {
  let t2 = { x: Vi(e20, "x", "softplus") };
  return $i.runKernel($r, t2);
} });
var Wu = Wi({ logSigmoid_(e20) {
  let t2 = Vi(e20, "x", "logSigmoid");
  return zu((e21) => ({ value: _u(Du(_u(e21))), gradFunc(t3) {
    return xo(t3, Yo(_u(e21)));
  } }))(t2);
} });
var Lu = Wi({ sub_(e20, t2) {
  let n2 = Vi(e20, "a", "sub"), r2 = Vi(t2, "b", "sub");
  return [n2, r2] = xi(n2, r2), $i.runKernel("Sub", { a: n2, b: r2 });
} });
var Bu = Wi({ logSoftmax_(e20, t2 = -1) {
  let n2 = Vi(e20, "logits", "logSoftmax");
  if (-1 === t2 && (t2 = n2.rank - 1), t2 !== n2.rank - 1) throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n2.rank} and axis was ${t2}`);
  return zu((e21, n3) => {
    let r2 = tu(e21, t2, true), a2 = Lu(e21, r2), i2 = Lu(co(a2, "float32"), Iu(ou(cu(a2), t2, true)));
    return n3([i2]), { value: i2, gradFunc(e22, n4) {
      let [r3] = n4, a3 = cu(r3);
      return Lu(e22, xo(ou(e22, t2, true), a3));
    } };
  })(n2);
} });
var Uu = Wi({ logSumExp_(e20, t2 = null, n2 = false) {
  let r2 = Vi(e20, "x", "logSumExp"), a2 = ue(t2, r2.shape), i2 = tu(r2, a2, true), s2 = Lu(r2, i2), o2 = cu(s2), l2 = ou(o2, a2), u2 = Iu(l2), d2 = fo(Ho(i2, u2.shape), u2);
  if (n2) {
    let e21 = Kl(d2.shape, a2);
    return Ho(d2, e21);
  }
  return d2;
} });
var ju = Wi({ logicalAnd_(e20, t2) {
  let n2 = Vi(e20, "a", "logicalAnd", "bool"), r2 = Vi(t2, "b", "logicalAnd", "bool");
  return Vl(n2.shape, r2.shape), $i.runKernel(yn, { a: n2, b: r2 });
} });
var Gu = Wi({ logicalNot_(e20) {
  let t2 = { x: Vi(e20, "x", "logicalNot", "bool") };
  return $i.runKernel(bn, t2);
} });
var Hu = Wi({ logicalOr_(e20, t2) {
  let n2 = Vi(e20, "a", "logicalOr", "bool"), r2 = Vi(t2, "b", "logicalOr", "bool");
  return Vl(n2.shape, r2.shape), $i.runKernel(gn, { a: n2, b: r2 });
} });
var Xu = Wi({ logicalXor_(e20, t2) {
  let n2 = Vi(e20, "a", "logicalXor", "bool"), r2 = Vi(t2, "b", "logicalXor", "bool");
  return Vl(n2.shape, r2.shape), ju(Hu(e20, t2), Gu(ju(e20, t2)));
} });
var qu = 2147483648;
var Zu = Wi({ searchSorted_(e20, t2, n2 = "left") {
  let r2 = Vi(e20, "sortedSequence", "searchSorted"), a2 = Vi(t2, "values", "searchSorted"), i2 = a2.shape[a2.shape.length - 1], s2 = Ho(r2, [-1, r2.shape[r2.shape.length - 1]]), o2 = Ho(a2, [-1, i2]);
  if (2 > s2.rank) throw Error("Sorted input argument must be at least 2-dimensional");
  if (s2.shape[0] !== o2.shape[0]) throw Error("Leading dimension of 'sortedSequence' and 'values' must match.");
  if (J(o2.shape) >= qu) throw Error("values tensor size must less than " + qu);
  if (s2.shape[1] >= qu) throw Error(`trailing dim_size must less than ${qu} for int32 output type, was ${s2.shape[1]}`);
  return $i.runKernel(yr, { sortedSequence: s2, values: o2 }, { side: n2 });
} });
function Ku(e20, t2) {
  return Zu(e20, t2, "left");
}
var Yu = Wi({ maxPool_(e20, t2, n2, r2, a2) {
  let i2 = Vi(e20, "x", "maxPool"), s2 = i2, o2 = false;
  3 === i2.rank && (o2 = true, s2 = Ho(i2, [1, i2.shape[0], i2.shape[1], i2.shape[2]])), Z(4 === s2.rank, () => `Error in maxPool: input must be rank 4 but got rank ${s2.rank}.`), Z(Bo(n2, 1), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${n2} and dilations '1'`), Go("maxPool", r2, a2);
  let l2 = $i.runKernel(In, { x: s2 }, { filterSize: t2, strides: n2, pad: r2, dimRoundingMode: a2 });
  return o2 ? Ho(l2, [l2.shape[1], l2.shape[2], l2.shape[3]]) : l2;
} });
var Ju = Wi({ maxPool3d_(e20, t2 = [1, 1, 1], n2, r2, a2, i2 = "NDHWC") {
  let s2 = Vi(e20, "x", "maxPool3d"), o2 = s2, l2 = false;
  4 === s2.rank && (l2 = true, o2 = Ho(s2, [1, s2.shape[0], s2.shape[1], s2.shape[2], s2.shape[3]])), Z(5 === o2.rank, () => `Error in maxPool3d: x must be rank 5 but got rank ${o2.rank}.`), Z("NDHWC" === i2, () => "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + i2), Go("maxPool3d", r2, a2);
  let u2 = $i.runKernel(Tn, { x: o2 }, { filterSize: t2, strides: n2, pad: r2, dimRoundingMode: a2, dataFormat: i2 });
  return l2 ? Ho(u2, [u2.shape[1], u2.shape[2], u2.shape[3], u2.shape[4]]) : u2;
} });
var Qu = Wi({ maxPoolWithArgmax_(e20, t2, n2, r2, a2 = false) {
  let i2 = { x: Vi(e20, "x", "maxPoolWithArgmax") }, s2 = $i.runKernel(On, i2, { filterSize: t2, strides: n2, pad: r2, includeBatchInIndex: a2 });
  return { result: s2[0], indexes: s2[1] };
} });
var ed = Wi({ maximum_(e20, t2) {
  let n2 = Vi(e20, "a", "maximum"), r2 = Vi(t2, "b", "maximum");
  return [n2, r2] = xi(n2, r2), "bool" === n2.dtype && (n2 = co(n2, "int32"), r2 = co(r2, "int32")), Vl(n2.shape, r2.shape), $i.runKernel(Sn, { a: n2, b: r2 });
} });
var td = Wi({ mean_(e20, t2 = null, n2 = false) {
  let r2 = { x: Vi(e20, "x", "mean") };
  return $i.runKernel(Fn, r2, { axis: t2, keepDims: n2 });
} });
function nd(e20, t2 = "float32") {
  if (Te(e20), "complex64" === t2) {
    let t3 = nd(e20, "float32"), n3 = nd(e20, "float32");
    return Li(t3, n3);
  }
  let n2 = Ie(J(e20), t2);
  return $i.makeTensor(n2, e20, t2);
}
function rd(e20, t2 = "float32") {
  if (Te(e20), "complex64" === t2) {
    let t3 = rd(e20, "float32"), n3 = nd(e20, "float32");
    return Li(t3, n3);
  }
  let n2 = Se(J(e20), t2);
  return $i.makeTensor(n2, e20, t2);
}
function ad(e20, t2, { indexing: n2 = "xy" } = {}) {
  if ("xy" !== n2 && "ij" !== n2) throw new TypeError(n2 + " is not a valid third argument to meshgrid");
  if (void 0 === e20) return [];
  let r2 = Vi(e20, "x", "meshgrid", e20 instanceof ni ? e20.dtype : "float32");
  if (void 0 === t2) return [r2];
  let a2 = Vi(t2, "y", "meshgrid", t2 instanceof ni ? t2.dtype : "float32"), i2 = J(r2.shape), s2 = J(a2.shape);
  return "xy" === n2 ? (r2 = Ho(r2, [1, -1]), a2 = Ho(a2, [-1, 1]), [Ko(rd([s2, 1], r2.dtype), r2), Ko(a2, rd([1, i2], a2.dtype))]) : (r2 = Ho(r2, [-1, 1]), a2 = Ho(a2, [1, -1]), [Ko(r2, rd([1, s2], r2.dtype)), Ko(rd([i2, 1], a2.dtype), a2)]);
}
var id = Wi({ minimum_(e20, t2) {
  let n2 = Vi(e20, "a", "minimum"), r2 = Vi(t2, "b", "minimum");
  return [n2, r2] = xi(n2, r2), "bool" === n2.dtype && (n2 = co(n2, "int32"), r2 = co(r2, "int32")), Vl(n2.shape, r2.shape), $i.runKernel(zn, { a: n2, b: r2 });
} });
var sd = Wi({ mirrorPad_(e20, t2, n2) {
  Z("reflect" === n2 || "symmetric" === n2, () => `Invalid mode. Mode must be either reflect or symmetric. Got ${n2}.`);
  let r2 = Vi(e20, "x", "mirrorPad");
  if (0 === r2.rank) throw Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
  Z(t2.length === r2.rank, () => `Padding doesn't match input. Must be ${r2.rank}. Got ${t2.length}.`);
  let a2 = "reflect" === n2 ? 1 : 0;
  for (let i2 = 0; r2.rank > i2; i2++) Z(2 === t2[i2].length, () => "Invalid number of paddings. Must be length of 2 each."), Z(!(0 > t2[i2][0] || t2[i2][0] > r2.shape[i2] - a2 || 0 > t2[i2][1] || t2[i2][1] > r2.shape[i2] - a2), () => `Padding in dimension ${i2} cannot be greater than or equal to ${r2.shape[i2] - a2} or less than 0 for input of shape ${r2.shape}`);
  return $i.runKernel(Vn, { x: r2 }, { paddings: t2, mode: n2 });
} });
var od = Wi({ mod_(e20, t2) {
  let n2 = Vi(e20, "a", "mod"), r2 = Vi(t2, "b", "mod");
  return [n2, r2] = xi(n2, r2), $i.runKernel("Mod", { a: n2, b: r2 });
} });
var ld = Wi({ moments_(e20, t2 = null, n2 = false) {
  let r2 = ue(t2, (e20 = Vi(e20, "x", "moments")).shape), a2 = td(e20, r2, n2), i2 = a2.shape;
  n2 || (i2 = Kl(a2.shape, r2));
  let s2 = su(Lu(co(e20, "float32"), Ho(a2, i2)));
  return { mean: a2, variance: td(s2, r2, n2) };
} });
var ud = Wi({ multiRNNCell_(e20, t2, n2, r2) {
  let a2 = Vi(t2, "data", "multiRNNCell"), i2 = _i(n2, "c", "multiRNNCell"), s2 = _i(r2, "h", "multiRNNCell"), o2 = a2, l2 = [];
  for (let c2 = 0; e20.length > c2; c2++) {
    let t3 = e20[c2](o2, i2[c2], s2[c2]);
    l2.push(t3[0]), l2.push(t3[1]), o2 = t3[1];
  }
  let u2 = [], d2 = [];
  for (let c2 = 0; l2.length > c2; c2 += 2) u2.push(l2[c2]), d2.push(l2[c2 + 1]);
  return [u2, d2];
} });
var dd = Wi({ multinomial_(e20, t2, n2, r2 = false) {
  let a2 = Vi(e20, "logits", "multinomial"), i2 = a2.size, s2 = a2.rank;
  if (2 > i2) throw Error(`Error in multinomial: you need at least 2 outcomes, but got ${i2}.`);
  if (s2 > 2) throw Error("Rank of probabilities must be 1 or 2, but is " + s2);
  n2 = n2 || Math.random();
  let o2 = { logits: 1 === s2 ? Ho(a2, [1, -1]) : a2 }, l2 = $i.runKernel(Dn, o2, { numSamples: t2, seed: n2, normalized: r2 });
  return 1 === s2 ? Ho(l2, [l2.size]) : l2;
} });
var cd = Wi({ notEqual_(e20, t2) {
  let n2 = Vi(e20, "a", "notEqual", "string_or_numeric"), r2 = Vi(t2, "b", "notEqual", "string_or_numeric");
  return [n2, r2] = xi(n2, r2), Vl(n2.shape, r2.shape), $i.runKernel(Bn, { a: n2, b: r2 });
} });
var hd = Wi({ oneHot_(e20, t2, n2 = 1, r2 = 0, a2 = "int32") {
  if (2 > t2) throw Error("Error in oneHot: depth must be >=2, but it is " + t2);
  let i2 = { indices: Vi(e20, "indices", "oneHot", "int32") };
  return $i.runKernel(Xn, i2, { dtype: a2, depth: t2, onValue: n2, offValue: r2 });
} });
var pd = Wi({ onesLike_(e20) {
  let t2 = { x: Vi(e20, "x", "onesLike") };
  return $i.runKernel(Hn, t2);
} });
var fd = Wi({ outerProduct_(e20, t2) {
  let n2 = Vi(e20, "v1", "outerProduct"), r2 = Vi(t2, "v2", "outerProduct");
  Z(1 === n2.rank && 1 === r2.rank, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${n2.rank} and ${r2.rank}.`);
  let a2 = Ho(n2, [-1, 1]), i2 = Ho(r2, [1, -1]);
  return Ko(a2, i2);
} });
var md = Wi({ pad_(e20, t2, n2 = 0) {
  let r2 = Vi(e20, "x", "pad");
  if (0 === r2.rank) throw Error("pad(scalar) is not defined. Pass non-scalar to pad");
  return $i.runKernel(Zn, { x: r2 }, { paddings: t2, constantValue: n2 });
} });
var Ad = Wi({ pad1d_(e20, t2, n2 = 0) {
  return Z(2 === t2.length, () => "Invalid number of paddings. Must be length of 2."), md(e20, [t2], n2);
} });
var xd = Wi({ pad2d_(e20, t2, n2 = 0) {
  return Z(2 === t2.length && 2 === t2[0].length && 2 === t2[1].length, () => "Invalid number of paddings. Must be length of 2 each."), md(e20, t2, n2);
} });
var yd = Wi({ pad3d_(e20, t2, n2 = 0) {
  return Z(3 === t2.length && 2 === t2[0].length && 2 === t2[1].length && 2 === t2[2].length, () => "Invalid number of paddings. Must be length of 2 each."), md(e20, t2, n2);
} });
var bd = Wi({ pad4d_(e20, t2, n2 = 0) {
  return Z(4 === t2.length && 2 === t2[0].length && 2 === t2[1].length && 2 === t2[2].length && 2 === t2[3].length, () => "Invalid number of paddings. Must be length of 2 each."), md(e20, t2, n2);
} });
var gd = Wi({ spaceToBatchND_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "spaceToBatchND");
  return Z(r2.rank >= 1 + t2.length, () => `input rank ${r2.rank} should be > than [blockShape] ${t2.length}`), Z(n2.length === t2.length, () => `paddings.shape[0] ${n2.length} must be equal to [blockShape] ${t2.length}`), Z(r2.shape.reduce((e21, r3, a2) => a2 > 0 && t2.length >= a2 ? e21 && (r3 + n2[a2 - 1][0] + n2[a2 - 1][1]) % t2[a2 - 1] === 0 : e21, true), () => `input spatial dimensions ${r2.shape.slice(1)} with paddings ${"" + n2} must be divisible by blockShapes ${"" + t2}`), $i.runKernel(Ir, { x: r2 }, { blockShape: t2, paddings: n2 });
} });
var vd = Wi({ pool_(e20, t2, n2, r2, a2, i2, s2) {
  null == a2 && (a2 = [1, 1]), null == i2 && (i2 = 1), 0 === r2 && (r2 = "valid");
  let o2 = Vi(e20, "x", "maxPool"), l2 = o2, u2 = false;
  3 === o2.rank && (u2 = true, l2 = Ho(o2, [1, o2.shape[0], o2.shape[1], o2.shape[2]])), Z(Bo(i2, a2), () => `Error in pool: Either strides or dilations must be 1. Got strides ${i2} and dilations '${a2}'`);
  let d2, c2 = Mo(l2.shape, t2, i2, a2, r2), h2 = [c2.dilationHeight, c2.dilationWidth];
  d2 = "same" === r2 ? ((e21, t3) => {
    let n3 = e21.map((e22, n4) => e22 + (e22 - 1) * (t3[n4] - 1)).map((e22) => e22 - 1), r3 = n3.map((e22) => Math.floor(e22 / 2)), a3 = n3.map((e22, t4) => e22 - r3[t4]);
    return n3.map((e22, t4) => [r3[t4], a3[t4]]);
  })([c2.filterHeight, c2.filterWidth], h2) : [[0, 0], [0, 0]];
  let p2 = 1 === h2[0] && 1 === h2[1], [f2, m2] = ((e21, t3, n3) => {
    let r3 = n3.map((e22) => e22[0]), a3 = n3.map((e22) => e22[1]), i3 = e21.concat(r3, a3), s3 = t3.map((e22, t4) => (e22 - i3[t4] % e22) % e22), o3 = a3.map((e22, t4) => e22 + s3[t4]), l3 = t3.map((e22, t4) => [r3[t4], o3[t4]]), u3 = t3.map((e22, t4) => [0, s3[t4]]);
    return [l3, u3];
  })([c2.inHeight, c2.inWidth], h2, d2), A2 = p2 ? r2 : "valid", x2 = p2 ? l2 : gd(l2, h2, f2), y2 = ("avg" === n2 ? () => Xo(x2, t2, i2, A2, s2) : () => Yu(x2, t2, i2, A2, s2))(), b2 = p2 ? y2 : tl(y2, h2, m2);
  return u2 ? Ho(b2, [b2.shape[1], b2.shape[2], b2.shape[3]]) : b2;
} });
var wd = Wi({ prelu_(e20, t2) {
  let n2 = Vi(e20, "x", "prelu"), r2 = Vi(t2, "alpha", "prelu");
  return $i.runKernel(Jn, { x: n2, alpha: r2 });
} });
var kd = Wi({ prod_(e20, t2 = null, n2 = false) {
  let r2 = Vi(e20, "x", "prod");
  return "bool" === r2.dtype && (r2 = co(r2, "int32")), $i.runKernel(Qn, { x: r2 }, { axis: t2, keepDims: n2 });
} });
var Nd = Wi({ raggedGather_(e20, t2, n2, r2) {
  let a2 = e20.map((e21, t3) => Vi(e21, "tensors" + t3, "raggedGather", "int32")), i2 = Vi(t2, "paramsDenseValues", "raggedGather"), s2 = Vi(n2, "indices", "raggedGather", "int32"), o2 = $i.runKernel(er, { paramsNestedSplits: a2, paramsDenseValues: i2, indices: s2 }, { outputRaggedRank: r2 });
  return { outputNestedSplits: o2.slice(0, o2.length - 1), outputDenseValues: o2[o2.length - 1] };
} });
var Cd = Wi({ raggedRange_(e20, t2, n2) {
  let r2 = Vi(e20, "starts", "raggedRange"), a2 = Vi(t2, "limits", "raggedRange", r2.dtype), i2 = Vi(n2, "deltas", "raggedRange", r2.dtype), s2 = $i.runKernel(tr, { starts: r2, limits: a2, deltas: i2 });
  return { rtNestedSplits: s2[0], rtDenseValues: s2[1] };
} });
var $d = Wi({ raggedTensorToTensor_(e20, t2, n2, r2, a2) {
  let i2 = Vi(e20, "shape", "raggedTensorToTensor", "int32"), s2 = Vi(t2, "values", "raggedTensorToTensor"), o2 = Vi(n2, "defaultValue", "raggedTensorToTensor", s2.dtype), l2 = r2.map((e21, t3) => Vi(e21, "tensors" + t3, "raggedTensorToTensor", "int32"));
  return $i.runKernel(nr, { shape: i2, values: s2, defaultValue: o2, rowPartitionTensors: l2 }, { rowPartitionTypes: a2 });
} });
var Rd = Wi({ rand_(e20, t2, n2) {
  Te(e20);
  let r2 = J(e20), a2 = null;
  if (null == n2 || "float32" === n2) a2 = new Float32Array(r2);
  else if ("int32" === n2) a2 = new Int32Array(r2);
  else {
    if ("bool" !== n2) throw Error("Unknown data type " + n2);
    a2 = new Uint8Array(r2);
  }
  for (let i2 = 0; r2 > i2; i2++) a2[i2] = t2();
  return $i.makeTensor(a2, e20, n2);
} });
var Sd = x(I());
var Id = {};
A(Id, { TEST_EPSILON_FLOAT16() {
  return Td;
}, createVideoElement() {
  return Bd;
}, encodeStrings() {
  return Ld;
}, expectArrayBuffersEqual() {
  return Wd;
}, expectArraysClose() {
  return Md;
}, expectArraysEqual() {
  return zd;
}, expectNumbersClose() {
  return Vd;
}, expectPromiseToFail() {
  return Pd;
}, expectValuesInRange() {
  return Dd;
}, play() {
  return Ud;
}, testEpsilon() {
  return Od;
} });
var Ed = 1e-3;
var Td = 0.1;
function Md(e20, t2, n2) {
  return null == n2 && (n2 = Od()), Fd(e20, t2, (e21, t3) => _d(e21, t3, n2));
}
function Od() {
  return 32 === $i.backend.floatPrecision() ? Ed : Td;
}
function Fd(e20, t2, n2) {
  let r2 = true;
  if ((Ua(e20) || Ua(t2)) && (r2 = false), Ua(e20) && Ua(t2) && (r2 = true), r2) {
    let n3 = e20.constructor.name, r3 = t2.constructor.name;
    if (n3 !== r3) throw Error(`Arrays are of different type. Actual: ${n3}. Expected: ${r3}`);
  }
  if (Array.isArray(e20) && Array.isArray(t2)) {
    let n3 = Fi(e20), r3 = Fi(t2);
    if (!te(n3, r3)) throw Error(`Arrays have different shapes. Actual: [${n3}]. Expected: [${r3}]`);
  }
  let a2 = Ua(e20) ? e20 : ja(e20), i2 = Ua(t2) ? t2 : ja(t2);
  if (a2.length !== i2.length) throw Error(`Arrays have different lengths actual: ${a2.length} vs expected: ${i2.length}.
Actual:   ${a2}.
Expected: ${i2}.`);
  for (let s2 = 0; i2.length > s2; ++s2) {
    let e21 = a2[s2], t3 = i2[s2];
    if (!n2(e21, t3)) throw Error(`Arrays differ: actual[${s2}] = ${e21}, expected[${s2}] = ${t3}.
Actual:   ${a2}.
Expected: ${i2}.`);
  }
  "undefined" != typeof expect && expect().nothing();
}
function Pd(e20, t2) {
  e20().then(() => t2.fail(), () => t2()), "undefined" != typeof expect && expect().nothing();
}
function zd(e20, t2) {
  let n2 = "string" == typeof t2 || "number" == typeof t2 || "boolean" == typeof t2 ? [t2] : t2;
  return ye(e20) || ye(e20[0]) || ye(t2) || ye(t2[0]) ? Fd(e20, n2, (e21, t3) => e21 == t3) : Fd(e20, t2, (e21, t3) => _d(e21, t3, 0));
}
function Vd(e20, t2, n2) {
  if (null == n2 && (n2 = Od()), !_d(e20, t2, n2)) throw Error(`Numbers differ: actual === ${e20}, expected === ${t2}`);
  "undefined" != typeof expect && expect().nothing();
}
function _d(e20, t2, n2) {
  return !isFinite(e20) && !isFinite(t2) || !(isNaN(e20) || isNaN(t2) || Math.abs(e20 - t2) > n2);
}
function Dd(e20, t2, n2) {
  for (let r2 = 0; e20.length > r2; r2++) if (t2 > e20[r2] || e20[r2] > n2) throw Error(`Value out of range:${e20[r2]} low: ${t2}, high: ${n2}`);
}
function Wd(e20, t2) {
  let n2 = new Float32Array(e20), r2 = new Float32Array(t2);
  if (n2.length !== r2.length) throw Error(`Expected ArrayBuffer to be of length ${r2.length}, but it was ${n2.length}`);
  for (let a2 = 0; r2.length > a2; a2++) if (n2[a2] !== r2[a2]) throw Error(`Expected ArrayBuffer value at ${a2} to be ${r2[a2]} but got ${n2[a2]} instead`);
}
function Ld(e20) {
  for (let t2 = 0; e20.length > t2; t2++) {
    let n2 = e20[t2];
    Array.isArray(n2) ? Ld(n2) : e20[t2] = La(n2);
  }
  return e20;
}
function Bd(e20) {
  let t2 = document.createElement("video");
  return "playsInline" in t2 && (t2.playsInline = true), t2.muted = true, t2.loop = true, t2.style.position = "fixed", t2.style.left = "0px", t2.style.top = "0px", t2.preload = "auto", t2.appendChild(e20), new Promise((e21) => {
    t2.addEventListener("loadeddata", (n2) => e21(t2)), t2.load();
  });
}
function Ud(e20) {
  return __async(this, null, function* () {
    yield e20.play(), "requestVideoFrameCallback" in e20 && (yield new Promise((t2) => {
      e20.requestVideoFrameCallback(t2);
    }));
  });
}
var jd = class {
  constructor(e20, t2, n2, r2, a2) {
    this.mean = e20, this.stdDev = t2, this.dtype = n2, this.nextVal = NaN, this.truncated = r2, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    let i2 = a2 || Math.random();
    this.random = Sd.alea("" + i2);
  }
  nextValue() {
    if (!isNaN(this.nextVal)) {
      let e21 = this.nextVal;
      return this.nextVal = NaN, e21;
    }
    let e20, t2, n2 = false;
    for (; !n2; ) {
      let r2, a2, i2;
      do {
        r2 = 2 * this.random() - 1, a2 = 2 * this.random() - 1, i2 = r2 * r2 + a2 * a2;
      } while (i2 >= 1 || 0 === i2);
      let s2 = Math.sqrt(-2 * Math.log(i2) / i2);
      e20 = this.mean + this.stdDev * r2 * s2, t2 = this.mean + this.stdDev * a2 * s2, (!this.truncated || this.isValidTruncated(e20)) && (n2 = true);
    }
    return (!this.truncated || this.isValidTruncated(t2)) && (this.nextVal = this.convertValue(t2)), this.convertValue(e20);
  }
  convertValue(e20) {
    return null == this.dtype || "float32" === this.dtype ? e20 : Math.round(e20);
  }
  isValidTruncated(e20) {
    return this.upper >= e20 && e20 >= this.lower;
  }
};
var Gd = class {
  constructor(e20, t2, n2, r2) {
    this.alpha = e20, this.beta = 1 / t2, this.dtype = n2;
    let a2 = r2 || Math.random();
    this.randu = Sd.alea("" + a2), this.randn = new jd(0, 1, n2, false, this.randu()), this.d = 1 > e20 ? e20 + 2 / 3 : e20 - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }
  nextValue() {
    let e20, t2, n2, r2, a2, i2;
    for (; ; ) {
      do {
        r2 = this.randn.nextValue(), i2 = 1 + this.c * r2;
      } while (0 >= i2);
      if (i2 *= i2 * i2, e20 = r2 * r2, t2 = 1 - 0.331 * e20 * e20, n2 = 0.5 * e20 + this.d * (1 - i2 + Math.log(i2)), a2 = this.randu(), t2 > a2 || n2 > Math.log(a2)) break;
    }
    return i2 *= 1 / this.beta * this.d, 1 > this.alpha && (i2 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(i2);
  }
  convertValue(e20) {
    return "float32" === this.dtype ? e20 : Math.round(e20);
  }
};
var Hd = class {
  constructor(e20 = 0, t2 = 1, n2, r2) {
    if (this.canReturnFloat = () => null == this.dtype || "float32" === this.dtype, this.min = e20, this.range = t2 - e20, this.dtype = n2, null == r2 && (r2 = Math.random()), "number" == typeof r2 && (r2 = "" + r2), !this.canReturnFloat() && 1 >= this.range) throw Error(`The difference between ${e20} - ${t2} <= 1 and dtype is not float`);
    this.random = Sd.alea(r2);
  }
  convertValue(e20) {
    return this.canReturnFloat() ? e20 : Math.round(e20);
  }
  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }
};
var Xd = Wi({ randomGamma_(e20, t2, n2 = 1, r2 = "float32", a2) {
  if (Te(e20), null == n2 && (n2 = 1), null == r2 && (r2 = "float32"), "float32" !== r2 && "int32" !== r2) throw Error("Unsupported data type " + r2);
  let i2 = new Gd(t2, n2, r2, a2), s2 = uo(e20, r2);
  for (let o2 = 0; s2.values.length > o2; o2++) s2.values[o2] = i2.nextValue();
  return s2.toTensor();
} });
var qd = Wi({ randomNormal_(e20, t2 = 0, n2 = 1, r2, a2) {
  if (Te(e20), null != r2 && "bool" === r2) throw Error("Unsupported data type " + r2);
  let i2 = new jd(t2, n2, r2, false, a2), s2 = uo(e20, r2);
  for (let o2 = 0; s2.values.length > o2; o2++) s2.values[o2] = i2.nextValue();
  return s2.toTensor();
} });
var Zd = Wi({ randomStandardNormal_(e20, t2, n2) {
  if (null != t2 && "bool" === t2) throw Error("Unsupported data type " + t2);
  return qd(e20, 0, 1, t2, n2);
} });
var Kd = Wi({ randomUniform_(e20, t2 = 0, n2 = 1, r2 = "float32", a2) {
  Te(e20);
  let i2 = uo(e20, r2), s2 = new Hd(t2, n2, null, a2);
  for (let o2 = 0; i2.values.length > o2; o2++) i2.values[o2] = s2.nextValue();
  return i2.toTensor();
} });
var Yd = Wi({ randomUniformInt_(e20, t2, n2, r2) {
  return Kd(e20, t2, n2, "int32", r2);
} });
function Jd(e20, t2, n2 = 1, r2 = "float32") {
  if (0 === n2) throw Error("Cannot have a step of zero");
  return $i.runKernel(rr, {}, { start: e20, stop: t2, step: n2, dtype: r2 });
}
var Qd = Wi({ real_(e20) {
  let t2 = { input: Vi(e20, "input", "real") };
  return $i.runKernel(ar, t2);
} });
var ec = Wi({ reciprocal_(e20) {
  let t2 = { x: Vi(e20, "x", "reciprocal") };
  return $i.runKernel(ir, t2);
} });
var tc = Wi({ relu_(e20) {
  let t2 = { x: Vi(e20, "x", "relu") };
  return $i.runKernel(sr, t2);
} });
var nc = Wi({ relu6_(e20) {
  let t2 = { x: Vi(e20, "x", "relu6") };
  return $i.runKernel(hr, t2);
} });
var rc = Wi({ reverse_(e20, t2) {
  let n2 = { x: Vi(e20, "x", "reverse") };
  return $i.runKernel(pr, n2, { dims: t2 });
} });
var ac = Wi({ reverse1d_(e20) {
  let t2 = Vi(e20, "x", "reverse");
  return Z(1 === t2.rank, () => `Error in reverse1D: x must be rank 1 but got rank ${t2.rank}.`), rc(t2, 0);
} });
var ic = Wi({ reverse2d_(e20, t2) {
  let n2 = Vi(e20, "x", "reverse");
  return Z(2 === n2.rank, () => `Error in reverse2D: x must be rank 2 but got rank ${n2.rank}.`), rc(n2, t2);
} });
var sc = Wi({ reverse3d_(e20, t2) {
  let n2 = Vi(e20, "x", "reverse");
  return Z(3 === n2.rank, () => `Error in reverse3D: x must be rank 3 but got rank ${n2.rank}.`), rc(n2, t2);
} });
var oc = Wi({ reverse4d_(e20, t2) {
  let n2 = Vi(e20, "x", "reverse");
  return Z(4 === n2.rank, () => `Error in reverse4D: x must be rank 4 but got rank ${n2.rank}.`), rc(n2, t2);
} });
var lc = Wi({ round_(e20) {
  let t2 = { x: Vi(e20, "x", "round") };
  return $i.runKernel(fr, t2);
} });
var uc = Wi({ rsqrt_(e20) {
  let t2 = { x: Vi(e20, "x", "rsqrt", "float32") };
  return $i.runKernel(mr, t2);
} });
var dc = Wi({ selu_(e20) {
  let t2 = { x: Vi(e20, "x", "selu") };
  return $i.runKernel(gr, t2);
} });
var cc = Wi({ separableConv2d_(e20, t2, n2, r2, a2, i2 = [1, 1], s2 = "NHWC") {
  let o2 = Vi(e20, "x", "separableConv2d"), l2 = Vi(t2, "depthwiseFilter", "separableConv2d"), u2 = Vi(n2, "pointwiseFilter", "separableConv2d"), d2 = o2, c2 = false;
  if (3 === o2.rank && (c2 = true, d2 = Ho(o2, [1, o2.shape[0], o2.shape[1], o2.shape[2]])), "NCHW" === s2) throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  Z(4 === d2.rank, () => `Error in separableConv2d: input must be rank 4, but got rank ${d2.rank}.`), Z(4 === l2.rank, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l2.rank}.`), Z(4 === u2.rank, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l2.rank}.`), Z(1 === u2.shape[0], () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u2.shape[0]}.`), Z(1 === u2.shape[1], () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u2.shape[1]}.`);
  let h2 = l2.shape[2], p2 = l2.shape[3];
  Z(u2.shape[2] === h2 * p2, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${h2 * p2}, but got ${u2.shape[2]}.`);
  let f2 = Tl(d2, l2, r2, a2, s2, i2), m2 = yl(f2, u2, 1, "valid", s2);
  return c2 ? Ho(m2, [m2.shape[1], m2.shape[2], m2.shape[3]]) : m2;
} });
var hc = (e20, t2) => __async(null, null, function* () {
  let n2 = Vi(e20, "x", "setdiff1d"), r2 = Vi(t2, "y", "setdiff1d");
  Z(n2.dtype === r2.dtype, () => `x and y should have the same dtype, but got x (${n2.dtype}) and y (${r2.dtype}).`), Z(1 === n2.rank, () => `x should be 1D tensor, but got x (${n2.shape}).`), Z(1 === r2.rank, () => `y should be 1D tensor, but got y (${r2.shape}).`);
  let a2 = yield n2.data(), i2 = yield r2.data(), s2 = new Set(i2), o2 = 0;
  for (let d2 = 0; a2.length > d2; d2++) s2.has(a2[d2]) || o2++;
  let l2 = new Qa([o2], n2.dtype), u2 = new Qa([o2], "int32");
  for (let d2 = 0, c2 = 0; a2.length > d2; d2++) s2.has(a2[d2]) || (l2.values[c2] = a2[d2], u2.values[c2] = d2, c2++);
  return [l2.toTensor(), u2.toTensor()];
});
var pc = Wi({ sign_(e20) {
  let t2 = { x: Vi(e20, "x", "sign") };
  return $i.runKernel(Nr, t2);
} });
var fc = Wi({ sin_(e20) {
  let t2 = { x: Vi(e20, "x", "sin", "float32") };
  return $i.runKernel("Sin", t2);
} });
var mc = Wi({ sinh_(e20) {
  let t2 = { x: Vi(e20, "x", "sinh") };
  return $i.runKernel(kr, t2);
} });
var Ac = Wi({ slice1d_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "slice1d");
  return Z(1 === r2.rank, () => `slice1d expects a rank-1 tensor, but got a rank-${r2.rank} tensor`), Jo(r2, [t2], [n2]);
} });
var xc = Wi({ slice2d_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "slice2d");
  return Z(2 === r2.rank, () => `slice2d expects a rank-2 tensor, but got a rank-${r2.rank} tensor`), Jo(r2, t2, n2);
} });
var yc = Wi({ slice3d_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "slice3d");
  return Z(3 === r2.rank, () => `slice3d expects a rank-3 tensor, but got a rank-${r2.rank} tensor`), Jo(r2, t2, n2);
} });
var bc = Wi({ slice4d_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "slice4d");
  return Z(4 === r2.rank, () => `slice4d expects a rank-4 tensor, but got a rank-${r2.rank} tensor`), Jo(r2, t2, n2);
} });
var gc = Wi({ softmax_(e20, t2 = -1) {
  let n2 = Vi(e20, "logits", "softmax", "float32");
  if (-1 === t2 && (t2 = n2.rank - 1), t2 !== n2.rank - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n2.rank} and dim was ${t2}`);
  return $i.runKernel(Tr, { logits: n2 }, { dim: t2 });
} });
var vc = Wi({ fft_(e20) {
  return Z("complex64" === e20.dtype, () => `The dtype for tf.spectral.fft() must be complex64 but got ${e20.dtype}.`), $i.runKernel("FFT", { input: e20 });
} });
var wc = Wi({ ifft_(e20) {
  return Z("complex64" === e20.dtype, () => `The dtype for tf.spectral.ifft() must be complex64 but got ${e20.dtype}.`), $i.runKernel(on, { input: e20 });
} });
var kc = Wi({ irfft_(e20) {
  let t2, n2 = e20.shape[e20.shape.length - 1], r2 = e20.size / n2;
  if (n2 > 2) {
    let a2 = [r2, 2 * (n2 - 1)], i2 = Ho(Qd(e20), [r2, n2]), s2 = Ho(gu(e20), [r2, n2]), o2 = rc(Jo(i2, [0, 1], [r2, n2 - 2]), 1), l2 = xo(rc(Jo(s2, [0, 1], [r2, n2 - 2]), 1), au(-1)), u2 = Zo([i2, o2], 1), d2 = Zo([s2, l2], 1), c2 = Ho(Li(u2, d2), [a2[0], a2[1]]);
    t2 = wc(c2);
  } else {
    let a2 = Ho(e20, [r2, n2]);
    t2 = wc(a2);
  }
  if (t2 = Qd(t2), 3 === e20.rank && 0 !== e20.shape[0]) {
    let n3 = t2, r3 = e20.shape[0];
    t2 = Ho(t2, [r3, t2.shape[0] / r3, t2.shape[1]]), n3.dispose();
  }
  return t2;
} });
var Nc = Wi({ split_(e20, t2, n2 = 0) {
  let r2 = { x: Vi(e20, "x", "split") };
  return $i.runKernel(Er, r2, { numOrSizeSplits: t2, axis: n2 });
} });
var Cc = Wi({ rfft_(e20, t2) {
  Z("float32" === e20.dtype, () => "The dtype for rfft() must be real value but got " + e20.dtype);
  let n2, r2 = e20.shape[e20.shape.length - 1], a2 = e20.size / r2;
  if (null != t2 && r2 > t2) {
    let a3 = e20.shape.map((e21) => 0), i3 = e20.shape.map((e21) => e21);
    i3[e20.shape.length - 1] = t2, n2 = Jo(e20, a3, i3), r2 = t2;
  } else if (null != t2 && t2 > r2) {
    let a3 = e20.shape.map((e21) => e21);
    a3[e20.shape.length - 1] = t2 - r2, n2 = Zo([e20, nd(a3)], e20.shape.length - 1), r2 = t2;
  } else n2 = e20;
  let i2 = Wl(n2), s2 = Ho(Li(n2, i2), [a2, r2]), o2 = vc(s2), l2 = Math.floor(r2 / 2) + 1, u2 = Qd(o2), d2 = gu(o2), c2 = Nc(u2, [l2, r2 - l2], u2.shape.length - 1), h2 = Nc(d2, [l2, r2 - l2], d2.shape.length - 1), p2 = n2.shape.slice();
  return p2[n2.shape.length - 1] = l2, Ho(Li(c2[0], h2[0]), p2);
} });
var $c = Wi({ squaredDifference_(e20, t2) {
  let n2 = Vi(e20, "a", "squaredDifference"), r2 = Vi(t2, "b", "squaredDifference");
  return [n2, r2] = xi(n2, r2), Vl(n2.shape, r2.shape), $i.runKernel(Vr, { a: n2, b: r2 }, {});
} });
var Rc = Wi({ squeeze_(e20, t2) {
  let n2 = Vi(e20, "x", "squeeze", "string_or_numeric");
  return Ho(n2, de(n2.shape, t2).newShape);
} });
var Sc = Wi({ stack_(e20, t2 = 0) {
  let n2 = _i(e20, "tensors", "stack", "string_or_numeric");
  return Z(n2.length >= 1, () => "Pass at least one tensor to tf.stack"), n2.length > 0 && Z(n2[0].rank >= t2, () => "Axis must be <= rank of the tensor"), $i.runKernel(qn, n2, { axis: t2 });
} });
var Ic = Wi({ step_(e20, t2 = 0) {
  let n2 = { x: Vi(e20, "x", "step") };
  return $i.runKernel(na, n2, { alpha: t2 });
} });
var Ec = Wi({ stridedSlice_(e20, t2, n2, r2, a2 = 0, i2 = 0, s2 = 0, o2 = 0, l2 = 0) {
  let u2 = { x: Vi(e20, "x", "stridedSlice", "string_or_numeric") };
  return $i.runKernel(Wr, u2, { begin: t2, end: n2, strides: r2, beginMask: a2, endMask: i2, ellipsisMask: s2, newAxisMask: o2, shrinkAxisMask: l2 });
} });
var Tc = Wi({ tan_(e20) {
  let t2 = { x: Vi(e20, "x", "tan", "float32") };
  return $i.runKernel("Tan", t2);
} });
function Mc(e20, t2) {
  Y(e20);
  let n2 = Fi(e20, t2);
  if (1 !== n2.length) throw Error("tensor1d() requires values to be a flat/TypedArray");
  return Bi(e20, null, n2, t2);
}
function Oc(e20, t2, n2) {
  if (Y(e20), null != t2 && 2 !== t2.length) throw Error("tensor2d() requires shape to have two numbers");
  let r2 = Fi(e20, n2);
  if (2 !== r2.length && 1 !== r2.length) throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === r2.length && null == t2) throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Bi(e20, t2, r2, n2);
}
function Fc(e20, t2, n2) {
  if (Y(e20), null != t2 && 3 !== t2.length) throw Error("tensor3d() requires shape to have three numbers");
  let r2 = Fi(e20, n2);
  if (3 !== r2.length && 1 !== r2.length) throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (1 === r2.length && null == t2) throw Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return Bi(e20, t2, r2, n2);
}
function Pc(e20, t2, n2) {
  if (Y(e20), null != t2 && 4 !== t2.length) throw Error("tensor4d() requires shape to have four numbers");
  let r2 = Fi(e20, n2);
  if (4 !== r2.length && 1 !== r2.length) throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (1 === r2.length && null == t2) throw Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return Bi(e20, t2, r2, n2);
}
function zc(e20, t2, n2) {
  if (Y(e20), null != t2 && 5 !== t2.length) throw Error("tensor5d() requires shape to have five numbers");
  let r2 = Fi(e20, n2);
  if (5 !== r2.length && 1 !== r2.length) throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (1 === r2.length && null == t2) throw Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return Bi(e20, t2, r2, n2);
}
function Vc(e20, t2, n2) {
  if (Y(e20), null != t2 && 6 !== t2.length) throw Error("tensor6d() requires shape to have six numbers");
  let r2 = Fi(e20, n2);
  if (6 !== r2.length && 1 !== r2.length) throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (1 === r2.length && null == t2) throw Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return Bi(e20, t2 = t2 || r2, r2, n2);
}
var _c = {};
function Dc(e20, t2, n2) {
  let r2 = t2.rank > 1 ? t2.shape[t2.rank - 1] : 1, a2 = t2.rank > 1 ? t2.rank - 1 : 1, i2 = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n2.shape}, indices.shape: ${t2.shape}, shape: ${e20}, sliceDim: ${r2}, and batchDim: ${a2}.`;
  if (a2 > n2.rank) throw Error(i2 + ` update.rank < ${a2}. `);
  if (r2 + (n2.rank - a2) > e20.length) throw Error(i2 + " Output shape length < " + (r2 + (n2.rank - a2)));
  if (n2.rank !== a2 + e20.length - r2) throw Error(i2 + " update.rank != " + (a2 + e20.length - r2));
  for (let s2 = 0; a2 > s2; ++s2) if (n2.shape[s2] !== t2.shape[s2]) throw Error(i2 + ` updates.shape[${s2}] (${n2.shape[s2]}) != indices.shape[${s2}] (${t2.shape[s2]}).`);
  for (let s2 = 0; n2.rank - a2 > s2; ++s2) if (n2.shape[s2 + a2] !== e20[s2 + r2]) throw Error(i2 + ` updates.shape[${s2 + a2}] (${n2.shape[s2 + a2]}) != shape[${s2 + a2}] (${e20[s2 + a2]})`);
}
function Wc(e20, t2, n2) {
  if (1 > t2.rank) throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t2.rank}.`);
  if (1 > e20.rank) throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e20.rank}.`);
  if ("int32" !== t2.dtype) throw Error("The dtype of 'indices' should be int32, but got dtype: " + t2.dtype);
  if (1 > n2.length) throw Error("Output rank must be greater or equal to 1, but got shape: " + n2);
  if (0 === n2.length) {
    if (0 === t2.size) throw Error("Indices specified for empty output. indices shape: " + t2.shape);
    if (0 === e20.size) throw Error("Updates specified for empty output. updates shape: " + e20.shape);
  }
  Dc(n2, t2, e20);
}
function Lc(e20, t2, n2) {
  let r2 = t2.shape.length, a2 = r2 > 1 ? t2.shape[r2 - 1] : 1, i2 = n2.length, s2 = 1;
  for (let l2 = a2; i2 > l2; ++l2) s2 *= n2[l2];
  let o2 = 1 > a2 ? 1 : a2;
  return { sliceRank: a2, numUpdates: J(t2.shape) / o2, sliceSize: s2, strides: [...Ne(n2.slice(0, a2)), 1], outputSize: J(n2) };
}
A(_c, { calculateShapes() {
  return Lc;
}, validateInput() {
  return Wc;
}, validateUpdateShape() {
  return Dc;
} });
var Bc = Wi({ tensorScatterUpdate_(e20, t2, n2) {
  let r2 = Vi(e20, "tensor", "tensorScatterupdate"), a2 = Vi(t2, "indices", "tensorScatterupdate", "int32"), i2 = Vi(n2, "updates", "tensorScatterupdate");
  if (Wc(i2, a2, r2.shape), r2.dtype !== i2.dtype) throw Error(`tensor and updates must have the same dtype, instead they are ${r2.dtype} and ${i2.dtype}.`);
  return $i.runKernel(xr, { tensor: r2, indices: a2, updates: i2 }, {});
} });
var Uc = Wi({ topk_(e20, t2 = 1, n2 = true) {
  let r2 = Vi(e20, "x", "topk");
  if (0 === r2.rank) throw Error("topk() expects the input to be of rank 1 or higher");
  let a2 = r2.shape[r2.shape.length - 1];
  if (0 > t2) throw Error("'k' passed to topk() must be >= 0 but got " + t2);
  if (t2 > a2) throw Error(`'k' passed to topk() must be <= the last dimension (${a2}) but got ${t2}`);
  let i2 = { x: r2 }, s2 = { k: t2, sorted: n2 }, [o2, l2] = $i.runKernel(qr, i2, s2);
  return { values: o2, indices: l2 };
} });
var jc = Wi({ truncatedNormal_(e20, t2 = 0, n2 = 1, r2, a2) {
  if (Te(e20), null != r2 && "bool" === r2) throw Error("Unsupported data type $ { dtype }");
  let i2 = new jd(t2, n2, r2, true, a2), s2 = uo(e20, r2);
  for (let o2 = 0; s2.values.length > o2; o2++) s2.values[o2] = i2.nextValue();
  return s2.toTensor();
} });
var Gc = Wi({ unique_(e20, t2 = 0) {
  let n2 = Vi(e20, "x", "unique", "string_or_numeric");
  Z(n2.rank > 0, () => "The input tensor must be at least 1D");
  let r2 = { x: n2 }, a2 = { axis: t2 }, [i2, s2] = $i.runKernel(Yr, r2, a2);
  return { values: i2, indices: s2 };
} });
var Hc = Wi({ unsortedSegmentSum_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "unsortedSegmentSum"), a2 = Vi(t2, "segmentIds", "unsortedSegmentSum", "int32");
  return Z(ne(n2), () => "numSegments must be of dtype int"), $i.runKernel(Qr, { x: r2, segmentIds: a2 }, { numSegments: n2 });
} });
var Xc = Wi({ unstack_(e20, t2 = 0) {
  let n2 = Vi(e20, "x", "unstack", "string_or_numeric");
  return Z(t2 >= -n2.shape.length && n2.shape.length > t2, () => `Axis = ${t2} is not in [-${n2.shape.length}, ${n2.shape.length})`), $i.runKernel(Jr, { value: n2 }, { axis: t2 });
} });
function qc(e20, t2) {
  return Zu(e20, t2, "right");
}
function Zc(e20, t2 = true, n2, r2) {
  return $i.makeVariable(e20, t2, n2, r2);
}
function Kc(e20, t2) {
  let n2 = [];
  for (let i2 = 0; t2.length > i2; i2++) t2[i2] && n2.push(i2);
  let r2 = uo(e20, "int32"), a2 = uo([n2.length, e20.length], "int32");
  for (let i2 = 0; n2.length > i2; i2++) {
    let t3 = r2.indexToLoc(n2[i2]);
    a2.values.set(t3, i2 * e20.length);
  }
  return a2.toTensor();
}
var Yc = (e20) => __async(null, null, function* () {
  let t2 = Vi(e20, "condition", "whereAsync", "bool"), n2 = yield t2.data(), r2 = Kc(t2.shape, n2);
  return e20 !== t2 && t2.dispose(), r2;
});
var Jc = (e20, t2, n2) => __async(null, null, function* () {
  let r2 = Vi(e20, "tensor", "boolMask"), a2 = Vi(t2, "mask", "boolMask", "bool"), i2 = n2 ?? 0, s2 = a2.rank, o2 = r2.shape;
  Z(s2 > 0, () => "mask cannot be scalar"), K(o2.slice(i2, i2 + s2), a2.shape, "mask's shape must match the first K dimensions of tensor's shape,");
  let l2 = 1;
  for (let m2 = i2; i2 + s2 > m2; m2++) l2 *= o2[m2];
  let u2 = o2.slice(0, i2).concat([l2], o2.slice(i2 + s2)), d2 = Ho(r2, u2), c2 = Ho(a2, [-1]), h2 = yield Yc(c2), p2 = Rc(h2, [1]), f2 = xu(d2, p2, i2);
  return e20 !== r2 && r2.dispose(), t2 !== a2 && a2.dispose(), p2.dispose(), d2.dispose(), c2.dispose(), h2.dispose(), f2;
});
var Qc = Wi({ transpose_(e20, t2, n2) {
  let r2 = Vi(e20, "x", "transpose");
  if (null == t2 && (t2 = r2.shape.map((e21, t3) => t3).reverse()), Z(r2.rank === t2.length, () => `Error in transpose: rank of input ${r2.rank} must match length of perm ${t2}.`), t2.forEach((e21) => {
    Z(e21 >= 0 && r2.rank > e21, () => `All entries in 'perm' must be between 0 and ${r2.rank - 1} but got ${t2}`);
  }), 1 >= r2.rank) return r2.clone();
  let a2 = { x: r2 }, i2 = { perm: t2 };
  return "complex64" === r2.dtype ? es(() => {
    let e21 = Qd(r2), t3 = gu(r2);
    return e21 = $i.runKernel(Kr, { x: e21 }, i2), t3 = $i.runKernel(Kr, { x: t3 }, i2), n2 && (t3 = _u(t3)), Li(e21, t3);
  }) : $i.runKernel(Kr, a2, i2);
} });
var eh = Wi({ movingAverage_(e20, t2, n2, r2, a2 = true) {
  let i2 = Vi(e20, "v", "movingAverage"), s2 = Vi(t2, "x", "movingAverage"), o2 = Vi(n2, "decay", "movingAverage");
  yi(i2, s2), Z(te(i2.shape, s2.shape), () => "Shape mismatch in v and x");
  let l2 = au(1), u2 = Lu(l2, o2), d2 = xo(Lu(s2, i2), u2);
  if (a2) {
    Z(null != r2, () => "When using zeroDebias: true, step is required.");
    let e21 = Vi(r2, "step", "movingAverage");
    d2 = Ao(d2, Lu(l2, ru(o2, e21)));
  }
  return fo(i2, d2);
} });
var th = Wi({ scatterND_(e20, t2, n2) {
  Te(n2);
  let r2 = Vi(e20, "indices", "scatterND", "int32"), a2 = Vi(t2, "updates", "scatterND");
  return Wc(a2, r2, n2), $i.runKernel(Ar, { indices: r2, updates: a2 }, { shape: n2 });
} });
var nh = Wi({ sparseToDense_(e20, t2, n2, r2 = 0) {
  Te(n2);
  let a2 = Vi(e20, "sparseIndices", "sparseToDense", "int32"), i2 = Vi(t2, "sparseValues", "sparseToDense", "string_or_numeric"), s2 = Vi(r2, "defaultValue", "sparseToDense", i2.dtype);
  return ((e21, t3, n3, r3) => {
    if ("int32" !== e21.dtype) throw Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e21.dtype}.`);
    if (e21.rank > 2) throw Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e21.shape}.`);
    let a3 = e21.rank > 0 ? e21.shape[0] : 1, i3 = e21.rank > 1 ? e21.shape[1] : 1;
    if (n3.length !== i3) throw Error(`outputShape has incorrect number of elements:, ${n3.length}, should be: ${i3}.`);
    if (0 !== t3.rank && (1 !== t3.rank || t3.size !== a3)) throw Error(`sparseValues has incorrect shape ${t3.shape}, should be [] or [${a3}]`);
    if (t3.dtype !== r3.dtype) throw Error("sparseValues.dtype must match defaultValues.dtype");
  })(a2, i2, n2, s2), $i.runKernel(zr, { sparseIndices: a2, sparseValues: i2, defaultValue: s2 }, { outputShape: n2 });
} });
var rh = Wi({ gatherND_(e20, t2) {
  let n2 = Vi(t2, "indices", "gatherND", "int32"), r2 = { params: Vi(e20, "x", "gatherND", "string_or_numeric"), indices: n2 };
  return $i.runKernel(nn, r2);
} });
var ah = Wi({ dropout_(e20, t2, n2, r2) {
  let a2 = Vi(e20, "x", "dropout");
  if (Z("float32" === a2.dtype, () => `x has to be a floating point tensor since it's going to be scaled, but got a ${a2.dtype} tensor instead.`), Z(t2 >= 0 && 1 > t2, () => `rate must be a float in the range [0, 1), but got ${t2}.`), 0 === t2) return e20 instanceof ni ? a2.clone() : a2;
  let i2 = ((e21, t3) => {
    if (null == t3) return e21.shape.slice();
    if (te(e21.shape, t3)) return t3;
    if (e21.shape.length === t3.length) {
      let n3 = [];
      for (let r3 = 0; e21.shape.length > r3; r3++) n3.push(null == t3[r3] && null != e21.shape[r3] ? e21.shape[r3] : t3[r3]);
      return n3;
    }
    return t3;
  })(a2, n2), s2 = 1 - t2, o2 = Ao(Au(fo(Kd(i2, 0, 1, "float32", r2), s2)), s2);
  return xo(a2, o2);
} });
function ih(e20) {
  return Math.floor(Math.pow(2, Math.ceil(Math.log(e20) / Math.log(2))));
}
function sh(e20, t2, n2) {
  let r2 = 1 - e20 % 2, a2 = new Float32Array(e20);
  for (let i2 = 0; e20 > i2; ++i2) a2[i2] = t2 - n2 * Math.cos(2 * Math.PI * i2 / (e20 + r2 - 1));
  return Mc(a2, "float32");
}
var oh = (e20, t2, n2 = 1) => __async(null, null, function* () {
  let r2 = Vi(e20, "predictions", "inTopK"), a2 = Vi(t2, "targets", "inTopK");
  Z(r2.rank > 1, () => "inTopK() expects the predictions to be of rank 2 or higher, but got " + r2.rank), Z(r2.rank - 1 === a2.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${r2.rank} and targets rank ${a2.rank}`), K(r2.shape.slice(0, r2.shape.length - 1), a2.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
  let i2 = r2.shape[r2.shape.length - 1];
  Z(n2 > 0 && i2 >= n2, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i2}), but got ${n2}`);
  let s2 = yield r2.data(), o2 = yield a2.data(), [l2, u2] = [s2.length / i2, i2], d2 = ce("bool", l2);
  for (let c2 = 0; l2 > c2; c2++) {
    let e21 = c2 * u2, t3 = s2.subarray(e21, e21 + u2), r3 = [];
    for (let n3 = 0; t3.length > n3; n3++) r3.push({ value: t3[n3], index: n3 });
    r3.sort((e22, t4) => t4.value - e22.value), d2[c2] = 0;
    for (let a3 = 0; n2 > a3; a3++) if (r3[a3].index === o2[c2]) {
      d2[c2] = 1;
      break;
    }
  }
  return e20 !== r2 && r2.dispose(), t2 !== a2 && a2.dispose(), Ui(d2, a2.shape, "bool");
});
var lh = {};
A(lh, { conv2d() {
  return fh;
}, depthwiseConv2d() {
  return xh;
}, matMul() {
  return yh;
} });
var uh = Wi({ conv2DBackpropFilter_(e20, t2, n2, r2, a2, i2 = "NHWC", s2) {
  let o2 = e20;
  3 === e20.rank && (o2 = Ho(e20, [1, e20.shape[0], e20.shape[1], e20.shape[2]]));
  let l2 = t2;
  3 === l2.rank && (l2 = Ho(t2, [1, t2.shape[0], t2.shape[1], t2.shape[2]])), Z(4 === o2.rank, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${o2.shape}.`), Z(4 === l2.rank, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${l2.shape}.`), Z(4 === n2.length, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${n2}.`);
  let u2 = "NHWC" === i2 ? o2.shape[3] : o2.shape[1], d2 = "NHWC" === i2 ? l2.shape[3] : l2.shape[1];
  return Z(u2 === n2[2], () => `Error in conv2dDerFilter: depth of input ${u2}) must match input depth in filter (${n2[2]}.`), Z(d2 === n2[3], () => `Error in conv2dDerFilter: depth of dy (${d2}) must match output depth for filter (${n2[3]}).`), Go("conv2dDerFilter", a2, s2), $i.runKernel(gt, { x: o2, dy: l2 }, { strides: r2, pad: a2, dataFormat: i2, dimRoundingMode: s2, filterShape: n2 });
} });
function dh(e20, t2, n2) {
  if (null == n2 || "linear" === n2) return e20;
  if ("relu" === n2) return xo(e20, Ic(t2));
  throw Error(`Cannot compute gradient for fused activation ${n2}.`);
}
function ch(e20, t2) {
  let n2 = t2, r2 = zl(e20.shape, t2.shape);
  return r2.length > 0 && (n2 = ou(n2, r2)), Ho(n2, e20.shape);
}
function hh(e20, t2, n2, r2) {
  if ("linear" === t2) return e20;
  if ("relu" === t2) return tc(e20);
  if ("elu" === t2) return jl(e20);
  if ("relu6" === t2) return nc(e20);
  if ("prelu" === t2) return wd(e20, n2);
  if ("leakyrelu" === t2) return Nu(e20, r2);
  if ("sigmoid" === t2) return Yo(e20);
  throw Error(`Unknown fused activation ${t2}.`);
}
var ph = (e20, t2) => !(e20 > 0) || "linear" === t2;
var fh = Wi({ fusedConv2d_({ x: e20, filter: t2, strides: n2, pad: r2, dataFormat: a2 = "NHWC", dilations: i2 = [1, 1], dimRoundingMode: s2, bias: o2, activation: l2 = "linear", preluActivationWeights: u2, leakyreluAlpha: d2 }) {
  if (false === ph($i.state.gradientDepth, l2 = l2 || "linear")) {
    Z("NHWC" === a2, () => `Error in fused conv2d: got dataFormat of ${a2} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
    let c3 = yl(e20, t2, n2, r2, a2, i2, s2);
    return null != o2 && (c3 = fo(c3, o2)), hh(c3, l2, u2, d2);
  }
  let c2 = Vi(e20, "x", "conv2d", "float32"), h2 = Vi(t2, "filter", "conv2d", "float32"), p2 = c2, f2 = false;
  3 === c2.rank && (f2 = true, p2 = Ho(c2, [1, c2.shape[0], c2.shape[1], c2.shape[2]])), Z(4 === p2.rank, () => `Error in fused conv2d: input must be rank 4, but got rank ${p2.rank}.`), Z(4 === h2.rank, () => `Error in fused conv2d: filter must be rank 4, but got rank ${h2.rank}.`), Go("fused conv2d", r2, s2);
  let m2 = "NHWC" === a2 ? p2.shape[3] : p2.shape[1];
  Z(h2.shape[2] === m2, () => `Error in conv2d: depth of input (${m2}) must match input depth for filter ${h2.shape[2]}.`), Z(Bo(n2, i2), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n2} and dilations '${i2}'`);
  let A2, x2, y2 = Fo(p2.shape, h2.shape, n2, i2, r2, s2);
  if (null != o2 && (A2 = Vi(o2, "bias", "fused conv2d"), [A2] = xi(A2, c2), "NHWC" === a2 ? Vl(y2.outShape, A2.shape) : (Z(1 >= A2.shape.length, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${A2.shape.length}.`), Z(0 === A2.shape.length || A2.shape[0] === y2.outChannels || 1 === A2.shape[0], () => `Error in fused conv2d: bias shape (${A2.shape}) is not compatible with the number of output channels (${y2.outChannels})`))), null != u2) {
    let e21 = u2.shape;
    if (Z(1 >= e21.length || 3 === e21.length, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e21.length}.`), 1 === e21.length) Z(1 === e21[0] || e21[0] === y2.outChannels, () => `Error in fused conv2d: PReLU activation weights (${e21}) is not compatible with the number of output channels (${y2.outChannels}).`);
    else if (3 === e21.length) try {
      Vl(e21, y2.outShape);
    } catch (w2) {
      throw Error(`Error in fused conv2d: PReLU activation weights (${e21}) is not compatible with the output shape of the conv2d (${y2.outShape}).`);
    }
    x2 = Vi(u2, "prelu weights", "fused conv2d");
  }
  let b2 = (e21, t3) => {
    Z("NHWC" === a2, () => `Error in gradient of fused conv2D: got dataFormat of ${a2} but only NHWC is currently supported.`);
    let [s3, o3, u3, d3] = t3, c3 = dh(e21, u3, l2);
    Z(Lo(i2), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i2}'`);
    let h3 = [gl(o3.shape, c3, s3, n2, r2), uh(o3, c3, s3.shape, n2, r2)];
    if (null != d3) {
      let e22 = ch(d3, c3);
      h3.push(e22);
    }
    return h3;
  }, g2 = { x: p2, filter: h2, bias: A2, preluActivationWeights: x2 }, v2 = { strides: n2, pad: r2, dataFormat: a2, dilations: i2, dimRoundingMode: s2, activation: l2, leakyreluAlpha: d2 };
  return null == o2 ? zu((e21, t3, n3) => {
    let r3 = $i.runKernel(sa, g2, v2);
    return n3([t3, e21, r3]), f2 && (r3 = Ho(r3, [r3.shape[1], r3.shape[2], r3.shape[3]])), { value: r3, gradFunc: b2 };
  })(p2, h2) : zu((e21, t3, n3, r3) => {
    let a3 = $i.runKernel(sa, g2, v2);
    return r3([t3, e21, a3, n3]), f2 && (a3 = Ho(a3, [a3.shape[1], a3.shape[2], a3.shape[3]])), { value: a3, gradFunc: b2 };
  })(p2, h2, A2);
} });
var mh = Wi({ depthwiseConv2dNativeBackpropFilter_(e20, t2, n2, r2, a2, i2 = [1, 1], s2) {
  let o2 = e20;
  3 === e20.rank && (o2 = Ho(e20, [1, e20.shape[0], e20.shape[1], e20.shape[2]]));
  let l2 = t2;
  return 3 === l2.rank && (l2 = Ho(t2, [1, t2.shape[0], t2.shape[1], t2.shape[2]])), $i.runKernel(Ot, { x: o2, dy: l2 }, { strides: r2, pad: a2, dimRoundingMode: s2, dilations: i2, filterShape: n2 });
} });
var Ah = Wi({ depthwiseConv2dNativeBackpropInput_(e20, t2, n2, r2, a2, i2 = [1, 1], s2) {
  let o2 = t2, l2 = false;
  3 === t2.rank && (l2 = true, o2 = Ho(t2, [1, t2.shape[0], t2.shape[1], t2.shape[2]]));
  let u2 = $i.runKernel(Ft, { dy: o2, filter: n2 }, { strides: r2, pad: a2, dimRoundingMode: s2, dilations: i2, inputShape: e20 });
  return l2 ? Ho(u2, [u2.shape[1], u2.shape[2], u2.shape[3]]) : u2;
} });
var xh = Wi({ fusedDepthwiseConv2d_({ x: e20, filter: t2, strides: n2, pad: r2, dataFormat: a2 = "NHWC", dilations: i2 = [1, 1], dimRoundingMode: s2, bias: o2, activation: l2 = "linear", preluActivationWeights: u2, leakyreluAlpha: d2 }) {
  if (false === ph($i.state.gradientDepth, l2)) {
    let c3 = Tl(e20, t2, n2, r2, a2, i2, s2);
    return null != o2 && (c3 = fo(c3, o2)), hh(c3, l2, u2, d2);
  }
  let c2 = Vi(e20, "x", "depthwiseConv2d", "float32"), h2 = Vi(t2, "filter", "depthwiseConv2d", "float32"), p2 = c2, f2 = false;
  3 === c2.rank && (f2 = true, p2 = Ho(c2, [1, c2.shape[0], c2.shape[1], c2.shape[2]])), Z(4 === p2.rank, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p2.rank}.`), Z(4 === h2.rank, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h2.rank}.`), Z(p2.shape[3] === h2.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${p2.shape[3]}) must match the inChannels dimension in filter ${h2.shape[2]}.`), null == i2 && (i2 = [1, 1]), Z(Bo(n2, i2), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n2} and dilations '${i2}'`), Go("fused depthwiseConv2d", r2, s2);
  let m2, A2, x2 = Fo(p2.shape, h2.shape, n2, i2, r2, s2, true);
  null != o2 && (m2 = Vi(o2, "bias", "fused conv2d"), [m2] = xi(m2, c2), Vl(x2.outShape, m2.shape)), null != u2 && (A2 = Vi(u2, "prelu weights", "fused depthwiseConv2d"));
  let y2 = (e21, t3) => {
    Z(Lo(i2), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i2}'`);
    let [a3, o3, u3, d3] = t3, c3 = dh(e21, u3, l2), h3 = Ah(o3.shape, c3, a3, n2, r2, i2, s2), p3 = mh(o3, c3, a3.shape, n2, r2, i2, s2);
    return null != d3 ? [h3, p3, ch(m2, c3)] : [h3, p3];
  }, b2 = { x: p2, filter: h2, bias: m2, preluActivationWeights: A2 }, g2 = { strides: n2, pad: r2, dataFormat: a2, dilations: i2, dimRoundingMode: s2, activation: l2, leakyreluAlpha: d2 };
  return null == o2 ? zu((e21, t3, n3) => {
    let r3 = $i.runKernel(oa, b2, g2);
    return n3([t3, e21, r3]), f2 && (r3 = Ho(r3, [r3.shape[1], r3.shape[2], r3.shape[3]])), { value: r3, gradFunc: y2 };
  })(p2, h2) : zu((e21, t3, n3, r3) => {
    let a3 = $i.runKernel(oa, b2, g2);
    return r3([t3, e21, a3, n3]), f2 && (a3 = Ho(a3, [a3.shape[1], a3.shape[2], a3.shape[3]])), { value: a3, gradFunc: y2 };
  })(p2, h2, m2);
} });
var yh = Wi({ fusedMatMul_({ a: e20, b: t2, transposeA: n2 = false, transposeB: r2 = false, bias: a2, activation: i2 = "linear", preluActivationWeights: s2, leakyreluAlpha: o2 = 0.2 }) {
  if (false === ph($i.state.gradientDepth, i2)) {
    let l3 = Ko(e20, t2, n2, r2);
    return null != a2 && (l3 = fo(l3, a2)), hh(l3, i2, s2, o2);
  }
  let l2 = Vi(e20, "a", "fused matMul"), u2 = Vi(t2, "b", "fused matMul");
  [l2, u2] = xi(l2, u2);
  let d2 = n2 ? l2.shape[l2.rank - 2] : l2.shape[l2.rank - 1], c2 = r2 ? u2.shape[u2.rank - 1] : u2.shape[u2.rank - 2], h2 = n2 ? l2.shape[l2.rank - 1] : l2.shape[l2.rank - 2], p2 = r2 ? u2.shape[u2.rank - 2] : u2.shape[u2.rank - 1], f2 = l2.shape.slice(0, -2), m2 = u2.shape.slice(0, -2), A2 = J(f2), x2 = J(m2);
  Z(d2 === c2, () => `Error in fused matMul: inner shapes (${d2}) and (${c2}) of Tensors with shapes ${l2.shape} and ${u2.shape} and transposeA=${n2} and transposeB=${r2} must match.`);
  let y2, b2, g2 = Vl(l2.shape.slice(0, -2), u2.shape.slice(0, -2)).concat([h2, p2]), v2 = Ho(l2, n2 ? [A2, d2, h2] : [A2, h2, d2]), w2 = Ho(u2, r2 ? [x2, p2, c2] : [x2, c2, p2]);
  null != a2 && (y2 = Vi(a2, "bias", "fused matMul"), [y2] = xi(y2, l2), Vl(g2, y2.shape)), null != s2 && (b2 = Vi(s2, "prelu weights", "fused matMul"));
  let k2 = (e21, t3) => {
    let s3, o3, [l3, u3, d3, c3] = t3, h3 = dh(Ho(e21, d3.shape), d3, i2);
    return n2 || r2 ? !n2 && r2 ? (s3 = Ko(h3, u3, false, false), o3 = Ko(h3, l3, true, false)) : n2 && !r2 ? (s3 = Ko(u3, h3, false, true), o3 = Ko(l3, h3, false, false)) : (s3 = Ko(u3, h3, true, true), o3 = Ko(h3, l3, true, true)) : (s3 = Ko(h3, u3, false, true), o3 = Ko(l3, h3, true, false)), null != a2 ? [s3, o3, ch(c3, h3)] : [s3, o3];
  }, N2 = { a: v2, b: w2, bias: y2, preluActivationWeights: b2 }, C2 = { transposeA: n2, transposeB: r2, activation: i2, leakyreluAlpha: o2 };
  return null == a2 ? zu((e21, t3, n3) => {
    let r3 = $i.runKernel(ia, N2, C2);
    return n3([e21, t3, r3]), { value: Ho(r3, g2), gradFunc: k2 };
  })(v2, w2) : zu((e21, t3, n3, r3) => {
    let a3 = $i.runKernel(ia, N2, C2);
    return r3([e21, t3, a3, n3]), { value: Ho(a3, g2), gradFunc: k2 };
  })(v2, w2, y2);
} });
var bh = Wi({ hammingWindow_(e20) {
  return sh(e20, 0.54, 0.46);
} });
var gh = Wi({ hannWindow_(e20) {
  return sh(e20, 0.5, 0.5);
} });
var vh = Wi({ frame_(e20, t2, n2, r2 = false, a2 = 0) {
  let i2 = 0, s2 = [];
  for (; e20.size >= i2 + t2; ) s2.push(Jo(e20, i2, t2)), i2 += n2;
  if (r2) for (; e20.size > i2; ) {
    let r3 = i2 + t2 - e20.size, o2 = Zo([Jo(e20, i2, t2 - r3), hl([r3], a2)]);
    s2.push(o2), i2 += n2;
  }
  return 0 === s2.length ? Oc([], [0, t2]) : Ho(Zo(s2), [s2.length, t2]);
} });
var wh = Wi({ stft_(e20, t2, n2, r2, a2 = gh) {
  null == r2 && (r2 = ih(t2));
  let i2 = vh(e20, t2, n2), s2 = xo(i2, a2(t2));
  return Cc(s2, r2);
} });
var kh = Wi({ cropAndResize_(e20, t2, n2, r2, a2 = "bilinear", i2 = 0) {
  let s2 = Vi(e20, "image", "cropAndResize"), o2 = Vi(t2, "boxes", "cropAndResize", "float32"), l2 = Vi(n2, "boxInd", "cropAndResize", "int32"), u2 = o2.shape[0];
  return Z(4 === s2.rank, () => `Error in cropAndResize: image must be rank 4,but got rank ${s2.rank}.`), Z(2 === o2.rank && 4 === o2.shape[1], () => `Error in cropAndResize: boxes must be have size [${u2},4] but had shape ${o2.shape}.`), Z(1 === l2.rank && l2.shape[0] === u2, () => `Error in cropAndResize: boxInd must be have size [${u2}] but had shape ${o2.shape}.`), Z(2 === r2.length, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${r2.length}.`), Z(r2[0] >= 1 && r2[1] >= 1, () => "cropSize must be atleast [1,1], but was " + r2), Z("bilinear" === a2 || "nearest" === a2, () => "method must be bilinear or nearest, but was " + a2), $i.runKernel(It, { image: s2, boxes: o2, boxInd: l2 }, { method: a2, extrapolationValue: i2, cropSize: r2 });
} });
var Nh = Wi({ flipLeftRight_(e20) {
  let t2 = Vi(e20, "image", "flipLeftRight", "float32");
  return Z(4 === t2.rank, () => `Error in flipLeftRight: image must be rank 4,but got rank ${t2.rank}.`), $i.runKernel(Yt, { image: t2 }, {});
} });
var Ch = Wi({ grayscaleToRGB_(e20) {
  let t2 = Vi(e20, "image", "grayscaleToRGB"), n2 = t2.rank - 1, r2 = t2.shape[n2];
  Z(t2.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t2.rank}.`), Z(1 === r2, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r2}.`);
  let a2 = Array(t2.rank);
  return a2.fill(1, 0, n2), a2[n2] = 3, fu(t2, a2);
} });
var $h = Wi({ rgbToGrayscale_(e20) {
  let t2 = Vi(e20, "image", "RGBToGrayscale"), n2 = t2.shape[t2.rank - 1];
  Z(t2.rank >= 2, () => `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t2.rank}.`), Z(3 === n2, () => `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${n2}.`);
  let r2, a2 = t2.dtype, i2 = co(t2, "float32"), s2 = Mc([0.2989, 0.587, 0.114]);
  switch (t2.rank) {
    case 2:
      r2 = Ul("ij,j->i", i2, s2);
      break;
    case 3:
      r2 = Ul("ijk,k->ij", i2, s2);
      break;
    case 4:
      r2 = Ul("ijkl,l->ijk", i2, s2);
      break;
    case 5:
      r2 = Ul("ijklm,m->ijkl", i2, s2);
      break;
    case 6:
      r2 = Ul("ijklmn,n->ijklm", i2, s2);
      break;
    default:
      throw Error("Not a valid tensor rank.");
  }
  return r2 = hu(r2, -1), co(r2, a2);
} });
var Rh = Wi({ rotateWithOffset_(e20, t2, n2 = 0, r2 = 0.5) {
  let a2 = Vi(e20, "image", "rotateWithOffset", "float32");
  return Z(4 === a2.rank, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${a2.rank}.`), $i.runKernel(aa, { image: a2 }, { radians: t2, fillValue: n2, center: r2 });
} });
function Sh(e20, t2, n2, r2, a2, i2) {
  null == r2 && (r2 = 0.5), null == a2 && (a2 = -Infinity), null == i2 && (i2 = 0);
  let s2 = e20.shape[0];
  return n2 = Math.min(n2, s2), Z(r2 >= 0 && 1 >= r2, () => `iouThreshold must be in [0, 1], but was '${r2}'`), Z(2 === e20.rank, () => `boxes must be a 2D tensor, but was of rank '${e20.rank}'`), Z(4 === e20.shape[1], () => "boxes must have 4 columns, but 2nd dimension was " + e20.shape[1]), Z(1 === t2.rank, () => "scores must be a 1D tensor"), Z(t2.shape[0] === s2, () => `scores has incompatible shape with boxes. Expected ${s2}, but was ${t2.shape[0]}`), Z(i2 >= 0 && 1 >= i2, () => `softNmsSigma must be in [0, 1], but was '${i2}'`), { maxOutputSize: n2, iouThreshold: r2, scoreThreshold: a2, softNmsSigma: i2 };
}
var Ih = Wi({ nonMaxSuppression_(e20, t2, n2, r2 = 0.5, a2 = -Infinity) {
  let i2 = Vi(e20, "boxes", "nonMaxSuppression", "float32"), s2 = Vi(t2, "scores", "nonMaxSuppression", "float32"), o2 = Sh(i2, s2, n2, r2, a2);
  return $i.runKernel(Un, { boxes: i2, scores: s2 }, { maxOutputSize: n2 = o2.maxOutputSize, iouThreshold: r2 = o2.iouThreshold, scoreThreshold: a2 = o2.scoreThreshold });
} });
function Eh(e20, t2, n2) {
  let r2 = ((e21, t3, n3) => ((e22, t4, n4) => {
    let r3 = 0, a2 = e22.length, i2 = 0, s2 = false;
    for (; a2 > r3; ) {
      i2 = r3 + (a2 - r3 >>> 1);
      let o2 = n4(t4, e22[i2]);
      o2 > 0 ? r3 = i2 + 1 : (a2 = i2, s2 = !o2);
    }
    return s2 ? r3 : -r3 - 1;
  })(e21, t3, n3 || Th))(e20, t2, n2);
  e20.splice(0 > r2 ? -(r2 + 1) : r2, 0, t2);
}
function Th(e20, t2) {
  return e20 > t2 ? 1 : t2 > e20 ? -1 : 0;
}
function Mh(e20, t2, n2, r2, a2) {
  return Ph(e20, t2, n2, r2, a2, 0);
}
function Oh(e20, t2, n2, r2, a2, i2) {
  return Ph(e20, t2, n2, r2, a2, 0, false, i2, true);
}
function Fh(e20, t2, n2, r2, a2, i2) {
  return Ph(e20, t2, n2, r2, a2, i2, true);
}
function Ph(e20, t2, n2, r2, a2, i2, s2 = false, o2 = false, l2 = false) {
  let u2 = [];
  for (let A2 = 0; t2.length > A2; A2++) t2[A2] > a2 && u2.push({ score: t2[A2], boxIndex: A2, suppressBeginIndex: 0 });
  u2.sort(_h);
  let d2 = i2 > 0 ? -0.5 / i2 : 0, c2 = [], h2 = [];
  for (; n2 > c2.length && u2.length > 0; ) {
    let t3 = u2.pop(), { score: n3, boxIndex: i3, suppressBeginIndex: s3 } = t3;
    if (a2 > n3) break;
    let o3 = false;
    for (let l3 = c2.length - 1; l3 >= s3; --l3) {
      let n4 = zh(e20, i3, c2[l3]);
      if (n4 >= r2) {
        o3 = true;
        break;
      }
      if (t3.score = t3.score * Vh(r2, d2, n4), a2 >= t3.score) break;
    }
    t3.suppressBeginIndex = c2.length, o3 || (t3.score === n3 ? (c2.push(i3), h2.push(t3.score)) : t3.score > a2 && Eh(u2, t3, _h));
  }
  let p2 = c2.length, f2 = n2 - p2;
  o2 && f2 > 0 && (c2.push(...Array(f2).fill(0)), h2.push(...Array(f2).fill(0)));
  let m2 = { selectedIndices: c2 };
  return s2 && (m2.selectedScores = h2), l2 && (m2.validOutputs = p2), m2;
}
function zh(e20, t2, n2) {
  let r2 = e20.subarray(4 * t2, 4 * t2 + 4), a2 = e20.subarray(4 * n2, 4 * n2 + 4), i2 = Math.min(r2[0], r2[2]), s2 = Math.min(r2[1], r2[3]), o2 = Math.max(r2[0], r2[2]), l2 = Math.max(r2[1], r2[3]), u2 = Math.min(a2[0], a2[2]), d2 = Math.min(a2[1], a2[3]), c2 = Math.max(a2[0], a2[2]), h2 = Math.max(a2[1], a2[3]), p2 = (o2 - i2) * (l2 - s2), f2 = (c2 - u2) * (h2 - d2);
  if (0 >= p2 || 0 >= f2) return 0;
  let m2 = Math.max(i2, u2), A2 = Math.max(s2, d2), x2 = Math.min(o2, c2), y2 = Math.min(l2, h2), b2 = Math.max(x2 - m2, 0) * Math.max(y2 - A2, 0);
  return b2 / (p2 + f2 - b2);
}
function Vh(e20, t2, n2) {
  return n2 > e20 ? 0 : Math.exp(t2 * n2 * n2);
}
function _h(e20, t2) {
  return e20.score - t2.score || e20.score === t2.score && t2.boxIndex - e20.boxIndex;
}
var Dh = Wi({ nonMaxSuppressionWithScore_(e20, t2, n2, r2 = 0.5, a2 = -Infinity, i2 = 0) {
  let s2 = Vi(e20, "boxes", "nonMaxSuppression"), o2 = Vi(t2, "scores", "nonMaxSuppression"), l2 = Sh(s2, o2, n2, r2, a2, i2), u2 = $i.runKernel(Gn, { boxes: s2, scores: o2 }, { maxOutputSize: n2 = l2.maxOutputSize, iouThreshold: r2 = l2.iouThreshold, scoreThreshold: a2 = l2.scoreThreshold, softNmsSigma: i2 = l2.softNmsSigma });
  return { selectedIndices: u2[0], selectedScores: u2[1] };
} });
var Wh = Wi({ nonMaxSuppressionPadded_(e20, t2, n2, r2 = 0.5, a2 = -Infinity, i2 = false) {
  let s2 = Vi(e20, "boxes", "nonMaxSuppression"), o2 = Vi(t2, "scores", "nonMaxSuppression"), l2 = Sh(s2, o2, n2, r2, a2, null), u2 = $i.runKernel(jn, { boxes: s2, scores: o2 }, { maxOutputSize: l2.maxOutputSize, iouThreshold: l2.iouThreshold, scoreThreshold: l2.scoreThreshold, padToMaxOutputSize: i2 });
  return { selectedIndices: u2[0], validOutputs: u2[1] };
} });
var Lh = Wi({ resizeBilinear_(e20, t2, n2 = false, r2 = false) {
  let a2 = Vi(e20, "images", "resizeBilinear");
  Z(3 === a2.rank || 4 === a2.rank, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a2.rank}.`), Z(2 === t2.length, () => `Error in resizeBilinear: new shape must 2D, but got shape ${t2}.`), Z(false === r2 || false === n2, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
  let i2 = a2, s2 = false;
  3 === a2.rank && (s2 = true, i2 = Ho(a2, [1, a2.shape[0], a2.shape[1], a2.shape[2]]));
  let o2 = $i.runKernel(dr, { images: i2 }, { alignCorners: n2, halfPixelCenters: r2, size: t2 });
  return s2 ? Ho(o2, [o2.shape[1], o2.shape[2], o2.shape[3]]) : o2;
} });
var Bh = Wi({ resizeNearestNeighbor_(e20, t2, n2 = false, r2 = false) {
  let a2 = Vi(e20, "images", "resizeNearestNeighbor");
  Z(3 === a2.rank || 4 === a2.rank, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a2.rank}.`), Z(2 === t2.length, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t2}.`), Z("float32" === a2.dtype || "int32" === a2.dtype, () => "`images` must have `int32` or `float32` as dtype"), Z(false === r2 || false === n2, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
  let i2 = a2, s2 = false;
  3 === a2.rank && (s2 = true, i2 = Ho(a2, [1, a2.shape[0], a2.shape[1], a2.shape[2]]));
  let o2 = $i.runKernel(lr, { images: i2 }, { alignCorners: n2, halfPixelCenters: r2, size: t2 });
  return s2 ? Ho(o2, [o2.shape[1], o2.shape[2], o2.shape[3]]) : o2;
} });
var Uh = Wi({ threshold_(e20, t2 = "binary", n2 = false, r2 = 0.5) {
  let a2, i2, s2, o2, l2 = Vi(e20, "image", "threshold"), u2 = l2.shape[0] * l2.shape[1], d2 = xo(Mc([r2]), 255);
  if (Z(3 === l2.rank, () => `Error in threshold: image must be rank 3,but got rank ${l2.rank}.`), Z(3 === l2.shape[2] || 1 === l2.shape[2], () => `Error in threshold: image color channel must be equal to 3 or 1but got ${l2.shape[2]}.`), Z("int32" === l2.dtype || "float32" === l2.dtype, () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${l2.dtype}.`), Z("otsu" === t2 || "binary" === t2, () => "Method must be binary or otsu, but was " + t2), 3 === l2.shape[2]) {
    [a2, i2, s2] = Nc(l2, [1, 1, 1], -1);
    let e21 = xo(a2, 0.2989), t3 = xo(i2, 0.587), n3 = xo(s2, 0.114);
    o2 = fo(fo(e21, t3), n3);
  } else o2 = e20;
  "otsu" === t2 && (d2 = ((e21, t3) => {
    let n3, r3, a3, i3, s3, o3, l3 = Mc([-1]), u3 = Mc([0]), d3 = Mc([0]);
    for (let c3 = 0; e21.size - 1 > c3; c3++) {
      n3 = Jo(e21, 0, c3 + 1), r3 = Jo(e21, c3 + 1), s3 = Ao(ou(n3), t3), o3 = Ao(ou(r3), t3);
      let h2 = ou(xo(n3, Jd(0, n3.size)));
      a3 = Ao(h2, ou(n3));
      let p2 = hl(r3.shape, n3.size), f2 = fo(Jd(0, r3.size), p2), m2 = xo(r3, f2);
      i3 = Ao(ou(m2), ou(r3));
      let A2 = Lu(a3, i3), x2 = Lu(a3, i3), y2 = xo(s3, o3);
      d3 = xo(xo(y2, A2), x2);
      let b2 = yu(d3, u3);
      u3 = Dl(b2, d3, u3), l3 = Dl(b2, Mc([c3]), l3);
    }
    return l3;
  })(ol(co(lc(o2), "int32"), Ui([]), 256), u2));
  let c2 = n2 ? $u(o2, d2) : yu(o2, d2);
  return co(xo(c2, 255), "int32");
} });
var jh = Wi({ transform_(e20, t2, n2 = "nearest", r2 = "constant", a2 = 0, i2) {
  let s2 = Vi(e20, "image", "transform", "float32"), o2 = Vi(t2, "transforms", "transform", "float32");
  return Z(4 === s2.rank, () => `Error in transform: image must be rank 4,but got rank ${s2.rank}.`), Z(2 === o2.rank && (o2.shape[0] === s2.shape[0] || 1 === o2.shape[0]) && 8 === o2.shape[1], () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), Z(null == i2 || 2 === i2.length, () => `Error in transform: outputShape must be [height, width] or null, but got ${i2}.`), $i.runKernel(Zr, { image: s2, transforms: o2 }, { interpolation: n2, fillMode: r2, fillValue: a2, outputShape: i2 });
} });
var Gh = Wi({ bandPart_(e20, t2, n2) {
  let r2 = Vi(e20, "a", "bandPart");
  Z(r2.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${r2.rank}.`);
  let a2, i2, s2 = r2.shape, [o2, l2] = r2.shape.slice(-2);
  "number" == typeof t2 ? (Z(t2 % 1 == 0, () => `bandPart(): numLower must be an integer, got ${t2}.`), Z(o2 >= t2, () => `bandPart(): numLower (${t2}) must not be greater than the number of rows (${o2}).`), a2 = Vi(0 > t2 ? o2 : t2, "numLower", "bandPart")) : (Z("int32" === t2.dtype, () => "bandPart(): numLower's dtype must be an int32."), a2 = Dl(Cu(t2, 0), o2, id(t2, o2))), "number" == typeof n2 ? (Z(n2 % 1 == 0, () => `bandPart(): numUpper must be an integer, got ${n2}.`), Z(l2 >= n2, () => `bandPart(): numUpper (${n2}) must not be greater than the number of columns (${l2}).`), i2 = Vi(0 > n2 ? l2 : n2, "numUpper", "bandPart")) : (Z("int32" === n2.dtype, () => "bandPart(): numUpper's dtype must be an int32."), i2 = Dl(Cu(n2, 0), l2, id(n2, l2)));
  let u2 = Ho(Jd(0, o2, 1, "int32"), [-1, 1]), d2 = Jd(0, l2, 1, "int32"), c2 = Lu(u2, d2), h2 = ju($u(c2, a2), bu(c2, _u(i2))), p2 = nd([o2, l2], r2.dtype);
  return Ho(Sc(Xc(Ho(r2, [-1, o2, l2])).map((e21) => Dl(h2, e21, p2))), s2);
} });
var Hh = Wi({ gramSchmidt_(e20) {
  let t2;
  if (Array.isArray(e20)) {
    t2 = false, Z(null != e20 && e20.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
    let n3 = e20[0].shape[0];
    for (let t3 = 1; e20.length > t3; ++t3) Z(e20[t3].shape[0] === n3, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${e20[t3].shape[0]} vs. ${n3})`);
  } else t2 = true, e20 = Nc(e20, e20.shape[0], 0).map((e21) => Rc(e21, [0]));
  Z(e20[0].shape[0] >= e20.length, () => `Gram-Schmidt: Number of vectors (${e20.length}) exceeds number of dimensions (${e20[0].shape[0]}).`);
  let n2 = [], r2 = e20;
  for (let a2 = 0; e20.length > a2; ++a2) n2.push($i.tidy(() => {
    let e21 = r2[a2];
    if (a2 > 0) for (let t3 = 0; a2 > t3; ++t3) {
      let r3 = xo(ou(xo(n2[t3], e21)), n2[t3]);
      e21 = Lu(e21, r3);
    }
    return Ao(e21, uu(e21, "euclidean"));
  }));
  return t2 ? Sc(n2, 0) : n2;
} });
function Xh(e20, t2 = false) {
  return $i.tidy(() => {
    Z(2 === e20.shape.length, () => `qr2d() requires a 2D Tensor, but got a ${e20.shape.length}D Tensor.`);
    let n2 = e20.shape[0], r2 = e20.shape[1], a2 = mu(n2), i2 = ho(e20), s2 = Oc([[1]], [1, 1]), o2 = ho(s2), l2 = r2 > n2 ? n2 : r2;
    for (let e21 = 0; l2 > e21; ++e21) {
      let t3 = i2, l3 = o2, u2 = a2;
      [o2, i2, a2] = $i.tidy(() => {
        let t4 = Jo(i2, [e21, e21], [n2 - e21, 1]), l4 = uu(t4), u3 = Jo(i2, [e21, e21], [1, 1]), d2 = Dl(yu(u3, 0), Oc([[-1]]), Oc([[1]])), c2 = Lu(u3, xo(d2, l4)), h2 = Ao(t4, c2);
        o2 = 1 === h2.shape[0] ? ho(s2) : Zo([s2, Jo(h2, [1, 0], [h2.shape[0] - 1, h2.shape[1]])], 0);
        let p2 = _u(Ao(Ko(d2, c2), l4)), f2 = Jo(i2, [e21, 0], [n2 - e21, r2]), m2 = xo(p2, o2), A2 = Qc(o2);
        if (0 === e21) i2 = Lu(f2, Ko(m2, Ko(A2, f2)));
        else {
          let t5 = Lu(f2, Ko(m2, Ko(A2, f2)));
          i2 = Zo([Jo(i2, [0, 0], [e21, r2]), t5], 0);
        }
        let x2 = Qc(m2), y2 = Jo(a2, [0, e21], [n2, a2.shape[1] - e21]);
        if (0 === e21) a2 = Lu(y2, Ko(Ko(y2, o2), x2));
        else {
          let t5 = Lu(y2, Ko(Ko(y2, o2), x2));
          a2 = Zo([Jo(a2, [0, 0], [n2, e21]), t5], 1);
        }
        return [o2, i2, a2];
      }), ts([t3, l3, u2]);
    }
    return !t2 && n2 > r2 && (a2 = Jo(a2, [0, 0], [n2, r2]), i2 = Jo(i2, [0, 0], [r2, r2])), [a2, i2];
  });
}
var qh;
var Zh = Wi({ qr_(e20, t2 = false) {
  if (Z(e20.rank >= 2, () => "qr() requires input tensor to have a rank >= 2, but got rank " + e20.rank), 2 === e20.rank) return Xh(e20, t2);
  {
    let n2 = e20.shape.slice(0, e20.shape.length - 2).reduce((e21, t3) => e21 * t3), r2 = Xc(Ho(e20, [n2, e20.shape[e20.shape.length - 2], e20.shape[e20.shape.length - 1]]), 0), a2 = [], i2 = [];
    return r2.forEach((e21) => {
      let [n3, r3] = Xh(e21, t2);
      a2.push(n3), i2.push(r3);
    }), [Ho(Sc(a2, 0), e20.shape), Ho(Sc(i2, 0), e20.shape)];
  }
} });
((e20) => {
  e20[e20.NONE = 0] = "NONE", e20[e20.MEAN = 1] = "MEAN", e20[e20.SUM = 2] = "SUM", e20[e20.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(qh || (qh = {}));
var Kh = Wi({ computeWeightedLoss_(e20, t2, n2 = qh.SUM_BY_NONZERO_WEIGHTS) {
  let r2 = Vi(e20, "losses", "computeWeightedLoss"), a2 = null;
  null != t2 && (a2 = Vi(t2, "weights", "computeWeightedLoss"));
  let i2 = null == a2 ? r2 : xo(r2, a2);
  if (n2 === qh.NONE) return i2;
  if (n2 === qh.SUM) return ou(i2);
  if (n2 === qh.MEAN) {
    if (null == a2) return td(i2);
    {
      let e21 = r2.size / a2.size, t3 = Ao(ou(i2), ou(a2));
      return e21 > 1 ? Ao(t3, au(e21)) : t3;
    }
  }
  if (n2 === qh.SUM_BY_NONZERO_WEIGHTS) {
    if (null == a2) return Ao(ou(i2), au(r2.size));
    {
      let e21 = xo(a2, rd(r2.shape)), t3 = co(ou(cd(e21, au(0))), "float32");
      return Ao(ou(i2), t3);
    }
  }
  throw Error("Unknown reduction: " + n2);
} });
var Yh = Wi({ absoluteDifference_(e20, t2, n2, r2 = qh.SUM_BY_NONZERO_WEIGHTS) {
  let a2 = Vi(e20, "labels", "absoluteDifference"), i2 = Vi(t2, "predictions", "absoluteDifference"), s2 = null;
  null != n2 && (s2 = Vi(n2, "weights", "absoluteDifference")), K(a2.shape, i2.shape, "Error in absoluteDifference: ");
  let o2 = yo(Lu(a2, i2));
  return Kh(o2, s2, r2);
} });
var Jh = Wi({ cosineDistance_(e20, t2, n2, r2, a2 = qh.SUM_BY_NONZERO_WEIGHTS) {
  let i2 = Vi(e20, "labels", "cosineDistance"), s2 = Vi(t2, "predictions", "cosineDistance"), o2 = null;
  null != r2 && (o2 = Vi(r2, "weights", "cosineDistance")), K(i2.shape, s2.shape, "Error in cosineDistance: ");
  let l2 = au(1), u2 = Lu(l2, ou(xo(i2, s2), n2, true));
  return Kh(u2, o2, a2);
} });
var Qh = Wi({ hingeLoss_(e20, t2, n2, r2 = qh.SUM_BY_NONZERO_WEIGHTS) {
  let a2 = Vi(e20, "labels", "hingeLoss"), i2 = Vi(t2, "predictions", "hingeLoss"), s2 = null;
  null != n2 && (s2 = Vi(n2, "weights", "hingeLoss")), K(a2.shape, i2.shape, "Error in hingeLoss: ");
  let o2 = au(1);
  a2 = Lu(xo(au(2), a2), o2);
  let l2 = tc(Lu(o2, xo(a2, i2)));
  return Kh(l2, s2, r2);
} });
var ep = Wi({ huberLoss_(e20, t2, n2, r2 = 1, a2 = qh.SUM_BY_NONZERO_WEIGHTS) {
  let i2 = Vi(e20, "labels", "huberLoss"), s2 = Vi(t2, "predictions", "huberLoss"), o2 = null;
  null != n2 && (o2 = Vi(n2, "weights", "huberLoss")), K(i2.shape, s2.shape, "Error in huberLoss: ");
  let l2 = au(r2), u2 = yo(Lu(s2, i2)), d2 = id(u2, l2), c2 = Lu(u2, d2), h2 = fo(xo(au(0.5), su(d2)), xo(l2, c2));
  return Kh(h2, o2, a2);
} });
var tp = Wi({ logLoss_(e20, t2, n2, r2 = 1e-7, a2 = qh.SUM_BY_NONZERO_WEIGHTS) {
  let i2 = Vi(e20, "labels", "logLoss"), s2 = Vi(t2, "predictions", "logLoss"), o2 = null;
  null != n2 && (o2 = Vi(n2, "weights", "logLoss")), K(i2.shape, s2.shape, "Error in logLoss: ");
  let l2 = au(1), u2 = au(r2), d2 = _u(xo(i2, Iu(fo(s2, u2)))), c2 = xo(Lu(l2, i2), Iu(fo(Lu(l2, s2), u2))), h2 = Lu(d2, c2);
  return Kh(h2, o2, a2);
} });
var np = Wi({ meanSquaredError_(e20, t2, n2, r2 = qh.SUM_BY_NONZERO_WEIGHTS) {
  let a2 = Vi(e20, "labels", "meanSquaredError"), i2 = Vi(t2, "predictions", "meanSquaredError"), s2 = null;
  null != n2 && (s2 = Vi(n2, "weights", "meanSquaredError")), K(a2.shape, i2.shape, "Error in meanSquaredError: ");
  let o2 = $c(a2, i2);
  return Kh(o2, s2, r2);
} });
var rp = Wi({ sigmoidCrossEntropy_(e20, t2, n2, r2 = 0, a2 = qh.SUM_BY_NONZERO_WEIGHTS) {
  let i2 = Vi(e20, "multiClassLabels", "sigmoidCrossEntropy"), s2 = Vi(t2, "logits", "sigmoidCrossEntropy"), o2 = null;
  if (null != n2 && (o2 = Vi(n2, "weights", "sigmoidCrossEntropy")), K(i2.shape, s2.shape, "Error in sigmoidCrossEntropy: "), r2 > 0) {
    let e21 = au(r2), t3 = au(1), n3 = au(0.5);
    i2 = fo(xo(i2, Lu(t3, e21)), xo(n3, e21));
  }
  let l2 = ((e21, t3) => {
    let n3 = Vi(e21, "labels", "sigmoidCrossEntropyWithLogits"), r3 = Vi(t3, "logits", "sigmoidCrossEntropyWithLogits");
    K(n3.shape, r3.shape, "Error in sigmoidCrossEntropyWithLogits: ");
    let a3 = tc(r3), i3 = xo(r3, n3), s3 = Eu(cu(_u(yo(r3))));
    return fo(Lu(a3, i3), s3);
  })(i2, s2);
  return Kh(l2, o2, a2);
} });
var ap = Wi({ softmaxCrossEntropy_(e20, t2, n2, r2 = 0, a2 = qh.SUM_BY_NONZERO_WEIGHTS) {
  let i2 = Vi(e20, "onehotLabels", "softmaxCrossEntropy"), s2 = Vi(t2, "logits", "softmaxCrossEntropy"), o2 = null;
  if (null != n2 && (o2 = Vi(n2, "weights", "softmaxCrossEntropy")), K(i2.shape, s2.shape, "Error in softmaxCrossEntropy: "), r2 > 0) {
    let e21 = au(r2), t3 = au(1), n3 = au(i2.shape[1]);
    i2 = fo(xo(i2, Lu(t3, e21)), Ao(e21, n3));
  }
  let l2 = ((e21, t3, n3 = -1) => {
    if (-1 === n3 && (n3 = t3.rank - 1), n3 !== t3.rank - 1) throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t3.rank} and dim was ${n3}`);
    return zu((e22, t4, r3) => {
      let a3 = Uu(t4, [n3], true), i3 = Lu(co(t4, "float32"), a3);
      r3([e22, i3]);
      let s3 = _u(xo(i3, e22));
      return { value: ou(s3, [n3]), gradFunc(e23, t5) {
        let [r4, a4] = t5, i4 = Kl(e23.shape, [n3]);
        return [xo(Ho(e23, i4), Lu(co(r4, "float32"), cu(a4))), xo(Ho(e23, i4), Lu(cu(a4), co(r4, "float32")))];
      } };
    })(e21, t3);
  })(i2, s2);
  return Kh(l2, o2, a2);
} });
var ip = Wi({ sparseFillEmptyRows_(e20, t2, n2, r2) {
  let a2 = Vi(e20, "indices", "sparseFillEmptyRows", "int32"), i2 = Vi(t2, "values", "sparseFillEmptyRows"), s2 = Vi(n2, "denseShape", "sparseFillEmptyRows", "int32"), o2 = Vi(r2, "defaultValue", "sparseFillEmptyRows", i2.dtype);
  if (2 !== a2.rank) throw Error("Indices should be Tensor2D but received shape\n        " + a2.shape);
  if (1 !== i2.rank) throw Error("Values should be Tensor1D but received shape " + i2.shape);
  if (1 !== s2.rank) throw Error("Dense shape should be Tensor1D but received shape " + s2.shape);
  if (0 !== o2.rank) throw Error("Default value should be a scalar but received shape " + o2.shape);
  let l2 = $i.runKernel(Mr, { indices: a2, values: i2, denseShape: s2, defaultValue: o2 });
  return { outputIndices: l2[0], outputValues: l2[1], emptyRowIndicator: l2[2], reverseIndexMap: l2[3] };
} });
var sp = Wi({ sparseReshape_(e20, t2, n2) {
  let r2 = Vi(e20, "inputIndices", "sparseReshape", "int32"), a2 = Vi(t2, "inputShape", "sparseReshape", "int32"), i2 = Vi(n2, "newShape", "sparseReshape", "int32");
  if (2 !== r2.rank) throw Error("Input indices should be Tensor2D but received shape\n        " + r2.shape);
  if (1 !== a2.rank) throw Error("Input shape should be Tensor1D but received shape " + a2.shape);
  if (1 !== i2.rank) throw Error("New shape should be Tensor1D but received shape " + i2.shape);
  let s2 = $i.runKernel(Or, { inputIndices: r2, inputShape: a2, newShape: i2 });
  return { outputIndices: s2[0], outputShape: s2[1] };
} });
var op = Wi({ sparseSegmentMean_(e20, t2, n2) {
  let r2 = Vi(e20, "data", "sparseSegmentMean"), a2 = Vi(t2, "indices", "sparseSegmentMean", "int32"), i2 = Vi(n2, "segmentIds", "sparseSegmentMean", "int32");
  if (1 > r2.rank) throw Error("Data should be at least 1 dimensional but received scalar");
  if (1 !== a2.rank) throw Error("Indices should be Tensor1D but received shape\n          " + a2.shape);
  if (1 !== i2.rank) throw Error("Segment ids should be Tensor1D but received shape\n          " + i2.shape);
  return $i.runKernel(Fr, { data: r2, indices: a2, segmentIds: i2 });
} });
var lp = Wi({ sparseSegmentSum_(e20, t2, n2) {
  let r2 = Vi(e20, "data", "sparseSegmentSum"), a2 = Vi(t2, "indices", "sparseSegmentSum", "int32"), i2 = Vi(n2, "segmentIds", "sparseSegmentSum", "int32");
  if (1 > r2.rank) throw Error("Data should be at least 1 dimensional but received scalar");
  if (1 !== a2.rank) throw Error("Indices should be Tensor1D but received shape\n         " + a2.shape);
  if (1 !== i2.rank) throw Error("Segment ids should be Tensor1D but received shape\n         " + i2.shape);
  return $i.runKernel(Pr, { data: r2, indices: a2, segmentIds: i2 });
} });
var up = Wi({ stringNGrams_(e20, t2, n2, r2, a2, i2, s2, o2) {
  let l2 = Vi(e20, "data", "stringNGrams", "string");
  if ("string" !== l2.dtype) throw Error("Data must be of datatype string");
  if (1 !== l2.shape.length) throw Error("Data must be a vector, saw: " + l2.shape);
  let u2 = Vi(t2, "dataSplits", "stringNGrams");
  if ("int32" !== u2.dtype) throw Error("Data splits must be of datatype int32");
  let d2 = $i.runKernel(Lr, { data: l2, dataSplits: u2 }, { separator: n2, nGramWidths: r2, leftPad: a2, rightPad: i2, padWidth: s2, preserveShortSequences: o2 });
  return { nGrams: d2[0], nGramsSplits: d2[1] };
} });
var dp = Wi({ stringSplit_(e20, t2, n2 = true) {
  let r2 = Vi(e20, "input", "stringSplit", "string"), a2 = Vi(t2, "delimiter", "stringSplit", "string");
  if (1 !== r2.rank) throw Error("Input should be Tensor1D but received shape " + r2.shape);
  if (0 !== a2.rank) throw Error("Delimiter should be a scalar but received shape " + a2.shape);
  let i2 = $i.runKernel(Br, { input: r2, delimiter: a2 }, { skipEmpty: n2 });
  return { indices: i2[0], values: i2[1], shape: i2[2] };
} });
var cp = Wi({ stringToHashBucketFast_(e20, t2) {
  let n2 = Vi(e20, "input", "stringToHashBucketFast", "string"), r2 = { numBuckets: t2 };
  if (0 >= t2) throw Error("Number of buckets must be at least 1");
  return $i.runKernel(Ur, { input: n2 }, r2);
} });
var hp = Wi({ staticRegexReplace_(e20, t2, n2, r2 = true) {
  let a2 = Vi(e20, "input", "staticRegexReplace", "string");
  return $i.runKernel(Dr, { x: a2 }, { pattern: t2, rewrite: n2, replaceGlobal: r2 });
} });
var pp = { fft: vc, ifft: wc, rfft: Cc, irfft: kc };
var fp = { hammingWindow: bh, hannWindow: gh, frame: vh, stft: wh };
var mp = { flipLeftRight: Nh, grayscaleToRGB: Ch, resizeNearestNeighbor: Bh, resizeBilinear: Lh, rgbToGrayscale: $h, rotateWithOffset: Rh, cropAndResize: kh, nonMaxSuppression: Ih, nonMaxSuppressionAsync(e20, t2, n2, r2 = 0.5, a2 = -Infinity) {
  return __async(this, null, function* () {
    let i2 = Vi(e20, "boxes", "nonMaxSuppressionAsync"), s2 = Vi(t2, "scores", "nonMaxSuppressionAsync"), o2 = Sh(i2, s2, n2, r2, a2);
    n2 = o2.maxOutputSize, r2 = o2.iouThreshold, a2 = o2.scoreThreshold;
    let l2 = yield Promise.all([i2.data(), s2.data()]), u2 = l2[0], d2 = l2[1], { selectedIndices: c2 } = Mh(u2, d2, n2, r2, a2);
    return i2 !== e20 && i2.dispose(), s2 !== t2 && s2.dispose(), Mc(c2, "int32");
  });
}, nonMaxSuppressionWithScore: Dh, nonMaxSuppressionWithScoreAsync(e20, t2, n2, r2 = 0.5, a2 = -Infinity, i2 = 0) {
  return __async(this, null, function* () {
    let s2 = Vi(e20, "boxes", "nonMaxSuppressionAsync"), o2 = Vi(t2, "scores", "nonMaxSuppressionAsync"), l2 = Sh(s2, o2, n2, r2, a2, i2);
    n2 = l2.maxOutputSize, r2 = l2.iouThreshold, a2 = l2.scoreThreshold, i2 = l2.softNmsSigma;
    let u2 = yield Promise.all([s2.data(), o2.data()]), d2 = u2[0], c2 = u2[1], { selectedIndices: h2, selectedScores: p2 } = Fh(d2, c2, n2, r2, a2, i2);
    return s2 !== e20 && s2.dispose(), o2 !== t2 && o2.dispose(), { selectedIndices: Mc(h2, "int32"), selectedScores: Mc(p2) };
  });
}, nonMaxSuppressionPadded: Wh, nonMaxSuppressionPaddedAsync(e20, t2, n2, r2 = 0.5, a2 = -Infinity, i2 = false) {
  return __async(this, null, function* () {
    let s2 = Vi(e20, "boxes", "nonMaxSuppressionAsync"), o2 = Vi(t2, "scores", "nonMaxSuppressionAsync"), l2 = Sh(s2, o2, n2, r2, a2, null), u2 = l2.maxOutputSize, d2 = l2.iouThreshold, c2 = l2.scoreThreshold, [h2, p2] = yield Promise.all([s2.data(), o2.data()]), { selectedIndices: f2, validOutputs: m2 } = Oh(h2, p2, u2, d2, c2, i2);
    return s2 !== e20 && s2.dispose(), o2 !== t2 && o2.dispose(), { selectedIndices: Mc(f2, "int32"), validOutputs: au(m2, "int32") };
  });
}, threshold: Uh, transform: jh };
var Ap = { bandPart: Gh, gramSchmidt: Hh, qr: Zh };
var xp = { absoluteDifference: Yh, computeWeightedLoss: Kh, cosineDistance: Jh, hingeLoss: Qh, huberLoss: ep, logLoss: tp, meanSquaredError: np, sigmoidCrossEntropy: rp, softmaxCrossEntropy: ap };
var yp = { sparseFillEmptyRows: ip, sparseReshape: sp, sparseSegmentMean: op, sparseSegmentSum: lp };
var bp = { stringNGrams: up, stringSplit: dp, stringToHashBucketFast: cp, staticRegexReplace: hp };
var gp = {};
A(gp, { Serializable() {
  return kp;
}, SerializationMap() {
  return Np;
}, getRegisteredName() {
  return $p;
}, registerClass() {
  return Cp;
} });
var vp = /* @__PURE__ */ new Map();
var wp = /* @__PURE__ */ new Map();
var kp = class {
  getClassName() {
    return this.constructor.className;
  }
  static fromConfig(e20, t2) {
    return new e20(t2);
  }
};
var Np = class e6 {
  constructor() {
    this.classNameMap = {};
  }
  static getMap() {
    return null == e6.instance && (e6.instance = new e6()), e6.instance;
  }
  static register(t2) {
    e6.getMap().classNameMap[t2.className] = [t2, t2.fromConfig];
  }
};
function Cp(e20, t2, n2) {
  Z(null != e20.className, () => "Class being registered does not have the static className property defined."), Z("string" == typeof e20.className, () => "className is required to be a string, but got type " + typeof e20.className), Z(e20.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), void 0 === t2 && (t2 = "Custom"), void 0 === n2 && (n2 = e20.className);
  let r2 = t2 + ">" + n2;
  return Np.register(e20), vp.set(r2, e20), wp.set(e20, r2), e20;
}
function $p(e20) {
  return wp.has(e20) ? wp.get(e20) : e20.className;
}
var Rp = class extends kp {
  minimize(e20, t2 = false, n2) {
    let { value: r2, grads: a2 } = this.computeGradients(e20, n2);
    if (null != n2) {
      let e21 = n2.map((e22) => ({ name: e22.name, tensor: a2[e22.name] }));
      this.applyGradients(e21);
    } else this.applyGradients(a2);
    return ts(a2), t2 ? r2 : (r2.dispose(), null);
  }
  get iterations() {
    return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
  }
  incrementIterations() {
    this.iterations_ = this.iterations + 1;
  }
  computeGradients(e20, t2) {
    return Pu(e20, t2);
  }
  dispose() {
    null != this.iterations_ && ts(this.iterations_);
  }
  saveIterations() {
    return __async(this, null, function* () {
      return null == this.iterations_ && (this.iterations_ = 0), { name: "iter", tensor: au(this.iterations_, "int32") };
    });
  }
  getWeights() {
    return __async(this, null, function* () {
      throw Error("getWeights() is not implemented for this optimizer yet.");
    });
  }
  setWeights(e20) {
    return __async(this, null, function* () {
      throw Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
    });
  }
  extractIterations(e20) {
    return __async(this, null, function* () {
      return this.iterations_ = (yield e20[0].tensor.data())[0], e20.slice(1);
    });
  }
};
Object.defineProperty(Rp, Symbol.hasInstance, { value(e20) {
  return null != e20.minimize && null != e20.computeGradients && null != e20.applyGradients;
} });
var Sp = class extends Rp {
  static get className() {
    return "Adadelta";
  }
  constructor(e20, t2, n2 = null) {
    super(), this.learningRate = e20, this.rho = t2, this.epsilon = n2, this.accumulatedGrads = [], this.accumulatedUpdates = [], null == n2 && (this.epsilon = $i.backend.epsilon());
  }
  applyGradients(e20) {
    (Array.isArray(e20) ? e20.map((e21) => e21.name) : Object.keys(e20)).forEach((t2, n2) => {
      let r2 = $i.registeredVariables[t2], a2 = false;
      null == this.accumulatedGrads[n2] && (this.accumulatedGrads[n2] = { originalName: t2 + "/accum_grad", variable: es(() => Wl(r2).variable(a2)) }), null == this.accumulatedUpdates[n2] && (this.accumulatedUpdates[n2] = { originalName: t2 + "/accum_var", variable: es(() => Wl(r2).variable(a2)) });
      let i2 = Array.isArray(e20) ? e20[n2].tensor : e20[t2];
      if (null == i2) return;
      let s2 = this.accumulatedGrads[n2].variable, o2 = this.accumulatedUpdates[n2].variable;
      es(() => {
        let e21 = fo(xo(s2, this.rho), xo(su(i2), 1 - this.rho)), t3 = xo(Ao(iu(fo(o2, this.epsilon)), iu(fo(s2, this.epsilon))), i2), n3 = fo(xo(o2, this.rho), xo(su(t3), 1 - this.rho));
        s2.assign(e21), o2.assign(n3);
        let a3 = fo(xo(t3, -this.learningRate), r2);
        r2.assign(a3);
      });
    }), this.incrementIterations();
  }
  dispose() {
    null != this.accumulatedUpdates && (ts(this.accumulatedGrads.map((e20) => e20.variable)), ts(this.accumulatedUpdates.map((e20) => e20.variable)));
  }
  getWeights() {
    return __async(this, null, function* () {
      let e20 = [...this.accumulatedGrads, ...this.accumulatedUpdates];
      return [yield this.saveIterations()].concat(e20.map((e21) => ({ name: e21.originalName, tensor: e21.variable })));
    });
  }
  setWeights(e20) {
    return __async(this, null, function* () {
      let t2 = (e20 = yield this.extractIterations(e20)).length / 2, n2 = false;
      this.accumulatedGrads = e20.slice(0, t2).map((e21) => ({ originalName: e21.name, variable: e21.tensor.variable(n2) })), this.accumulatedUpdates = e20.slice(t2, 2 * t2).map((e21) => ({ originalName: e21.name, variable: e21.tensor.variable(n2) }));
    });
  }
  getConfig() {
    return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
  }
  static fromConfig(e20, t2) {
    return new e20(t2.learningRate, t2.rho, t2.epsilon);
  }
};
var Ip = class extends Rp {
  static get className() {
    return "Adagrad";
  }
  constructor(e20, t2 = 0.1) {
    super(), this.learningRate = e20, this.initialAccumulatorValue = t2, this.accumulatedGrads = [];
  }
  applyGradients(e20) {
    (Array.isArray(e20) ? e20.map((e21) => e21.name) : Object.keys(e20)).forEach((t2, n2) => {
      let r2 = $i.registeredVariables[t2];
      null == this.accumulatedGrads[n2] && (this.accumulatedGrads[n2] = { originalName: t2 + "/accumulator", variable: es(() => hl(r2.shape, this.initialAccumulatorValue).variable(false)) });
      let a2 = Array.isArray(e20) ? e20[n2].tensor : e20[t2];
      if (null == a2) return;
      let i2 = this.accumulatedGrads[n2].variable;
      es(() => {
        let e21 = fo(i2, su(a2));
        i2.assign(e21);
        let t3 = fo(xo(Ao(a2, iu(fo(e21, $i.backend.epsilon()))), -this.learningRate), r2);
        r2.assign(t3);
      });
    }), this.incrementIterations();
  }
  dispose() {
    null != this.accumulatedGrads && ts(this.accumulatedGrads.map((e20) => e20.variable));
  }
  getWeights() {
    return __async(this, null, function* () {
      return [yield this.saveIterations()].concat(this.accumulatedGrads.map((e20) => ({ name: e20.originalName, tensor: e20.variable })));
    });
  }
  setWeights(e20) {
    return __async(this, null, function* () {
      e20 = yield this.extractIterations(e20), this.accumulatedGrads = e20.map((e21) => ({ originalName: e21.name, variable: e21.tensor.variable(false) }));
    });
  }
  getConfig() {
    return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
  }
  static fromConfig(e20, t2) {
    return new e20(t2.learningRate, t2.initialAccumulatorValue);
  }
};
var Ep = class extends Rp {
  static get className() {
    return "Adam";
  }
  constructor(e20, t2, n2, r2 = null) {
    super(), this.learningRate = e20, this.beta1 = t2, this.beta2 = n2, this.epsilon = r2, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], es(() => {
      this.accBeta1 = au(t2).variable(), this.accBeta2 = au(n2).variable();
    }), null == r2 && (this.epsilon = $i.backend.epsilon());
  }
  applyGradients(e20) {
    let t2 = Array.isArray(e20) ? e20.map((e21) => e21.name) : Object.keys(e20);
    es(() => {
      let n2 = Lu(1, this.accBeta1), r2 = Lu(1, this.accBeta2);
      t2.forEach((t3, a2) => {
        let i2 = $i.registeredVariables[t3], s2 = false;
        null == this.accumulatedFirstMoment[a2] && (this.accumulatedFirstMoment[a2] = { originalName: t3 + "/m", variable: es(() => Wl(i2).variable(s2)) }), null == this.accumulatedSecondMoment[a2] && (this.accumulatedSecondMoment[a2] = { originalName: t3 + "/v", variable: es(() => Wl(i2).variable(s2)) });
        let o2 = Array.isArray(e20) ? e20[a2].tensor : e20[t3];
        if (null == o2) return;
        let l2 = this.accumulatedFirstMoment[a2].variable, u2 = this.accumulatedSecondMoment[a2].variable, d2 = fo(xo(l2, this.beta1), xo(o2, 1 - this.beta1)), c2 = fo(xo(u2, this.beta2), xo(su(o2), 1 - this.beta2)), h2 = Ao(d2, n2), p2 = Ao(c2, r2);
        l2.assign(d2), u2.assign(c2);
        let f2 = fo(xo(Ao(h2, fo(iu(p2), this.epsilon)), -this.learningRate), i2);
        i2.assign(f2);
      }), this.accBeta1.assign(xo(this.accBeta1, this.beta1)), this.accBeta2.assign(xo(this.accBeta2, this.beta2));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && ts(this.accumulatedFirstMoment.map((e20) => e20.variable)), null != this.accumulatedSecondMoment && ts(this.accumulatedSecondMoment.map((e20) => e20.variable));
  }
  getWeights() {
    return __async(this, null, function* () {
      let e20 = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
      return [yield this.saveIterations()].concat(e20.map((e21) => ({ name: e21.originalName, tensor: e21.variable })));
    });
  }
  setWeights(e20) {
    return __async(this, null, function* () {
      e20 = yield this.extractIterations(e20), es(() => {
        this.accBeta1.assign(ru(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(ru(this.beta2, this.iterations_ + 1));
      });
      let t2 = e20.length / 2, n2 = false;
      this.accumulatedFirstMoment = e20.slice(0, t2).map((e21) => ({ originalName: e21.name, variable: e21.tensor.variable(n2) })), this.accumulatedSecondMoment = e20.slice(t2, 2 * t2).map((e21) => ({ originalName: e21.name, variable: e21.tensor.variable(n2) }));
    });
  }
  getConfig() {
    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
  }
  static fromConfig(e20, t2) {
    return new e20(t2.learningRate, t2.beta1, t2.beta2, t2.epsilon);
  }
};
var Tp = class extends Rp {
  static get className() {
    return "Adamax";
  }
  constructor(e20, t2, n2, r2 = null, a2 = 0) {
    super(), this.learningRate = e20, this.beta1 = t2, this.beta2 = n2, this.epsilon = r2, this.decay = a2, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], es(() => {
      this.iteration = au(0).variable(), this.accBeta1 = au(t2).variable();
    }), null == r2 && (this.epsilon = $i.backend.epsilon());
  }
  applyGradients(e20) {
    let t2 = Array.isArray(e20) ? e20.map((e21) => e21.name) : Object.keys(e20);
    es(() => {
      let n2 = Lu(1, this.accBeta1), r2 = Ao(-this.learningRate, fo(xo(this.iteration, this.decay), 1));
      t2.forEach((t3, a2) => {
        let i2 = $i.registeredVariables[t3], s2 = false;
        null == this.accumulatedFirstMoment[a2] && (this.accumulatedFirstMoment[a2] = { originalName: t3 + "/m", variable: Wl(i2).variable(s2) }), null == this.accumulatedWeightedInfNorm[a2] && (this.accumulatedWeightedInfNorm[a2] = { originalName: t3 + "/v", variable: Wl(i2).variable(s2) });
        let o2 = Array.isArray(e20) ? e20[a2].tensor : e20[t3];
        if (null == o2) return;
        let l2 = this.accumulatedFirstMoment[a2].variable, u2 = this.accumulatedWeightedInfNorm[a2].variable, d2 = fo(xo(l2, this.beta1), xo(o2, 1 - this.beta1)), c2 = xo(u2, this.beta2), h2 = yo(o2), p2 = ed(c2, h2);
        l2.assign(d2), u2.assign(p2);
        let f2 = fo(xo(Ao(r2, n2), Ao(d2, fo(p2, this.epsilon))), i2);
        i2.assign(f2);
      }), this.iteration.assign(fo(this.iteration, 1)), this.accBeta1.assign(xo(this.accBeta1, this.beta1));
    }), this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && ts(this.accumulatedFirstMoment.map((e20) => e20.variable)), null != this.accumulatedWeightedInfNorm && ts(this.accumulatedWeightedInfNorm.map((e20) => e20.variable));
  }
  getWeights() {
    return __async(this, null, function* () {
      throw Error("getWeights() is not implemented for Adamax yet.");
    });
  }
  setWeights(e20) {
    return __async(this, null, function* () {
      throw Error("setWeights() is not implemented for Adamax yet.");
    });
  }
  getConfig() {
    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };
  }
  static fromConfig(e20, t2) {
    return new e20(t2.learningRate, t2.beta1, t2.beta2, t2.epsilon, t2.decay);
  }
};
var Mp = class extends Rp {
  static get className() {
    return "SGD";
  }
  constructor(e20) {
    super(), this.learningRate = e20, this.setLearningRate(e20);
  }
  applyGradients(e20) {
    (Array.isArray(e20) ? e20.map((e21) => e21.name) : Object.keys(e20)).forEach((t2, n2) => {
      let r2 = Array.isArray(e20) ? e20[n2].tensor : e20[t2];
      if (null == r2) return;
      let a2 = $i.registeredVariables[t2];
      es(() => {
        let e21 = fo(xo(this.c, r2), a2);
        a2.assign(e21);
      });
    }), this.incrementIterations();
  }
  setLearningRate(e20) {
    this.learningRate = e20, null != this.c && this.c.dispose(), this.c = ns(au(-e20));
  }
  dispose() {
    this.c.dispose();
  }
  getWeights() {
    return __async(this, null, function* () {
      return [yield this.saveIterations()];
    });
  }
  setWeights(e20) {
    return __async(this, null, function* () {
      if (0 !== (e20 = yield this.extractIterations(e20)).length) throw Error("SGD optimizer does not have settable weights.");
    });
  }
  getConfig() {
    return { learningRate: this.learningRate };
  }
  static fromConfig(e20, t2) {
    return new e20(t2.learningRate);
  }
};
var Op = class extends Mp {
  static get className() {
    return "Momentum";
  }
  constructor(e20, t2, n2 = false) {
    super(e20), this.learningRate = e20, this.momentum = t2, this.useNesterov = n2, this.accumulations = [], this.m = au(this.momentum);
  }
  applyGradients(e20) {
    (Array.isArray(e20) ? e20.map((e21) => e21.name) : Object.keys(e20)).forEach((t2, n2) => {
      let r2 = $i.registeredVariables[t2];
      null == this.accumulations[n2] && (this.accumulations[n2] = { originalName: t2 + "/momentum", variable: es(() => Wl(r2).variable(false)) });
      let a2 = this.accumulations[n2].variable, i2 = Array.isArray(e20) ? e20[n2].tensor : e20[t2];
      null != i2 && es(() => {
        let e21, t3 = fo(xo(this.m, a2), i2);
        e21 = fo(xo(this.c, this.useNesterov ? fo(i2, xo(t3, this.m)) : t3), r2), a2.assign(t3), r2.assign(e21);
      });
    }), this.incrementIterations();
  }
  dispose() {
    this.m.dispose(), null != this.accumulations && ts(this.accumulations.map((e20) => e20.variable));
  }
  setMomentum(e20) {
    this.momentum = e20;
  }
  getWeights() {
    return __async(this, null, function* () {
      return [yield this.saveIterations()].concat(this.accumulations.map((e20) => ({ name: e20.originalName, tensor: e20.variable })));
    });
  }
  setWeights(e20) {
    return __async(this, null, function* () {
      e20 = yield this.extractIterations(e20), this.accumulations = e20.map((e21) => ({ originalName: e21.name, variable: e21.tensor.variable(false) }));
    });
  }
  getConfig() {
    return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
  }
  static fromConfig(e20, t2) {
    return new e20(t2.learningRate, t2.momentum, t2.useNesterov);
  }
};
var Fp = class extends Rp {
  static get className() {
    return "RMSProp";
  }
  constructor(e20, t2 = 0.9, n2 = 0, r2 = null, a2 = false) {
    if (super(), this.learningRate = e20, this.decay = t2, this.momentum = n2, this.epsilon = r2, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = a2, null == r2 && (this.epsilon = $i.backend.epsilon()), null == e20) throw Error("learningRate for RMSPropOptimizer must be defined.");
  }
  applyGradients(e20) {
    (Array.isArray(e20) ? e20.map((e21) => e21.name) : Object.keys(e20)).forEach((t2, n2) => {
      let r2 = $i.registeredVariables[t2], a2 = false;
      null == this.accumulatedMeanSquares[n2] && (this.accumulatedMeanSquares[n2] = { originalName: t2 + "/rms", variable: es(() => Wl(r2).variable(a2)) }), null == this.accumulatedMoments[n2] && (this.accumulatedMoments[n2] = { originalName: t2 + "/momentum", variable: es(() => Wl(r2).variable(a2)) }), null == this.accumulatedMeanGrads[n2] && this.centered && (this.accumulatedMeanGrads[n2] = { originalName: t2 + "/mg", variable: es(() => Wl(r2).variable(a2)) });
      let i2 = Array.isArray(e20) ? e20[n2].tensor : e20[t2];
      if (null == i2) return;
      let s2 = this.accumulatedMeanSquares[n2].variable, o2 = this.accumulatedMoments[n2].variable;
      es(() => {
        let e21 = fo(xo(s2, this.decay), xo(su(i2), 1 - this.decay));
        if (this.centered) {
          let t3 = this.accumulatedMeanGrads[n2].variable, a3 = fo(xo(t3, this.decay), xo(i2, 1 - this.decay)), l2 = Ao(xo(i2, this.learningRate), iu(Lu(e21, fo(su(a3), this.epsilon)))), u2 = fo(xo(o2, this.momentum), l2);
          s2.assign(e21), t3.assign(a3), o2.assign(u2);
          let d2 = Lu(r2, u2);
          r2.assign(d2);
        } else {
          let e22 = fo(xo(s2, this.decay), xo(su(i2), 1 - this.decay)), t3 = fo(xo(o2, this.momentum), Ao(xo(i2, this.learningRate), iu(fo(e22, this.epsilon))));
          s2.assign(e22), o2.assign(t3);
          let n3 = Lu(r2, t3);
          r2.assign(n3);
        }
      });
    }), this.incrementIterations();
  }
  dispose() {
    null != this.accumulatedMeanSquares && ts(this.accumulatedMeanSquares.map((e20) => e20.variable)), null != this.accumulatedMeanGrads && this.centered && ts(this.accumulatedMeanGrads.map((e20) => e20.variable)), null != this.accumulatedMoments && ts(this.accumulatedMoments.map((e20) => e20.variable));
  }
  getWeights() {
    return __async(this, null, function* () {
      let e20 = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
      return this.centered && e20.push(...this.accumulatedMeanGrads), [yield this.saveIterations()].concat(e20.map((e21) => ({ name: e21.originalName, tensor: e21.variable })));
    });
  }
  setWeights(e20) {
    return __async(this, null, function* () {
      e20 = yield this.extractIterations(e20);
      let t2 = this.centered ? e20.length / 3 : e20.length / 2, n2 = false;
      this.accumulatedMeanSquares = e20.slice(0, t2).map((e21) => ({ originalName: e21.name, variable: e21.tensor.variable(n2) })), this.accumulatedMoments = e20.slice(t2, 2 * t2).map((e21) => ({ originalName: e21.name, variable: e21.tensor.variable(n2) })), this.centered && (this.accumulatedMeanGrads = e20.slice(2 * t2, 3 * t2).map((e21) => ({ originalName: e21.name, variable: e21.tensor.variable(n2) })));
    });
  }
  getConfig() {
    return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };
  }
  static fromConfig(e20, t2) {
    return new e20(t2.learningRate, t2.decay, t2.momentum, t2.epsilon, t2.centered);
  }
};
var Pp = [Sp, Ip, Ep, Tp, Op, Fp, Mp];
var zp = {};
function Vp(e20) {
  return new Promise((e21) => setTimeout(e21)).then(e20);
}
A(zp, { CompositeArrayBuffer() {
  return Gi;
}, browserFiles() {
  return Wp;
}, browserHTTPRequest() {
  return Zp;
}, concatenateArrayBuffers() {
  return ks;
}, copyModel() {
  return oo;
}, decodeWeights() {
  return fs;
}, decodeWeightsStream() {
  return bs;
}, encodeWeights() {
  return ps;
}, fromMemory() {
  return Qp;
}, fromMemorySync() {
  return ef;
}, getLoadHandlers() {
  return Fs;
}, getModelArtifactsForJSON() {
  return Rs;
}, getModelArtifactsForJSONSync() {
  return $s;
}, getModelArtifactsInfoForJSON() {
  return Ss;
}, getSaveHandlers() {
  return Os;
}, getWeightSpecs() {
  return Is;
}, http() {
  return qp;
}, isHTTPScheme() {
  return Hp;
}, listModels() {
  return io;
}, loadWeights() {
  return Up;
}, moveModel() {
  return lo;
}, registerLoadRouter() {
  return Ms;
}, registerSaveRouter() {
  return Ts;
}, removeModel() {
  return so;
}, weightsLoaderFactory() {
  return jp;
}, withSaveHandler() {
  return tf;
}, withSaveHandlerSync() {
  return nf;
} });
var _p = class e7 {
  constructor(t2) {
    if (!_e().getBool("IS_BROWSER")) throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    t2.startsWith(e7.URL_SCHEME) && (t2 = t2.slice(e7.URL_SCHEME.length)), (null == t2 || 0 === t2.length) && (t2 = "model"), this.modelJsonFileName = t2 + ".json", this.weightDataFileName = t2 + ".weights.bin";
  }
  save(e20) {
    return __async(this, null, function* () {
      if ("undefined" == typeof document) throw Error("Browser downloads are not supported in this environment since `document` is not present");
      let t2 = Gi.join(e20.weightData), n2 = window.URL.createObjectURL(new Blob([t2], { type: "application/octet-stream" }));
      if (e20.modelTopology instanceof ArrayBuffer) throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
      {
        let t3 = Cs(e20, [{ paths: ["./" + this.weightDataFileName], weights: e20.weightSpecs }]), r2 = window.URL.createObjectURL(new Blob([JSON.stringify(t3)], { type: "application/json" })), a2 = this.modelJsonAnchor ?? document.createElement("a");
        if (a2.download = this.modelJsonFileName, a2.href = r2, yield Vp(() => a2.dispatchEvent(new MouseEvent("click"))), null != e20.weightData) {
          let e21 = this.weightDataAnchor ?? document.createElement("a");
          e21.download = this.weightDataFileName, e21.href = n2, yield Vp(() => e21.dispatchEvent(new MouseEvent("click")));
        }
        return { modelArtifactsInfo: Ss(e20) };
      }
    });
  }
};
_p.URL_SCHEME = "downloads://";
var Dp = class {
  constructor(e20) {
    if (null == e20 || 1 > e20.length) throw Error("When calling browserFiles, at least 1 file is required, but received " + e20);
    this.jsonFile = e20[0], this.weightsFiles = e20.slice(1);
  }
  load() {
    return __async(this, null, function* () {
      return new Promise((e20, t2) => {
        let n2 = new FileReader();
        n2.onload = (n3) => {
          let r2 = JSON.parse(n3.target.result), a2 = r2.modelTopology;
          if (null == a2) return void t2(Error("modelTopology field is missing from file " + this.jsonFile.name));
          if (null == r2.weightsManifest) return void t2(Error("weightManifest field is missing from file " + this.jsonFile.name));
          if (0 === this.weightsFiles.length) return void e20({ modelTopology: a2 });
          let i2 = Rs(r2, (e21) => this.loadWeights(e21));
          e20(i2);
        }, n2.onerror = (e21) => t2(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`), n2.readAsText(this.jsonFile);
      });
    });
  }
  loadWeights(e20) {
    let t2 = [], n2 = [];
    for (let i2 of e20) t2.push(...i2.weights), n2.push(...i2.paths);
    let r2 = this.checkManifestAndWeightFiles(e20), a2 = n2.map((e21) => this.loadWeightsFile(e21, r2[e21]));
    return Promise.all(a2).then((e21) => [t2, e21]);
  }
  loadWeightsFile(e20, t2) {
    return new Promise((n2, r2) => {
      let a2 = new FileReader();
      a2.onload = (e21) => {
        n2(e21.target.result);
      }, a2.onerror = (t3) => r2(`Failed to weights data from file of path '${e20}'.`), a2.readAsArrayBuffer(t2);
    });
  }
  checkManifestAndWeightFiles(e20) {
    let t2 = [], n2 = this.weightsFiles.map((e21) => Ns(e21.name)), r2 = {};
    for (let a2 of e20) a2.paths.forEach((e21) => {
      let a3 = Ns(e21);
      if (-1 !== t2.indexOf(a3)) throw Error(`Duplicate file basename found in weights manifest: '${a3}'`);
      if (t2.push(a3), -1 === n2.indexOf(a3)) throw Error(`Weight file with basename '${a3}' is not provided.`);
      r2[e21] = this.weightsFiles[n2.indexOf(a3)];
    });
    if (t2.length !== this.weightsFiles.length) throw Error(`Mismatch in the number of files in weights manifest (${t2.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
    return r2;
  }
};
function Wp(e20) {
  return new Dp(e20);
}
function Lp(e20, t2, n2, r2) {
  var a2;
  Z(null != (a2 = e20) && Array.isArray(a2) && a2.length > 0, () => "promises must be a none empty array"), ((e21, t3) => {
    Z(e21 >= 0 && 1 >= e21, () => "Progress fraction must be in range [0, 1], but got startFraction " + e21), Z(t3 >= 0 && 1 >= t3, () => "Progress fraction must be in range [0, 1], but got endFraction " + t3), Z(t3 >= e21, () => `startFraction must be no more than endFraction, but got startFraction ${e21} and endFraction ${t3}`);
  })(n2 = n2 ?? 0, r2 = r2 ?? 1);
  let i2 = 0;
  return Promise.all(e20.map((a3) => (a3.then((a4) => {
    let s2 = n2 + ++i2 / e20.length * (r2 - n2);
    return t2(s2), a4;
  }), a3)));
}
function Bp(e20, t2) {
  return __async(this, null, function* () {
    null == t2 && (t2 = {});
    let n2 = t2.fetchFunc ?? _e().platform.fetch, r2 = e20.map((e21) => n2(e21, t2.requestInit, { isBinary: true })), a2 = (null == t2.onProgress ? yield Promise.all(r2) : yield Lp(r2, t2.onProgress, 0, 0.5)).map((e21) => e21.arrayBuffer());
    return null == t2.onProgress ? yield Promise.all(a2) : yield Lp(a2, t2.onProgress, 0.5, 1);
  });
}
function Up(e20, t2 = "", n2, r2) {
  return __async(this, null, function* () {
    return jp((e21) => Bp(e21, { requestInit: r2 }))(e20, t2, n2);
  });
}
function jp(e20) {
  return (t2, n2 = "", r2) => __async(null, null, function* () {
    let a2 = t2.map(() => false), i2 = {}, s2 = null != r2 ? r2.map(() => false) : [], o2 = [];
    if (t2.forEach((e21, t3) => {
      let n3 = 0;
      e21.weights.forEach((e22) => {
        let l3 = ji["quantization" in e22 ? e22.quantization.dtype : e22.dtype] * J(e22.shape), u3 = () => {
          a2[t3] = true, null == i2[t3] && (i2[t3] = []), i2[t3].push({ manifestEntry: e22, groupOffset: n3, sizeBytes: l3 });
        };
        null != r2 ? r2.forEach((t4, n4) => {
          t4 === e22.name && (u3(), s2[n4] = true);
        }) : u3(), o2.push(e22.name), n3 += l3;
      });
    }), !s2.every((e21) => e21)) {
      let e21 = r2.filter((e22, t3) => !s2[t3]);
      throw Error(`Could not find weights in manifest with names: ${e21.join(", ")}. 
Manifest JSON has weights with names: ${o2.join(", ")}.`);
    }
    let l2 = a2.reduce((e21, t3, n3) => (t3 && e21.push(n3), e21), []), u2 = [];
    l2.forEach((e21) => {
      t2[e21].paths.forEach((e22) => {
        let t3 = n2 + (n2.endsWith("/") ? "" : "/") + e22;
        u2.push(t3);
      });
    });
    let d2 = yield e20(u2), c2 = {}, h2 = 0;
    return l2.forEach((e21) => {
      let n3 = t2[e21].paths.length, r3 = new Gi(d2.slice(h2, h2 + n3));
      i2[e21].forEach((e22) => {
        let t3 = fs(r3.slice(e22.groupOffset, e22.groupOffset + e22.sizeBytes), [e22.manifestEntry]);
        for (let n4 in t3) c2[n4] = t3[n4];
      }), h2 += n3;
    }), c2;
  });
}
Es.registerSaveRouter((e20) => _e().getBool("IS_BROWSER") && !Array.isArray(e20) && e20.startsWith(_p.URL_SCHEME) ? ((e21 = "model") => new _p(e21))(e20.slice(_p.URL_SCHEME.length)) : null);
var Gp = class {
  constructor(e20, t2) {
    if (this.DEFAULT_METHOD = "POST", null == t2 && (t2 = {}), this.weightPathPrefix = t2.weightPathPrefix, this.weightUrlConverter = t2.weightUrlConverter, null != t2.fetchFunc ? (Z("function" == typeof t2.fetchFunc, () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this.fetch = t2.fetchFunc) : this.fetch = _e().platform.fetch, Z(null != e20 && e20.length > 0, () => "URL path for http must not be null, undefined or empty."), Array.isArray(e20) && Z(2 === e20.length, () => `URL paths for http must have a length of 2, (actual length is ${e20.length}).`), this.path = e20, null != t2.requestInit && null != t2.requestInit.body) throw Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = t2.requestInit || {}, this.loadOptions = t2;
  }
  save(e20) {
    return __async(this, null, function* () {
      if (e20.modelTopology instanceof ArrayBuffer) throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
      let t2 = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
      t2.body = new FormData();
      let n2 = Cs(e20, [{ paths: ["./model.weights.bin"], weights: e20.weightSpecs }]);
      if (t2.body.append("model.json", new Blob([JSON.stringify(n2)], { type: "application/json" }), "model.json"), null != e20.weightData) {
        let n3 = Gi.join(e20.weightData);
        t2.body.append("model.weights.bin", new Blob([n3], { type: "application/octet-stream" }), "model.weights.bin");
      }
      let r2 = yield this.fetch(this.path, t2);
      if (r2.ok) return { modelArtifactsInfo: Ss(e20), responses: [r2] };
      throw Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r2.status}.`);
    });
  }
  loadModelJSON() {
    return __async(this, null, function* () {
      let e20, t2 = yield this.fetch(this.path, this.requestInit);
      if (!t2.ok) throw Error(`Request to ${this.path} failed with status code ${t2.status}. Please verify this URL points to the model JSON of the model to load.`);
      try {
        e20 = yield t2.json();
      } catch (n2) {
        let e21 = `Failed to parse model JSON of response from ${this.path}.`;
        throw this.path.endsWith(".pb") ? e21 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : e21 += " Please make sure the server is serving valid JSON for this request.", Error(e21);
      }
      if (null == e20.modelTopology && null == e20.weightsManifest) throw Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
      return e20;
    });
  }
  load() {
    return __async(this, null, function* () {
      return this.loadOptions.streamWeights ? this.loadStream() : Rs(yield this.loadModelJSON(), (e20) => this.loadWeights(e20));
    });
  }
  loadStream() {
    return __async(this, null, function* () {
      let e20 = yield this.loadModelJSON(), t2 = yield this.getWeightUrls(e20.weightsManifest), n2 = Is(e20.weightsManifest);
      return Object.assign(Object.assign({}, e20), { weightSpecs: n2, getWeightStream: () => ((e21, t3) => {
        var n3;
        let r2, a2 = t3.fetchFunc ?? _e().platform.fetch, i2 = 0;
        return null === (n3 = t3.onProgress) || void 0 === n3 || n3.call(t3, 0), new ReadableStream({ pull(n4) {
          return __async(this, null, function* () {
            for (var s2; e21.length > i2; ) {
              r2 || (r2 = (yield a2(e21[i2], t3.requestInit, { isBinary: true })).body.getReader());
              let { done: o2, value: l2 } = yield r2.read();
              if (!o2) return void n4.enqueue(l2);
              i2++, r2 = void 0, null === (s2 = t3.onProgress) || void 0 === s2 || s2.call(t3, i2 / e21.length);
            }
            n4.close();
          });
        } });
      })(t2, this.loadOptions) });
    });
  }
  getWeightUrls(e20) {
    return __async(this, null, function* () {
      let t2 = Array.isArray(this.path) ? this.path[1] : this.path, [n2, r2] = ((e21) => {
        let t3 = e21.lastIndexOf("/"), n3 = e21.lastIndexOf("?");
        return [e21.substring(0, t3) + "/", n3 > t3 ? e21.substring(n3) : ""];
      })(t2), a2 = this.weightPathPrefix || n2, i2 = [], s2 = [];
      for (let o2 of e20) for (let e21 of o2.paths) null != this.weightUrlConverter ? s2.push(this.weightUrlConverter(e21)) : i2.push(a2 + e21 + r2);
      return this.weightUrlConverter && i2.push(...yield Promise.all(s2)), i2;
    });
  }
  loadWeights(e20) {
    return __async(this, null, function* () {
      let t2 = yield this.getWeightUrls(e20);
      return [Is(e20), yield Bp(t2, this.loadOptions)];
    });
  }
};
function Hp(e20) {
  return null != e20.match(Gp.URL_SCHEME_REGEX);
}
Gp.URL_SCHEME_REGEX = /^https?:\/\//;
var Xp = (e20, t2) => {
  if ("undefined" == typeof fetch && (null == t2 || null == t2.fetchFunc)) return null;
  {
    let n2 = true;
    if (n2 = Array.isArray(e20) ? e20.every((e21) => Hp(e21)) : Hp(e20), n2) return qp(e20, t2);
  }
  return null;
};
function qp(e20, t2) {
  return new Gp(e20, t2);
}
function Zp(e20, t2) {
  return qp(e20, t2);
}
Es.registerSaveRouter(Xp), Es.registerLoadRouter(Xp);
var Kp = class {
  constructor(e20) {
    this.modelArtifacts = e20;
  }
  load() {
    return this.modelArtifacts;
  }
};
var Yp = class {
  constructor(e20) {
    this.saveHandler = e20;
  }
  save(e20) {
    return this.saveHandler(e20);
  }
};
var Jp = class {
  constructor(e20) {
    e20.load && (this.load = () => Promise.resolve(e20.load())), e20.save && (this.save = (t2) => Promise.resolve(e20.save(t2)));
  }
};
function Qp(e20, t2, n2, r2) {
  return new Jp(ef(...arguments));
}
function ef(e20, t2, n2, r2) {
  return 1 === arguments.length ? null != e20.modelTopology || null != e20.weightSpecs ? new Kp(e20) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Kp({ modelTopology: e20 })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new Kp({ modelTopology: e20, weightSpecs: t2, weightData: n2, trainingConfig: r2 }));
}
function tf(e20) {
  return new Yp(e20);
}
function nf(e20) {
  return new Yp(e20);
}
var rf = {};
A(rf, { confusionMatrix() {
  return sf;
} });
var af;
var sf = Wi({ confusionMatrix_(e20, t2, n2) {
  let r2 = Vi(e20, "labels", "confusionMatrix"), a2 = Vi(t2, "predictions", "confusionMatrix");
  Z(null == n2 || n2 > 0 && Number.isInteger(n2), () => "If provided, numClasses must be a positive integer, but got " + n2), Z(1 === r2.rank, () => "Expected the rank of labels to be 1, but got " + r2.rank), Z(1 === a2.rank, () => "Expected the rank of predictions to be 1, but got " + a2.rank), Z(r2.shape[0] === a2.shape[0], () => `Mismatch in the number of examples: ${r2.shape[0]} vs. ${a2.shape[0]}. Labels and predictions should have the same number of elements.`), Z(n2 > 0 && Number.isInteger(n2), () => "numClasses is required to be a positive integer, but got " + n2);
  let i2 = hd(co(r2, "int32"), n2), s2 = hd(co(a2, "int32"), n2), o2 = Qc(i2), l2 = Ko(o2, s2);
  return co(l2, "int32");
} });
var of = {};
A(of, { draw() {
  return pf;
}, fromPixels() {
  return ff;
}, fromPixelsAsync() {
  return df;
}, toPixels() {
  return hf;
} });
var lf = false;
function uf(e20, t2 = 3) {
  if (t2 > 4) throw Error("Cannot construct Tensor with more than 4 channels from pixels.");
  if (null == e20) throw Error("pixels passed to tf.browser.fromPixels() can not be null");
  let n2 = false, r2 = false, a2 = false, i2 = false, s2 = false, o2 = false;
  if (e20.data instanceof Uint8Array) n2 = true;
  else if ("undefined" != typeof ImageData && e20 instanceof ImageData) r2 = true;
  else if ("undefined" != typeof HTMLVideoElement && e20 instanceof HTMLVideoElement) a2 = true;
  else if ("undefined" != typeof HTMLImageElement && e20 instanceof HTMLImageElement) i2 = true;
  else if (null != e20.getContext) s2 = true;
  else {
    if (!("undefined" != typeof ImageBitmap && e20 instanceof ImageBitmap)) throw Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + e20.constructor.name);
    o2 = true;
  }
  if (null != ha(ra, $i.backendName)) return $i.runKernel(ra, { pixels: e20 }, { numChannels: t2 });
  let l2, u2, [d2, c2] = a2 ? [e20.videoWidth, e20.videoHeight] : [e20.width, e20.height];
  if (s2) l2 = e20.getContext("2d").getImageData(0, 0, d2, c2).data;
  else if (r2 || n2) l2 = e20.data;
  else if (i2 || a2 || o2) {
    if (null == af) if ("undefined" == typeof document) {
      if ("undefined" == typeof OffscreenCanvas || "undefined" == typeof OffscreenCanvasRenderingContext2D) throw Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
      af = new OffscreenCanvas(1, 1).getContext("2d");
    } else af = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
    af.canvas.width = d2, af.canvas.height = c2, af.drawImage(e20, 0, 0, d2, c2), l2 = af.getImageData(0, 0, d2, c2).data;
  }
  if (4 === t2) u2 = new Int32Array(l2);
  else {
    let e21 = d2 * c2;
    u2 = new Int32Array(e21 * t2);
    for (let n3 = 0; e21 > n3; n3++) for (let e22 = 0; t2 > e22; ++e22) u2[n3 * t2 + e22] = l2[4 * n3 + e22];
  }
  return Fc(u2, [c2, d2, t2], "int32");
}
function df(e20, t2 = 3) {
  return __async(this, null, function* () {
    let n2 = null;
    if (_e().getBool("WRAP_TO_IMAGEBITMAP") && ((e21) => "undefined" != typeof window && "undefined" != typeof ImageBitmap && window.hasOwnProperty("createImageBitmap") && !(e21 instanceof ImageBitmap) && ((e22) => null != e22 && 0 !== e22.width && 0 !== e22.height)(e21) && !((e22) => null != e22 && e22.data instanceof Uint8Array)(e21))(e20)) {
      let t3;
      try {
        t3 = yield createImageBitmap(e20, { premultiplyAlpha: "none" });
      } catch (r2) {
        t3 = null;
      }
      n2 = null != t3 && t3.width === e20.width && t3.height === e20.height ? t3 : e20;
    } else n2 = e20;
    return uf(n2, t2);
  });
}
function cf(e20) {
  if (2 !== e20.rank && 3 !== e20.rank) throw Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e20.rank}.`);
  let t2 = 2 === e20.rank ? 1 : e20.shape[2];
  if (t2 > 4 || 2 === t2) throw Error("toPixels only supports depth of size 1, 3 or 4 but got " + t2);
  if ("float32" !== e20.dtype && "int32" !== e20.dtype) throw Error(`Unsupported type for toPixels: ${e20.dtype}. Please use float32 or int32 tensors.`);
}
function hf(e20, t2) {
  return __async(this, null, function* () {
    let n2 = Vi(e20, "img", "toPixels");
    if (!(e20 instanceof ni)) {
      let e21 = n2;
      n2 = co(e21, "int32"), e21.dispose();
    }
    cf(n2);
    let [r2, a2] = n2.shape.slice(0, 2), i2 = 2 === n2.rank ? 1 : n2.shape[2], s2 = yield n2.data(), o2 = "float32" === n2.dtype ? 255 : 1, l2 = new Uint8ClampedArray(a2 * r2 * 4);
    for (let u2 = 0; r2 * a2 > u2; ++u2) {
      let e21 = [0, 0, 0, 255];
      for (let r3 = 0; i2 > r3; r3++) {
        let t4 = s2[u2 * i2 + r3];
        if ("float32" === n2.dtype) {
          if (0 > t4 || t4 > 1) throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t4}.`);
        } else if ("int32" === n2.dtype && (0 > t4 || t4 > 255)) throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t4}.`);
        1 === i2 ? (e21[0] = t4 * o2, e21[1] = t4 * o2, e21[2] = t4 * o2) : e21[r3] = t4 * o2;
      }
      let t3 = 4 * u2;
      l2[t3 + 0] = Math.round(e21[0]), l2[t3 + 1] = Math.round(e21[1]), l2[t3 + 2] = Math.round(e21[2]), l2[t3 + 3] = Math.round(e21[3]);
    }
    if (null != t2) {
      lf || null != ha(Dt, $i.backendName) && (console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."), lf = true), t2.width = a2, t2.height = r2;
      let e21 = t2.getContext("2d"), n3 = new ImageData(l2, a2, r2);
      e21.putImageData(n3, 0, 0);
    }
    return n2 !== e20 && n2.dispose(), l2;
  });
}
function pf(e20, t2, n2) {
  let r2 = Vi(e20, "img", "draw");
  if (!(e20 instanceof ni)) {
    let e21 = r2;
    r2 = co(e21, "int32"), e21.dispose();
  }
  cf(r2), ((e21) => {
    let t3 = (null == e21 ? void 0 : e21.alpha) || 1;
    if (t3 > 1 || 0 > t3) throw Error(`Alpha value ${t3} is suppoed to be in range [0 - 1].`);
  })(null == n2 ? void 0 : n2.imageOptions), $i.runKernel(Dt, { image: r2 }, { canvas: t2, options: n2 });
}
var ff = Wi({ fromPixels_: uf });
var mf = {};
function Af(e20, t2) {
  let n2 = e20.shape.length, r2 = t2.shape.length;
  if (1 > n2) throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n2}.`);
  if (1 > r2) throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r2}.`);
  if ("int32" !== t2.dtype) throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t2.dtype}.`);
  if (t2.shape[r2 - 1] > n2) throw Error(`index innermost dimension length must be <= tensor rank; saw: ${t2.shape[r2 - 1]} vs. ${n2}`);
  if (0 === J(e20.shape)) throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${e20.shape}.`);
  let a2 = t2.shape, i2 = a2[a2.length - 1], s2 = 1;
  for (let c2 = 0; a2.length - 1 > c2; ++c2) s2 *= a2[c2];
  let o2 = e20.shape, l2 = a2.slice();
  l2.pop();
  let u2 = 1;
  for (let c2 = i2; n2 > c2; ++c2) u2 *= o2[c2], l2.push(o2[c2]);
  let d2 = [...Ne(e20.shape).map((e21) => e21 / u2), 1].slice(0, i2);
  return [l2, s2, u2, d2];
}
A(mf, { prepareAndValidate() {
  return Af;
} });
var xf = {};
A(xf, { assertParamsValid() {
  return gf;
}, computeFlatOffset() {
  return Of;
}, computeOutShape() {
  return wf;
}, getNormalizedAxes() {
  return $f;
}, isSliceContinous() {
  return Mf;
}, maskToAxes() {
  return vf;
}, parseSliceParams() {
  return Ff;
}, sliceInfo() {
  return Pf;
}, startForAxis() {
  return Ef;
}, startIndicesWithElidedDims() {
  return Rf;
}, stopForAxis() {
  return Tf;
}, stopIndicesWithElidedDims() {
  return Sf;
}, stridesForAxis() {
  return If;
}, stridesWithElidedDims() {
  return kf;
} });
var yf = -2;
var bf = -1;
function gf(e20, t2, n2) {
  let r2 = e20.shape.length;
  Z(r2 === t2.length, () => `Error in slice${r2}D: Length of begin ${t2} must match the rank of the array (${r2}).`), Z(r2 === n2.length, () => `Error in slice${r2}D: Length of size ${n2} must match the rank of the array (${r2}).`);
  for (let a2 = 0; r2 > a2; ++a2) Z(e20.shape[a2] >= t2[a2] + n2[a2], () => `Error in slice${r2}D: begin[${a2}] + size[${a2}] (${t2[a2] + n2[a2]}) would overflow input.shape[${a2}] (${e20.shape[a2]})`);
}
function vf(e20) {
  let t2 = [], n2 = 0;
  for (; e20 > 0; ) 1 & e20 && t2.push(n2), e20 /= 2, n2++;
  return t2;
}
function wf(e20, t2, n2) {
  let r2 = [];
  for (let a2 = 0; e20.length > a2; a2++) r2[a2] = Math.ceil((t2[a2] - e20[a2]) / n2[a2]);
  return r2;
}
function kf(e20, t2, n2, r2) {
  let a2 = [...e20];
  for (let i2 = a2.length; r2.length > i2; i2++) a2.push(1);
  for (let i2 = 0; n2 > i2; i2++) 0 === i2 ? a2[t2] = 1 : (a2.splice(t2, 0, 1), a2.pop());
  return a2;
}
function Nf(e20, t2, n2) {
  return n2 > e20 ? n2 - (t2 - 1) : n2;
}
function Cf(e20, t2) {
  let n2 = [];
  for (let r2 = 0; e20 > r2; r2++) n2.push(t2 + r2);
  return n2;
}
function $f(e20, t2, n2, r2, a2, i2, s2, o2, l2) {
  let u2 = e20.length, d2 = Array(u2), c2 = Array(u2), h2 = Array(u2);
  if (t2.length && n2 > 0) {
    let l3 = t2[0], u3 = n2 + 1;
    d2 = Rf(s2, l3, u3, r2, e20), c2 = Sf(o2, l3, u3, a2, e20), h2 = kf(i2, l3, u3, e20);
  } else for (let p2 = 0; u2 > p2; p2++) d2[p2] = Ef(s2, r2, i2, e20, p2, l2), c2[p2] = Tf(o2, a2, i2, e20, p2, l2), h2[p2] = If(i2, p2, l2);
  return { begin: d2, end: c2, strides: h2 };
}
function Rf(e20, t2, n2, r2, a2) {
  let i2 = [...a2], s2 = Cf(n2, t2);
  for (let o2 = 0; i2.length > o2; o2++) if (s2.indexOf(o2) > -1) i2[o2] = 0;
  else {
    let a3 = Nf(t2, n2, o2), s3 = r2[a3];
    e20 & 1 << a3 && (s3 = 0), i2[o2] = s3;
  }
  return i2;
}
function Sf(e20, t2, n2, r2, a2) {
  let i2 = [...a2], s2 = Cf(n2, t2);
  for (let o2 = 0; i2.length > o2; o2++) if (s2.indexOf(o2) > -1) i2[o2] = Number.MAX_SAFE_INTEGER;
  else {
    let a3 = Nf(t2, n2, o2), s3 = r2[a3];
    e20 & 1 << a3 && (s3 = Number.MAX_SAFE_INTEGER), i2[o2] = s3;
  }
  for (let o2 = 0; i2.length > o2; o2++) 0 > i2[o2] && (i2[o2] += a2[o2]), i2[o2] = U(0, i2[o2], a2[o2]);
  return i2;
}
function If(e20, t2, n2) {
  let r2 = e20[t2];
  return (n2 & 1 << t2 || null == r2) && (r2 = 1), r2;
}
function Ef(e20, t2, n2, r2, a2, i2) {
  let s2 = t2[a2];
  (e20 & 1 << a2 || i2 & 1 << a2 || null == s2) && (s2 = (n2[a2] || 1) > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  let o2 = r2[a2];
  return 0 > s2 && (s2 += o2), s2 = U(0, s2, o2 - 1), s2;
}
function Tf(e20, t2, n2, r2, a2, i2) {
  let s2 = t2[a2], o2 = n2[a2] || 1;
  (e20 & 1 << a2 || i2 & 1 << a2 || null == s2) && (s2 = o2 > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  let l2 = r2[a2];
  return 0 > s2 && (s2 += l2), s2 = o2 > 0 ? U(0, s2, l2) : U(-1, s2, l2 - 1), s2;
}
function Mf(e20, t2, n2) {
  let r2 = n2.length;
  for (let a2 = 0; n2.length > a2; a2++) if (n2[a2] > 1) {
    r2 = a2;
    break;
  }
  for (let a2 = r2 + 1; n2.length > a2; a2++) if (t2[a2] > 0 || n2[a2] !== e20[a2]) return false;
  return true;
}
function Of(e20, t2) {
  let n2 = e20.length > 0 ? e20[e20.length - 1] : 1;
  for (let r2 = 0; e20.length - 1 > r2; r2++) n2 += e20[r2] * t2[r2];
  return n2;
}
function Ff(e20, t2, n2) {
  let r2, a2, i2 = e20.shape.length;
  return r2 = "number" == typeof t2 ? [t2, ...Array(i2 - 1).fill(0)] : i2 > t2.length ? t2.concat(Array(i2 - t2.length).fill(0)) : t2.slice(), r2.forEach((e21) => {
    Z(-1 !== e21, () => "slice() does not support negative begin indexing.");
  }), a2 = null == n2 ? Array(i2).fill(-1) : "number" == typeof n2 ? [n2, ...Array(i2 - 1).fill(-1)] : i2 > n2.length ? n2.concat(Array(i2 - n2.length).fill(-1)) : n2, a2 = a2.map((t3, n3) => 0 > t3 ? (Z(-1 === t3, () => `Negative size values should be exactly -1 but got ${t3} for the slice() size at index ${n3}.`), e20.shape[n3] - r2[n3]) : t3), [r2, a2];
}
function Pf(e20, t2, n2, r2, a2, i2, s2, o2, l2) {
  let u2;
  if (null == r2 ? (u2 = Array(t2.length), u2.fill(1)) : u2 = r2, null != s2 && s2 & s2 - 1) throw Error("Multiple ellipses in slice is not allowed.");
  let d2 = false, c2 = { dims: u2.length, numAddAxisAfterEllipsis: 0, begin: t2.slice(), end: n2.slice(), strides: u2.slice(), beginMask: a2, endMask: i2, ellipsisMask: s2, newAxisMask: o2, shrinkAxisMask: l2 };
  for (let y2 = 0; c2.dims > y2; y2++) d2 && !!(1 << y2 & o2) && c2.numAddAxisAfterEllipsis++, 1 << y2 & s2 && (d2 = true);
  d2 || (c2.ellipsisMask |= 1 << c2.dims, c2.dims++);
  let h2 = { dims: e20.length, beginMask: 0, endMask: 0, beginValid: false, endValid: false };
  ((e21, t3) => {
    t3.beginMask = 0, t3.endMask = 0, t3.shrinkAxisMask = 0;
    let n3 = 0;
    t3.beginValid = null != e21.begin, t3.endValid = null != e21.end, t3.begin = Array(t3.dims), t3.end = Array(t3.dims), t3.strides = Array(t3.dims), t3.finalShapeGatherIndices = [], t3.finalShapeGatherIndicesSparse = [], t3.inputShapeGatherIndicesSparse = Array(t3.dims);
    for (let r3 = 0; e21.dims > r3; r3++) if (1 << r3 & e21.ellipsisMask) {
      let a3 = Math.min(t3.dims - (e21.dims - r3) + 1 + e21.numAddAxisAfterEllipsis, t3.dims);
      for (; a3 > n3; n3++) t3.begin[n3] = 0, t3.end[n3] = 0, t3.strides[n3] = 1, t3.beginMask |= 1 << n3, t3.endMask |= 1 << n3, t3.finalShapeGatherIndices.push(n3), t3.finalShapeGatherIndicesSparse.push(-1), t3.inputShapeGatherIndicesSparse[n3] = r3;
    } else if (1 << r3 & e21.newAxisMask) t3.finalShapeGatherIndices.push(yf), t3.finalShapeGatherIndicesSparse.push(-1);
    else {
      if (n3 === t3.begin.length) throw Error(`Index out of range using input dim ${n3}; input has only ${t3.dims} dims, ${t3.begin.length}.`);
      null != e21.begin && (t3.begin[n3] = e21.begin[r3]), null != e21.end && (t3.end[n3] = e21.end[r3]), t3.strides[n3] = e21.strides[r3], e21.beginMask & 1 << r3 && (t3.beginMask |= 1 << n3), e21.endMask & 1 << r3 && (t3.endMask |= 1 << n3), e21.shrinkAxisMask & 1 << r3 ? (t3.finalShapeGatherIndices.push(bf), t3.finalShapeGatherIndicesSparse.push(-1), t3.shrinkAxisMask |= 1 << n3) : (t3.finalShapeGatherIndices.push(n3), t3.finalShapeGatherIndicesSparse.push(r3)), t3.inputShapeGatherIndicesSparse[n3] = r3, n3++;
    }
  })(c2, h2);
  let p2 = true, f2 = true, m2 = true, A2 = [], x2 = [];
  for (let y2 = 0; e20.length > y2; ++y2) {
    if (0 === h2.strides[y2]) throw Error(`strides[${y2}] must be non-zero`);
    let t3 = !!(h2.shrinkAxisMask & 1 << y2), n3 = e20[y2];
    if (-1 === n3) {
      A2.push(t3 ? 1 : -1);
      continue;
    }
    let r3 = [h2.beginMask & 1 << y2, h2.endMask & 1 << y2], a3 = [h2.strides[y2] > 0 ? 0 : -1, h2.strides[y2] > 0 ? n3 : n3 - 1];
    if (t3 && 0 >= h2.strides[y2]) throw Error("only stride 1 allowed on non-range indexing.");
    m2 = m2 && 1 === h2.strides[y2];
    let i3 = !!(h2.beginMask & 1 << y2 && h2.endMask & 1 << y2);
    if (h2.beginValid && h2.endValid) {
      if (t3) {
        let e22 = 0 > h2.begin[y2] ? n3 + h2.begin[y2] : h2.begin[y2];
        if (h2.begin[y2] = e22, h2.end[y2] = h2.begin[y2] + 1, 0 > e22 || e22 >= n3) throw Error(`slice index ${h2.begin[y2]} of dimension ${y2} out of bounds.`);
      } else h2.begin[y2] = zf(h2.begin[y2], 0, h2.strides[y2], n3, r3, a3), h2.end[y2] = zf(h2.end[y2], 1, h2.strides[y2], n3, r3, a3);
      let e21 = 1 === h2.strides[y2] && 0 === h2.begin[y2] && h2.end[y2] === n3;
      p2 = p2 && e21, f2 = f2 && (0 === y2 && 1 === h2.strides[y2] || e21);
    } else p2 = p2 && 1 === h2.strides[y2] && i3, f2 = f2 && (0 === y2 && 1 === h2.strides[y2] || i3);
    let s3, o3 = false;
    if (h2.beginValid && h2.endValid ? (s3 = h2.end[y2] - h2.begin[y2], o3 = true) : t3 ? (s3 = 1, o3 = true) : i3 && n3 >= 0 && (s3 = 0 > h2.strides[y2] ? -n3 : n3, o3 = true), o3) {
      let e21;
      e21 = 0 === s3 || 0 > s3 != 0 > h2.strides[y2] ? 0 : Math.trunc(s3 / h2.strides[y2]) + (s3 % h2.strides[y2] !== 0 ? 1 : 0), A2.push(e21);
    } else A2.push(-1);
  }
  for (let y2 = 0; h2.finalShapeGatherIndices.length > y2; ++y2) {
    let e21 = h2.finalShapeGatherIndices[y2];
    0 > e21 ? e21 === yf && x2.push(1) : x2.push(A2[e21]);
  }
  return { finalShapeSparse: x2.filter((e21, t3) => h2.finalShapeGatherIndices[t3] !== yf), finalShape: x2, isIdentity: p2, sliceDim0: f2, isSimpleSlice: m2, begin: h2.begin, end: h2.end, strides: h2.strides };
}
function zf(e20, t2, n2, r2, a2, i2) {
  if (a2[t2]) return n2 > 0 ? i2[t2] : i2[t2 + 1 & 1];
  {
    let t3 = 0 > e20 ? r2 + e20 : e20;
    return i2[0] > t3 ? i2[0] : t3 > i2[1] ? i2[1] : t3;
  }
}
var Vf = "4.22.0";
var _f = class {
  static sgd(e20) {
    return new Mp(e20);
  }
  static momentum(e20, t2, n2 = false) {
    return new Op(e20, t2, n2);
  }
  static rmsprop(e20, t2 = 0.9, n2 = 0, r2 = null, a2 = false) {
    return new Fp(e20, t2, n2, r2, a2);
  }
  static adam(e20 = 1e-3, t2 = 0.9, n2 = 0.999, r2 = null) {
    return new Ep(e20, t2, n2, r2);
  }
  static adadelta(e20 = 1e-3, t2 = 0.95, n2 = null) {
    return new Sp(e20, t2, n2);
  }
  static adamax(e20 = 2e-3, t2 = 0.9, n2 = 0.999, r2 = null, a2 = 0) {
    return new Tp(e20, t2, n2, r2, a2);
  }
  static adagrad(e20, t2 = 0.1) {
    return new Ip(e20, t2);
  }
};
var Df = _f;
var Wf = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : (e20) => e20();
function Lf() {
  return new Promise((e20) => Wf(() => e20()));
}
var Bf;
var Uf = {};
function jf(e20, t2) {
  let n2 = e20[0].length;
  e20.forEach((e21, t3) => {
    Z(e21.length === n2, () => `Error in concat${n2}D: rank of tensors[${t3}] must be the same as the rank of the rest (${n2})`);
  }), Z(t2 >= 0 && n2 > t2, () => `Error in concat${n2}D: axis must be between 0 and ${n2 - 1}.`);
  let r2 = e20[0];
  e20.forEach((e21, a2) => {
    for (let i2 = 0; n2 > i2; i2++) Z(i2 === t2 || e21[i2] === r2[i2], () => `Error in concat${n2}D: Shape of tensors[${a2}] (${e21}) does not match the shape of the rest (${r2}) along the non-concatenated axis ${a2}.`);
  });
}
function Gf(e20, t2) {
  let n2 = e20[0].slice();
  for (let r2 = 1; e20.length > r2; r2++) n2[t2] += e20[r2][t2];
  return n2;
}
function Hf(e20, t2, n2) {
  let r2 = [];
  if (null == n2 && null == t2) return r2;
  if (null == t2) for (; e20 + n2.length > r2.length; ) r2.push(-1);
  else r2 = t2.slice();
  if (null == n2) return r2;
  if (e20 + n2.length !== r2.length) throw Error(`rt input.shape and shape=${t2} are incompatible: rt input.rank = ${e20 + n2.length}, but shape.rank = ${r2.length}`);
  for (let a2 = 1; n2.length > a2; ++a2) {
    let i2 = n2[a2], s2 = r2[r2.length - n2.length + a2], o2 = r2[s2];
    if (i2 >= 0) {
      if (0 > o2) r2[s2] = i2;
      else if (o2 !== i2) throw Error(`rt input.shape and shape=${t2} are incompatible: rt input.shape[${a2 + e20}] = ${i2} but shape[${a2 + e20}] = ${o2}`);
    }
  }
  return r2;
}
function Xf(e20) {
  let t2 = { FIRST_DIM_SIZE: Bf.FIRST_DIM_SIZE, VALUE_ROWIDS: Bf.VALUE_ROWIDS, ROW_LENGTHS: Bf.ROW_LENGTHS, ROW_SPLITS: Bf.ROW_SPLITS, ROW_LIMITS: Bf.ROW_LIMITS, ROW_STARTS: Bf.ROW_STARTS }, n2 = [];
  for (let r2 of e20) {
    if (!(r2 in t2)) break;
    n2.push(t2[r2]);
  }
  return n2;
}
function qf(e20) {
  return 0 === e20.length ? 0 : e20[0] === Bf.FIRST_DIM_SIZE ? e20.length - 1 : e20.length;
}
function Zf(e20, t2) {
  if (null == e20 || null == t2) return;
  let n2 = e20.length, r2 = t2.length;
  if (n2 >= r2) throw Error(`defaultValue.shape=${e20} and ragged tensor flatValues.shape=${t2}, are incompatible: defaultValue.rank = ${n2} must be less than ragged tensor input flatValues.rank = ${r2})`);
  for (let a2 = 0; Math.min(n2, r2 - 1) > a2; ++a2) {
    let n3 = e20[a2], r3 = t2[a2 + 1];
    if (n3 >= 0 && r3 >= 0 && 1 !== n3 && n3 !== r3) throw Error(`defaultValue.shape=${e20}, and ragged tensor input flatValues.shape=${t2} are incompatible: defaultValue.shape[${a2 - e20.length}] = ${n3} but ragged tensor input.flatValues.shape[${a2 - e20.length}] = ${r3}`);
  }
}
A(Uf, { ERF_A1() {
  return om;
}, ERF_A2() {
  return lm;
}, ERF_A3() {
  return um;
}, ERF_A4() {
  return dm;
}, ERF_A5() {
  return cm;
}, ERF_P() {
  return sm;
}, PARALLELIZE_THRESHOLD() {
  return Kf;
}, RowPartitionType() {
  return Bf;
}, SELU_SCALE() {
  return im;
}, SELU_SCALEALPHA() {
  return am;
}, applyActivation() {
  return hh;
}, assertAndGetBroadcastShape() {
  return Vl;
}, assertAxesAreInnerMostDims() {
  return Yl;
}, assertParamsConsistent() {
  return jf;
}, assignToTypedArray() {
  return xm;
}, axesAreInnerMostDims() {
  return Xl;
}, calculateShapes() {
  return Lc;
}, checkEinsumDimSizes() {
  return $m;
}, checkPadOnDimRoundingMode() {
  return Go;
}, combineLocations() {
  return ql;
}, combineRaggedTensorToTensorShapes() {
  return Hf;
}, complexWithEvenIndex() {
  return fm;
}, complexWithOddIndex() {
  return mm;
}, computeConv2DInfo() {
  return Fo;
}, computeConv3DInfo() {
  return Po;
}, computeDefaultPad() {
  return zo;
}, computeDilation2DInfo() {
  return To;
}, computeOptimalWindowSize() {
  return Yf;
}, computeOutAndReduceShapes() {
  return Zl;
}, computeOutShape() {
  return Gf;
}, computePool2DInfo() {
  return Mo;
}, computePool3DInfo() {
  return Oo;
}, convertConv2DDataFormat() {
  return jo;
}, decodeEinsumEquation() {
  return Nm;
}, eitherStridesOrDilationsAreOne() {
  return Bo;
}, expandShapeToKeepDim() {
  return Kl;
}, exponent() {
  return bm;
}, exponents() {
  return ym;
}, fromStringArrayToUint8() {
  return qm;
}, fromUint8ToStringArray() {
  return Xm;
}, getAxesPermutation() {
  return Jl;
}, getBroadcastDims() {
  return Pl;
}, getComplexWithIndex() {
  return Am;
}, getEinsumComputePath() {
  return Rm;
}, getEinsumPermutation() {
  return Cm;
}, getFusedBiasGradient() {
  return ch;
}, getFusedDyActivation() {
  return dh;
}, getImageCenter() {
  return Jf;
}, getInnerMostAxes() {
  return eu;
}, getPermuted() {
  return em;
}, getRaggedRank() {
  return qf;
}, getReductionAxes() {
  return zl;
}, getReshaped() {
  return Qf;
}, getReshapedPermuted() {
  return tm;
}, getRowPartitionTypesHelper() {
  return Xf;
}, getSliceBeginCoords() {
  return nm;
}, getSliceSize() {
  return rm;
}, getSparseFillEmptyRowsIndicesDenseShapeMismatch() {
  return Tm;
}, getSparseFillEmptyRowsNegativeIndexErrorMessage() {
  return Mm;
}, getSparseFillEmptyRowsOutOfRangeIndexErrorMessage() {
  return Om;
}, getSparseReshapeEmptyTensorZeroOutputDimErrorMessage() {
  return zm;
}, getSparseReshapeInputOutputMismatchErrorMessage() {
  return _m;
}, getSparseReshapeInputOutputMultipleErrorMessage() {
  return Vm;
}, getSparseReshapeMultipleNegativeOneOutputDimErrorMessage() {
  return Fm;
}, getSparseReshapeNegativeOutputDimErrorMessage() {
  return Pm;
}, getSparseSegmentReductionIndicesOutOfRangeErrorMessage() {
  return Bm;
}, getSparseSegmentReductionNegativeSegmentIdsErrorMessage() {
  return Dm;
}, getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage() {
  return Wm;
}, getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage() {
  return Lm;
}, getUndoAxesPermutation() {
  return Ql;
}, isIdentityPermutation() {
  return Sm;
}, log() {
  return ua;
}, mergeRealAndImagArrays() {
  return hm;
}, prepareAndValidate() {
  return Af;
}, prepareSplitSize() {
  return Em;
}, segment_util() {
  return Um;
}, shouldFuse() {
  return ph;
}, slice_util() {
  return xf;
}, splitRealAndImagArrays() {
  return pm;
}, stridesOrDilationsArePositive() {
  return Uo;
}, tupleValuesAreOne() {
  return Lo;
}, upcastType() {
  return pi;
}, validateDefaultValueShape() {
  return Zf;
}, validateInput() {
  return Wc;
}, validateUpdateShape() {
  return Dc;
}, warn() {
  return la;
} }), ((e20) => {
  e20[e20.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", e20[e20.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", e20[e20.ROW_LENGTHS = 2] = "ROW_LENGTHS", e20[e20.ROW_SPLITS = 3] = "ROW_SPLITS", e20[e20.ROW_LIMITS = 4] = "ROW_LIMITS", e20[e20.ROW_STARTS = 5] = "ROW_STARTS";
})(Bf || (Bf = {}));
var Kf = 30;
function Yf(e20) {
  return e20 > Kf ? ke(e20, Math.floor(Math.sqrt(e20))) : e20;
}
function Jf(e20, t2, n2) {
  return [n2 * ("number" == typeof e20 ? e20 : e20[0]), t2 * ("number" == typeof e20 ? e20 : e20[1])];
}
function Qf(e20, t2, n2, r2 = true) {
  let a2 = [];
  if (r2) a2 = a2.concat(t2.slice(0)), a2.push(e20[0] / n2), a2 = a2.concat(e20.slice(1));
  else {
    a2 = a2.concat(e20[0]);
    let n3 = t2.length;
    for (let r3 = 0; n3 > r3; ++r3) a2 = a2.concat([e20[r3 + 1] / t2[r3], t2[r3]]);
    a2 = a2.concat(e20.slice(n3 + 1));
  }
  return a2;
}
function em(e20, t2, n2 = true) {
  let r2 = [];
  if (n2) {
    r2.push(t2);
    for (let n3 = t2 + 1; e20 > n3; ++n3) n3 > 2 * t2 ? r2.push(n3) : (r2.push(n3), r2.push(n3 - (t2 + 1)));
  } else {
    let n3 = [], a2 = [];
    for (let r3 = 1; e20 > r3; ++r3) 2 * t2 + 1 > r3 && r3 % 2 != 1 ? n3.push(r3) : a2.push(r3);
    r2.push(...n3), r2.push(0), r2.push(...a2);
  }
  return r2;
}
function tm(e20, t2, n2, r2 = true) {
  let a2 = [];
  a2.push(r2 ? e20[0] / n2 : e20[0] * n2);
  for (let i2 = 1; e20.length > i2; ++i2) a2.push(i2 > t2.length ? e20[i2] : r2 ? t2[i2 - 1] * e20[i2] : e20[i2] / t2[i2 - 1]);
  return a2;
}
function nm(e20, t2) {
  let n2 = [0];
  for (let r2 = 0; t2 > r2; ++r2) n2.push(e20[r2][0]);
  return n2;
}
function rm(e20, t2, n2) {
  let r2 = e20.slice(0, 1);
  for (let a2 = 0; n2 > a2; ++a2) r2.push(e20[a2 + 1] - t2[a2][0] - t2[a2][1]);
  return r2;
}
var am = 1.7580993408473768;
var im = 1.0507009873554805;
var sm = 0.3275911;
var om = 0.254829592;
var lm = -0.284496736;
var um = 1.421413741;
var dm = -1.453152027;
var cm = 1.061405429;
function hm(e20, t2) {
  if (e20.length !== t2.length) throw Error(`Cannot merge real and imag arrays of different lengths. real:${e20.length}, imag: ${t2.length}.`);
  let n2 = new Float32Array(2 * e20.length);
  for (let r2 = 0; n2.length > r2; r2 += 2) n2[r2] = e20[r2 / 2], n2[r2 + 1] = t2[r2 / 2];
  return n2;
}
function pm(e20) {
  let t2 = new Float32Array(e20.length / 2), n2 = new Float32Array(e20.length / 2);
  for (let r2 = 0; e20.length > r2; r2 += 2) t2[r2 / 2] = e20[r2], n2[r2 / 2] = e20[r2 + 1];
  return { real: t2, imag: n2 };
}
function fm(e20) {
  let t2 = Math.ceil(e20.length / 4), n2 = new Float32Array(t2), r2 = new Float32Array(t2);
  for (let a2 = 0; e20.length > a2; a2 += 4) n2[Math.floor(a2 / 4)] = e20[a2], r2[Math.floor(a2 / 4)] = e20[a2 + 1];
  return { real: n2, imag: r2 };
}
function mm(e20) {
  let t2 = Math.floor(e20.length / 4), n2 = new Float32Array(t2), r2 = new Float32Array(t2);
  for (let a2 = 2; e20.length > a2; a2 += 4) n2[Math.floor(a2 / 4)] = e20[a2], r2[Math.floor(a2 / 4)] = e20[a2 + 1];
  return { real: n2, imag: r2 };
}
function Am(e20, t2) {
  return { real: e20[2 * t2], imag: e20[2 * t2 + 1] };
}
function xm(e20, t2, n2, r2) {
  e20[2 * r2] = t2, e20[2 * r2 + 1] = n2;
}
function ym(e20, t2) {
  let n2 = new Float32Array(e20 / 2), r2 = new Float32Array(e20 / 2);
  for (let a2 = 0; Math.ceil(e20 / 2) > a2; a2++) {
    let i2 = (t2 ? 2 : -2) * Math.PI * (a2 / e20);
    n2[a2] = Math.cos(i2), r2[a2] = Math.sin(i2);
  }
  return { real: n2, imag: r2 };
}
function bm(e20, t2, n2) {
  let r2 = (n2 ? 2 : -2) * Math.PI * (e20 / t2);
  return { real: Math.cos(r2), imag: Math.sin(r2) };
}
var gm = "->";
var vm = /->/g;
var wm = ",";
var km = "...";
function Nm(e20, t2) {
  let n2 = ((e20 = e20.replace(/\s/g, "")).length - e20.replace(vm, "").length) / gm.length;
  if (1 > n2) throw Error("Equations without an arrow are not supported.");
  if (n2 > 1) throw Error(`Equation must contain exactly one arrow ("${gm}").`);
  let [r2, a2] = e20.split(gm);
  Z(-1 === r2.indexOf(km), () => `The ellipsis notation ("${km}") is not supported yet.`);
  let i2 = r2.split(wm), s2 = i2.length;
  if (t2 !== s2) throw Error(`Expected ${s2} input tensors, received ${t2}`);
  if (s2 > 2) throw Error("Support for more than 2 input tensors is not implemented yet.");
  let o2 = [];
  for (let c2 = 0; a2.length > c2; ++c2) {
    let e21 = a2[c2];
    if (!i2.some((t3) => -1 !== t3.indexOf(e21))) throw Error(`Output subscripts contain the label ${e21} not present in the input subscripts.`);
    -1 === o2.indexOf(e21) && o2.push(e21);
  }
  for (let c2 = 0; r2.length > c2; ++c2) {
    let e21 = r2[c2];
    -1 === o2.indexOf(e21) && e21 !== wm && o2.push(e21);
  }
  let l2 = Array(i2.length);
  for (let c2 = 0; s2 > c2; ++c2) {
    if (new Set(i2[c2].split("")).size !== i2[c2].length) throw Error(`Found duplicate axes in input component ${i2[c2]}. Support for duplicate axes in input is not implemented yet.`);
    l2[c2] = [];
    for (let e21 = 0; i2[c2].length > e21; ++e21) l2[c2].push(o2.indexOf(i2[c2][e21]));
  }
  let u2 = o2.length, d2 = [];
  for (let c2 = a2.length; u2 > c2; ++c2) d2.push(c2);
  return { allDims: o2, summedDims: d2, idDims: l2 };
}
function Cm(e20, t2) {
  let n2 = Array(e20);
  n2.fill(-1);
  for (let a2 = 0; t2.length > a2; ++a2) n2[t2[a2]] = a2;
  let r2 = [];
  for (let a2 = 0; e20 > a2; ++a2) -1 === n2[a2] && r2.push(a2);
  return n2 = n2.filter((e21) => -1 !== e21), { permutationIndices: n2, expandDims: r2 };
}
function $m(e20, t2, n2) {
  let r2 = Array(e20);
  for (let a2 = 0; n2.length > a2; ++a2) {
    let e21 = n2[a2].shape;
    for (let n3 = 0; t2[a2].length > n3; ++n3) void 0 === r2[t2[a2][n3]] ? r2[t2[a2][n3]] = e21[n3] : Z(r2[t2[a2][n3]] === e21[n3], () => `Expected dimension ${r2[t2[a2][n3]]} at axis ${n3} of input shaped ${JSON.stringify(e21)}, but got dimension ${e21[n3]}`);
  }
}
function Rm(e20, t2) {
  let n2 = e20, r2 = [], a2 = 0;
  0 === e20.length && n2.push(-1), a2 = e20.length + 1;
  for (let s2 = 0; a2 > s2; ++s2) r2.push([]);
  let i2 = [];
  for (let s2 = 0; n2.length > s2; ++s2) {
    let e21 = Im(t2, n2[s2]);
    for (let t3 of e21) -1 === i2.indexOf(t3) && (r2[s2].push(t3), i2.push(t3));
  }
  return { path: n2, steps: r2 };
}
function Sm(e20) {
  return e20.every((e21, t2) => e21 === t2);
}
function Im(e20, t2) {
  let n2 = [];
  for (let r2 = 0; e20.length > r2; ++r2) (0 === e20[r2].length || -1 !== e20[r2].indexOf(t2) || -1 === t2) && n2.push(r2);
  return n2;
}
function Em(e20, t2, n2 = 0) {
  let r2 = [];
  if ("number" == typeof t2) Z(e20.shape[n2] % t2 === 0, () => "Number of splits must evenly divide the axis."), r2 = Array(t2).fill(e20.shape[n2] / t2);
  else {
    Z(1 >= t2.reduce((e21, t3) => (-1 === t3 && (e21 += 1), e21), 0), () => "There should be only one negative value in split array.");
    let a2 = t2.indexOf(-1);
    if (-1 !== a2) {
      let r3 = t2.reduce((e21, t3) => t3 > 0 ? e21 + t3 : e21);
      t2[a2] = e20.shape[n2] - r3;
    }
    Z(e20.shape[n2] === t2.reduce((e21, t3) => e21 + t3), () => "The sum of sizes must match the size of the axis dimension."), r2 = t2;
  }
  return r2;
}
function Tm(e20) {
  return "Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = " + e20;
}
function Mm(e20, t2) {
  return `indices(${e20}, 0) is invalid: ${t2} < 0`;
}
function Om(e20, t2, n2) {
  return `indices(${e20}, 0) is invalid: ${t2} >= ${n2}`;
}
function Fm(e20, t2) {
  return `only one output dimension may be -1, not both ${e20} and ${t2}`;
}
function Pm(e20, t2) {
  return `size ${e20} must be non-negative, not ${t2}`;
}
function zm() {
  return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
}
function Vm(e20, t2) {
  return `Input to reshape is a SparseTensor with ${J(e20)}
  dense values, but the requested shape requires a multiple of ${J(t2)}. inputShape=${e20} outputShape= ${t2}`;
}
function _m(e20, t2) {
  return `Input to reshape is a tensor with ${J(e20)} dense values, but the requested shape has ${J(t2)}. inputShape=${e20} outputShape=${t2}`;
}
function Dm() {
  return "segment ids must be >= 0";
}
function Wm() {
  return "segment ids are not increasing";
}
function Lm(e20, t2) {
  return `Segment id ${e20} out of range [0, ${t2}), possibly because segmentIds input is not sorted.`;
}
function Bm(e20, t2, n2) {
  return `Bad: indices[${e20}] == ${t2} out of range [0, ${n2})`;
}
var Um = {};
function jm(e20, t2) {
  let n2, r2 = false;
  for (e20 > Kf ? n2 = ke(e20, Math.floor(Math.sqrt(e20))) : (n2 = e20, r2 = true); !r2; ) n2 > t2 || n2 === e20 ? r2 = true : n2 = ke(e20, n2 + 1);
  return n2;
}
function Gm(e20, t2, n2) {
  let r2 = [], a2 = e20.length;
  for (let i2 = 0; a2 > i2; i2++) r2.push(i2 !== t2 ? e20[i2] : n2);
  return r2;
}
function Hm(e20, t2, n2, r2) {
  let a2 = t2.shape.length, i2 = e20.shape.length;
  if (0 !== r2 && (-a2 > r2 || r2 > a2)) throw Error(`Expect batchDims in the range of [-${a2}, ${a2}], but got ${r2}`);
  if (0 > r2 && (r2 += a2), r2 > i2) throw Error(`batchDims (${r2}) must be less than rank(x) (
    ${i2}).`);
  if (r2 > n2) throw Error(`batchDims (${r2}) must be less than or equal to axis (${n2}).`);
  for (let c2 = 0; r2 > c2; ++c2) if (e20.shape[c2] !== t2.shape[c2]) throw Error(`x.shape[${c2}]: ${e20.shape[c2]} should be equal to indices.shape[${c2}]: ${t2.shape[c2]}.`);
  let s2 = e20.shape[n2], o2 = [], l2 = 1, u2 = 1, d2 = 1;
  for (let c2 = 0; r2 > c2; ++c2) o2.push(e20.shape[c2]), l2 *= e20.shape[c2];
  for (let c2 = r2; n2 > c2; c2++) o2.push(e20.shape[c2]), u2 *= e20.shape[c2];
  for (let c2 = r2; a2 > c2; c2++) o2.push(t2.shape[c2]);
  for (let c2 = n2 + 1; i2 > c2; c2++) o2.push(e20.shape[c2]), d2 *= e20.shape[c2];
  return { batchSize: l2, sliceSize: d2, outerSize: u2, dimSize: s2, outputShape: o2 };
}
function Xm(e20) {
  try {
    return e20.map((e21) => Ba(e21));
  } catch (t2) {
    throw Error("Failed to decode encoded string bytes into utf-8, error: " + t2);
  }
}
function qm(e20) {
  return e20.map((e21) => La(e21));
}
A(Um, { collectGatherOpShapeInfo() {
  return Hm;
}, computeOutShape() {
  return Gm;
}, segOpComputeOptimalWindowSize() {
  return jm;
} });
var Zm;
var Km;
var Ym = {};
A(Ym, { nonMaxSuppressionV3Impl() {
  return Mh;
}, nonMaxSuppressionV4Impl() {
  return Oh;
}, nonMaxSuppressionV5Impl() {
  return Fh;
}, whereImpl() {
  return Kc;
} }), (() => {
  for (let e20 of Pp) Cp(e20);
})(), _e().registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (e20) => {
  e20 && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
}), ((e20) => {
  e20[e20.DT_INVALID = 0] = "DT_INVALID", e20[e20.DT_FLOAT = 1] = "DT_FLOAT", e20[e20.DT_DOUBLE = 2] = "DT_DOUBLE", e20[e20.DT_INT32 = 3] = "DT_INT32", e20[e20.DT_UINT8 = 4] = "DT_UINT8", e20[e20.DT_INT16 = 5] = "DT_INT16", e20[e20.DT_INT8 = 6] = "DT_INT8", e20[e20.DT_STRING = 7] = "DT_STRING", e20[e20.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e20[e20.DT_INT64 = 9] = "DT_INT64", e20[e20.DT_BOOL = 10] = "DT_BOOL", e20[e20.DT_QINT8 = 11] = "DT_QINT8", e20[e20.DT_QUINT8 = 12] = "DT_QUINT8", e20[e20.DT_QINT32 = 13] = "DT_QINT32", e20[e20.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e20[e20.DT_QINT16 = 15] = "DT_QINT16", e20[e20.DT_QUINT16 = 16] = "DT_QUINT16", e20[e20.DT_UINT16 = 17] = "DT_UINT16", e20[e20.DT_COMPLEX128 = 18] = "DT_COMPLEX128", e20[e20.DT_HALF = 19] = "DT_HALF", e20[e20.DT_RESOURCE = 20] = "DT_RESOURCE", e20[e20.DT_VARIANT = 21] = "DT_VARIANT", e20[e20.DT_UINT32 = 22] = "DT_UINT32", e20[e20.DT_UINT64 = 23] = "DT_UINT64", e20[e20.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e20[e20.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e20[e20.DT_INT32_REF = 103] = "DT_INT32_REF", e20[e20.DT_UINT8_REF = 104] = "DT_UINT8_REF", e20[e20.DT_INT16_REF = 105] = "DT_INT16_REF", e20[e20.DT_INT8_REF = 106] = "DT_INT8_REF", e20[e20.DT_STRING_REF = 107] = "DT_STRING_REF", e20[e20.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e20[e20.DT_INT64_REF = 109] = "DT_INT64_REF", e20[e20.DT_BOOL_REF = 110] = "DT_BOOL_REF", e20[e20.DT_QINT8_REF = 111] = "DT_QINT8_REF", e20[e20.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e20[e20.DT_QINT32_REF = 113] = "DT_QINT32_REF", e20[e20.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", e20[e20.DT_QINT16_REF = 115] = "DT_QINT16_REF", e20[e20.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", e20[e20.DT_UINT16_REF = 117] = "DT_UINT16_REF", e20[e20.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", e20[e20.DT_HALF_REF = 119] = "DT_HALF_REF", e20[e20.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", e20[e20.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", e20[e20.DT_UINT32_REF = 122] = "DT_UINT32_REF", e20[e20.DT_UINT64_REF = 123] = "DT_UINT64_REF";
})(Zm || (Zm = {})), ((e20) => {
  var t2;
  (t2 = e20.CheckpointFormatVersion || (e20.CheckpointFormatVersion = {}))[t2.LEGACY = 0] = "LEGACY", t2[t2.V1 = 1] = "V1", t2[t2.V2 = 2] = "V2";
})(Km || (Km = {}));
var Jm = {};
function Qm(e20, t2) {
  Jm[e20] = { tfOpName: e20, category: "custom", inputs: [], attrs: [], customExecutor: t2 };
}
function eA(e20) {
  return Jm[e20];
}
function tA(e20) {
  delete Jm[e20];
}
function nA(e20, t2, n2, r2, a2) {
  let i2 = t2.inputParams[e20];
  if (i2 && void 0 !== i2.inputIndexStart) {
    let e21 = i2.inputIndexStart, s3 = 0 === i2.inputIndexEnd ? void 0 : void 0 === i2.inputIndexEnd ? e21 + 1 : i2.inputIndexEnd, o2 = 0 > e21 ? t2.inputNames.length + e21 : e21;
    if ("tensor" === i2.type) return rA(t2.inputNames[o2], n2, r2, a2);
    if ("tensors" === i2.type) {
      let i3 = t2.inputs.slice(e21, s3);
      return t2.inputNames.slice(e21, s3).filter((e22, t3) => {
        var n3;
        return "NoOp" !== (null === (n3 = i3[t3]) || void 0 === n3 ? void 0 : n3.op);
      }).map((e22) => rA(e22, n2, r2, a2));
    }
    let l2 = rA(t2.inputNames[o2], n2, r2, a2), u2 = l2.dataSync();
    return "number" === i2.type ? u2[0] : va.toNestedArray(l2.shape, u2);
  }
  let s2 = t2.attrParams[e20];
  return s2 && s2.value;
}
function rA(e20, t2, n2, r2) {
  let [a2, i2] = oA(e20, n2);
  if (null != r2) {
    let e21 = r2.getHashTableHandleByName(a2);
    if (null != e21) return e21;
  }
  let s2 = n2.currentContextIds.find((e21) => !!t2[sA(a2, e21)]);
  return void 0 !== s2 ? t2[sA(a2, s2)][i2] : void 0;
}
function aA(e20, t2, n2) {
  return t2[sA(e20, n2.currentContextId)];
}
function iA(e20, t2) {
  let [n2, r2, a2] = oA(e20, t2);
  return [sA(n2, t2 && t2.currentContextId), r2, a2];
}
function sA(e20, t2) {
  return t2 ? `${e20}-${t2}` : e20;
}
function oA(e20, t2) {
  if ("" === e20) return ["", 0, void 0];
  let n2 = null != t2 && null != t2.parseNodeNameCache;
  if (n2) {
    let n3 = t2.parseNodeNameCache.get(e20);
    if (null != n3) return n3;
  }
  let r2, a2 = e20.split(":");
  return r2 = 1 === a2.length ? [e20, 0, void 0] : [a2[0], +a2[a2.length - 1], 3 === a2.length ? a2[1] : void 0], n2 && t2.parseNodeNameCache.set(e20, r2), r2;
}
function lA(e20, t2, n2) {
  let r2 = nA("pad", e20, t2, n2);
  if ("explicit" === r2) {
    r2 = nA("explicitPaddings", e20, t2, n2);
    let a2 = [[0, 0], [0, 0], [0, 0], [0, 0]];
    for (let e21 = 0; 4 > e21; e21++) a2[e21][0] = r2[2 * e21], a2[e21][1] = r2[2 * e21 + 1];
    return a2;
  }
  return r2;
}
function uA(e20) {
  return e20.kept ? e20 : ho(e20);
}
var dA = {};
A(dA, { json() {
  return cA;
} });
var cA = [{ tfOpName: "Add", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddV2", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AddN", category: "arithmetic", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "BiasAdd", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "Sub", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "RealDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Div", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "DivNoNan", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mul", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Maximum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Minimum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Pow", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SquaredDifference", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Mod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "FloorMod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
var hA = {};
A(hA, { json() {
  return pA;
} });
var pA = [{ tfOpName: "Abs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atan2", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Ceil", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ClipByValue", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "clipValueMin", type: "number" }, { start: 2, name: "clipValueMax", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Complex", category: "basic_math", inputs: [{ start: 0, name: "real", type: "tensor" }, { start: 1, name: "imag", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ComplexAbs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Elu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Exp", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Floor", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Imag", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Neg", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Real", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: true }] }, { tfOpName: "Prelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "alpha", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Relu6", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Selu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sigmoid", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Rsqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Square", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Tanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Sign", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Round", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Expm1", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Log1p", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Reciprocal", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Softplus", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Asinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Acosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Atanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Erf", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LeakyRelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "alpha", name: "alpha", type: "number", defaultValue: 0.2 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsNan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsFinite", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "IsInf", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
var fA = {};
A(fA, { json() {
  return mA;
} });
var mA = [{ tfOpName: "EmptyTensorList", category: "control", inputs: [{ start: 0, name: "elementShape", type: "shape" }, { start: 1, name: "maxNumElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "LoopCond", category: "control", inputs: [{ start: 0, name: "pred", type: "tensor" }] }, { tfOpName: "Switch", category: "control", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "pred", type: "tensor" }] }, { tfOpName: "Merge", category: "control", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "Enter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "frame_name", name: "frameName", type: "string" }, { tfName: "is_constant", name: "isConstant", type: "bool" }] }, { tfOpName: "Exit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NextIteration", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayV3", category: "control", inputs: [{ start: 0, name: "size", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "dynamic_size", name: "dynamicSize", type: "bool" }, { tfName: "clear_after_read", name: "clearAfterRead", type: "bool" }, { tfName: "identical_element_shapes", name: "identicalElementShapes", type: "bool" }, { tfName: "tensor_array_name", name: "name", type: "string" }] }, { tfOpName: "TensorArrayWriteV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayReadV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "TensorArrayGatherV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }] }, { tfOpName: "TensorArrayScatterV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArrayConcatV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape_except0", name: "elementShapeExcept0", type: "shape", notSupported: true }] }, { tfOpName: "TensorArraySplitV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "tensor", type: "tensor" }, { start: 2, name: "lengths", type: "number[]" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArraySizeV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }, { start: 1, name: "flowIn", type: "number" }] }, { tfOpName: "TensorArrayCloseV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "tensor" }] }, { tfOpName: "StatelessIf", category: "control", inputs: [{ start: 0, name: "cond", type: "tensor" }, { start: 1, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "then_branch", name: "thenBranch", type: "func" }, { tfName: "else_branch", name: "elseBranch", type: "func" }] }, { tfOpName: "If", category: "control", inputs: [{ start: 0, name: "cond", type: "tensor" }, { start: 1, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "then_branch", name: "thenBranch", type: "func" }, { tfName: "else_branch", name: "elseBranch", type: "func" }] }, { tfOpName: "StatelessWhile", category: "control", inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "cond", name: "cond", type: "func" }, { tfName: "body", name: "body", type: "func" }] }, { tfOpName: "While", category: "control", inputs: [{ start: 0, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "cond", name: "cond", type: "func" }, { tfName: "body", name: "body", type: "func" }] }, { tfOpName: "TensorListScatter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListScatterV2", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }, { start: 3, name: "numElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListGather", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListGetItem", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListSetItem", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListReserve", category: "control", inputs: [{ start: 0, name: "elementShape", type: "shape" }, { start: 1, name: "numElements", type: "number" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListFromTensor", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListStack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }, { tfName: "num_elements", name: "numElements", type: "dtype" }] }, { tfOpName: "TensorListSplit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }, { start: 2, name: "lengths", type: "number[]" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListConcat", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }], attrs: [{ tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListConcatV2", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }], attrs: [{ tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListPopBack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "elementShape", type: "shape" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListPushBack", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "tensor", type: "tensor" }], attrs: [{ tfName: "element_dtype", name: "elementDType", type: "dtype" }] }, { tfOpName: "TensorListLength", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }] }, { tfOpName: "TensorListResize", category: "control", inputs: [{ start: 0, name: "tensorListId", type: "tensor" }, { start: 1, name: "size", type: "number" }] }];
var AA = {};
A(AA, { json() {
  return xA;
} });
var xA = [{ tfOpName: "AvgPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [], notSupported: true }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPoolWithArgmax", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "include_batch_in_index", name: "includeBatchInIndex", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "AvgPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MaxPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Conv1D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "stride", name: "stride", type: "number" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NWC" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "dilation", name: "dilation", type: "number", defaultValue: 1 }] }, { tfOpName: "Conv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "_FusedConv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "use_cudnn_on_gpu", name: "useCudnnOnGpu", type: "bool", defaultValue: true }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }, { tfName: "leakyrelu_alpha", name: "leakyreluAlpha", type: "number", defaultValue: 0.2 }] }, { tfOpName: "Conv2DBackpropInput", category: "convolution", inputs: [{ start: 2, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 0, name: "outputShape", type: "number[]" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]", notSupported: true }] }, { tfOpName: "DepthwiseConv2d", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "DepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "FusedDepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }] }, { tfOpName: "Conv3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "Dilation2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "rates", name: "dilations", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }] }];
var yA = {};
A(yA, { json() {
  return bA;
} });
var bA = [{ tfOpName: "Fill", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }, { start: 1, name: "value", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "LinSpace", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "num", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "OneHot", category: "creation", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "depth", type: "number" }, { start: 2, name: "onValue", type: "number", defaultValue: 1 }, { start: 3, name: "offValue", type: "number", defaultValue: 0 }], attrs: [{ tfName: "axis", name: "axis", type: "number", notSupported: true }, { tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "Ones", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "OnesLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "RandomStandardNormal", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "RandomUniform", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "minval", name: "minval", type: "number", defaultValue: 0 }, { tfName: "maxval", name: "maxval", type: "number", defaultValue: 1 }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "RandomUniformInt", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "minval", name: "minval", type: "number" }, { tfName: "maxval", name: "maxval", type: "number" }, { tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }] }, { tfOpName: "Range", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "step", type: "number", defaultValue: 0 }], attrs: [{ tfName: "Tidx", name: "dtype", type: "dtype" }] }, { tfOpName: "TruncatedNormal", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "means", name: "mean", type: "number", defaultValue: 0 }, { tfName: "stddev", name: "stdDev", type: "number", defaultValue: 1 }, { tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "T", name: "T", type: "number", notSupported: true }] }, { tfOpName: "Zeros", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "ZerosLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "Multinomial", category: "creation", inputs: [{ start: 0, name: "logits", type: "tensor" }, { start: 1, name: "numSamples", type: "number" }], attrs: [{ tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number" }, { tfName: "T", name: "dtype", type: "dtype" }, { tfName: "output_dtype", name: "output_dtype", type: "dtype" }] }];
var gA = {};
A(gA, { json() {
  return vA;
} });
var vA = [{ tfOpName: "NonMaxSuppressionV2", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV3", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV4", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }, { tfName: "T_threshold", name: "threshold", type: "dtype", notSupported: true }, { tfName: "pad_to_max_output_size", name: "padToMaxOutputSize", type: "bool" }] }, { tfOpName: "NonMaxSuppressionV5", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }, { start: 5, name: "softNmsSigma", type: "number" }] }, { tfOpName: "Where", category: "dynamic", inputs: [{ start: 0, name: "condition", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ListDiff", category: "dynamic", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }];
var wA = {};
A(wA, { json() {
  return kA;
} });
var kA = [{ tfOpName: "LowerBound", category: "evaluation", inputs: [{ start: 0, name: "sortedSequence", type: "tensor" }, { start: 1, name: "values", type: "tensor" }] }, { tfOpName: "TopKV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "k", type: "number" }], attrs: [{ tfName: "sorted", name: "sorted", type: "bool" }] }, { tfOpName: "UpperBound", category: "evaluation", inputs: [{ start: 0, name: "sortedSequence", type: "tensor" }, { start: 1, name: "values", type: "tensor" }] }, { tfOpName: "Unique", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "UniqueV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }];
var NA = {};
A(NA, { json() {
  return CA;
} });
var CA = [{ tfOpName: "PlaceholderWithDefault", category: "graph", inputs: [{ start: 0, name: "default", type: "tensor" }], attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Placeholder", category: "graph", attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Const", category: "graph" }, { tfOpName: "Identity", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IdentityN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Snapshot", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Rank", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Size", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Shape", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "ShapeN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Print", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "data", type: "tensors" }], attrs: [{ tfName: "message", name: "message", type: "string" }, { tfName: "first_n", name: "firstN", type: "number", notSupported: true }, { tfName: "summarize", name: "summarize", type: "number", defaultValue: 3 }] }, { tfOpName: "NoOp", category: "graph", inputs: [] }, { tfOpName: "StopGradient", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "FakeQuantWithMinMaxVars", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "min", name: "min", type: "number" }, { tfName: "max", name: "max", type: "number" }] }];
var $A = {};
A($A, { json() {
  return RA;
} });
var RA = [{ tfOpName: "HashTable", category: "hash_table", inputs: [], attrs: [{ tfName: "shared_name", name: "sharedName", type: "string" }, { tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" }, { tfName: "key_dtype", name: "keyDType", type: "dtype" }, { tfName: "value_dtype", name: "valueDType", type: "dtype" }] }, { tfOpName: "HashTableV2", category: "hash_table", inputs: [], attrs: [{ tfName: "shared_name", name: "sharedName", type: "string" }, { tfName: "use_node_name_sharing", name: "useNodeNameSharing", type: "bool" }, { tfName: "key_dtype", name: "keyDType", type: "dtype" }, { tfName: "value_dtype", name: "valueDType", type: "dtype" }] }, { tfOpName: "LookupTableImport", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableImportV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableFind", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableFindV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "Tin", name: "tIn", type: "dtype", notSupported: true }, { tfName: "Tout", name: "tOut", type: "dtype", notSupported: true }] }, { tfOpName: "LookupTableSize", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }] }, { tfOpName: "LookupTableSizeV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }] }, { tfOpName: "InitializeTable", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }] }, { tfOpName: "InitializeTableV2", category: "hash_table", inputs: [{ start: 0, name: "tableHandle", type: "tensor" }, { start: 1, name: "keys", type: "tensor" }, { start: 2, name: "values", type: "tensor" }] }];
var SA = {};
A(SA, { json() {
  return IA;
} });
var IA = [{ tfOpName: "ResizeBilinear", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "ResizeNearestNeighbor", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "half_pixel_centers", name: "halfPixelCenters", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "CropAndResize", category: "image", inputs: [{ start: 0, name: "image", type: "tensor" }, { start: 1, name: "boxes", type: "tensor" }, { start: 2, name: "boxInd", type: "tensor" }, { start: 3, name: "cropSize", type: "number[]" }], attrs: [{ tfName: "method", name: "method", type: "string" }, { tfName: "extrapolation_value", name: "extrapolationValue", type: "number" }] }, { tfOpName: "ImageProjectiveTransformV3", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "transforms", type: "tensor" }, { start: 2, name: "outputShape", type: "number[]" }, { start: 3, name: "fillValue", type: "number" }], attrs: [{ tfName: "interpolation", name: "interpolation", type: "string" }, { tfName: "fill_mode", name: "fillMode", type: "string" }] }];
var EA = {};
A(EA, { json() {
  return TA;
} });
var TA = [{ tfOpName: "Equal", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "NotEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Greater", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "GreaterEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Less", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LessEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalAnd", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalNot", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "LogicalOr", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Select", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SelectV2", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BitwiseAnd", category: "logical", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }] }];
var MA = {};
A(MA, { json() {
  return OA;
} });
var OA = [{ tfOpName: "_FusedMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }, { tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "leakyrelu_alpha", name: "leakyreluAlpha", type: "number", defaultValue: 0.2 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "MatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "BatchMatMulV2", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Transpose", category: "matrices", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "perm", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Einsum", category: "matrices", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "equation", name: "equation", type: "string" }, { tfName: "N", name: "n", type: "number", defaultValue: 2 }, { tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "MatrixBandPart", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "numLower", type: "tensor" }, { start: 1, name: "numUpper", type: "tensor" }] }];
var FA = {};
A(FA, { json() {
  return PA;
} });
var PA = [{ tfOpName: "EuclideanNorm", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool", defaultValue: false }] }, { tfOpName: "FusedBatchNorm", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV2", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "FusedBatchNormV3", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: true }] }, { tfOpName: "LRN", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "depth_radius", name: "radius", type: "number", defaultValue: 5 }, { tfName: "bias", name: "bias", type: "number", defaultValue: 1 }, { tfName: "alpha", name: "alpha", type: "number", defaultValue: 1 }, { tfName: "beta", name: "beta", type: "number", defaultValue: 0.5 }] }, { tfOpName: "Softmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "LogSoftmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }];
var zA = {};
A(zA, { json() {
  return VA;
} });
var VA = [{ tfOpName: "Bincount", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "size", type: "number" }, { start: 2, name: "weights", type: "tensor" }] }, { tfOpName: "DenseBincount", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "size", type: "number" }, { start: 2, name: "weights", type: "tensor" }], attrs: [{ tfName: "binary_output", name: "binaryOutput", type: "bool" }] }, { tfOpName: "Max", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Mean", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Min", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Sum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "All", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Any", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "ArgMax", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "ArgMin", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "Prod", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "Cumprod", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }], attrs: [{ tfName: "exclusive", name: "exclusive", type: "bool" }, { tfName: "reverse", name: "reverse", type: "bool" }] }, { tfOpName: "Cumsum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }], attrs: [{ tfName: "exclusive", name: "exclusive", type: "bool" }, { tfName: "reverse", name: "reverse", type: "bool" }] }];
var _A = {};
A(_A, { json() {
  return DA;
} });
var DA = [{ tfOpName: "ConcatV2", category: "slice_join", inputs: [{ start: 0, end: -1, name: "tensors", type: "tensors" }, { start: -1, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "Concat", category: "slice_join", inputs: [{ start: 1, end: 0, name: "tensors", type: "tensors" }, { start: 0, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "GatherV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }], attrs: [{ tfName: "batch_dims", name: "batchDims", type: "number", defaultValue: 0 }] }, { tfOpName: "Gather", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", notSupported: true }] }, { tfOpName: "Reverse", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "dims", type: "bool[]" }] }, { tfOpName: "ReverseV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }] }, { tfOpName: "Slice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "size", type: "number[]" }] }, { tfOpName: "StridedSlice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "end", type: "number[]" }, { start: 3, name: "strides", type: "number[]" }], attrs: [{ tfName: "begin_mask", name: "beginMask", type: "number", defaultValue: 0 }, { tfName: "end_mask", name: "endMask", type: "number", defaultValue: 0 }, { tfName: "new_axis_mask", name: "newAxisMask", type: "number", defaultValue: 0 }, { tfName: "ellipsis_mask", name: "ellipsisMask", type: "number", defaultValue: 0 }, { tfName: "shrink_axis_mask", name: "shrinkAxisMask", type: "number", defaultValue: 0 }] }, { tfOpName: "Pack", category: "slice_join", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "Unpack", category: "slice_join", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }, { tfName: "num", name: "num", type: "number", defaultValue: 0, notSupported: true }] }, { tfOpName: "Tile", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "reps", type: "number[]" }] }, { tfOpName: "Split", category: "slice_join", inputs: [{ start: 0, name: "axis", type: "number", defaultValue: 0 }, { start: 1, name: "x", type: "tensor" }], attrs: [{ tfName: "num_split", name: "numOrSizeSplits", type: "number", defaultValue: 1 }] }, { tfOpName: "SplitV", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "numOrSizeSplits", type: "number[]" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "ScatterNd", category: "slice_join", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "shape", type: "number[]" }] }, { tfOpName: "GatherNd", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }] }, { tfOpName: "SparseToDense", category: "slice_join", inputs: [{ start: 0, name: "sparseIndices", type: "tensor" }, { start: 1, name: "outputShape", type: "number[]" }, { start: 2, name: "sparseValues", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: false, notSupported: true }] }, { tfOpName: "TensorScatterUpdate", category: "slice_join", inputs: [{ start: 0, name: "tensor", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "values", type: "tensor" }] }];
var WA = {};
A(WA, { json() {
  return LA;
} });
var LA = [{ tfOpName: "SparseFillEmptyRows", category: "sparse", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "denseShape", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }] }, { tfOpName: "SparseReshape", category: "sparse", inputs: [{ start: 0, name: "inputIndices", type: "tensor" }, { start: 1, name: "inputShape", type: "tensor" }, { start: 2, name: "newShape", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: true }] }, { tfOpName: "SparseSegmentMean", category: "sparse", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "segmentIds", type: "tensor" }] }, { tfOpName: "SparseSegmentSum", category: "sparse", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "segmentIds", type: "tensor" }] }];
var BA = {};
A(BA, { json() {
  return UA;
} });
var UA = [{ tfOpName: "FFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "RFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }, { tfOpName: "IRFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: true }] }];
var jA = {};
A(jA, { json() {
  return GA;
} });
var GA = [{ tfOpName: "StaticRegexReplace", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }], attrs: [{ tfName: "pattern", name: "pattern", type: "string" }, { tfName: "rewrite", name: "rewrite", type: "string" }, { tfName: "replace_global", name: "replaceGlobal", type: "bool" }] }, { tfOpName: "StringNGrams", category: "string", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "dataSplits", type: "tensor" }], attrs: [{ tfName: "separator", name: "separator", type: "string" }, { tfName: "ngram_widths", name: "nGramWidths", type: "number[]" }, { tfName: "left_pad", name: "leftPad", type: "string" }, { tfName: "right_pad", name: "rightPad", type: "string" }, { tfName: "pad_width", name: "padWidth", type: "number" }, { tfName: "preserve_short_sequences", name: "preserveShortSequences", type: "bool" }], outputs: ["ngrams", "ngrams_splits"] }, { tfOpName: "StringSplit", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "delimiter", type: "tensor" }], attrs: [{ tfName: "skip_empty", name: "skipEmpty", type: "bool" }], outputs: ["indices", "values", "shape"] }, { tfOpName: "StringToHashBucketFast", category: "string", inputs: [{ start: 0, name: "input", type: "tensor" }], attrs: [{ tfName: "num_buckets", name: "numBuckets", type: "number" }] }];
var HA = {};
A(HA, { json() {
  return XA;
} });
var XA = [{ tfOpName: "Cast", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "SrcT", name: "sdtype", type: "dtype", notSupported: true }, { tfName: "DstT", name: "dtype", type: "dtype" }] }, { tfOpName: "ExpandDims", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "MirrorPad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "mode", name: "mode", type: "string" }] }, { tfOpName: "Pad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "constant_value", name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "PadV2", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }, { start: 2, name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "Reshape", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }] }, { tfOpName: "EnsureShape", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }] }, { tfOpName: "Squeeze", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "axis", tfDeprecatedName: "squeeze_dims", name: "axis", type: "number[]" }] }, { tfOpName: "SpaceToBatchND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "paddings", type: "number[]" }] }, { tfOpName: "BatchToSpaceND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "crops", type: "number[]" }] }, { tfOpName: "DepthToSpace", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "block_size", name: "blockSize", type: "number" }, { tfName: "data_format", name: "dataFormat", type: "string" }] }, { tfOpName: "BroadcastTo", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }], attrs: [] }, { tfOpName: "BroadcastArgs", category: "transformation", inputs: [{ start: 0, name: "s0", type: "tensor" }, { start: 1, name: "s1", type: "tensor" }], attrs: [] }];
var qA = class {
  static get Instance() {
    return this.tr || (this.tr = new this());
  }
  constructor() {
    let e20 = [].concat(...[dA, hA, fA, AA, yA, gA, wA, NA, $A, SA, EA, MA, FA, zA, _A, WA, BA, jA, HA].map((e21) => e21.json));
    this.opMappers = e20.reduce((e21, t2) => (e21[t2.tfOpName] = t2, e21), {});
  }
  transformGraph(e20, t2 = {}) {
    let n2 = [], r2 = [], a2 = [], i2 = e20.node.reduce((e21, t3) => (e21[t3.name] = this.mapNode(t3), t3.op.startsWith("Placeholder") ? n2.push(e21[t3.name]) : "Const" === t3.op ? r2.push(e21[t3.name]) : (null == t3.input || 0 === t3.input.length) && a2.push(e21[t3.name]), e21), {}), s2 = [], o2 = [], l2 = {}, u2 = {};
    null != t2 && (l2 = this.mapSignatureEntries(t2.inputs), u2 = this.mapSignatureEntries(t2.outputs));
    let d2 = Object.keys(i2);
    d2.forEach((e21) => {
      let t3 = i2[e21];
      t3.inputNames.forEach((e22, n3) => {
        let [r3, , a3] = iA(e22), s3 = i2[r3];
        if (null != s3.outputs) {
          let e23 = s3.outputs.indexOf(a3);
          -1 !== e23 && (t3.inputNames[n3] = `${r3}:${e23}`);
        }
        t3.inputs.push(s3), s3.children.push(t3);
      });
    }), 0 === Object.keys(u2).length ? d2.forEach((e21) => {
      let t3 = i2[e21];
      0 === t3.children.length && o2.push(t3);
    }) : Object.keys(u2).forEach((e21) => {
      let [t3] = iA(e21), n3 = i2[t3];
      null != n3 && (n3.signatureKey = u2[e21], o2.push(n3));
    }), Object.keys(l2).length > 0 ? Object.keys(l2).forEach((e21) => {
      let [t3] = iA(e21), n3 = i2[t3];
      n3 && (n3.signatureKey = l2[e21], s2.push(n3));
    }) : s2 = n2;
    let c2 = {};
    null != e20.library && null != e20.library.function && (c2 = e20.library.function.reduce((e21, t3) => (e21[t3.signature.name] = this.mapFunction(t3), e21), {}));
    let h2 = { nodes: i2, inputs: s2, outputs: o2, weights: r2, placeholders: n2, signature: t2, functions: c2 };
    return a2.length > 0 && (h2.initNodes = a2), h2;
  }
  mapSignatureEntries(e20) {
    return Object.keys(e20 || {}).reduce((t2, n2) => (t2[e20[n2].name] = n2, t2), {});
  }
  mapNode(e20) {
    let t2 = eA(e20.op) || this.opMappers[e20.op] || {};
    null == e20.attr && (e20.attr = {});
    let n2 = { name: e20.name, op: e20.op, category: t2.category, inputNames: (e20.input || []).map((e21) => e21.startsWith("^") ? e21.slice(1) : e21), inputs: [], children: [], inputParams: {}, attrParams: {}, rawAttrs: e20.attr, outputs: t2.outputs };
    return null != t2.inputs && (n2.inputParams = t2.inputs.reduce((e21, t3) => (e21[t3.name] = { type: t3.type, inputIndexStart: t3.start, inputIndexEnd: t3.end }, e21), {})), null != t2.attrs && (n2.attrParams = t2.attrs.reduce((t3, n3) => {
      let r2, a2 = n3.type;
      switch (n3.type) {
        case "string":
          r2 = KA(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = KA(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "string[]":
          r2 = sx(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = sx(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "number":
          r2 = JA(e20.attr, n3.tfName, n3.defaultValue || 0), void 0 === r2 && n3.tfDeprecatedName && (r2 = JA(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "number[]":
          r2 = ix(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = ix(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "bool":
          r2 = YA(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = YA(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "bool[]":
          r2 = lx(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = lx(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "shape":
          r2 = ax(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = ax(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "shape[]":
          r2 = ox(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = ox(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "dtype":
          r2 = tx(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = tx(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "dtype[]":
          r2 = nx(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = nx(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "func":
          r2 = ex(e20.attr, n3.tfName, n3.defaultValue), void 0 === r2 && n3.tfDeprecatedName && (r2 = ex(e20.attr, n3.tfDeprecatedName, n3.defaultValue));
          break;
        case "tensor":
        case "tensors":
          break;
        default:
          throw Error(`Unsupported param type: ${n3.type} for op: ${e20.op}`);
      }
      return t3[n3.name] = { value: r2, type: a2 }, t3;
    }, {})), n2;
  }
  mapFunction(e20) {
    let t2 = e20.nodeDef, n2 = [], r2 = {};
    null != t2 && (r2 = t2.reduce((e21, t3) => (e21[t3.name] = this.mapNode(t3), "Const" === t3.op && n2.push(e21[t3.name]), e21), {}));
    let a2 = [], i2 = [];
    e20.signature.inputArg.forEach((e21) => {
      let [t3] = iA(e21.name), n3 = { name: t3, op: "Placeholder", inputs: [], inputNames: [], category: "graph", inputParams: {}, attrParams: { dtype: { value: QA(e21.type), type: "dtype" } }, children: [] };
      n3.signatureKey = e21.name, a2.push(n3), r2[t3] = n3;
    }), Object.keys(r2).forEach((e21) => {
      let t3 = r2[e21];
      t3.inputNames.forEach((e22, n3) => {
        let [a3, , i3] = iA(e22), s3 = r2[a3];
        if (null != s3.outputs) {
          let e23 = s3.outputs.indexOf(i3);
          -1 !== e23 && (t3.inputNames[n3] = `${a3}:${e23}`);
        }
        t3.inputs.push(s3), s3.children.push(t3);
      });
    });
    let s2 = e20.ret;
    e20.signature.outputArg.forEach((e21) => {
      let [t3, n3] = iA(s2[e21.name]), a3 = r2[t3];
      null != a3 && (a3.defaultOutput = n3, i2.push(a3));
    });
    let o2 = this.mapArgsToSignature(e20);
    return { nodes: r2, inputs: a2, outputs: i2, weights: n2, placeholders: [], signature: o2 };
  }
  mapArgsToSignature(e20) {
    return { methodName: e20.signature.name, inputs: e20.signature.inputArg.reduce((e21, t2) => (e21[t2.name] = this.mapArgToTensorInfo(t2), e21), {}), outputs: e20.signature.outputArg.reduce((t2, n2) => (t2[n2.name] = this.mapArgToTensorInfo(n2, e20.ret), t2), {}) };
  }
  mapArgToTensorInfo(e20, t2) {
    let n2 = e20.name;
    return null != t2 && (n2 = t2[n2]), { name: n2, dtype: e20.type };
  }
};
function ZA(e20, t2) {
  let n2 = Array.isArray(e20) ? String.fromCharCode.apply(null, e20) : ((e21) => {
    let t3 = _e().global;
    if (void 0 !== t3.atob) return t3.atob(e21);
    if ("undefined" != typeof Buffer) return "" + new Buffer(e21, "base64");
    throw Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
  })(e20);
  return t2 ? n2 : n2.toLowerCase();
}
function KA(e20, t2, n2, r2 = false) {
  let a2 = e20[t2];
  return null != a2 ? ZA(a2.s, r2) : n2;
}
function YA(e20, t2, n2) {
  let r2 = e20[t2];
  return r2 ? r2.b : n2;
}
function JA(e20, t2, n2) {
  let r2 = e20[t2] || {}, a2 = null != r2.i ? r2.i : null != r2.f ? r2.f : n2;
  return "number" == typeof a2 ? a2 : parseInt(a2, 10);
}
function QA(e20) {
  switch ("string" == typeof e20 && (e20 = Zm[e20]), e20) {
    case Zm.DT_FLOAT:
    case Zm.DT_HALF:
      return "float32";
    case Zm.DT_INT32:
    case Zm.DT_INT64:
    case Zm.DT_INT8:
    case Zm.DT_UINT8:
      return "int32";
    case Zm.DT_BOOL:
      return "bool";
    case Zm.DT_DOUBLE:
      return "float32";
    case Zm.DT_STRING:
      return "string";
    case Zm.DT_COMPLEX64:
    case Zm.DT_COMPLEX128:
      return "complex64";
    default:
      return null;
  }
}
function ex(e20, t2, n2) {
  let r2 = e20[t2];
  return r2 && r2.func ? r2.func.name : n2;
}
function tx(e20, t2, n2) {
  let r2 = e20[t2];
  return r2 && r2.type ? QA(r2.type) : n2;
}
function nx(e20, t2, n2) {
  let r2 = e20[t2];
  return r2 && r2.list && r2.list.type ? r2.list.type.map((e21) => QA(e21)) : n2;
}
function rx(e20) {
  if (!e20.unknownRank) return null != e20.dim ? e20.dim.map((e21) => "number" == typeof e21.size ? e21.size : parseInt(e21.size, 10)) : [];
}
function ax(e20, t2, n2) {
  let r2 = e20[t2];
  return r2 && r2.shape ? rx(r2.shape) : n2;
}
function ix(e20, t2, n2) {
  let r2 = e20[t2];
  return r2 ? ((r2.list.f && r2.list.f.length ? r2.list.f : r2.list.i) || []).map((e21) => "number" == typeof e21 ? e21 : parseInt(e21, 10)) : n2;
}
function sx(e20, t2, n2, r2 = false) {
  let a2 = e20[t2];
  return a2 && a2.list && a2.list.s ? a2.list.s.map((e21) => ZA(e21, r2)) : n2;
}
function ox(e20, t2, n2) {
  let r2 = e20[t2];
  return r2 && r2.list && r2.list.shape ? r2.list.shape.map((e21) => rx(e21)) : n2;
}
function lx(e20, t2, n2) {
  let r2 = e20[t2];
  return r2 && r2.list && r2.list.b ? r2.list.b : n2;
}
var ux = class {
  constructor(e20, t2, n2) {
    this.node = e20, this.tensorMap = t2, this.context = n2, this.inputs = [], this.attrs = {}, this.inputs = e20.inputNames.map((e21) => this.getInput(e21)), null != e20.rawAttrs && (this.attrs = Object.keys(e20.rawAttrs).reduce((e21, t3) => (e21[t3] = this.getAttr(t3), e21), {}));
  }
  getInput(e20) {
    return rA(e20, this.tensorMap, this.context);
  }
  getAttr(e20, t2) {
    let n2 = this.node.rawAttrs[e20];
    if (null != n2.tensor) return rA(e20, this.tensorMap, this.context);
    if (null != n2.i || null != n2.f) return JA(this.node.rawAttrs, e20, t2);
    if (null != n2.s) return KA(this.node.rawAttrs, e20, t2);
    if (null != n2.b) return YA(this.node.rawAttrs, e20, t2);
    if (null != n2.shape) return ax(this.node.rawAttrs, e20, t2);
    if (null != n2.type) return tx(this.node.rawAttrs, e20, t2);
    if (null != n2.list) {
      if (null != n2.list.i || null != n2.list.f) return ix(this.node.rawAttrs, e20, t2);
      if (null != n2.list.s) return sx(this.node.rawAttrs, e20, t2);
      if (null != n2.list.shape) return ox(this.node.rawAttrs, e20, t2);
      if (null != n2.list.b) return lx(this.node.rawAttrs, e20, t2);
      if (null != n2.list.type) return nx(this.node.rawAttrs, e20, t2);
    }
    return t2;
  }
};
var dx = {};
function cx(e20, t2, n2 = "") {
  if ("number" != typeof e20 && "number" != typeof t2) {
    va.assert(e20.length === t2.length, () => n2 + ` Shapes ${e20} and ${t2} must match`);
    for (let r2 = 0; e20.length > r2; r2++) {
      let a2 = e20[r2], i2 = t2[r2];
      va.assert(0 > a2 || 0 > i2 || a2 === i2, () => n2 + ` Shapes ${e20} and ${t2} must match`);
    }
  }
}
function hx(e20) {
  return !("number" == typeof e20 || e20.some((e21) => 0 > e21));
}
function px(e20, t2, n2) {
  let r2 = fx(e20, n2), a2 = !hx(r2);
  if (a2 && 0 === t2.length) throw Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: " + r2);
  if (a2 && t2.forEach((e21) => {
    r2 = fx(e21.shape, r2);
  }), !hx(r2)) throw Error("Non-fully-defined elementShape: " + r2);
  return r2;
}
function fx(e20, t2) {
  if ("number" == typeof e20) return t2;
  if ("number" == typeof t2) return e20;
  if (e20.length !== t2.length) throw Error(`Incompatible ranks during merge: ${e20} vs. ${t2}`);
  let n2 = [];
  for (let r2 = 0; e20.length > r2; ++r2) {
    let a2 = e20[r2], i2 = t2[r2];
    if (a2 >= 0 && i2 >= 0 && a2 !== i2) throw Error(`Incompatible shape during merge: ${e20} vs. ${t2}`);
    n2[r2] = 0 > a2 ? i2 : a2;
  }
  return n2;
}
A(dx, { OP_SCOPE_SUFFIX() {
  return Di;
}, abs() {
  return yo;
}, acos() {
  return bo;
}, acosh() {
  return go;
}, add() {
  return fo;
}, addN() {
  return vo;
}, all() {
  return wo;
}, any() {
  return ko;
}, argMax() {
  return No;
}, argMin() {
  return Co;
}, asin() {
  return $o;
}, asinh() {
  return Ro;
}, atan() {
  return So;
}, atan2() {
  return Io;
}, atanh() {
  return Eo;
}, avgPool() {
  return Xo;
}, avgPool3d() {
  return qo;
}, basicLSTMCell() {
  return el;
}, batchNorm() {
  return rl;
}, batchNorm2d() {
  return al;
}, batchNorm3d() {
  return il;
}, batchNorm4d() {
  return sl;
}, batchToSpaceND() {
  return tl;
}, bincount() {
  return ol;
}, bitwiseAnd() {
  return ll;
}, booleanMaskAsync() {
  return Jc;
}, broadcastArgs() {
  return ul;
}, broadcastTo() {
  return dl;
}, buffer() {
  return uo;
}, cast() {
  return co;
}, ceil() {
  return cl;
}, clipByValue() {
  return pl;
}, clone() {
  return ho;
}, complex() {
  return Li;
}, concat() {
  return Zo;
}, concat1d() {
  return fl;
}, concat2d() {
  return ml;
}, concat3d() {
  return Al;
}, concat4d() {
  return xl;
}, conv1d() {
  return bl;
}, conv2d() {
  return yl;
}, conv2dTranspose() {
  return vl;
}, conv3d() {
  return wl;
}, conv3dTranspose() {
  return Nl;
}, cos() {
  return Cl;
}, cosh() {
  return $l;
}, cosineWindow() {
  return sh;
}, cumprod() {
  return Rl;
}, cumsum() {
  return Sl;
}, denseBincount() {
  return Il;
}, depthToSpace() {
  return El;
}, depthwiseConv2d() {
  return Tl;
}, diag() {
  return Ml;
}, dilation2d() {
  return Ol;
}, div() {
  return Ao;
}, divNoNan() {
  return Ll;
}, dot() {
  return Bl;
}, dropout() {
  return ah;
}, einsum() {
  return Ul;
}, elu() {
  return jl;
}, enclosingPowerOfTwo() {
  return ih;
}, ensureShape() {
  return Gl;
}, equal() {
  return _l;
}, erf() {
  return Hl;
}, euclideanNorm() {
  return du;
}, exp() {
  return cu;
}, expandDims() {
  return hu;
}, expm1() {
  return pu;
}, eye() {
  return mu;
}, fft() {
  return vc;
}, fill() {
  return hl;
}, floor() {
  return Au;
}, floorDiv() {
  return mo;
}, fused() {
  return lh;
}, gather() {
  return xu;
}, gatherND() {
  return rh;
}, greater() {
  return yu;
}, greaterEqual() {
  return bu;
}, ifft() {
  return wc;
}, imag() {
  return gu;
}, image() {
  return mp;
}, inTopKAsync() {
  return oh;
}, irfft() {
  return kc;
}, isFinite() {
  return vu;
}, isInf() {
  return wu;
}, isNaN() {
  return ku;
}, leakyRelu() {
  return Nu;
}, less() {
  return Cu;
}, lessEqual() {
  return $u;
}, linalg() {
  return Ap;
}, linspace() {
  return Ru;
}, localResponseNormalization() {
  return Su;
}, log() {
  return Iu;
}, log1p() {
  return Eu;
}, logSigmoid() {
  return Wu;
}, logSoftmax() {
  return Bu;
}, logSumExp() {
  return Uu;
}, logicalAnd() {
  return ju;
}, logicalNot() {
  return Gu;
}, logicalOr() {
  return Hu;
}, logicalXor() {
  return Xu;
}, losses() {
  return xp;
}, lowerBound() {
  return Ku;
}, matMul() {
  return Ko;
}, max() {
  return tu;
}, maxPool() {
  return Yu;
}, maxPool3d() {
  return Ju;
}, maxPoolWithArgmax() {
  return Qu;
}, maximum() {
  return ed;
}, mean() {
  return td;
}, meshgrid() {
  return ad;
}, min() {
  return nu;
}, minimum() {
  return id;
}, mirrorPad() {
  return sd;
}, mod() {
  return od;
}, moments() {
  return ld;
}, movingAverage() {
  return eh;
}, mul() {
  return xo;
}, multiRNNCell() {
  return ud;
}, multinomial() {
  return dd;
}, neg() {
  return _u;
}, norm() {
  return uu;
}, notEqual() {
  return cd;
}, oneHot() {
  return hd;
}, ones() {
  return rd;
}, onesLike() {
  return pd;
}, op() {
  return Wi;
}, outerProduct() {
  return fd;
}, pad() {
  return md;
}, pad1d() {
  return Ad;
}, pad2d() {
  return xd;
}, pad3d() {
  return yd;
}, pad4d() {
  return bd;
}, pool() {
  return vd;
}, pow() {
  return ru;
}, prelu() {
  return wd;
}, print() {
  return po;
}, prod() {
  return kd;
}, raggedGather() {
  return Nd;
}, raggedRange() {
  return Cd;
}, raggedTensorToTensor() {
  return $d;
}, rand() {
  return Rd;
}, randomGamma() {
  return Xd;
}, randomNormal() {
  return qd;
}, randomStandardNormal() {
  return Zd;
}, randomUniform() {
  return Kd;
}, randomUniformInt() {
  return Yd;
}, range() {
  return Jd;
}, real() {
  return Qd;
}, reciprocal() {
  return ec;
}, relu() {
  return tc;
}, relu6() {
  return nc;
}, reshape() {
  return Ho;
}, reverse() {
  return rc;
}, reverse1d() {
  return ac;
}, reverse2d() {
  return ic;
}, reverse3d() {
  return sc;
}, reverse4d() {
  return oc;
}, rfft() {
  return Cc;
}, round() {
  return lc;
}, rsqrt() {
  return uc;
}, scalar() {
  return au;
}, scatterND() {
  return th;
}, searchSorted() {
  return Zu;
}, selu() {
  return dc;
}, separableConv2d() {
  return cc;
}, setdiff1dAsync() {
  return hc;
}, sigmoid() {
  return Yo;
}, sign() {
  return pc;
}, signal() {
  return fp;
}, sin() {
  return fc;
}, sinh() {
  return mc;
}, slice() {
  return Jo;
}, slice1d() {
  return Ac;
}, slice2d() {
  return xc;
}, slice3d() {
  return yc;
}, slice4d() {
  return bc;
}, softmax() {
  return gc;
}, softplus() {
  return Du;
}, spaceToBatchND() {
  return gd;
}, sparse() {
  return yp;
}, sparseToDense() {
  return nh;
}, spectral() {
  return pp;
}, split() {
  return Nc;
}, sqrt() {
  return iu;
}, square() {
  return su;
}, squaredDifference() {
  return $c;
}, squeeze() {
  return Rc;
}, stack() {
  return Sc;
}, step() {
  return Ic;
}, stridedSlice() {
  return Ec;
}, string() {
  return bp;
}, sub() {
  return Lu;
}, sum() {
  return ou;
}, tan() {
  return Tc;
}, tanh() {
  return Qo;
}, tensor() {
  return Ui;
}, tensor1d() {
  return Mc;
}, tensor2d() {
  return Oc;
}, tensor3d() {
  return Fc;
}, tensor4d() {
  return Pc;
}, tensor5d() {
  return zc;
}, tensor6d() {
  return Vc;
}, tensorScatterUpdate() {
  return Bc;
}, tile() {
  return fu;
}, topk() {
  return Uc;
}, transpose() {
  return Qc;
}, truncatedNormal() {
  return jc;
}, unique() {
  return Gc;
}, unsortedSegmentSum() {
  return Hc;
}, unstack() {
  return Xc;
}, upperBound() {
  return qc;
}, variable() {
  return Zc;
}, where() {
  return Dl;
}, whereAsync() {
  return Yc;
}, zeros() {
  return nd;
}, zerosLike() {
  return Wl;
} });
var mx = class {
  constructor(e20, t2, n2, r2, a2, i2, s2) {
    this.name = e20, this.dtype = t2, this.maxSize = n2, this.elementShape = r2, this.identicalElementShapes = a2, this.dynamicSize = i2, this.clearAfterRead = s2, this.tensors = [], this.closed_ = false, this.idTensor = au(0), ns(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  get closed() {
    return this.closed_;
  }
  clearAndClose(e20) {
    this.tensors.forEach((t2) => {
      (null == e20 || !e20.has(t2.tensor.id)) && t2.tensor.dispose();
    }), this.tensors = [], this.closed_ = true, this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  read(e20) {
    if (this.closed_) throw Error(`TensorArray ${this.name} has already been closed.`);
    if (0 > e20 || e20 >= this.size()) throw Error(`Tried to read from index ${e20}, but array size is: ${this.size()}`);
    let t2 = this.tensors[e20];
    if (t2.cleared) throw Error(`TensorArray ${this.name}: Could not read index ${e20} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
    return this.clearAfterRead && (t2.cleared = true), t2.read = true, t2.tensor;
  }
  readMany(e20) {
    return e20.map((e21) => this.read(e21));
  }
  write(e20, t2) {
    if (this.closed_) throw Error(`TensorArray ${this.name} has already been closed.`);
    if (0 > e20 || !this.dynamicSize && e20 >= this.maxSize) throw Error(`Tried to write to index ${e20}, but array is not resizeable and size is: ${this.maxSize}`);
    let n2 = this.tensors[e20] || {};
    if (t2.dtype !== this.dtype) throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e20},
          because the value dtype is ${t2.dtype}, but TensorArray dtype is ${this.dtype}.`);
    if (0 === this.size() && (null == this.elementShape || 0 === this.elementShape.length) && (this.elementShape = t2.shape), cx(this.elementShape, t2.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${e20}.`), n2.read) throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e20}, because it has already been read.`);
    if (n2.written) throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e20}, because it has already been written.`);
    n2.tensor = t2, ns(t2), n2.written = true, this.tensors[e20] = n2;
  }
  writeMany(e20, t2) {
    if (e20.length !== t2.length) throw Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e20.length} is not the same as tensors size: ${t2.length}.`);
    e20.forEach((e21, n2) => this.write(e21, t2[n2]));
  }
  gather(e20, t2) {
    if (t2 && t2 !== this.dtype) throw Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t2}`);
    if (e20) e20 = e20.slice(0, this.size());
    else {
      e20 = [];
      for (let t3 = 0; t3 < this.size(); t3++) e20.push(t3);
    }
    if (0 === e20.length) return Ui([], [0].concat(this.elementShape));
    let n2 = this.readMany(e20);
    return cx(this.elementShape, n2[0].shape, "TensorArray shape mismatch: "), Sc(n2, 0);
  }
  concat(e20) {
    if (e20 && e20 !== this.dtype) throw Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e20}`);
    if (0 === this.size()) return Ui([], [0].concat(this.elementShape));
    let t2 = [];
    for (let r2 = 0; r2 < this.size(); r2++) t2.push(r2);
    let n2 = this.readMany(t2);
    return cx(this.elementShape, n2[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n2[0].shape})`), Zo(n2, 0);
  }
  scatter(e20, t2) {
    if (t2.dtype !== this.dtype) throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t2.dtype}`);
    if (e20.length !== t2.shape[0]) throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${e20.length} vs. ${t2.shape[0]}`);
    let n2 = Math.max(...e20);
    if (!this.dynamicSize && n2 >= this.maxSize) throw Error(`Max index must be < array size (${n2}  vs. ${this.maxSize})`);
    this.writeMany(e20, Xc(t2, 0));
  }
  split(e20, t2) {
    if (t2.dtype !== this.dtype) throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t2.dtype}`);
    let n2 = 0, r2 = e20.map((e21) => (n2 += e21, n2));
    if (n2 !== t2.shape[0]) throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n2}, and tensor's shape is: ${t2.shape}`);
    if (!this.dynamicSize && e20.length !== this.maxSize) throw Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e20.length}), and the TensorArray is not marked as dynamically resizeable`);
    let a2 = 0 === n2 ? 0 : t2.size / n2, i2 = [];
    es(() => {
      t2 = Ho(t2, [1, n2, a2]);
      for (let n3 = 0; e20.length > n3; ++n3) i2[n3] = Ho(Jo(t2, [0, 0 === n3 ? 0 : r2[n3 - 1], 0], [1, e20[n3], a2]), this.elementShape);
      return i2;
    });
    let s2 = [];
    for (let o2 = 0; e20.length > o2; o2++) s2[o2] = o2;
    this.writeMany(s2, i2);
  }
};
var Ax = class e8 {
  get id() {
    return this.idTensor.id;
  }
  constructor(e20, t2, n2, r2 = -1) {
    this.tensors = e20, this.elementShape = t2, this.elementDtype = n2, null != e20 && e20.forEach((e21) => {
      if (n2 !== e21.dtype) throw Error(`Invalid data types; op elements ${n2}, but list elements ${e21.dtype}`);
      cx(t2, e21.shape, "TensorList shape mismatch: "), ns(e21);
    }), this.idTensor = au(0), this.maxNumElements = r2, ns(this.idTensor);
  }
  copy() {
    return new e8([...this.tensors], this.elementShape, this.elementDtype);
  }
  clearAndClose(e20) {
    this.tensors.forEach((t2) => {
      (null == e20 || !e20.has(t2.id)) && t2.dispose();
    }), this.tensors.length = 0, this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  stack(e20, t2, n2 = -1) {
    if (t2 !== this.elementDtype) throw Error(`Invalid data types; op elements ${t2}, but list elements ${this.elementDtype}`);
    if (-1 !== n2 && this.tensors.length !== n2) throw Error(`Operation expected a list with ${n2} elements but got a list with ${this.tensors.length} elements.`);
    cx(e20, this.elementShape, "TensorList shape mismatch: ");
    let r2 = px(this.elementShape, this.tensors, e20);
    return es(() => {
      let e21 = this.tensors.map((e22) => Ho(e22, r2));
      return Sc(e21, 0);
    });
  }
  popBack(e20, t2) {
    if (t2 !== this.elementDtype) throw Error(`Invalid data types; op elements ${t2}, but list elements ${this.elementDtype}`);
    if (0 === this.size()) throw Error("Trying to pop from an empty list.");
    let n2 = px(this.elementShape, this.tensors, e20), r2 = this.tensors.pop();
    return r2.kept = false, cx(r2.shape, e20, "TensorList shape mismatch: "), Ho(r2, n2);
  }
  pushBack(e20) {
    if (e20.dtype !== this.elementDtype) throw Error(`Invalid data types; op elements ${e20.dtype}, but list elements ${this.elementDtype}`);
    if (cx(e20.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size()) throw Error("Trying to push element into a full list.");
    ns(e20), this.tensors.push(e20);
  }
  resize(t2) {
    if (0 > t2) throw Error("TensorListResize expects size to be non-negative. Got: " + t2);
    if (-1 !== this.maxNumElements && t2 > this.maxNumElements) throw Error(`TensorListResize input size ${t2} is greater maxNumElement ${this.maxNumElements}.`);
    let n2 = new e8([], this.elementShape, this.elementDtype, this.maxNumElements);
    n2.tensors.length = t2;
    for (let e20 = 0; Math.min(this.tensors.length, t2) > e20; ++e20) n2.tensors[e20] = this.tensors[e20];
    return n2;
  }
  getItem(e20, t2, n2) {
    if (n2 !== this.elementDtype) throw Error(`Invalid data types; op elements ${n2}, but list elements ${this.elementDtype}`);
    if (0 > e20 || e20 > this.tensors.length) throw Error(`Trying to access element ${e20} in a list with ${this.tensors.length} elements.`);
    if (null == this.tensors[e20]) throw Error(`element at index ${e20} is null.`);
    cx(this.tensors[e20].shape, t2, "TensorList shape mismatch: ");
    let r2 = px(this.elementShape, this.tensors, t2);
    return Ho(this.tensors[e20], r2);
  }
  setItem(e20, t2) {
    if (t2.dtype !== this.elementDtype) throw Error(`Invalid data types; op elements ${t2.dtype}, but list elements ${this.elementDtype}`);
    if (0 > e20 || -1 !== this.maxNumElements && e20 >= this.maxNumElements) throw Error(`Trying to set element ${e20} in a list with max ${this.maxNumElements} elements.`);
    cx(this.elementShape, t2.shape, "TensorList shape mismatch: "), ns(t2), null != this.tensors[e20] && (this.tensors[e20].kept = false), this.tensors[e20] = t2;
  }
  gather(e20, t2, n2) {
    if (t2 !== this.elementDtype) throw Error(`Invalid data types; op elements ${t2}, but list elements ${this.elementDtype}`);
    cx(this.elementShape, n2, "TensorList shape mismatch: "), e20 = e20.slice(0, this.size());
    let r2 = px(this.elementShape, this.tensors, n2);
    return 0 === e20.length ? Ui([], [0].concat(r2)) : es(() => {
      let t3 = e20.map((e21) => Ho(this.tensors[e21], r2));
      return Sc(t3, 0);
    });
  }
  concat(e20, t2) {
    if (e20 && e20 !== this.elementDtype) throw Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e20}`);
    cx(this.elementShape, t2, "TensorList shape mismatch: ");
    let n2 = px(this.elementShape, this.tensors, t2);
    return 0 === this.size() ? Ui([], [0].concat(n2)) : es(() => {
      let e21 = this.tensors.map((e22) => Ho(e22, n2));
      return Zo(e21, 0);
    });
  }
};
function xx(e20, t2, n2) {
  let [r2, a2] = nA("fusedOps", e20, t2, n2), i2 = "biasadd" === r2, s2 = !i2, o2 = "prelu" === a2, l2 = "fusedbatchnorm" === r2, u2 = nA("numArgs", e20, t2, n2);
  if (i2) {
    if (o2 && 2 !== u2) throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
    if (!o2 && i2 && 1 !== u2) throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
  }
  if (l2) throw Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
  let d2 = nA("strides", e20, t2, n2), c2 = lA(e20, t2, n2), h2 = nA("dataFormat", e20, t2, n2).toUpperCase(), p2 = nA("dilations", e20, t2, n2), [f2, m2] = nA("args", e20, t2, n2);
  return s2 && (m2 = f2, f2 = void 0), { stride: d2, pad: c2, dataFormat: h2, dilations: p2, biasArg: f2, preluArg: m2, activationFunc: a2, leakyreluAlpha: nA("leakyreluAlpha", e20, t2, n2) };
}
function yx(e20, t2, n2) {
  return { boxes: nA("boxes", e20, t2, n2), scores: nA("scores", e20, t2, n2), maxOutputSize: nA("maxOutputSize", e20, t2, n2), iouThreshold: nA("iouThreshold", e20, t2, n2), scoreThreshold: nA("scoreThreshold", e20, t2, n2), softNmsSigma: nA("softNmsSigma", e20, t2, n2) };
}
var bx = class {
  get id() {
    return this.handle.id;
  }
  constructor(e20, t2) {
    this.keyDType = e20, this.valueDType = t2, this.handle = au(0), this.tensorMap = /* @__PURE__ */ new Map(), ns(this.handle);
  }
  clearAndClose() {
    this.tensorMap.forEach((e20) => e20.dispose()), this.tensorMap.clear(), this.handle.dispose();
  }
  size() {
    return this.tensorMap.size;
  }
  tensorSize() {
    return au(this.size(), "int32");
  }
  import(e20, t2) {
    return __async(this, null, function* () {
      this.checkKeyAndValueTensor(e20, t2);
      let n2 = yield e20.data();
      return this.tensorMap.forEach((e21) => e21.dispose()), this.tensorMap.clear(), es(() => {
        let e21 = Xc(t2), r2 = n2.length, a2 = e21.length;
        va.assert(r2 === a2, () => `The number of elements doesn't match, keys has ${r2} elements, the values has ${a2} elements.`);
        for (let t3 = 0; r2 > t3; t3++) {
          let r3 = n2[t3], a3 = e21[t3];
          ns(a3), this.tensorMap.set(r3, a3);
        }
        return this.handle;
      });
    });
  }
  find(e20, t2) {
    return __async(this, null, function* () {
      this.checkKeyAndValueTensor(e20, t2);
      let n2 = yield e20.data();
      return es(() => {
        let e21 = [];
        for (let r2 = 0; n2.length > r2; r2++) {
          let a2 = this.findWithDefault(n2[r2], t2);
          e21.push(a2);
        }
        return Sc(e21);
      });
    });
  }
  findWithDefault(e20, t2) {
    let n2 = this.tensorMap.get(e20);
    return null != n2 ? n2 : t2;
  }
  checkKeyAndValueTensor(e20, t2) {
    if (e20.dtype !== this.keyDType) throw Error(`Expect key dtype ${this.keyDType}, but got ${e20.dtype}`);
    if (t2.dtype !== this.valueDType) throw Error(`Expect value dtype ${this.valueDType}, but got ${t2.dtype}`);
  }
};
function gx(e20, t2, n2, r2, a2 = es) {
  let i2 = ((e21, t3, n3) => {
    switch (e21.category) {
      case "arithmetic":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "BiasAdd":
            case "AddV2":
            case "Add":
              return [r3.add(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "AddN":
              return [r3.addN(nA("tensors", e22, t4, n4))];
            case "FloorMod":
            case "Mod":
              return [r3.mod(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "Mul":
              return [r3.mul(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "RealDiv":
            case "Div":
              return [r3.div(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "DivNoNan":
              return [r3.divNoNan(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "FloorDiv":
              return [r3.floorDiv(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "Sub":
              return [r3.sub(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "Minimum":
              return [r3.minimum(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "Maximum":
              return [r3.maximum(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "Pow":
              return [r3.pow(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "SquaredDifference":
              return [r3.squaredDifference(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "basic_math":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "Abs":
            case "ComplexAbs":
              return [r3.abs(nA("x", e22, t4, n4))];
            case "Acos":
              return [r3.acos(nA("x", e22, t4, n4))];
            case "Acosh":
              return [r3.acosh(nA("x", e22, t4, n4))];
            case "Asin":
              return [r3.asin(nA("x", e22, t4, n4))];
            case "Asinh":
              return [r3.asinh(nA("x", e22, t4, n4))];
            case "Atan":
              return [r3.atan(nA("x", e22, t4, n4))];
            case "Atan2":
              return [r3.atan2(nA("x", e22, t4, n4), nA("y", e22, t4, n4))];
            case "Atanh":
              return [r3.atanh(nA("x", e22, t4, n4))];
            case "Ceil":
              return [r3.ceil(nA("x", e22, t4, n4))];
            case "Complex":
              return [r3.complex(nA("real", e22, t4, n4), nA("imag", e22, t4, n4))];
            case "Cos":
              return [r3.cos(nA("x", e22, t4, n4))];
            case "Cosh":
              return [r3.cosh(nA("x", e22, t4, n4))];
            case "Elu":
              return [r3.elu(nA("x", e22, t4, n4))];
            case "Erf":
              return [r3.erf(nA("x", e22, t4, n4))];
            case "Exp":
              return [r3.exp(nA("x", e22, t4, n4))];
            case "Expm1":
              return [r3.expm1(nA("x", e22, t4, n4))];
            case "Floor":
              return [r3.floor(nA("x", e22, t4, n4))];
            case "Log":
              return [r3.log(nA("x", e22, t4, n4))];
            case "Log1p":
              return [r3.log1p(nA("x", e22, t4, n4))];
            case "Imag":
              return [r3.imag(nA("x", e22, t4, n4))];
            case "Neg":
              return [r3.neg(nA("x", e22, t4, n4))];
            case "Reciprocal":
              return [r3.reciprocal(nA("x", e22, t4, n4))];
            case "Real":
              return [r3.real(nA("x", e22, t4, n4))];
            case "Relu":
              return [r3.relu(nA("x", e22, t4, n4))];
            case "Round":
              return [r3.round(nA("x", e22, t4, n4))];
            case "Selu":
              return [r3.selu(nA("x", e22, t4, n4))];
            case "Sigmoid":
              return [r3.sigmoid(nA("x", e22, t4, n4))];
            case "Sin":
              return [r3.sin(nA("x", e22, t4, n4))];
            case "Sign":
              return [r3.sign(nA("x", e22, t4, n4))];
            case "Sinh":
              return [r3.sinh(nA("x", e22, t4, n4))];
            case "Softplus":
              return [r3.softplus(nA("x", e22, t4, n4))];
            case "Sqrt":
              return [r3.sqrt(nA("x", e22, t4, n4))];
            case "Square":
              return [r3.square(nA("x", e22, t4, n4))];
            case "Tanh":
              return [r3.tanh(nA("x", e22, t4, n4))];
            case "Tan":
              return [r3.tan(nA("x", e22, t4, n4))];
            case "ClipByValue":
              return [r3.clipByValue(nA("x", e22, t4, n4), nA("clipValueMin", e22, t4, n4), nA("clipValueMax", e22, t4, n4))];
            case "Relu6":
              return [r3.relu6(nA("x", e22, t4, n4))];
            case "Rsqrt":
              return [r3.rsqrt(rA(e22.inputNames[0], t4, n4))];
            case "LeakyRelu":
              return [r3.leakyRelu(nA("x", e22, t4, n4), nA("alpha", e22, t4, n4))];
            case "Prelu":
              return [r3.prelu(nA("x", e22, t4, n4), nA("alpha", e22, t4, n4))];
            case "IsNan":
              return [r3.isNaN(rA(e22.inputNames[0], t4, n4))];
            case "IsInf":
              return [r3.isInf(rA(e22.inputNames[0], t4, n4))];
            case "IsFinite":
              return [r3.isFinite(rA(e22.inputNames[0], t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "control":
        return ((e22, t4, n4) => __async(null, null, function* () {
          switch (e22.op) {
            case "If":
            case "StatelessIf": {
              let r3 = nA("thenBranch", e22, t4, n4), a3 = nA("elseBranch", e22, t4, n4), i4 = nA("cond", e22, t4, n4), s2 = nA("args", e22, t4, n4);
              return (yield i4.data())[0] ? n4.functionMap[r3].executeFunctionAsync(s2, n4.tensorArrayMap, n4.tensorListMap) : n4.functionMap[a3].executeFunctionAsync(s2, n4.tensorArrayMap, n4.tensorListMap);
            }
            case "While":
            case "StatelessWhile": {
              let r3 = nA("body", e22, t4, n4), a3 = nA("cond", e22, t4, n4), i4 = nA("args", e22, t4, n4), s2 = yield n4.functionMap[a3].executeFunctionAsync(i4, n4.tensorArrayMap, n4.tensorListMap), o2 = i4.map((e23) => e23.id), l2 = yield s2[0].data();
              s2.forEach((e23) => {
                !e23.kept && -1 === o2.indexOf(e23.id) && e23.dispose();
              });
              let u2 = i4;
              for (; l2[0]; ) {
                let e23 = u2;
                u2 = yield n4.functionMap[r3].executeFunctionAsync(u2, n4.tensorArrayMap, n4.tensorListMap);
                let t5 = u2.map((e24) => e24.id);
                e23.forEach((e24) => {
                  !e24.kept && -1 === o2.indexOf(e24.id) && -1 === t5.indexOf(e24.id) && e24.dispose();
                });
                let i5 = yield n4.functionMap[a3].executeFunctionAsync(u2, n4.tensorArrayMap, n4.tensorListMap);
                l2 = yield i5[0].data(), i5.forEach((e24) => {
                  !e24.kept && -1 === o2.indexOf(e24.id) && -1 === t5.indexOf(e24.id) && e24.dispose();
                });
              }
              return u2;
            }
            case "LoopCond":
              return [uA(nA("pred", e22, t4, n4))];
            case "Switch": {
              let r3 = nA("pred", e22, t4, n4), a3 = nA("data", e22, t4, n4);
              return a3.kept || (a3 = uA(a3)), (yield r3.data())[0] ? [void 0, a3] : [a3, void 0];
            }
            case "Merge": {
              let r3 = e22.inputNames.find((e23) => void 0 !== rA(e23, t4, n4));
              return r3 ? [uA(rA(r3, t4, n4))] : void 0;
            }
            case "Enter": {
              let r3 = nA("frameName", e22, t4, n4), a3 = nA("tensor", e22, t4, n4);
              return n4.enterFrame(r3), [uA(a3)];
            }
            case "Exit": {
              let r3 = nA("tensor", e22, t4, n4);
              return n4.exitFrame(), [uA(r3)];
            }
            case "NextIteration": {
              let r3 = nA("tensor", e22, t4, n4);
              return n4.nextIteration(), [uA(r3)];
            }
            case "TensorArrayV3": {
              let r3 = nA("size", e22, t4, n4), a3 = nA("dtype", e22, t4, n4), i4 = nA("elementShape", e22, t4, n4), s2 = nA("dynamicSize", e22, t4, n4), o2 = nA("clearAfterRead", e22, t4, n4), l2 = nA("identicalElementShapes", e22, t4, n4), u2 = nA("name", e22, t4, n4), d2 = new mx(u2, a3, r3, i4, l2, s2, o2);
              return n4.addTensorArray(d2), [d2.idTensor, au(1)];
            }
            case "TensorArrayWriteV3": {
              let r3 = nA("tensorArrayId", e22, t4, n4), a3 = nA("index", e22, t4, n4), i4 = nA("tensor", e22, t4, n4), s2 = n4.getTensorArray(r3.id);
              return s2.write(a3, i4), [s2.idTensor];
            }
            case "TensorArrayReadV3": {
              let r3 = nA("tensorArrayId", e22, t4, n4), a3 = nA("index", e22, t4, n4);
              return [n4.getTensorArray(r3.id).read(a3)];
            }
            case "TensorArrayGatherV3": {
              let r3 = nA("tensorArrayId", e22, t4, n4), a3 = nA("indices", e22, t4, n4), i4 = nA("dtype", e22, t4, n4);
              return [n4.getTensorArray(r3.id).gather(a3, i4)];
            }
            case "TensorArrayScatterV3": {
              let r3 = nA("tensorArrayId", e22, t4, n4), a3 = nA("indices", e22, t4, n4), i4 = nA("tensor", e22, t4, n4), s2 = n4.getTensorArray(r3.id);
              return s2.scatter(a3, i4), [s2.idTensor];
            }
            case "TensorArrayConcatV3": {
              let r3 = nA("tensorArrayId", e22, t4, n4), a3 = n4.getTensorArray(r3.id), i4 = nA("dtype", e22, t4, n4);
              return [a3.concat(i4)];
            }
            case "TensorArraySplitV3": {
              let r3 = nA("tensorArrayId", e22, t4, n4), a3 = nA("tensor", e22, t4, n4), i4 = nA("lengths", e22, t4, n4), s2 = n4.getTensorArray(r3.id);
              return s2.split(i4, a3), [s2.idTensor];
            }
            case "TensorArraySizeV3": {
              let r3 = nA("tensorArrayId", e22, t4, n4);
              return [au(n4.getTensorArray(r3.id).size(), "int32")];
            }
            case "TensorArrayCloseV3": {
              let r3 = nA("tensorArrayId", e22, t4, n4), a3 = n4.getTensorArray(r3.id);
              return a3.clearAndClose(), [a3.idTensor];
            }
            case "TensorListSetItem": {
              let r3 = nA("tensorListId", e22, t4, n4), a3 = nA("index", e22, t4, n4), i4 = nA("tensor", e22, t4, n4), s2 = n4.getTensorList(r3.id);
              return s2.setItem(a3, i4), [s2.idTensor];
            }
            case "TensorListGetItem": {
              let r3 = nA("tensorListId", e22, t4, n4), a3 = nA("index", e22, t4, n4), i4 = nA("elementShape", e22, t4, n4), s2 = nA("elementDType", e22, t4, n4);
              return [n4.getTensorList(r3.id).getItem(a3, i4, s2)];
            }
            case "TensorListScatterV2":
            case "TensorListScatter": {
              let r3 = nA("indices", e22, t4, n4), a3 = ((e23, t5, n5, r4) => {
                if (t5.length !== e23.shape[0]) throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${t5.length} vs. ${e23.shape[0]}`);
                let a4 = Math.max(...t5);
                if (null != r4 && -1 !== r4 && a4 >= r4) throw Error(`Max index must be < array size (${a4}  vs. ${r4})`);
                let i4 = new Ax([], n5, e23.dtype, r4), s2 = Xc(e23, 0);
                return t5.forEach((e24, t6) => {
                  i4.setItem(e24, s2[t6]);
                }), i4;
              })(nA("tensor", e22, t4, n4), r3, nA("elementShape", e22, t4, n4), nA("numElements", e22, t4, n4));
              return n4.addTensorList(a3), [a3.idTensor];
            }
            case "TensorListReserve":
            case "EmptyTensorList": {
              let r3, a3 = nA("elementShape", e22, t4, n4), i4 = nA("elementDType", e22, t4, n4);
              r3 = "TensorListReserve" === e22.op ? "numElements" : "maxNumElements";
              let s2 = nA(r3, e22, t4, n4), o2 = ((e23, t5, n5, r4) => new Ax([], e23, t5, r4))(a3, i4, 0, "TensorListReserve" === e22.op ? -1 : s2);
              return n4.addTensorList(o2), [o2.idTensor];
            }
            case "TensorListGather": {
              let r3 = nA("tensorListId", e22, t4, n4), a3 = nA("indices", e22, t4, n4), i4 = nA("elementShape", e22, t4, n4), s2 = nA("elementDType", e22, t4, n4);
              return [n4.getTensorList(r3.id).gather(a3, s2, i4)];
            }
            case "TensorListStack": {
              let r3 = nA("tensorListId", e22, t4, n4), a3 = nA("elementShape", e22, t4, n4), i4 = nA("elementDType", e22, t4, n4), s2 = nA("numElements", e22, t4, n4);
              return [n4.getTensorList(r3.id).stack(a3, i4, s2)];
            }
            case "TensorListFromTensor": {
              let r3 = ((e23, t5, n5) => {
                let r4 = e23.dtype;
                if (1 > e23.shape.length) throw Error("Tensor must be at least a vector, but saw shape: " + e23.shape);
                if (e23.dtype !== n5) throw Error(`Invalid data types; op elements ${e23.dtype}, but list elements ${n5}`);
                cx(e23.shape.slice(1), t5, "TensorList shape mismatch: ");
                let a3 = Xc(e23);
                return new Ax(a3, t5, r4);
              })(nA("tensor", e22, t4, n4), nA("elementShape", e22, t4, n4), nA("elementDType", e22, t4, n4));
              return n4.addTensorList(r3), [r3.idTensor];
            }
            case "TensorListConcat":
            case "TensorListConcatV2": {
              let r3 = nA("tensorListId", e22, t4, n4), a3 = n4.getTensorList(r3.id), i4 = nA("dtype", e22, t4, n4), s2 = nA("elementShape", e22, t4, n4);
              return [a3.concat(i4, s2)];
            }
            case "TensorListPushBack": {
              let r3 = nA("tensorListId", e22, t4, n4), a3 = nA("tensor", e22, t4, n4), i4 = n4.getTensorList(r3.id);
              return i4.pushBack(a3), [i4.idTensor];
            }
            case "TensorListPopBack": {
              let r3 = nA("tensorListId", e22, t4, n4), a3 = nA("elementShape", e22, t4, n4), i4 = nA("elementDType", e22, t4, n4);
              return [n4.getTensorList(r3.id).popBack(a3, i4)];
            }
            case "TensorListSplit": {
              let r3 = nA("tensor", e22, t4, n4), a3 = nA("elementShape", e22, t4, n4), i4 = ((e23, t5, n5) => {
                let r4 = 0, a4 = t5.map((e24) => (r4 += e24, r4));
                if (r4 !== e23.shape[0]) throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r4}, and tensor's shape is: ${e23.shape}`);
                let i5 = fx(e23.shape.slice(1), n5), s2 = 0 === r4 ? 0 : e23.size / r4, o2 = es(() => {
                  let n6 = [];
                  e23 = Ho(e23, [1, r4, s2]);
                  for (let r5 = 0; t5.length > r5; ++r5) n6[r5] = Ho(Jo(e23, [0, 0 === r5 ? 0 : a4[r5 - 1], 0], [1, t5[r5], s2]), i5);
                  return e23.dispose(), n6;
                }), l2 = new Ax([], n5, e23.dtype, t5.length);
                for (let u2 = 0; o2.length > u2; u2++) l2.setItem(u2, o2[u2]);
                return l2;
              })(r3, nA("lengths", e22, t4, n4), a3);
              return n4.addTensorList(i4), [i4.idTensor];
            }
            case "TensorListLength": {
              let r3 = nA("tensorListId", e22, t4, n4);
              return [au(n4.getTensorList(r3.id).size(), "int32")];
            }
            case "TensorListResize": {
              let r3 = nA("tensorListId", e22, t4, n4), a3 = nA("size", e22, t4, n4), i4 = n4.getTensorList(r3.id).resize(a3);
              return n4.addTensorList(i4), [i4.idTensor];
            }
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        }))(e21, t3, n3);
      case "convolution":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "Conv1D": {
              let a3 = nA("stride", e22, t4, n4), i4 = nA("pad", e22, t4, n4), s2 = nA("dataFormat", e22, t4, n4).toUpperCase(), o2 = nA("dilation", e22, t4, n4);
              return [r3.conv1d(nA("x", e22, t4, n4), nA("filter", e22, t4, n4), a3, i4, s2, o2)];
            }
            case "Conv2D": {
              let a3 = nA("strides", e22, t4, n4), i4 = lA(e22, t4, n4), s2 = nA("dataFormat", e22, t4, n4).toUpperCase(), o2 = nA("dilations", e22, t4, n4);
              return [r3.conv2d(nA("x", e22, t4, n4), nA("filter", e22, t4, n4), [a3[1], a3[2]], i4, s2, [o2[1], o2[2]])];
            }
            case "_FusedConv2D": {
              let { stride: a3, pad: i4, dataFormat: s2, dilations: o2, biasArg: l2, preluArg: u2, activationFunc: d2, leakyreluAlpha: c2 } = xx(e22, t4, n4);
              return [r3.fused.conv2d({ x: nA("x", e22, t4, n4), filter: nA("filter", e22, t4, n4), strides: [a3[1], a3[2]], pad: i4, dataFormat: s2, dilations: [o2[1], o2[2]], bias: l2, activation: d2, preluActivationWeights: u2, leakyreluAlpha: c2 })];
            }
            case "FusedDepthwiseConv2dNative": {
              let { stride: a3, pad: i4, dataFormat: s2, dilations: o2, biasArg: l2, preluArg: u2, activationFunc: d2, leakyreluAlpha: c2 } = xx(e22, t4, n4);
              return [r3.fused.depthwiseConv2d({ x: nA("x", e22, t4, n4), filter: nA("filter", e22, t4, n4), strides: [a3[1], a3[2]], pad: i4, dataFormat: s2, dilations: [o2[1], o2[2]], bias: l2, activation: d2, preluActivationWeights: u2, leakyreluAlpha: c2 })];
            }
            case "Conv2DBackpropInput":
            case "Conv2dTranspose": {
              let a3 = nA("outputShape", e22, t4, n4), i4 = nA("strides", e22, t4, n4), s2 = lA(e22, t4, n4);
              return [r3.conv2dTranspose(nA("x", e22, t4, n4), nA("filter", e22, t4, n4), a3, [i4[1], i4[2]], s2)];
            }
            case "DepthwiseConv2dNative":
            case "DepthwiseConv2d": {
              let a3 = nA("strides", e22, t4, n4), i4 = lA(e22, t4, n4), s2 = nA("dilations", e22, t4, n4), o2 = nA("dataFormat", e22, t4, n4).toUpperCase();
              return [r3.depthwiseConv2d(nA("input", e22, t4, n4), nA("filter", e22, t4, n4), [a3[1], a3[2]], i4, o2, [s2[1], s2[2]])];
            }
            case "Conv3D": {
              let a3 = nA("strides", e22, t4, n4), i4 = nA("pad", e22, t4, n4), s2 = nA("dataFormat", e22, t4, n4).toUpperCase(), o2 = nA("dilations", e22, t4, n4);
              return [r3.conv3d(nA("x", e22, t4, n4), nA("filter", e22, t4, n4), [a3[1], a3[2], a3[3]], i4, s2, [o2[1], o2[2], o2[3]])];
            }
            case "AvgPool": {
              let a3 = nA("strides", e22, t4, n4), i4 = nA("pad", e22, t4, n4), s2 = nA("kernelSize", e22, t4, n4);
              return [r3.avgPool(nA("x", e22, t4, n4), [s2[1], s2[2]], [a3[1], a3[2]], i4)];
            }
            case "MaxPool": {
              let a3 = nA("strides", e22, t4, n4), i4 = nA("pad", e22, t4, n4), s2 = nA("kernelSize", e22, t4, n4);
              return [r3.maxPool(nA("x", e22, t4, n4), [s2[1], s2[2]], [a3[1], a3[2]], i4)];
            }
            case "MaxPoolWithArgmax": {
              let a3 = nA("strides", e22, t4, n4), i4 = nA("pad", e22, t4, n4), s2 = nA("kernelSize", e22, t4, n4), o2 = nA("includeBatchInIndex", e22, t4, n4), { result: l2, indexes: u2 } = r3.maxPoolWithArgmax(nA("x", e22, t4, n4), [s2[1], s2[2]], [a3[1], a3[2]], i4, o2);
              return [l2, u2];
            }
            case "AvgPool3D": {
              let a3 = nA("strides", e22, t4, n4), i4 = nA("pad", e22, t4, n4), s2 = nA("kernelSize", e22, t4, n4);
              return [r3.avgPool3d(nA("x", e22, t4, n4), [s2[1], s2[2], s2[3]], [a3[1], a3[2], a3[3]], i4)];
            }
            case "MaxPool3D": {
              let a3 = nA("strides", e22, t4, n4), i4 = nA("pad", e22, t4, n4), s2 = nA("kernelSize", e22, t4, n4);
              return [r3.maxPool3d(nA("x", e22, t4, n4), [s2[1], s2[2], s2[3]], [a3[1], a3[2], a3[3]], i4)];
            }
            case "Dilation2D": {
              let a3 = nA("strides", e22, t4, n4), i4 = nA("pad", e22, t4, n4), s2 = nA("dilations", e22, t4, n4), o2 = a3[1], l2 = a3[2], u2 = s2[1], d2 = s2[2];
              return [r3.dilation2d(nA("x", e22, t4, n4), nA("filter", e22, t4, n4), [o2, l2], i4, [u2, d2], "NHWC")];
            }
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "creation":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "Fill": {
              let a3 = nA("shape", e22, t4, n4), i4 = nA("dtype", e22, t4, n4), s2 = nA("value", e22, t4, n4);
              return [r3.fill(a3, s2, i4)];
            }
            case "LinSpace": {
              let a3 = nA("start", e22, t4, n4), i4 = nA("stop", e22, t4, n4), s2 = nA("num", e22, t4, n4);
              return [r3.linspace(a3, i4, s2)];
            }
            case "Multinomial": {
              let a3 = nA("logits", e22, t4, n4), i4 = nA("numSamples", e22, t4, n4), s2 = nA("seed", e22, t4, n4);
              return [r3.multinomial(a3, i4, s2)];
            }
            case "OneHot": {
              let a3 = nA("indices", e22, t4, n4), i4 = nA("depth", e22, t4, n4), s2 = nA("onValue", e22, t4, n4), o2 = nA("offValue", e22, t4, n4), l2 = nA("dtype", e22, t4, n4);
              return [r3.oneHot(a3, i4, s2, o2, l2)];
            }
            case "Ones":
              return [r3.ones(nA("shape", e22, t4, n4), nA("dtype", e22, t4, n4))];
            case "OnesLike":
              return [r3.onesLike(nA("x", e22, t4, n4))];
            case "RandomStandardNormal":
              return [r3.randomStandardNormal(nA("shape", e22, t4, n4), nA("dtype", e22, t4, n4), nA("seed", e22, t4, n4))];
            case "RandomUniform":
              return [r3.randomUniform(nA("shape", e22, t4, n4), nA("minval", e22, t4, n4), nA("maxval", e22, t4, n4), nA("dtype", e22, t4, n4))];
            case "RandomUniformInt":
              return [r3.randomUniformInt(nA("shape", e22, t4, n4), nA("minval", e22, t4, n4), nA("maxval", e22, t4, n4), nA("seed", e22, t4, n4))];
            case "Range": {
              let a3 = nA("start", e22, t4, n4), i4 = nA("stop", e22, t4, n4), s2 = nA("step", e22, t4, n4);
              return [r3.range(a3, i4, s2, nA("dtype", e22, t4, n4))];
            }
            case "TruncatedNormal": {
              let a3 = nA("shape", e22, t4, n4), i4 = nA("mean", e22, t4, n4), s2 = nA("stdDev", e22, t4, n4), o2 = nA("seed", e22, t4, n4);
              return [r3.truncatedNormal(a3, i4, s2, nA("dtype", e22, t4, n4), o2)];
            }
            case "Zeros":
              return [r3.zeros(nA("shape", e22, t4, n4), nA("dtype", e22, t4, n4))];
            case "ZerosLike":
              return [r3.zerosLike(nA("x", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "dynamic":
        return ((_0, _12, _2, _3, ..._4) => __async(null, [_0, _12, _2, _3, ..._4], function* (e22, t4, n4, r3, a3 = dx) {
          switch (e22.op) {
            case "NonMaxSuppressionV5": {
              let { boxes: r4, scores: i4, maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2, softNmsSigma: u2 } = yx(e22, t4, n4), d2 = yield a3.image.nonMaxSuppressionWithScoreAsync(r4, i4, s2, o2, l2, u2);
              return [d2.selectedIndices, d2.selectedScores];
            }
            case "NonMaxSuppressionV4": {
              let { boxes: r4, scores: i4, maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2 } = yx(e22, t4, n4), u2 = nA("padToMaxOutputSize", e22, t4, n4), d2 = yield a3.image.nonMaxSuppressionPaddedAsync(r4, i4, s2, o2, l2, u2);
              return [d2.selectedIndices, d2.validOutputs];
            }
            case "NonMaxSuppressionV3":
            case "NonMaxSuppressionV2": {
              let { boxes: r4, scores: i4, maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2 } = yx(e22, t4, n4);
              return [yield a3.image.nonMaxSuppressionAsync(r4, i4, s2, o2, l2)];
            }
            case "Where": {
              let r4 = a3.cast(nA("condition", e22, t4, n4), "bool"), i4 = [yield a3.whereAsync(r4)];
              return r4.dispose(), i4;
            }
            case "ListDiff":
              return a3.setdiff1dAsync(nA("x", e22, t4, n4), nA("y", e22, t4, n4));
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        }))(e21, t3, n3);
      case "evaluation":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "LowerBound": {
              let a3 = nA("sortedSequence", e22, t4, n4), i4 = nA("values", e22, t4, n4);
              return [r3.lowerBound(a3, i4)];
            }
            case "TopKV2": {
              let a3 = nA("x", e22, t4, n4), i4 = nA("k", e22, t4, n4), s2 = nA("sorted", e22, t4, n4), o2 = r3.topk(a3, i4, s2);
              return [o2.values, o2.indices];
            }
            case "UpperBound": {
              let a3 = nA("sortedSequence", e22, t4, n4), i4 = nA("values", e22, t4, n4);
              return [r3.upperBound(a3, i4)];
            }
            case "Unique": {
              let a3 = nA("x", e22, t4, n4), i4 = r3.unique(a3);
              return [i4.values, i4.indices];
            }
            case "UniqueV2": {
              let a3 = nA("x", e22, t4, n4), i4 = nA("axis", e22, t4, n4), s2 = r3.unique(a3, i4);
              return [s2.values, s2.indices];
            }
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "image":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "ResizeBilinear": {
              let a3 = nA("images", e22, t4, n4), i4 = nA("size", e22, t4, n4), s2 = nA("alignCorners", e22, t4, n4), o2 = nA("halfPixelCenters", e22, t4, n4);
              return [r3.image.resizeBilinear(a3, [i4[0], i4[1]], s2, o2)];
            }
            case "ResizeNearestNeighbor": {
              let a3 = nA("images", e22, t4, n4), i4 = nA("size", e22, t4, n4), s2 = nA("alignCorners", e22, t4, n4), o2 = nA("halfPixelCenters", e22, t4, n4);
              return [r3.image.resizeNearestNeighbor(a3, [i4[0], i4[1]], s2, o2)];
            }
            case "CropAndResize": {
              let a3 = nA("image", e22, t4, n4), i4 = nA("boxes", e22, t4, n4), s2 = nA("boxInd", e22, t4, n4), o2 = nA("cropSize", e22, t4, n4), l2 = nA("method", e22, t4, n4), u2 = nA("extrapolationValue", e22, t4, n4);
              return [r3.image.cropAndResize(a3, i4, s2, o2, l2, u2)];
            }
            case "ImageProjectiveTransformV3": {
              let a3 = nA("images", e22, t4, n4), i4 = nA("transforms", e22, t4, n4), s2 = nA("outputShape", e22, t4, n4), o2 = nA("fillValue", e22, t4, n4), l2 = nA("interpolation", e22, t4, n4), u2 = nA("fillMode", e22, t4, n4);
              return [r3.image.transform(a3, i4, l2.toLowerCase(), u2.toLowerCase(), o2, s2)];
            }
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "graph":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "Const":
              return t4[e22.name];
            case "PlaceholderWithDefault":
              let a3 = nA("default", e22, t4, n4);
              return [rA(e22.name, t4, n4) || a3];
            case "Placeholder":
              return [rA(e22.name, t4, n4)];
            case "Identity":
            case "StopGradient":
            case "FakeQuantWithMinMaxVars":
            case "Snapshot":
              return [uA(nA("x", e22, t4, n4))];
            case "IdentityN":
              return nA("x", e22, t4, n4).map((e23) => uA(e23));
            case "Shape":
              return [r3.tensor1d(nA("x", e22, t4, n4).shape, "int32")];
            case "ShapeN":
              return nA("x", e22, t4, n4).map((e23) => r3.tensor1d(e23.shape));
            case "Size":
              return [r3.scalar(nA("x", e22, t4, n4).size, "int32")];
            case "Rank":
              return [r3.scalar(nA("x", e22, t4, n4).rank, "int32")];
            case "NoOp":
              return [r3.scalar(1)];
            case "Print":
              let i4 = nA("x", e22, t4, n4), s2 = nA("data", e22, t4, n4), o2 = nA("message", e22, t4, n4), l2 = nA("summarize", e22, t4, n4);
              console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o2);
              for (let e23 = 0; s2.length > e23; e23++) console.log([].slice.call(s2[e23].dataSync()).slice(0, l2));
              return [i4];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "logical":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "Equal":
              return [r3.equal(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "NotEqual":
              return [r3.notEqual(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "Greater":
              return [r3.greater(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "GreaterEqual":
              return [r3.greaterEqual(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "Less":
              return [r3.less(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "LessEqual":
              return [r3.lessEqual(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "LogicalAnd":
              return [r3.logicalAnd(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "LogicalNot":
              return [r3.logicalNot(nA("a", e22, t4, n4))];
            case "LogicalOr":
              return [r3.logicalOr(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "Select":
            case "SelectV2":
              return [r3.where(nA("condition", e22, t4, n4), nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            case "BitwiseAnd":
              return [r3.bitwiseAnd(nA("a", e22, t4, n4), nA("b", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "matrices":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "BatchMatMul":
            case "BatchMatMulV2":
            case "MatMul":
              return [r3.matMul(nA("a", e22, t4, n4), nA("b", e22, t4, n4), nA("transposeA", e22, t4, n4), nA("transposeB", e22, t4, n4))];
            case "Einsum":
              return [r3.einsum(nA("equation", e22, t4, n4), ...nA("tensors", e22, t4, n4))];
            case "Transpose":
              return [r3.transpose(nA("x", e22, t4, n4), nA("perm", e22, t4, n4))];
            case "_FusedMatMul":
              let [a3, i4] = nA("fusedOps", e22, t4, n4), s2 = "biasadd" === a3, o2 = "prelu" === i4, l2 = nA("numArgs", e22, t4, n4), u2 = nA("leakyreluAlpha", e22, t4, n4);
              if (s2) {
                if (o2 && 2 !== l2) throw Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                if (!o2 && 1 !== l2) throw Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
              }
              let [d2, c2] = nA("args", e22, t4, n4);
              return [r3.fused.matMul({ a: nA("a", e22, t4, n4), b: nA("b", e22, t4, n4), transposeA: nA("transposeA", e22, t4, n4), transposeB: nA("transposeB", e22, t4, n4), bias: d2, activation: i4, preluActivationWeights: c2, leakyreluAlpha: u2 })];
            case "MatrixBandPart":
              return [r3.linalg.bandPart(nA("a", e22, t4, n4), nA("numLower", e22, t4, n4), nA("numUpper", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "normalization":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "EuclideanNorm":
              return [r3.euclideanNorm(nA("x", e22, t4, n4), nA("axis", e22, t4, n4), nA("keepDims", e22, t4, n4))];
            case "FusedBatchNorm":
            case "FusedBatchNormV2":
            case "FusedBatchNormV3":
              return [r3.batchNorm(nA("x", e22, t4, n4), nA("mean", e22, t4, n4), nA("variance", e22, t4, n4), nA("offset", e22, t4, n4), nA("scale", e22, t4, n4), nA("epsilon", e22, t4, n4))];
            case "LRN":
              return [r3.localResponseNormalization(nA("x", e22, t4, n4), nA("radius", e22, t4, n4), nA("bias", e22, t4, n4), nA("alpha", e22, t4, n4), nA("beta", e22, t4, n4))];
            case "Softmax":
              return [r3.softmax(nA("x", e22, t4, n4))];
            case "LogSoftmax":
              return [r3.logSoftmax(nA("x", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "ragged":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "RaggedGather": {
              let { outputNestedSplits: a3, outputDenseValues: i4 } = r3.raggedGather(nA("paramsNestedSplits", e22, t4, n4), nA("paramsDenseValues", e22, t4, n4), nA("indices", e22, t4, n4), nA("outputRaggedRank", e22, t4, n4));
              return a3.concat(i4);
            }
            case "RaggedRange": {
              let { rtNestedSplits: a3, rtDenseValues: i4 } = r3.raggedRange(nA("starts", e22, t4, n4), nA("limits", e22, t4, n4), nA("splits", e22, t4, n4));
              return [a3, i4];
            }
            case "RaggedTensorToTensor":
              return [r3.raggedTensorToTensor(nA("shape", e22, t4, n4), nA("values", e22, t4, n4), nA("defaultValue", e22, t4, n4), nA("rowPartitionTensors", e22, t4, n4), nA("rowPartitionTypes", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "reduction":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "Max": {
              let a4 = nA("axis", e22, t4, n4), i5 = nA("keepDims", e22, t4, n4);
              return [r3.max(nA("x", e22, t4, n4), a4, i5)];
            }
            case "Mean": {
              let a4 = nA("axis", e22, t4, n4), i5 = nA("keepDims", e22, t4, n4);
              return [r3.mean(nA("x", e22, t4, n4), a4, i5)];
            }
            case "Min": {
              let a4 = nA("axis", e22, t4, n4), i5 = nA("keepDims", e22, t4, n4);
              return [r3.min(nA("x", e22, t4, n4), a4, i5)];
            }
            case "Sum": {
              let a4 = nA("axis", e22, t4, n4), i5 = nA("keepDims", e22, t4, n4);
              return [r3.sum(nA("x", e22, t4, n4), a4, i5)];
            }
            case "All": {
              let a4 = nA("axis", e22, t4, n4), i5 = nA("keepDims", e22, t4, n4);
              return [r3.all(nA("x", e22, t4, n4), a4, i5)];
            }
            case "Any": {
              let a4 = nA("axis", e22, t4, n4), i5 = nA("keepDims", e22, t4, n4);
              return [r3.any(nA("x", e22, t4, n4), a4, i5)];
            }
            case "ArgMax": {
              let a4 = nA("axis", e22, t4, n4);
              return [r3.argMax(nA("x", e22, t4, n4), a4)];
            }
            case "ArgMin": {
              let a4 = nA("axis", e22, t4, n4);
              return [r3.argMin(nA("x", e22, t4, n4), a4)];
            }
            case "Prod": {
              let a4 = nA("axis", e22, t4, n4), i5 = nA("keepDims", e22, t4, n4);
              return [r3.prod(nA("x", e22, t4, n4), a4, i5)];
            }
            case "Cumprod": {
              let a4 = nA("axis", e22, t4, n4), i5 = nA("exclusive", e22, t4, n4), s3 = nA("reverse", e22, t4, n4);
              return [r3.cumprod(nA("x", e22, t4, n4), a4, i5, s3)];
            }
            case "Cumsum": {
              let a4 = nA("axis", e22, t4, n4), i5 = nA("exclusive", e22, t4, n4), s3 = nA("reverse", e22, t4, n4);
              return [r3.cumsum(nA("x", e22, t4, n4), a4, i5, s3)];
            }
            case "Bincount":
              let a3 = nA("x", e22, t4, n4), i4 = nA("weights", e22, t4, n4), s2 = nA("size", e22, t4, n4);
              return [r3.bincount(a3, i4, s2)];
            case "DenseBincount": {
              let a4 = nA("x", e22, t4, n4), i5 = nA("weights", e22, t4, n4), s3 = nA("size", e22, t4, n4), o2 = nA("binaryOutput", e22, t4, n4);
              return [r3.denseBincount(a4, i5, s3, o2)];
            }
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "slice_join":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "ConcatV2":
            case "Concat": {
              let a3 = nA("n", e22, t4, n4), i4 = nA("axis", e22, t4, n4), s2 = nA("tensors", e22, t4, n4);
              return s2 = s2.slice(0, a3), [r3.concat(s2, i4)];
            }
            case "Gather": {
              let a3 = nA("x", e22, t4, n4), i4 = nA("indices", e22, t4, n4);
              return [r3.gather(a3, r3.cast(i4, "int32"), 0)];
            }
            case "GatherV2": {
              let a3 = nA("axis", e22, t4, n4), i4 = nA("batchDims", e22, t4, n4), s2 = nA("x", e22, t4, n4), o2 = nA("indices", e22, t4, n4);
              return [r3.gather(s2, r3.cast(o2, "int32"), a3, i4)];
            }
            case "Reverse": {
              let a3 = nA("dims", e22, t4, n4), i4 = [];
              for (let e23 = 0; a3.length > e23; e23++) a3[e23] && i4.push(e23);
              let s2 = nA("x", e22, t4, n4);
              return [r3.reverse(s2, i4)];
            }
            case "ReverseV2": {
              let a3 = nA("axis", e22, t4, n4), i4 = nA("x", e22, t4, n4);
              return [r3.reverse(i4, a3)];
            }
            case "Slice": {
              let a3 = nA("begin", e22, t4, n4), i4 = nA("size", e22, t4, n4);
              return [r3.slice(nA("x", e22, t4, n4), a3, i4)];
            }
            case "StridedSlice": {
              let a3 = nA("begin", e22, t4, n4), i4 = nA("end", e22, t4, n4), s2 = nA("strides", e22, t4, n4), o2 = nA("beginMask", e22, t4, n4), l2 = nA("endMask", e22, t4, n4), u2 = nA("ellipsisMask", e22, t4, n4), d2 = nA("newAxisMask", e22, t4, n4), c2 = nA("shrinkAxisMask", e22, t4, n4), h2 = nA("x", e22, t4, n4);
              return [r3.stridedSlice(h2, a3, i4, s2, o2, l2, u2, d2, c2)];
            }
            case "Pack":
              return es(() => {
                let a3 = nA("axis", e22, t4, n4), i4 = nA("tensors", e22, t4, n4), s2 = i4[0].shape, o2 = r3.squeeze(i4[0]).shape, l2 = i4.map((e23) => {
                  let t5 = va.arraysEqual(e23.shape, s2);
                  if (!t5 && !va.arraysEqual(r3.squeeze(e23).shape, o2)) throw Error("the input tensors shape does not match");
                  return t5 ? e23 : r3.reshape(e23, s2);
                });
                return [r3.stack(l2, a3)];
              });
            case "Unpack": {
              let a3 = nA("axis", e22, t4, n4), i4 = nA("tensor", e22, t4, n4);
              return r3.unstack(i4, a3);
            }
            case "Tile": {
              let a3 = nA("reps", e22, t4, n4);
              return [r3.tile(nA("x", e22, t4, n4), a3)];
            }
            case "Split":
            case "SplitV": {
              let a3 = nA("axis", e22, t4, n4), i4 = nA("numOrSizeSplits", e22, t4, n4), s2 = nA("x", e22, t4, n4);
              return r3.split(s2, i4, a3);
            }
            case "ScatterNd": {
              let a3 = nA("indices", e22, t4, n4), i4 = nA("values", e22, t4, n4), s2 = nA("shape", e22, t4, n4);
              return [r3.scatterND(a3, i4, s2)];
            }
            case "GatherNd": {
              let a3 = nA("x", e22, t4, n4), i4 = nA("indices", e22, t4, n4);
              return [r3.gatherND(a3, i4)];
            }
            case "SparseToDense": {
              let a3 = nA("sparseIndices", e22, t4, n4), i4 = nA("outputShape", e22, t4, n4), s2 = nA("sparseValues", e22, t4, n4), o2 = nA("defaultValue", e22, t4, n4);
              return [r3.sparseToDense(a3, s2, i4, s2.dtype === o2.dtype ? o2 : r3.cast(o2, s2.dtype))];
            }
            case "TensorScatterUpdate": {
              let a3 = nA("indices", e22, t4, n4), i4 = nA("values", e22, t4, n4), s2 = nA("tensor", e22, t4, n4);
              return [r3.tensorScatterUpdate(s2, a3, i4)];
            }
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "sparse":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "SparseFillEmptyRows": {
              let { outputIndices: a3, outputValues: i4, emptyRowIndicator: s2, reverseIndexMap: o2 } = r3.sparse.sparseFillEmptyRows(nA("indices", e22, t4, n4), nA("values", e22, t4, n4), nA("denseShape", e22, t4, n4), nA("defaultValue", e22, t4, n4));
              return [a3, i4, s2, o2];
            }
            case "SparseReshape": {
              let { outputIndices: a3, outputShape: i4 } = r3.sparse.sparseReshape(nA("inputIndices", e22, t4, n4), nA("inputShape", e22, t4, n4), nA("newShape", e22, t4, n4));
              return [a3, i4];
            }
            case "SparseSegmentMean":
              return [r3.sparse.sparseSegmentMean(nA("data", e22, t4, n4), nA("indices", e22, t4, n4), nA("segmentIds", e22, t4, n4))];
            case "SparseSegmentSum":
              return [r3.sparse.sparseSegmentSum(nA("data", e22, t4, n4), nA("indices", e22, t4, n4), nA("segmentIds", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "spectral":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "FFT":
              return [r3.fft(nA("x", e22, t4, n4))];
            case "IFFT":
              return [r3.ifft(nA("x", e22, t4, n4))];
            case "RFFT":
              return [r3.rfft(nA("x", e22, t4, n4))];
            case "IRFFT":
              return [r3.irfft(nA("x", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "string":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "StaticRegexReplace":
              return [r3.string.staticRegexReplace(nA("input", e22, t4, n4), nA("pattern", e22, t4, n4), nA("rewrite", e22, t4, n4), nA("replaceGlobal", e22, t4, n4))];
            case "StringNGrams": {
              let { nGrams: a3, nGramsSplits: i4 } = r3.string.stringNGrams(nA("data", e22, t4, n4), nA("dataSplits", e22, t4, n4), nA("separator", e22, t4, n4), nA("nGramWidths", e22, t4, n4), nA("leftPad", e22, t4, n4), nA("rightPad", e22, t4, n4), nA("padWidth", e22, t4, n4), nA("preserveShortSequences", e22, t4, n4));
              return [a3, i4];
            }
            case "StringSplit": {
              let { indices: a3, values: i4, shape: s2 } = r3.string.stringSplit(nA("input", e22, t4, n4), nA("delimiter", e22, t4, n4), nA("skipEmpty", e22, t4, n4));
              return [a3, i4, s2];
            }
            case "StringToHashBucketFast":
              return [r3.string.stringToHashBucketFast(nA("input", e22, t4, n4), nA("numBuckets", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "transformation":
        return a2(() => ((e22, t4, n4, r3 = dx) => {
          switch (e22.op) {
            case "Cast":
              return [r3.cast(nA("x", e22, t4, n4), nA("dtype", e22, t4, n4))];
            case "ExpandDims": {
              let a3 = nA("axis", e22, t4, n4);
              return [r3.expandDims(nA("x", e22, t4, n4), a3)];
            }
            case "Squeeze": {
              let a3 = nA("axis", e22, t4, n4);
              return [r3.squeeze(nA("x", e22, t4, n4), a3)];
            }
            case "Reshape":
              return [r3.reshape(nA("x", e22, t4, n4), nA("shape", e22, t4, n4))];
            case "EnsureShape":
              return [r3.ensureShape(nA("x", e22, t4, n4), nA("shape", e22, t4, n4))];
            case "MirrorPad":
              return [r3.mirrorPad(nA("x", e22, t4, n4), nA("padding", e22, t4, n4), nA("mode", e22, t4, n4))];
            case "PadV2":
            case "Pad":
              return [r3.pad(nA("x", e22, t4, n4), nA("padding", e22, t4, n4), nA("constantValue", e22, t4, n4))];
            case "SpaceToBatchND": {
              let a3 = nA("blockShape", e22, t4, n4), i4 = nA("paddings", e22, t4, n4);
              return [r3.spaceToBatchND(nA("x", e22, t4, n4), a3, i4)];
            }
            case "BatchToSpaceND": {
              let a3 = nA("blockShape", e22, t4, n4), i4 = nA("crops", e22, t4, n4);
              return [r3.batchToSpaceND(nA("x", e22, t4, n4), a3, i4)];
            }
            case "DepthToSpace": {
              let a3 = nA("blockSize", e22, t4, n4), i4 = nA("dataFormat", e22, t4, n4).toUpperCase();
              return [r3.depthToSpace(nA("x", e22, t4, n4), a3, i4)];
            }
            case "BroadcastTo":
              return [r3.broadcastTo(nA("x", e22, t4, n4), nA("shape", e22, t4, n4))];
            case "BroadcastArgs":
              return [r3.broadcastArgs(nA("s0", e22, t4, n4), nA("s1", e22, t4, n4))];
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        })(e21, t3, n3));
      case "hash_table":
        return ((e22, t4, n4, r3) => __async(null, null, function* () {
          switch (e22.op) {
            case "HashTable":
            case "HashTableV2": {
              let a3 = r3.getHashTableHandleByName(e22.name);
              if (null != a3) return [a3];
              {
                let a4 = nA("keyDType", e22, t4, n4), i4 = nA("valueDType", e22, t4, n4), s2 = new bx(a4, i4);
                return r3.addHashTable(e22.name, s2), [s2.handle];
              }
            }
            case "InitializeTable":
            case "InitializeTableV2":
            case "LookupTableImport":
            case "LookupTableImportV2": {
              let a3 = nA("tableHandle", e22, t4, n4, r3), i4 = nA("keys", e22, t4, n4), s2 = nA("values", e22, t4, n4);
              return [yield r3.getHashTableById(a3.id).import(i4, s2)];
            }
            case "LookupTableFind":
            case "LookupTableFindV2": {
              let a3 = nA("tableHandle", e22, t4, n4, r3), i4 = nA("keys", e22, t4, n4), s2 = nA("defaultValue", e22, t4, n4);
              return [yield r3.getHashTableById(a3.id).find(i4, s2)];
            }
            case "LookupTableSize":
            case "LookupTableSizeV2": {
              let a3 = nA("tableHandle", e22, t4, n4, r3);
              return [r3.getHashTableById(a3.id).tensorSize()];
            }
            default:
              throw TypeError(`Node type ${e22.op} is not implemented`);
          }
        }))(e21, t3, n3, r2);
      case "custom":
        let i3 = eA(e21.op);
        if (i3 && i3.customExecutor) return i3.customExecutor(new ux(e21, t3, n3));
        throw TypeError(`Custom op ${e21.op} is not registered.`);
      default:
        throw TypeError(`Unknown op '${e21.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
    }
  })(e20, t2, n2);
  return va.isPromise(i2) ? i2.then((e21) => [].concat(e21)) : [].concat(i2);
}
var vx = class {
  constructor(e20 = {}, t2 = {}, n2 = {}, r2 = {}, a2) {
    this.weightMap = e20, this.tensorArrayMap = t2, this.tensorListMap = n2, this.functionMap = r2, this.parseNodeNameCache = a2, this.rootContext = { id: 0, frameName: "", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }
  newFrame(e20, t2) {
    return { id: e20, frameName: t2, iterationId: 0 };
  }
  set currentContext(e20) {
    this.contexts !== e20 && (this.contexts = e20, this.generateCurrentContextIds());
  }
  get currentContext() {
    return this.contexts;
  }
  get currentContextId() {
    return this.nr[0];
  }
  get currentContextIds() {
    return this.nr;
  }
  generateCurrentContextIds() {
    let e20 = [];
    for (let t2 = 0; this.contexts.length - 1 > t2; t2++) {
      let n2 = this.contexts.slice(0, this.contexts.length - t2);
      e20.push(this.contextIdforContexts(n2));
    }
    e20.push(""), this.nr = e20;
  }
  contextIdforContexts(e20) {
    return e20 ? e20.map((e21) => 0 === e21.id && 0 === e21.iterationId ? "" : `${e21.frameName}-${e21.iterationId}`).join("/") : "";
  }
  enterFrame(e20) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e20)), this.nr.unshift(this.contextIdforContexts(this.contexts)));
  }
  exitFrame() {
    if (!this.contexts || 1 >= this.contexts.length) throw Error("Cannot exit frame, the context is empty");
    this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
  }
  nextIteration() {
    if (!this.contexts || 0 >= this.contexts.length) throw Error("Cannot increase frame iteration, the context is empty");
    {
      this.contexts = this.contexts.slice(), this.lastId++;
      let e20 = Object.assign({}, this.contexts[this.contexts.length - 1]);
      e20.iterationId += 1, e20.id = this.lastId, this.contexts.splice(-1, 1, e20), this.nr.splice(0, 1, this.contextIdforContexts(this.contexts));
    }
  }
  getWeight(e20) {
    return this.weightMap[e20];
  }
  addTensorArray(e20) {
    this.tensorArrayMap[e20.id] = e20;
  }
  getTensorArray(e20) {
    return this.tensorArrayMap[e20];
  }
  addTensorList(e20) {
    this.tensorListMap[e20.id] = e20;
  }
  getTensorList(e20) {
    return this.tensorListMap[e20];
  }
  dispose(e20) {
    for (let t2 in this.tensorArrayMap) this.tensorArrayMap[t2].clearAndClose(e20);
    for (let t2 in this.tensorListMap) this.tensorListMap[t2].clearAndClose(e20);
  }
};
function wx(e20, t2, n2, r2) {
  let a2 = /* @__PURE__ */ new Set(), i2 = [], s2 = null, o2 = null, l2 = /* @__PURE__ */ new Set(), u2 = new Set(Object.keys(e20).map((e21) => oA(e21)[0]));
  r2 = r2 || [];
  let d2 = new Set(r2.map((e21) => oA(e21.name)[0])), c2 = [...t2];
  for (; c2.length > 0; ) {
    let e21 = c2.pop();
    if ((Rx(e21) || Sx(e21) || Ix(e21)) && null == s2 && (s2 = e21, o2 = s2.children.map((e22) => e22.name).filter((e22) => a2.has(e22))), a2.add(e21.name), null == n2[e21.name] && !u2.has(e21.name) && !d2.has(e21.name)) {
      if (0 === e21.inputs.length) {
        i2.push(e21.name);
        continue;
      }
      e21.inputs.forEach((e22) => {
        l2.has(e22.name) || (l2.add(e22.name), c2.push(e22));
      });
    }
  }
  return { inputs: e20, outputs: t2, usedNodes: a2, missingInputs: i2, dynamicNode: s2, syncInputs: o2 };
}
var kx = class extends Error {
  constructor(e20) {
    super("NodesExecutionOrderError: " + e20);
  }
};
var Nx = /* @__PURE__ */ new Set(["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"]);
var Cx = /* @__PURE__ */ new Set(["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"]);
var $x = /* @__PURE__ */ new Set(["HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2"]);
function Rx(e20) {
  return Nx.has(e20.op);
}
function Sx(e20) {
  return Cx.has(e20.op);
}
function Ix(e20) {
  return $x.has(e20.op);
}
var Ex = class e9 {
  get weightIds() {
    return this.parent ? this.parent.weightIds : this.rr;
  }
  get functionExecutorMap() {
    return this.parent ? this.parent.functionExecutorMap : this.ar;
  }
  get weightMap() {
    return this.parent ? this.parent.weightMap : this.ir;
  }
  set weightMap(e20) {
    let t2 = Object.keys(e20).map((t3) => e20[t3].map((e21) => e21.id));
    this.rr = [].concat(...t2), this.ir = e20;
  }
  set resourceManager(e20) {
    this.sr = e20;
  }
  get inputs() {
    return this.lr.map((e20) => ({ name: e20.name, shape: e20.attrParams.shape ? e20.attrParams.shape.value : void 0, dtype: e20.attrParams.dtype ? e20.attrParams.dtype.value : void 0 }));
  }
  get outputs() {
    return this.ur.map((e20) => ({ name: e20.name, shape: e20.attrParams.shape ? e20.attrParams.shape.value : void 0, dtype: e20.attrParams.dtype ? e20.attrParams.dtype.value : void 0 }));
  }
  get inputNodes() {
    return this.lr.map((e20) => e20.signatureKey || e20.name);
  }
  get outputNodes() {
    return this.ur.map((e20) => {
      let t2 = e20.signatureKey || e20.name;
      return e20.defaultOutput ? `${t2}:${e20.defaultOutput}` : t2;
    });
  }
  get functions() {
    return Object.keys(this.dr).reduce((e20, t2) => (e20[t2] = this.dr[t2].signature, e20), {});
  }
  constructor(t2, n2) {
    this.graph = t2, this.parent = n2, this.compiledMap = /* @__PURE__ */ new Map(), this.parseNodeNameCache = /* @__PURE__ */ new Map(), this.ir = {}, this.SEPARATOR = ",", this.dr = {}, this.ar = {}, this.keepIntermediateTensors = false, this.ur = t2.outputs, this.lr = t2.inputs, this.cr = t2.initNodes, this.hr = t2.signature, this.dr = t2.functions, null != t2.functions && Object.keys(t2.functions).forEach((n3) => {
      this.ar[n3] = new e9(t2.functions[n3], this);
    });
  }
  getCompilationKey(e20, t2) {
    let n2 = e20.map((e21) => e21.name).sort(), r2 = t2.map((e21) => e21.name).sort();
    return n2.join(this.SEPARATOR) + "--" + r2.join(this.SEPARATOR);
  }
  compile(e20, t2) {
    let n2 = wx(e20, t2, this.weightMap, this.cr), { missingInputs: r2, dynamicNode: a2, syncInputs: i2 } = n2;
    if (null != a2) throw Error(`This execution contains the node '${a2.name}', which has the dynamic op '${a2.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i2}]`);
    if (r2.length > 0) {
      let n3 = t2.map((e21) => e21.name);
      throw Error(`Cannot compute the outputs [${n3}] from the provided inputs [${Object.keys(e20)}]. Missing the following inputs: [${r2}]`);
    }
    let s2 = ((e21, t3) => {
      let { usedNodes: n3, inputs: r3 } = t3, a3 = (e22) => n3.has("string" == typeof e22 ? e22 : e22.name);
      function i3(e22) {
        return [...new Map(e22.map((e23) => [e23.name, e23])).values()];
      }
      let s3 = i3([...Object.keys(r3).map((e22) => oA(e22)[0]).map((t4) => e21.nodes[t4]), ...e21.weights, ...e21.initNodes || []]).filter(a3), o3 = i3([...s3, ...Object.values(e21.nodes)]).filter(a3), l2 = new Map(o3.map((e22) => [e22.name, e22])), u2 = {};
      for (let p2 of o3) {
        u2[p2.name] = u2[p2.name] || 0;
        for (let e22 of p2.children) a3(e22) || (u2[e22.name] = Infinity), u2[e22.name] = (u2[e22.name] || 0) + 1;
      }
      let d2 = Object.entries(u2).filter(([, e22]) => 0 === e22).map(([e22]) => e22), c2 = [...d2];
      for (; d2.length > 0; ) {
        let e22 = d2.pop(), t4 = l2.get(e22);
        for (let n4 of t4.children.filter(a3)) 0 === --u2[n4.name] && (c2.push(n4.name), d2.push(n4.name));
      }
      let h2 = ((e22, t4) => {
        let n4 = new Map(e22.map((e23) => [e23.name, e23])), r4 = t4.map((e23) => e23.name), a4 = new Set(r4);
        for (; r4.length > 0; ) {
          let e23 = r4.pop(), t5 = n4.get(e23);
          for (let i4 of t5.children) !n4.has(i4.name) || a4.has(i4.name) || (a4.add(i4.name), r4.push(i4.name));
        }
        return e22.filter((e23) => a4.has(e23.name));
      })(c2.map((e22) => l2.get(e22)), s3);
      return ((e22, t4) => {
        let n4 = new Map(e22.map((e23, t5) => [e23.name, t5])), r4 = new Set(t4.map((e23) => e23.name)), a4 = (e23) => r4.has("string" == typeof e23 ? e23 : e23.name), i4 = new Set(e22.map((e23) => e23.name)), s4 = (e23) => i4.has("string" == typeof e23 ? e23 : e23.name);
        for (let o4 of e22) {
          for (let e23 of o4.children.filter(s4)) {
            if (!n4.has(e23.name)) throw new kx(`Child ${e23.name} of node ${o4.name} is unreachable.`);
            if (n4.get(o4.name) > n4.get(e23.name)) throw new kx(`Node ${o4.name} is scheduled to run after its child ${e23.name}.`);
          }
          if (!a4(o4)) for (let e23 of o4.inputs) {
            if (!n4.has(e23.name)) throw new kx(`Input ${e23.name} of node ${o4.name} is unreachable.`);
            if (n4.get(e23.name) > n4.get(o4.name)) throw new kx(`Node ${o4.name} is scheduled to run before its input ${e23.name}.`);
          }
        }
      })(h2, s3), h2;
    })(this.graph, n2), o2 = ((e21) => {
      let t3 = new Map(e21.map((e22, t4) => [e22.name, t4])), n3 = Number.MAX_SAFE_INTEGER, r3 = e21.map((e22, t4) => Rx(e22) ? n3 : t4), a3 = (e22) => r3[t3.get(e22.name)] ?? -1, i3 = e21.map((e22, t4) => e22.children.map(a3).reduce((e23, t5) => Math.max(e23, t5), r3[t4])), s3 = /* @__PURE__ */ new Map();
      for (let o3 = 0; e21.length > o3; ++o3) {
        let t4 = i3[o3];
        if (t4 === n3) continue;
        let r4 = e21[o3], a4 = e21[t4];
        s3.has(a4.name) || s3.set(a4.name, []), s3.get(a4.name).push(r4);
      }
      return s3;
    })(s2);
    return { orderedNodes: s2, nodeLiveUntilMap: o2 };
  }
  cloneAndKeepTensor(e20) {
    if (null == e20) return null;
    let t2 = e20.clone();
    return ns(t2), t2;
  }
  cloneTensorList(e20) {
    return e20 ? e20.map((e21) => this.cloneAndKeepTensor(e21)) : null;
  }
  cloneTensorMap(e20) {
    return Object.fromEntries(Object.entries(e20).map(([e21, t2]) => [e21, this.cloneTensorList(t2)]));
  }
  execute(e20, t2) {
    this.disposeIntermediateTensors(), e20 = this.mapInputs(e20);
    let n2 = Object.keys(e20).sort();
    this.checkInputs(e20), this.checkInputShapeAndType(e20), t2 = this.mapOutputs(t2), this.checkOutputs(t2);
    let r2 = n2.map((e21) => this.graph.nodes[oA(e21)[0]]), a2 = t2.map((e21) => oA(e21)[0]), i2 = new Set(a2), s2 = a2.map((e21) => this.graph.nodes[e21]);
    0 === s2.length && (s2 = this.ur);
    let o2 = this.getCompilationKey(r2, s2), l2 = this.compiledMap.get(o2);
    null == l2 && (l2 = this.compile(e20, s2), this.compiledMap.set(o2, l2));
    try {
      this.keepIntermediateTensors = _e().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (c2) {
      this.keepIntermediateTensors = false, console.warn(c2.message);
    }
    let u2 = {}, d2 = {};
    return es(() => {
      let n3 = new vx(this.weightMap, u2, d2, this.functionExecutorMap, this.parseNodeNameCache), r3 = Object.assign({}, this.weightMap);
      this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap)), Object.keys(e20).forEach((t3) => {
        let [a4, i3] = oA(t3, n3), s4 = [];
        s4[i3] = e20[t3], r3[a4] = s4, this.keepIntermediateTensors && (this.clonedTensorsMap[a4] = this.cloneTensorList(s4));
      });
      let a3 = this.getFrozenTensorIds(r3), { orderedNodes: s3, nodeLiveUntilMap: o3 } = l2;
      for (let e21 of s3) {
        if (r3[e21.name]) continue;
        let t3 = gx(e21, r3, n3, this.sr);
        if (va.isPromise(t3)) throw Error(`The execution of the op '${e21.op}' returned a promise. Please use model.executeAsync() instead.`);
        r3[e21.name] = t3, this.keepIntermediateTensors && (this.clonedTensorsMap[e21.name] = this.cloneTensorList(t3)), this.checkTensorForDisposalWithNodeLiveUntilInfo(e21, r3, n3, a3, i2, o3.get(e21.name));
      }
      return null == this.parent && n3.dispose(a3), t2.map((e21) => rA(e21, r3, n3));
    });
  }
  getFrozenTensorIds(e20) {
    let t2 = [].concat.apply([], Object.keys(e20).map((t3) => e20[t3]).map((e21) => e21.map((e22) => e22.id)));
    return new Set(t2);
  }
  checkTensorForDisposal(e20, t2, n2, r2, a2, i2, s2) {
    if (!Rx(t2) && !i2.has(e20)) {
      for (let r3 of n2[e20]) null != r3 && (s2[r3.id] = (s2[r3.id] || 0) + t2.children.length);
      for (let e21 of t2.inputs) {
        if (Rx(e21)) continue;
        let t3 = aA(e21.name, n2, r2);
        if (null != t3) for (let e22 of t3) {
          if (!e22 || e22.kept || a2.has(e22.id)) continue;
          let t4 = s2[e22.id];
          1 === t4 ? (e22.dispose(), delete s2[e22.id]) : null != t4 && s2[e22.id]--;
        }
      }
    }
  }
  checkTensorForDisposalWithNodeLiveUntilInfo(e20, t2, n2, r2, a2, i2) {
    function s2(e21) {
      return Rx(e21) || a2.has(e21.name);
    }
    if (!Rx(e20) && null != i2) for (let o2 of i2) {
      if (s2(o2)) continue;
      let e21 = aA(o2.name, t2, n2);
      for (let t3 of e21) !t3 || t3.kept || r2.has(t3.id) || t3.dispose();
    }
  }
  executeAsync(e20, t2) {
    return __async(this, null, function* () {
      return this.pr(e20, t2);
    });
  }
  disposeIntermediateTensors() {
    this.clonedTensorsMap && (Object.values(this.clonedTensorsMap).forEach((e20) => {
      for (let t2 of e20) t2 && !t2.isDisposed && t2.dispose();
    }), this.clonedTensorsMap = null);
  }
  getIntermediateTensors() {
    return this.clonedTensorsMap;
  }
  pr(_0, _12) {
    return __async(this, arguments, function* (e20, t2, n2 = false, r2 = {}, a2 = {}) {
      this.disposeIntermediateTensors(), n2 || (e20 = this.mapInputs(e20), this.checkInputs(e20), this.checkInputShapeAndType(e20), t2 = this.mapOutputs(t2), this.checkOutputs(t2));
      try {
        this.keepIntermediateTensors = _e().getBool("KEEP_INTERMEDIATE_TENSORS");
      } catch (c2) {
        this.keepIntermediateTensors = false, console.warn(c2.message);
      }
      let i2 = new vx(this.weightMap, r2, a2, this.functionExecutorMap, this.parseNodeNameCache);
      this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap));
      let s2 = yield this.executeWithControlFlow(e20, i2, t2, n2), o2 = t2.map((e21) => rA(e21, s2, i2)), l2 = o2.map((e21) => e21.id), u2 = Object.keys(e20).map((t3) => e20[t3].id), d2 = /* @__PURE__ */ new Set([...l2, ...u2, ...this.weightIds]);
      return Object.values(s2).forEach((e21) => {
        e21.forEach((e22) => {
          e22 && !e22.isDisposed && !d2.has(e22.id) && e22.dispose();
        });
      }), null == this.parent && i2.dispose(d2), o2;
    });
  }
  executeFunctionAsync(e20, t2, n2) {
    return __async(this, null, function* () {
      let r2 = e20.reduce((e21, t3, n3) => (e21[this.inputs[n3].name] = t3, e21), {});
      return this.pr(r2, this.outputNodes, true, t2, n2);
    });
  }
  executeWithControlFlow(e20, t2, n2, r2) {
    return __async(this, null, function* () {
      let a2 = Object.keys(e20), i2 = a2.map((e21) => this.graph.nodes[oA(e21)[0]]), s2 = n2.map((e21) => oA(e21)[0]), o2 = new Set(s2), l2 = s2.map((e21) => this.graph.nodes[e21]);
      0 === l2.length && (l2 = this.ur);
      let { usedNodes: u2, missingInputs: d2, dynamicNode: c2, syncInputs: h2 } = wx(e20, l2, this.weightMap, this.cr), p2 = [...i2, ...this.graph.weights, ...this.cr || []].map((e21) => ({ node: e21, contexts: t2.currentContext })), f2 = Object.assign({}, this.weightMap);
      Object.keys(e20).forEach((t3) => {
        let [n3, r3] = oA(t3), a3 = [];
        a3[r3] = e20[t3], f2[n3] = a3;
      });
      let m2 = {}, A2 = this.getFrozenTensorIds(f2), x2 = {};
      for (; p2.length > 0; ) {
        let e21 = this.processStack(i2, p2, t2, f2, x2, A2, o2, m2, u2);
        yield Promise.all(e21);
      }
      null == c2 && !r2 && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
      let y2 = l2.filter((e21) => !Rx(e21) && !rA(e21.name, f2, t2)).map((e21) => e21.name);
      if (y2.length > 0) {
        let e21 = "";
        throw null != c2 && (e21 = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h2}]`), Error(`Cannot compute the outputs [${y2}] from the provided inputs [${a2}]. Consider providing the following inputs: [${d2}]. ${e21}`);
      }
      return f2;
    });
  }
  processStack(e20, t2, n2, r2, a2, i2, s2, o2, l2) {
    let u2 = [];
    for (; t2.length > 0; ) {
      let e21 = t2.pop();
      n2.currentContext = e21.contexts;
      let d2 = "";
      if ("Enter" === e21.node.op && nA("isConstant", e21.node, r2, n2) && ([d2] = iA(e21.node.name, n2)), null == r2[e21.node.name]) {
        let c2 = gx(e21.node, r2, n2, this.sr);
        d2 || ([d2] = iA(e21.node.name, n2));
        let h2 = n2.currentContext;
        va.isPromise(c2) ? u2.push(c2.then((u3) => (r2[d2] = u3, this.keepIntermediateTensors && (this.clonedTensorsMap[d2] = this.cloneTensorList(u3)), n2.currentContext = h2, this.checkTensorForDisposal(d2, e21.node, r2, n2, i2, s2, o2), this.processChildNodes(e21.node, t2, n2, r2, a2, l2), u3))) : (r2[d2] = c2, this.keepIntermediateTensors && (this.clonedTensorsMap[d2] = this.cloneTensorList(c2)), this.checkTensorForDisposal(d2, e21.node, r2, n2, i2, s2, o2), this.processChildNodes(e21.node, t2, n2, r2, a2, l2));
      } else this.processChildNodes(e21.node, t2, n2, r2, a2, l2);
    }
    return u2;
  }
  processChildNodes(e20, t2, n2, r2, a2, i2) {
    e20.children.forEach((e21) => {
      let [s2] = iA(e21.name, n2);
      a2[s2] || !i2.has(e21.name) || ("Merge" === e21.op ? e21.inputNames.some((e22) => !!rA(e22, r2, n2)) && (a2[s2] = true, t2.push({ contexts: n2.currentContext, node: e21 })) : e21.inputNames.every((e22) => !!rA(e22, r2, n2)) && (a2[s2] = true, t2.push({ contexts: n2.currentContext, node: e21 })));
    });
  }
  dispose() {
    Object.keys(this.weightMap).forEach((e20) => this.weightMap[e20].forEach((e21) => e21.dispose()));
  }
  checkInputShapeAndType(e20) {
    Object.keys(e20).forEach((t2) => {
      let n2 = e20[t2], [r2] = oA(t2), a2 = this.graph.nodes[r2];
      if (a2.attrParams.shape && a2.attrParams.shape.value) {
        let e21 = a2.attrParams.shape.value, t3 = e21.length === n2.shape.length && n2.shape.every((t4, n3) => -1 === e21[n3] || e21[n3] === t4);
        va.assert(t3, () => `The shape of dict['${a2.name}'] provided in model.execute(dict) must be [${e21}], but was [${n2.shape}]`);
      }
      a2.attrParams.dtype && a2.attrParams.dtype.value && va.assert(n2.dtype === a2.attrParams.dtype.value, () => `The dtype of dict['${a2.name}'] provided in model.execute(dict) must be ${a2.attrParams.dtype.value}, but was ${n2.dtype}`);
    });
  }
  mapInputs(e20) {
    var t2, n2;
    let r2 = {};
    for (let a2 in e20) {
      let i2 = null === (n2 = null === (t2 = this.hr) || void 0 === t2 ? void 0 : t2.inputs) || void 0 === n2 ? void 0 : n2[a2];
      null != i2 ? r2[i2.name] = e20[a2] : r2[a2] = e20[a2];
    }
    return r2;
  }
  checkInputs(e20) {
    let t2 = Object.keys(e20).filter((e21) => {
      let [t3] = oA(e21);
      return null == this.graph.nodes[t3];
    });
    if (t2.length > 0) throw Error(`The dict provided in model.execute(dict) has keys: [${t2}] that are not part of graph`);
  }
  mapOutputs(e20) {
    return e20.map((e21) => {
      var t2, n2;
      let r2 = null === (n2 = null === (t2 = this.hr) || void 0 === t2 ? void 0 : t2.outputs) || void 0 === n2 ? void 0 : n2[e21];
      return null != r2 ? r2.name : e21;
    }, {});
  }
  checkOutputs(e20) {
    e20.forEach((e21) => {
      let [t2] = oA(e21);
      if (!this.graph.nodes[t2]) throw Error(`The output '${e21}' is not found in the graph`);
    });
  }
};
var Tx = class {
  constructor(e20 = {}, t2 = {}) {
    this.hashTableNameToHandle = e20, this.hashTableMap = t2;
  }
  addHashTable(e20, t2) {
    this.hashTableNameToHandle[e20] = t2.handle, this.hashTableMap[t2.id] = t2;
  }
  getHashTableHandleByName(e20) {
    return this.hashTableNameToHandle[e20];
  }
  getHashTableById(e20) {
    return this.hashTableMap[e20];
  }
  dispose() {
    for (let e20 in this.hashTableMap) this.hashTableMap[e20].clearAndClose(), delete this.hashTableMap[e20];
    for (let e20 in this.hashTableNameToHandle) this.hashTableNameToHandle[e20].dispose(), delete this.hashTableNameToHandle[e20];
  }
};
var Mx = "?tfjs-format=file";
var Ox = "model.json";
var Fx = class {
  get modelVersion() {
    return this.version;
  }
  get inputNodes() {
    return this.executor.inputNodes;
  }
  get outputNodes() {
    return this.executor.outputNodes;
  }
  get inputs() {
    return this.executor.inputs;
  }
  get outputs() {
    return this.executor.outputs;
  }
  get weights() {
    return this.executor.weightMap;
  }
  get metadata() {
    return this.artifacts.userDefinedMetadata;
  }
  get modelSignature() {
    return this.signature;
  }
  get modelStructuredOutputKeys() {
    return this.structuredOutputKeys;
  }
  constructor(e20, t2 = {}, n2 = zp) {
    this.modelUrl = e20, this.loadOptions = t2, this.version = "n/a", this.io = n2, null == t2 && (this.loadOptions = {}), this.resourceManager = new Tx();
  }
  findIOHandler() {
    let e20 = this.modelUrl;
    if (null != e20.load) this.handler = e20;
    else if (null != this.loadOptions.requestInit) this.handler = this.io.browserHTTPRequest(e20, this.loadOptions);
    else {
      let t2 = this.io.getLoadHandlers(e20, this.loadOptions);
      if (0 === t2.length) t2.push(this.io.browserHTTPRequest(e20, this.loadOptions));
      else if (t2.length > 1) throw Error(`Found more than one (${t2.length}) load handlers for URL '${[e20]}'`);
      this.handler = t2[0];
    }
  }
  load() {
    if (this.findIOHandler(), null == this.handler.load) throw Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
    let e20 = this.handler.load();
    return va.isPromise(e20) ? e20.then((e21) => null == e21.getWeightStream ? this.loadSync(e21) : this.loadStreaming(e21)) : this.loadSync(e20);
  }
  loadSync(e20) {
    let t2 = this.io.decodeWeights(e20.weightData, e20.weightSpecs);
    return this.loadWithWeightMap(e20, t2);
  }
  loadStreaming(e20) {
    return __async(this, null, function* () {
      if (null == e20.getWeightStream) throw Error("Model artifacts missing streamWeights function");
      let t2 = yield bs(e20.getWeightStream(), e20.weightSpecs);
      return this.loadWithWeightMap(e20, t2);
    });
  }
  loadWithWeightMap(e20, t2) {
    this.artifacts = e20;
    let n2 = this.artifacts.modelTopology, r2 = this.artifacts.signature;
    if (null != this.artifacts.userDefinedMetadata) {
      let e21 = this.artifacts.userDefinedMetadata;
      null != e21.signature && (r2 = e21.signature), null != e21.structuredOutputKeys && (this.structuredOutputKeys = e21.structuredOutputKeys);
    }
    if (this.signature = r2, this.version = `${n2.versions.producer}.${n2.versions.minConsumer}`, this.executor = new Ex(qA.Instance.transformGraph(n2, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(t2), this.executor.resourceManager = this.resourceManager, null != e20.modelInitializer && null != e20.modelInitializer.node) {
      let t3 = qA.Instance.transformGraph(e20.modelInitializer);
      this.initializer = new Ex(t3), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializerSignature = e20.initializerSignature;
    }
    return true;
  }
  save(e20, t2) {
    return __async(this, null, function* () {
      if ("string" == typeof e20) {
        let t3 = this.io.getSaveHandlers(e20);
        if (0 === t3.length) throw Error(`Cannot find any save handlers for URL '${e20}'`);
        if (t3.length > 1) throw Error(`Found more than one (${t3.length}) save handlers for URL '${e20}'`);
        e20 = t3[0];
      }
      if (null == e20.save) throw Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      return e20.save(this.artifacts);
    });
  }
  addStructuredOutputNames(e20) {
    if (this.structuredOutputKeys) {
      let t2 = {};
      return (e20 instanceof ni ? [e20] : e20).forEach((e21, n2) => t2[this.structuredOutputKeys[n2]] = e21), t2;
    }
    return e20;
  }
  predict(e20, t2) {
    let n2 = this.execute(e20, this.outputNodes);
    return this.addStructuredOutputNames(n2);
  }
  predictAsync(e20, t2) {
    return __async(this, null, function* () {
      let n2 = yield this.executeAsync(e20, this.outputNodes);
      return this.addStructuredOutputNames(n2);
    });
  }
  normalizeInputs(e20) {
    var t2;
    if (!(e20 instanceof ni || Array.isArray(e20))) {
      let n3 = null === (t2 = this.signature) || void 0 === t2 ? void 0 : t2.inputs;
      if (null != n3) for (let t3 in n3) {
        let r3 = n3[t3];
        null != r3.resourceId && (e20[t3] = this.resourceIdToCapturedInput[r3.resourceId]);
      }
      return e20;
    }
    e20 = Array.isArray(e20) ? e20 : [e20];
    let n2 = Object.keys(this.resourceIdToCapturedInput).length;
    if (e20.length + n2 !== this.inputNodes.length) throw Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - n2} non-resource placeholders, while there are ${e20.length} input tensors provided.`);
    let r2 = 0;
    return this.inputNodes.reduce((t3, n3) => {
      var a2, i2, s2;
      let o2 = null === (s2 = null === (i2 = null === (a2 = this.signature) || void 0 === a2 ? void 0 : a2.inputs) || void 0 === i2 ? void 0 : i2[n3]) || void 0 === s2 ? void 0 : s2.resourceId;
      return t3[n3] = null != o2 ? this.resourceIdToCapturedInput[o2] : e20[r2++], t3;
    }, {});
  }
  normalizeOutputs(e20) {
    return Array.isArray(e20 = e20 || this.outputNodes) ? e20 : [e20];
  }
  executeInitializerGraph() {
    return null == this.initializer ? [] : this.initializer.execute({}, null == this.initializerSignature ? [] : Object.keys(this.initializerSignature.outputs));
  }
  executeInitializerGraphAsync() {
    return __async(this, null, function* () {
      return null == this.initializer ? [] : this.initializer.executeAsync({}, null == this.initializerSignature ? [] : Object.keys(this.initializerSignature.outputs));
    });
  }
  setResourceIdToCapturedInput(e20) {
    if (this.resourceIdToCapturedInput = {}, this.initializerSignature) {
      let t2 = this.initializerSignature.outputs, n2 = Object.keys(t2);
      for (let r2 = 0; n2.length > r2; r2++) this.resourceIdToCapturedInput[t2[n2[r2]].resourceId] = e20[r2];
    }
  }
  execute(e20, t2) {
    null == this.resourceIdToCapturedInput && this.setResourceIdToCapturedInput(this.executeInitializerGraph()), e20 = this.normalizeInputs(e20), t2 = this.normalizeOutputs(t2);
    let n2 = this.executor.execute(e20, t2);
    return n2.length > 1 ? n2 : n2[0];
  }
  executeAsync(e20, t2) {
    return __async(this, null, function* () {
      null == this.resourceIdToCapturedInput && this.setResourceIdToCapturedInput(yield this.executeInitializerGraphAsync()), e20 = this.normalizeInputs(e20), t2 = this.normalizeOutputs(t2);
      let n2 = yield this.executor.executeAsync(e20, t2);
      return n2.length > 1 ? n2 : n2[0];
    });
  }
  getIntermediateTensors() {
    return this.executor.getIntermediateTensors();
  }
  disposeIntermediateTensors() {
    this.executor.disposeIntermediateTensors();
  }
  convertTensorMapToTensorsMap(e20) {
    return Object.keys(e20).reduce((t2, n2) => (t2[n2] = [e20[n2]], t2), {});
  }
  dispose() {
    this.executor.dispose(), this.initializer && (this.initializer.dispose(), this.resourceIdToCapturedInput && ts(this.resourceIdToCapturedInput)), this.resourceManager.dispose();
  }
};
function Px(_0) {
  return __async(this, arguments, function* (e20, t2 = {}, n2 = zp) {
    if (null == e20) throw Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
    null == t2 && (t2 = {}), t2.fromTFHub && "string" == typeof e20 && (e20 = ((e21) => (e21.endsWith("/") || (e21 += "/"), `${e21}${Ox}${Mx}`))(e20));
    let r2 = new Fx(e20, t2, n2);
    return yield r2.load(), r2;
  });
}
function zx(e20) {
  if (null == e20) throw Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");
  let t2;
  if (e20 instanceof Array) {
    let [n3, r2] = e20;
    if (!n3) throw Error("modelJSON must be the first element of the array");
    if (!(r2 && r2 instanceof ArrayBuffer)) throw Error("An ArrayBuffer of weights must be the second element of the array");
    if (!("modelTopology" in n3)) throw Error("Model JSON is missing 'modelTopology'");
    if (!("weightsManifest" in n3)) throw Error("Model JSON is missing 'weightsManifest'");
    let a2 = zp.getWeightSpecs(n3.weightsManifest), i2 = zp.getModelArtifactsForJSONSync(n3, a2, r2);
    t2 = zp.fromMemorySync(i2);
  } else if ("load" in e20) t2 = e20;
  else {
    if (!("modelTopology" in e20 && "weightSpecs" in e20 && "weightData" in e20)) throw Error("Unknown model format");
    t2 = zp.fromMemorySync(e20);
  }
  let n2 = new Fx(t2);
  return n2.load(), n2;
}
var Vx = "4.22.0";
function _x(e20, t2) {
  Array.isArray(e20) || (e20 = [e20]), e20.forEach((e21) => {
    null != e21 && va.assert("complex64" !== e21.dtype, () => t2 + " does not support complex64 tensors in the CPU backend.");
  });
}
var Dx = Ym.whereImpl;
var Wx = class e10 extends D {
  nextDataId() {
    return e10.nextDataId++;
  }
  constructor() {
    super(), this.blockSize = 48, this.firstUse = true, this.data = new _(this, Yi());
  }
  write(e20, t2, n2) {
    this.firstUse && (this.firstUse = false, _e().get("IS_NODE") && Uf.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));
    let r2 = { id: this.nextDataId() };
    return this.data.set(r2, { values: e20, dtype: n2, refCount: 1 }), r2;
  }
  makeTensorInfo(e20, t2, n2) {
    let r2;
    if ("string" === t2 && null != n2 && n2.length > 0 && va.isString(n2[0])) {
      let a2 = n2.map((e21) => va.encodeString(e21));
      r2 = this.write(a2, e20, t2);
    } else r2 = this.write(n2, e20, t2);
    return { dataId: r2, shape: e20, dtype: t2 };
  }
  refCount(e20) {
    return this.data.has(e20) ? this.data.get(e20).refCount : 0;
  }
  incRef(e20) {
    this.data.get(e20).refCount++;
  }
  decRef(e20) {
    this.data.has(e20) && this.data.get(e20).refCount--;
  }
  move(e20, t2, n2, r2, a2) {
    this.data.set(e20, { values: t2, dtype: r2, refCount: a2 });
  }
  numDataIds() {
    return this.data.numDataIds();
  }
  read(e20) {
    return __async(this, null, function* () {
      return this.readSync(e20);
    });
  }
  readSync(e20) {
    let { dtype: t2, complexTensorInfos: n2 } = this.data.get(e20);
    if ("complex64" === t2) {
      let e21 = this.readSync(n2.real.dataId), t3 = this.readSync(n2.imag.dataId);
      return Uf.mergeRealAndImagArrays(e21, t3);
    }
    return va.convertBackendValuesAndArrayBuffer(this.data.get(e20).values, t2);
  }
  bufferSync(e20) {
    let t2 = this.readSync(e20.dataId);
    if ("string" === e20.dtype) try {
      let n2 = t2.map((e21) => va.decodeString(e21));
      return uo(e20.shape, e20.dtype, n2);
    } catch (n2) {
      throw Error("Failed to decode encoded string bytes into utf-8");
    }
    return uo(e20.shape, e20.dtype, t2);
  }
  makeOutput(e20, t2, n2) {
    return Yi().makeTensorFromTensorInfo(this.makeTensorInfo(t2, n2, e20), this);
  }
  disposeData(e20, t2 = false) {
    if (this.data.has(e20)) {
      if (this.data.get(e20).refCount--, !t2 && this.data.get(e20).refCount > 0) return false;
      let { complexTensorInfos: n2 } = this.data.get(e20);
      null != n2 && (this.disposeData(n2.real.dataId, true), this.disposeData(n2.imag.dataId, true)), this.data.delete(e20);
    }
    return true;
  }
  disposeIntermediateTensorInfo(e20) {
    this.disposeData(e20.dataId);
  }
  time(e20) {
    return __async(this, null, function* () {
      let t2 = va.now();
      return e20(), { kernelMs: va.now() - t2 };
    });
  }
  memory() {
    return { unreliable: true, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
  }
  where(e20) {
    _x([e20], "where");
    let t2 = this.readSync(e20.dataId);
    return Dx(e20.shape, t2);
  }
  dispose() {
  }
  floatPrecision() {
    return 32;
  }
  epsilon() {
    return super.epsilon();
  }
};
Wx.nextDataId = 0;
var Lx = {};
function Bx(e20) {
  let t2 = new Float32Array(e20.length);
  for (let n2 = 0; e20.length > n2; ++n2) t2[n2] = Math.abs(e20[n2]);
  return t2;
}
A(Lx, { addImpl() {
  return ry;
}, bincountImpl() {
  return oy;
}, bincountReduceImpl() {
  return ly;
}, bitwiseAndImpl() {
  return uy;
}, castImpl() {
  return Jx;
}, ceilImpl() {
  return my;
}, concatImpl() {
  return yy;
}, equalImpl() {
  return by;
}, expImpl() {
  return wy;
}, expm1Impl() {
  return Cy;
}, floorDivImpl() {
  return Ty;
}, floorImpl() {
  return Sy;
}, gatherNdImpl() {
  return Fy;
}, gatherV2Impl() {
  return Py;
}, greaterEqualImpl() {
  return Dy;
}, greaterImpl() {
  return zy;
}, lessEqualImpl() {
  return Gy;
}, lessImpl() {
  return By;
}, linSpaceImpl() {
  return qy;
}, logImpl() {
  return Zy;
}, maxImpl() {
  return Yy;
}, maximumImpl() {
  return Jy;
}, minimumImpl() {
  return tb;
}, multiplyImpl() {
  return ab;
}, negImpl() {
  return lb;
}, notEqualImpl() {
  return db;
}, prodImpl() {
  return Ab;
}, raggedGatherImpl() {
  return bb;
}, raggedRangeImpl() {
  return vb;
}, raggedTensorToTensorImpl() {
  return $b;
}, rangeImpl() {
  return Rb;
}, rsqrtImpl() {
  return Sb;
}, scatterImpl() {
  return Tb;
}, sigmoidImpl() {
  return Mb;
}, simpleAbsImpl() {
  return Bx;
}, sliceImpl() {
  return Pb;
}, sparseFillEmptyRowsImpl() {
  return _b;
}, sparseReshapeImpl() {
  return Db;
}, sparseSegmentReductionImpl() {
  return Wb;
}, sqrtImpl() {
  return Lb;
}, squaredDifferenceImpl() {
  return jb;
}, staticRegexReplaceImpl() {
  return Xb;
}, stridedSliceImpl() {
  return Kb;
}, stringNGramsImpl() {
  return Jb;
}, stringSplitImpl() {
  return eg;
}, stringToHashBucketFastImpl() {
  return tg;
}, subImpl() {
  return ng;
}, tileImpl() {
  return sg;
}, topKImpl() {
  return ug;
}, transposeImpl() {
  return pb;
}, uniqueImpl() {
  return dg;
} });
var Ux = { kernelName: "Abs", backendName: "cpu", kernelFunc(e20) {
  let { x: t2 } = e20.inputs, n2 = e20.backend;
  _x(t2, "abs");
  let r2 = new Float32Array(va.sizeFromShape(t2.shape));
  return r2 = Bx(n2.data.get(t2.dataId).values), n2.makeOutput(r2, t2.shape, t2.dtype);
} };
function jx(e20) {
  return (t2, n2, r2, a2, i2) => {
    let s2 = Uf.assertAndGetBroadcastShape(t2, n2), o2 = s2.length, l2 = va.computeStrides(s2), u2 = va.sizeFromShape(s2), d2 = va.getTypedArrayFromDType(i2, u2), c2 = t2.length, h2 = n2.length, p2 = va.computeStrides(t2), f2 = va.computeStrides(n2), m2 = Uf.getBroadcastDims(t2, s2), A2 = Uf.getBroadcastDims(n2, s2);
    if (m2.length + A2.length === 0) for (let x2 = 0; d2.length > x2; ++x2) d2[x2] = e20(r2[x2 % r2.length], a2[x2 % a2.length]);
    else for (let x2 = 0; d2.length > x2; ++x2) {
      let t3 = va.indexToLoc(x2, o2, l2), n3 = t3.slice(-c2);
      m2.forEach((e21) => n3[e21] = 0);
      let i3 = va.locToIndex(n3, c2, p2), s3 = t3.slice(-h2);
      A2.forEach((e21) => s3[e21] = 0);
      let u3 = va.locToIndex(s3, h2, f2);
      d2[x2] = e20(r2[i3], a2[u3]);
    }
    return [d2, s2];
  };
}
function Gx(e20) {
  let { inputs: t2, backend: n2 } = e20, { real: r2, imag: a2 } = t2, i2 = n2.data.get(r2.dataId).values, s2 = n2.data.get(a2.dataId).values, o2 = n2.makeTensorInfo(r2.shape, "complex64");
  return n2.data.get(o2.dataId).complexTensorInfos = { real: n2.makeTensorInfo(r2.shape, "float32", i2), imag: n2.makeTensorInfo(a2.shape, "float32", s2) }, o2;
}
var Hx = { kernelName: At, backendName: "cpu", kernelFunc: Gx };
function Xx(e20, t2, n2 = "float32") {
  if ("complex64" === n2) return Gx({ inputs: { real: Xx(e20, t2, "float32"), imag: Xx(e20, t2, "float32") }, backend: e20 });
  let r2 = va.makeZerosTypedArray(va.sizeFromShape(t2), n2);
  return e20.makeTensorInfo(t2, n2, r2);
}
function qx(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2;
  return n2.incRef(r2.dataId), { dataId: r2.dataId, shape: r2.shape, dtype: r2.dtype };
}
var Zx = { kernelName: sn, backendName: "cpu", kernelFunc: qx };
function Kx(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2, a2 = n2.data.get(r2.dataId).complexTensorInfos.real, i2 = n2.data.get(a2.dataId).values;
  return n2.makeTensorInfo(a2.shape, a2.dtype, i2);
}
var Yx = { kernelName: ar, backendName: "cpu", kernelFunc: Kx };
function Jx(e20, t2, n2, r2) {
  if ("int32" === r2) return [t2, "int32", Int32Array.from(e20)];
  if ("bool" === r2) {
    let r3 = va.toTypedArray([0], n2), [a2, i2] = jx((e21, t3) => e21 !== t3 ? 1 : 0)(t2, [], e20, r3, "bool");
    return [i2, "bool", a2];
  }
  throw Error(`Error in Cast: failed to cast ${n2} to ${r2}`);
}
function Qx(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { dtype: i2 } = r2;
  if ("complex64" === i2) {
    if ("complex64" === a2.dtype) return qx({ inputs: { x: a2 }, backend: n2 });
    let e21 = Xx(n2, a2.shape, a2.dtype), t3 = Qx({ inputs: { x: a2 }, backend: n2, attrs: { dtype: "float32" } }), r3 = Gx({ inputs: { real: t3, imag: e21 }, backend: n2 });
    return n2.disposeIntermediateTensorInfo(e21), n2.disposeIntermediateTensorInfo(t3), r3;
  }
  if ("complex64" === a2.dtype) {
    let e21 = Kx({ inputs: { input: a2 }, backend: n2 }), t3 = Qx({ inputs: { x: e21 }, backend: n2, attrs: { dtype: i2 } });
    return n2.disposeIntermediateTensorInfo(e21), t3;
  }
  if (!va.hasEncodingLoss(a2.dtype, i2)) {
    let e21 = qx({ inputs: { x: a2 }, backend: n2 });
    return { dataId: e21.dataId, shape: e21.shape, dtype: i2 };
  }
  let s2 = n2.data.get(a2.dataId).values, [o2, l2, u2] = Jx(s2, a2.shape, a2.dtype, i2);
  return n2.makeTensorInfo(o2, l2, u2);
}
var ey = { kernelName: pt, backendName: "cpu", kernelFunc: Qx };
function ty(e20, t2, n2, r2) {
  return null == n2 ? ({ inputs: n3, backend: a2 }) => {
    let { a: i2, b: s2 } = n3, o2 = a2;
    _x([i2, s2], e20);
    let l2 = o2.data.get(i2.dataId).values, u2 = o2.data.get(s2.dataId).values, d2 = "string" === i2.dtype ? Uf.fromUint8ToStringArray(l2) : l2, c2 = "string" === i2.dtype ? Uf.fromUint8ToStringArray(u2) : u2, h2 = r2 || i2.dtype, [p2, f2] = t2(i2.shape, s2.shape, d2, c2, h2);
    return o2.makeTensorInfo(f2, h2, p2);
  } : ({ inputs: e21, backend: a2 }) => {
    let { a: i2, b: s2 } = e21, o2 = a2;
    if ("complex64" === i2.dtype || "complex64" === s2.dtype) {
      let e22 = Qx({ inputs: { x: i2 }, backend: o2, attrs: { dtype: "complex64" } }), t3 = o2.data.get(e22.dataId), r3 = t3.complexTensorInfos.imag, a3 = o2.data.get(t3.complexTensorInfos.real.dataId).values, l2 = o2.data.get(r3.dataId).values, u2 = Qx({ inputs: { x: s2 }, backend: o2, attrs: { dtype: "complex64" } }), d2 = o2.data.get(u2.dataId), c2 = d2.complexTensorInfos.imag, h2 = o2.data.get(d2.complexTensorInfos.real.dataId).values, p2 = o2.data.get(c2.dataId).values, [f2, m2, A2] = n2(i2.shape, s2.shape, a3, l2, h2, p2), x2 = o2.makeTensorInfo(A2, "float32", f2), y2 = o2.makeTensorInfo(A2, "float32", m2), b2 = Gx({ inputs: { real: x2, imag: y2 }, backend: o2 });
      return o2.disposeIntermediateTensorInfo(e22), o2.disposeIntermediateTensorInfo(u2), o2.disposeIntermediateTensorInfo(x2), o2.disposeIntermediateTensorInfo(y2), b2;
    }
    {
      let e22 = o2.data.get(i2.dataId).values, n3 = o2.data.get(s2.dataId).values, a3 = r2 || i2.dtype, [l2, u2] = t2(i2.shape, s2.shape, e22, n3, a3);
      return o2.makeTensorInfo(u2, a3, l2);
    }
  };
}
function ny(e20) {
  return (t2, n2, r2, a2, i2, s2) => {
    let o2 = Uf.assertAndGetBroadcastShape(t2, n2), l2 = va.sizeFromShape(o2), u2 = o2.length, d2 = va.computeStrides(o2), c2 = va.getTypedArrayFromDType("float32", l2), h2 = va.getTypedArrayFromDType("float32", l2), p2 = Uf.getBroadcastDims(t2, o2), f2 = Uf.getBroadcastDims(n2, o2), m2 = Uf.mergeRealAndImagArrays(r2, a2), A2 = Uf.mergeRealAndImagArrays(i2, s2), x2 = t2.length, y2 = va.computeStrides(t2), b2 = n2.length, g2 = va.computeStrides(n2);
    if (p2.length + f2.length === 0) for (let v2 = 0; c2.length > v2; v2++) {
      let t3 = v2 % m2.length, n3 = v2 % A2.length, r3 = e20(m2[2 * t3], m2[2 * t3 + 1], A2[2 * n3], A2[2 * n3 + 1]);
      c2[v2] = r3.real, h2[v2] = r3.imag;
    }
    else for (let v2 = 0; c2.length > v2; v2++) {
      let t3 = va.indexToLoc(v2, u2, d2), n3 = t3.slice(-x2);
      p2.forEach((e21) => n3[e21] = 0);
      let r3 = va.locToIndex(n3, x2, y2), a3 = t3.slice(-b2);
      f2.forEach((e21) => a3[e21] = 0);
      let i3 = va.locToIndex(a3, b2, g2), s3 = e20(m2[2 * r3], m2[2 * r3 + 1], A2[2 * i3], A2[2 * i3 + 1]);
      c2[v2] = s3.real, h2[v2] = s3.imag;
    }
    return [c2, h2, o2];
  };
}
var ry = jx((e20, t2) => e20 + t2);
var ay = ny((e20, t2, n2, r2) => ({ real: e20 + n2, imag: t2 + r2 }));
var iy = ty("Add", ry, ay);
var sy = { kernelName: "Add", backendName: "cpu", kernelFunc: iy };
function oy(e20, t2, n2, r2, a2) {
  let i2 = va.sizeFromShape(r2), s2 = va.makeZerosTypedArray(a2, n2);
  for (let o2 = 0; e20.length > o2; o2++) {
    let n3 = e20[o2];
    if (0 > n3) throw Error("Input x must be non-negative!");
    n3 >= a2 || (s2[n3] += i2 > 0 ? t2[o2] : 1);
  }
  return s2;
}
function ly(e20, t2, n2, r2 = false) {
  let a2 = e20.shape[0], i2 = e20.shape[1], s2 = uo([a2, n2], t2.dtype);
  for (let o2 = 0; a2 > o2; o2++) for (let a3 = 0; i2 > a3; a3++) {
    let i3 = e20.get(o2, a3);
    if (0 > i3) throw Error("Input x must be non-negative!");
    i3 >= n2 || s2.set(r2 ? 1 : t2.size > 0 ? s2.get(o2, i3) + t2.get(o2, a3) : s2.get(o2, i3) + 1, o2, i3);
  }
  return s2;
}
var uy = jx((e20, t2) => e20 & t2);
var dy = ty(dt, uy);
var cy = { kernelName: dt, backendName: "cpu", kernelFunc: dy };
function hy(e20) {
  return (t2, n2, r2) => {
    let a2 = va.getArrayFromDType(n2, t2.length);
    for (let i2 = 0; t2.length > i2; ++i2) a2[i2] = e20(t2[i2], r2);
    return a2;
  };
}
function py(e20, t2, n2) {
  return fy(e20, hy(t2), n2);
}
function fy(e20, t2, n2) {
  return ({ inputs: r2, attrs: a2, backend: i2 }) => {
    let { x: s2 } = r2;
    _x(s2, e20);
    let o2, l2 = i2, u2 = l2.data.get(s2.dataId).values;
    if ("string" === s2.dtype) {
      if (!Array.isArray(u2)) throw Error("String tensor's value was not an instance of Array");
      o2 = Uf.fromUint8ToStringArray(u2);
    } else o2 = u2;
    let d2 = n2 || s2.dtype, c2 = t2(o2, d2, a2);
    return l2.makeTensorInfo(s2.shape, d2, c2);
  };
}
var my = hy((e20) => Math.ceil(e20));
var Ay = fy(ft, my);
var xy = { kernelName: ft, backendName: "cpu", kernelFunc: Ay };
function yy(e20, t2, n2, r2) {
  let a2 = va.getArrayFromDType(n2, va.sizeFromShape(t2));
  if (r2 && "string" !== n2) {
    let t3 = 0;
    e20.forEach((e21) => {
      let n3 = va.sizeFromShape(e21.shape);
      a2.set(e21.vals, t3), t3 += n3;
    });
  } else {
    let r3 = 0;
    e20.forEach((e21) => {
      let i2 = "string" === n2 ? Uf.fromUint8ToStringArray(e21.vals) : e21.vals, s2 = 0;
      for (let n3 = 0; e21.shape[0] > n3; ++n3) {
        let o2 = n3 * t2[1] + r3;
        for (let t3 = 0; e21.shape[1] > t3; ++t3) a2[o2 + t3] = i2[s2++];
      }
      r3 += e21.shape[1];
    });
  }
  return a2;
}
var by = jx((e20, t2) => e20 === t2 ? 1 : 0);
var gy = ty(Gt, by, null, "bool");
var vy = { kernelName: Gt, backendName: "cpu", kernelFunc: gy };
var wy = hy((e20) => Math.exp(e20));
var ky = fy("Exp", wy, "float32");
var Ny = { kernelName: "Exp", backendName: "cpu", kernelFunc: ky };
var Cy = hy((e20) => Math.expm1(e20));
var $y = fy(qt, Cy);
var Ry = { kernelName: qt, backendName: "cpu", kernelFunc: $y };
var Sy = hy((e20) => Math.floor(e20));
var Iy = fy(Jt, Sy);
var Ey = { kernelName: Jt, backendName: "cpu", kernelFunc: Iy };
var Ty = jx((e20, t2) => Math.floor(e20 / t2));
var My = ty(Qt, Ty, null, "int32");
var Oy = { kernelName: Qt, backendName: "cpu", kernelFunc: My };
function Fy(e20, t2, n2, r2, a2, i2, s2, o2, l2) {
  let u2 = uo([r2, i2], n2);
  for (let d2 = 0; r2 > d2; d2++) {
    let n3 = [], r3 = 0;
    for (let t3 = 0; a2 > t3; t3++) {
      let i3 = e20[d2 * a2 + t3];
      r3 += i3 * s2[t3], n3.push(i3);
    }
    if (0 > r3 || r3 >= l2 / i2) throw Error(`Invalid indices: ${n3} does not index into ${o2}`);
    for (let e21 = 0; i2 > e21; e21++) u2.values[d2 * i2 + e21] = t2.get(...t2.indexToLoc(r3 * i2 + e21));
  }
  return u2;
}
function Py(e20, t2, n2) {
  let r2 = uo(n2, e20.dtype);
  for (let a2 = 0; r2.size > a2; ++a2) {
    let n3 = r2.indexToLoc(a2).slice(), i2 = t2.locToIndex([n3[0], n3[2]]);
    n3[2] = t2.values[i2];
    let s2 = e20.locToIndex(n3);
    s2 >= 0 && e20.values.length > s2 && (r2.values[a2] = e20.values[s2]);
  }
  return r2;
}
var zy = jx((e20, t2) => e20 > t2 ? 1 : 0);
var Vy = ty(rn, zy, null, "bool");
var _y = { kernelName: rn, backendName: "cpu", kernelFunc: Vy };
var Dy = jx((e20, t2) => t2 > e20 ? 0 : 1);
var Wy = ty(an, Dy, null, "bool");
var Ly = { kernelName: an, backendName: "cpu", kernelFunc: Wy };
var By = jx((e20, t2) => t2 > e20 ? 1 : 0);
var Uy = ty(pn, By, null, "bool");
var jy = { kernelName: pn, backendName: "cpu", kernelFunc: Uy };
var Gy = jx((e20, t2) => e20 > t2 ? 0 : 1);
var Hy = ty(fn, Gy, null, "bool");
var Xy = { kernelName: fn, backendName: "cpu", kernelFunc: Hy };
function qy(e20, t2, n2) {
  let r2 = (t2 - e20) / (n2 - 1), a2 = va.makeZerosTypedArray(n2, "float32");
  a2[0] = e20;
  for (let i2 = 1; a2.length > i2; i2++) a2[i2] = a2[i2 - 1] + r2;
  return a2;
}
var Zy = hy((e20) => Math.log(e20));
var Ky = { kernelName: "Log", backendName: "cpu", kernelFunc: fy("Log", Zy) };
function Yy(e20, t2, n2, r2) {
  let a2 = va.getTypedArrayFromDType(r2, va.sizeFromShape(n2));
  for (let i2 = 0; a2.length > i2; ++i2) {
    let n3 = i2 * t2, r3 = e20[n3];
    for (let a3 = 0; t2 > a3; ++a3) {
      let t3 = e20[n3 + a3];
      (Number.isNaN(t3) || t3 > r3) && (r3 = t3);
    }
    a2[i2] = r3;
  }
  return a2;
}
var Jy = jx((e20, t2) => Math.max(e20, t2));
var Qy = ty(Sn, Jy);
var eb = { kernelName: Sn, backendName: "cpu", kernelFunc: Qy };
var tb = jx((e20, t2) => Math.min(e20, t2));
var nb = ty(zn, tb);
var rb = { kernelName: zn, backendName: "cpu", kernelFunc: nb };
var ab = jx((e20, t2) => e20 * t2);
var ib = ny((e20, t2, n2, r2) => ({ real: e20 * n2 - t2 * r2, imag: e20 * r2 + t2 * n2 }));
var sb = ty(Wn, ab, ib);
var ob = { kernelName: Wn, backendName: "cpu", kernelFunc: sb };
function lb(e20, t2, n2) {
  let r2 = va.createScalarValue(-1, n2);
  return ab([], t2, r2, e20, n2);
}
var ub = { kernelName: "Neg", backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2;
  _x(r2, "neg");
  let a2 = n2.data.get(r2.dataId).values, [i2, s2] = lb(a2, r2.shape, r2.dtype);
  return n2.makeTensorInfo(s2, r2.dtype, i2);
} };
var db = jx((e20, t2) => e20 !== t2 ? 1 : 0);
var cb = ty(Bn, db, null, "bool");
var hb = { kernelName: Bn, backendName: "cpu", kernelFunc: cb };
function pb(e20, t2, n2, r2, a2) {
  let i2 = t2.length, s2 = va.sizeFromShape(t2), o2 = va.computeStrides(t2), l2 = va.computeStrides(a2), u2 = va.getTypedArrayFromDType(n2, va.sizeFromShape(a2));
  for (let d2 = 0; s2 > d2; ++d2) {
    let t3 = va.indexToLoc(d2, i2, o2), n3 = Array(t3.length);
    for (let e21 = 0; n3.length > e21; e21++) n3[e21] = t3[r2[e21]];
    u2[va.locToIndex(n3, i2, l2)] = e20[d2];
  }
  return u2;
}
function fb(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { x: a2 } = t2, { perm: i2 } = n2;
  _x(a2, "transpose");
  let s2 = Array(a2.shape.length);
  for (let l2 = 0; s2.length > l2; l2++) s2[l2] = a2.shape[i2[l2]];
  let o2 = pb(r2.data.get(a2.dataId).values, a2.shape, a2.dtype, i2, s2);
  return { dataId: r2.write(o2, s2, a2.dtype), shape: s2, dtype: a2.dtype };
}
var mb = { kernelName: Kr, backendName: "cpu", kernelFunc: fb };
function Ab(e20, t2, n2, r2) {
  let [a2, i2] = Uf.computeOutAndReduceShapes(e20, r2), s2 = pi(t2, "int32"), o2 = va.makeZerosTypedArray(va.sizeFromShape(a2), s2), l2 = va.sizeFromShape(i2);
  for (let u2 = 0; o2.length > u2; ++u2) {
    let e21 = u2 * l2, t3 = 1;
    for (let r3 = 0; l2 > r3; ++r3) t3 *= n2[e21 + r3];
    o2[u2] = t3;
  }
  return { outVals: o2, outShape: a2, outDtype: s2 };
}
var xb = { kernelName: Qn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2;
  _x(a2, "prod");
  let o2 = a2.shape.length, l2 = va.parseAxisParam(i2, a2.shape), u2 = Uf.getAxesPermutation(l2, o2), d2 = l2, c2 = a2, h2 = [];
  null != u2 && (c2 = fb({ inputs: { x: a2 }, backend: n2, attrs: { perm: u2 } }), h2.push(c2), d2 = Uf.getInnerMostAxes(d2.length, o2));
  let p2 = n2.data.get(c2.dataId).values, { outVals: f2, outShape: m2, outDtype: A2 } = Ab(c2.shape, c2.dtype, p2, d2), x2 = m2;
  return s2 && (x2 = Uf.expandShapeToKeepDim(m2, l2)), h2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), n2.makeTensorInfo(x2, A2, f2);
} };
function yb(e20, t2) {
  let n2 = e20.slice(0, t2);
  for (; t2 > n2.length; ) n2.push(1);
  for (let r2 = t2; e20.length > r2; r2++) n2[t2 - 1] *= e20[r2];
  return n2;
}
function bb(e20, t2, n2, r2, a2, i2, s2, o2) {
  if (0 === e20.length) throw Error("paramsNestedSplits must be non empty");
  if (0 === t2[0].length) throw Error("Split tensors must not be scalars");
  if (((e21, t3, n3) => {
    e21.forEach((e22, r3) => {
      if (0 > e22 || e22 >= n3) {
        let a3 = va.indexToLoc(r3, t3.length, va.computeStrides(t3)).join(",");
        throw Error(`indices[${a3}] = ${e22} is not in [0, ${n3})`);
      }
    });
  })(i2, s2, t2[0][0] - 1), 0 === r2.length) throw Error("params.rank must be nonzero");
  let l2 = r2[0], { outSplits: u2, valueSlices: d2, numValues: c2 } = ((e21, t3, n3, r3) => {
    let a3 = [], i3 = 0, s3 = Array(t3.length - 1 + n3.length).fill(null).map(() => [0]);
    ((e22, t4) => {
      for (let n4 = 0; e22.length > n4; ++n4) {
        let r4 = e22[n4], a4 = n4 === e22.length - 1 ? t4 : e22[n4 + 1].length;
        if (0 === r4.length) throw Error("Ragged splits may not be empty");
        if (0 > r4[0]) throw Error("Ragged splits must be non-negative");
        if (r4[r4.length - 1] > a4) throw Error("Ragged splits must not point past values");
        for (let e23 = 1; r4.length > e23; ++e23) if (r4[e23 - 1] > r4[e23]) throw Error("Ragged splits must be sorted in ascending order");
      }
    })(n3, r3);
    let o3 = 1;
    for (let l3 = 0; t3.length - 1 > l3; ++l3) {
      o3 *= t3[l3];
      let e22 = t3[l3 + 1];
      for (let t4 = 1; o3 + 1 > t4; ++t4) s3[l3].push(t4 * e22);
    }
    for (let l3 = 0; e21.length > l3; ++l3) {
      let r4 = e21[l3], o4 = e21[l3] + 1;
      for (let e22 = 0; n3.length > e22; ++e22) {
        let a4 = n3[e22], i4 = e22 + t3.length - 1;
        if (i4 >= 0) {
          let e23 = s3[i4], t4 = e23[e23.length - 1] - a4[r4];
          for (let n4 = r4; o4 > n4; ++n4) s3[i4].push(a4[n4 + 1] + t4);
        }
        r4 = a4[r4], o4 = a4[o4];
      }
      o4 !== r4 && (a3.push([r4, o4]), i3 += o4 - r4);
    }
    return { outSplits: s3, valueSlices: a3, numValues: i3 };
  })(i2, s2, e20, l2), h2 = ((e21) => {
    let t3 = [];
    for (let n3 = 0; e21.length > n3; ++n3) {
      let r3 = va.getArrayFromDType("int32", e21[n3].length);
      t3.push(r3), e21[n3].forEach((e22, t4) => r3[t4] = e22);
    }
    return t3;
  })(u2), p2 = ((e21, t3, n3, r3, a3) => {
    let i3 = t3.slice();
    i3[0] = a3;
    let s3 = va.getArrayFromDType(n3, va.sizeFromShape(i3)), o3 = e21.length;
    return ((e22, t4, n4, r4, a4, i4) => {
      let s4 = yb(t4, 2)[1], o4 = yb(i4, 2)[1], l3 = 0;
      for (let u3 of n4) for (let t5 = u3[0]; u3[1] > t5; ++t5) {
        for (let n5 = 0; r4 > n5; ++n5) a4[l3 * o4 + n5] = e22[t5 * s4 + n5];
        ++l3;
      }
    })(e21, t3, r3, 0 === o3 ? 0 : o3 / t3[0], s3, i3), [s3, i3];
  })(n2, r2, a2, d2, c2);
  return [h2, p2[0], p2[1]];
}
var gb = 2147483647;
function vb(e20, t2, n2, r2, a2, i2, s2) {
  if (t2.length > 1) throw Error("starts must be a scalar or vector");
  if (a2.length > 1) throw Error("limits must be a scalar or vector");
  if (s2.length > 1) throw Error("deltas must be a scalar or vector");
  let o2 = 0 === t2.length, l2 = 0 === a2.length, u2 = 0 === s2.length, d2 = [];
  o2 || d2.push(t2[0]), l2 || d2.push(a2[0]), u2 || d2.push(s2[0]);
  for (let m2 = 1; d2.length > m2; ++m2) if (d2[m2] !== d2[m2 - 1]) throw Error("starts, limits, and deltas must have the same shape");
  let c2 = 0 === d2.length ? 1 : d2[0], h2 = va.getArrayFromDType("int32", c2 + 1);
  h2[0] = 0;
  for (let m2 = 0; c2 > m2; ++m2) {
    let t3, n3 = o2 ? e20[0] : e20[m2], a3 = l2 ? r2[0] : r2[m2], s3 = u2 ? i2[0] : i2[m2];
    if (0 === s3) throw Error("Requires delta != 0");
    if (s3 > 0 && n3 > a3 || 0 > s3 && a3 > n3) t3 = 0;
    else if (t3 = Math.ceil(Math.abs((a3 - n3) / s3)), t3 > gb) throw Error("Requires ((limit - start) / delta) <= " + gb);
    h2[m2 + 1] = h2[m2] + t3;
  }
  let p2 = va.getArrayFromDType(n2, h2[c2]), f2 = 0;
  for (let m2 = 0; c2 > m2; ++m2) {
    let t3 = h2[m2 + 1] - h2[m2], n3 = o2 ? e20[0] : e20[m2], r3 = u2 ? i2[0] : i2[m2];
    for (let e21 = 0; t3 > e21; ++e21) p2[f2++] = n3, n3 += r3;
  }
  return [h2, p2];
}
var wb = Uf.RowPartitionType;
var kb = class e11 {
  constructor(e20, t2, n2, r2, a2, i2, s2, o2, l2, u2) {
    this.shape = e20, this.shapeShape = t2, this.values = n2, this.valuesShape = r2, this.valuesDType = a2, this.defaultValue = i2, this.defaultValueShape = s2, this.rowPartitionValues = o2, this.rowPartitionValuesShapes = l2, this.rowPartitionTypes = Uf.getRowPartitionTypesHelper(u2), this.raggedRank = Uf.getRaggedRank(this.rowPartitionTypes);
  }
  getRowPartitionTypeByDimension(e20) {
    return this.rowPartitionTypes[0] === wb.FIRST_DIM_SIZE ? this.rowPartitionTypes[e20 + 1] : this.rowPartitionTypes[e20];
  }
  getRowPartitionTensor(e20) {
    return this.rowPartitionTypes[0] === wb.FIRST_DIM_SIZE ? this.rowPartitionValues[e20 + 1] : this.rowPartitionValues[e20];
  }
  getMaxWidth(t2) {
    let n2 = this.getRowPartitionTensor(t2 - 1);
    switch (this.getRowPartitionTypeByDimension(t2 - 1)) {
      case wb.VALUE_ROWIDS:
        return e11.getMaxWidthValueRowID(n2);
      case wb.ROW_SPLITS:
        return e11.getMaxWidthRowSplit(n2);
      default:
        throw Error("Cannot handle partition type " + wb[this.getRowPartitionTypeByDimension(t2 - 1)]);
    }
  }
  static getMaxWidthRowSplit(e20) {
    let t2 = e20.length;
    if (0 === t2 || 1 === t2) return 0;
    let n2 = 0;
    for (let r2 = 0; t2 - 1 > r2; ++r2) {
      let t3 = e20[r2 + 1] - e20[r2];
      t3 > n2 && (n2 = t3);
    }
    return n2;
  }
  static getMaxWidthValueRowID(e20) {
    let t2 = e20.length;
    if (0 === t2) return 0;
    let n2 = 0, r2 = e20[0], a2 = 0;
    for (let i2 = 1; t2 > i2; ++i2) {
      let t3 = e20[i2];
      t3 !== r2 && (r2 = t3, a2 = Math.max(i2 - n2, a2), n2 = i2);
    }
    return Math.max(t2 - n2, a2);
  }
  tensorShapeFromTensor(e20, t2, n2 = true) {
    if (0 === t2.length) {
      if (-1 === e20[0]) return [];
      throw Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
    }
    return Cb(e20, n2);
  }
  calculateOutputSize(e20) {
    let t2 = this.valuesShape;
    Uf.validateDefaultValueShape(this.defaultValueShape, t2);
    let n2 = this.tensorShapeFromTensor(this.shape, this.shapeShape), r2 = Uf.combineRaggedTensorToTensorShapes(this.raggedRank, n2, t2);
    0 > r2[0] && (r2[0] = e20);
    for (let a2 = 1; this.raggedRank >= a2; ++a2) 0 > r2[a2] && (r2[a2] = this.getMaxWidth(a2));
    return r2;
  }
  calculateFirstParentOutputIndex(e20, t2, n2) {
    let r2 = Math.min(e20, n2), a2 = [], i2 = 0;
    for (let s2 = 0; r2 > s2; ++s2, i2 += t2) a2.push(i2);
    for (let s2 = r2; e20 > s2; ++s2) a2.push(-1);
    return va.assert(a2.length === e20, () => "Final length of result must be equal to firstDimension."), a2;
  }
  calculateOutputIndexRowSplit(e20, t2, n2, r2) {
    let a2 = e20.length, i2 = [];
    for (let s2 = 0; a2 - 1 > s2; ++s2) {
      let a3 = e20[s2 + 1] - e20[s2], o2 = Math.min(r2, a3), l2 = t2[s2];
      -1 === l2 && (o2 = 0);
      for (let e21 = 0; o2 > e21; ++e21) i2.push(l2), l2 += n2;
      for (let e21 = 0; a3 - o2 > e21; ++e21) i2.push(-1);
    }
    if (a2 > 0 && i2.length !== e20[a2 - 1]) throw Error("Invalid row split size.");
    return i2;
  }
  calculateOutputIndexValueRowID(e20, t2, n2, r2) {
    let a2 = e20.length, i2 = [];
    if (0 === a2) return [];
    let s2 = 0, o2 = e20[0];
    if (o2 >= t2.length) throw Error(`Got currentValueRowId=${o2}, which is not less than ${t2.length}`);
    let l2 = t2[o2];
    i2.push(l2);
    for (let u2 = 1; a2 > u2; ++u2) {
      let a3 = e20[u2];
      if (a3 === o2) l2 >= 0 && (++s2, r2 > s2 ? l2 += n2 : l2 = -1);
      else {
        if (s2 = 0, o2 = a3, a3 >= t2.length) throw Error(`Got nextValueRowId=${a3} which is not less than ${t2.length}`);
        l2 = t2[a3];
      }
      i2.push(l2);
    }
    if (i2.length !== e20.length) throw Error("Invalid row ids.");
    return i2;
  }
  calculateOutputIndex(e20, t2, n2, r2) {
    let a2 = this.getRowPartitionTensor(e20), i2 = this.getRowPartitionTypeByDimension(e20);
    switch (i2) {
      case wb.VALUE_ROWIDS:
        return this.calculateOutputIndexValueRowID(a2, t2, n2, r2);
      case wb.ROW_SPLITS:
        if (a2.length - 1 > t2.length) throw Error(`Row partition size is greater than output size: ${a2.length - 1} > ${t2.length}`);
        return this.calculateOutputIndexRowSplit(a2, t2, n2, r2);
      default:
        throw Error("Unsupported partition type: " + wb[i2]);
    }
  }
  getFirstDimensionSize() {
    let e20 = this.rowPartitionValues[0];
    if (0 === this.rowPartitionTypes.length) throw Error("No row_partition_types given.");
    let t2 = this.rowPartitionTypes[0];
    switch (t2) {
      case wb.FIRST_DIM_SIZE:
        return e20[0];
      case wb.VALUE_ROWIDS:
        throw Error("Cannot handle VALUE_ROWIDS in first dimension.");
      case wb.ROW_SPLITS:
        return this.rowPartitionValuesShapes[0][0] - 1;
      default:
        throw Error("Cannot handle type " + wb[t2]);
    }
  }
  compute() {
    if (0 >= this.rowPartitionValues[0].length) throw Error("Invalid first partition input. Tensor requires at least one element.");
    let e20 = this.getFirstDimensionSize(), t2 = this.calculateOutputSize(e20), n2 = Array(this.raggedRank + 1);
    n2[n2.length - 1] = 1;
    for (let i2 = n2.length - 2; i2 >= 0; --i2) n2[i2] = n2[i2 + 1] * t2[i2 + 1];
    let r2 = Cb(t2, false), a2 = va.getArrayFromDType(this.valuesDType, va.sizeFromShape(r2));
    if (n2[0] * t2[0] > 0) {
      let i2 = this.calculateFirstParentOutputIndex(e20, n2[0], t2[0]);
      for (let e21 = 1; this.raggedRank >= e21; ++e21) i2 = this.calculateOutputIndex(e21 - 1, i2, n2[e21], t2[e21]);
      this.setOutput(this.raggedRank, i2, a2, r2);
    }
    return [r2, a2];
  }
  setOutput(e20, t2, n2, r2) {
    if (0 === n2.length) return;
    let a2 = this.values, i2 = n2, s2 = r2.slice();
    s2 = s2.slice(e20 + 1);
    let o2 = va.sizeFromShape(s2), l2 = t2.length, u2 = this.defaultValue;
    if (u2.length !== o2 && 1 !== u2.length) {
      let e21 = this.defaultValueShape;
      es(() => {
        let t3 = Ho(u2, e21);
        u2 = dl(t3, s2).dataSync();
      });
    }
    let d2 = 0, c2 = 0, h2 = 0;
    for (let p2 = 0; l2 >= p2; ++p2) {
      let e21 = l2 > p2 ? t2[p2] : -1;
      if (e21 !== h2) {
        if (h2 > c2) {
          let e22 = a2.subarray(d2 * o2);
          Nb(i2.subarray(c2 * o2), e22, (h2 - c2) * o2);
        }
        if (l2 > p2 || (e21 = Math.floor(n2.length / o2)), e21 > h2) if (1 === this.defaultValue.length) i2.subarray(h2 * o2, e21 * o2).fill(this.defaultValue[0]), h2 = e21;
        else for (; e21 > h2; ) Nb(i2.slice(h2 * o2), u2, o2), ++h2;
        0 > e21 ? (d2 = p2 + 1, c2 = h2) : (d2 = p2, c2 = h2, h2 = c2 + 1);
      } else ++h2;
    }
  }
};
function Nb(e20, t2, n2) {
  for (let r2 = 0; n2 > r2; r2++) e20[r2] = t2[r2];
}
function Cb(e20, t2) {
  let n2 = [];
  for (let r2 of e20) {
    if (0 > r2) {
      if (!t2) throw Error(`Dimension ${r2} must be >= 0`);
      if (-1 > r2) throw Error(`Dimension ${r2} must be >= -1`);
      r2 = -1;
    }
    n2.push(r2);
  }
  return n2;
}
function $b(e20, t2, n2, r2, a2, i2, s2, o2, l2, u2) {
  return new kb(e20, t2, n2, r2, a2, i2, s2, o2, l2, u2).compute();
}
function Rb(e20, t2, n2, r2) {
  if (e20 === t2 || t2 > e20 && 0 > n2 || e20 > t2 && n2 > 1) return va.makeZerosTypedArray(0, r2);
  let a2 = va.makeZerosTypedArray(Math.abs(Math.ceil((t2 - e20) / n2)), r2);
  e20 > t2 && 1 === n2 && (n2 = -1), a2[0] = e20;
  for (let i2 = 1; a2.length > i2; i2++) a2[i2] = a2[i2 - 1] + n2;
  return a2;
}
var Sb = hy((e20) => 1 / Math.sqrt(e20));
var Ib = fy(mr, Sb);
var Eb = { kernelName: mr, backendName: "cpu", kernelFunc: Ib };
function Tb(e20, t2, n2, r2, a2, i2, s2, o2, l2, u2) {
  let d2 = [r2 / a2, a2], c2 = e20.values, h2 = t2.values;
  if (0 === r2) return uo(n2, t2.dtype);
  let p2 = l2 instanceof Qa ? l2 : uo(d2, t2.dtype);
  "string" == typeof l2 || "number" == typeof l2 ? p2.values.fill(l2) : "boolean" == typeof l2 && p2.values.fill(+l2);
  for (let f2 = 0; i2 > f2; f2++) {
    let e21 = [], i3 = 0;
    for (let t3 = 0; s2 > t3; t3++) {
      let n3 = c2[f2 * s2 + t3];
      e21.push(n3), i3 += n3 * o2[t3];
    }
    if (0 > i3 || i3 >= r2 / a2) throw Error(`Invalid indices: ${e21} does not index into ${n2}`);
    for (let n3 = 0; a2 > n3; n3++) u2 ? p2.values[i3 * a2 + n3] += h2[f2 * a2 + n3] : p2.values[i3 * a2 + n3] = 0 === t2.rank ? h2[0] : h2[f2 * a2 + n3];
  }
  return p2;
}
var Mb = hy((e20) => 1 / (1 + Math.exp(-e20)));
var Ob = py(Cr, (e20) => 1 / (1 + Math.exp(-e20)));
var Fb = { kernelName: Cr, backendName: "cpu", kernelFunc: Ob };
function Pb(e20, t2, n2, r2, a2) {
  let i2 = xf.isSliceContinous(r2, t2, n2), s2 = va.sizeFromShape(n2), o2 = va.computeStrides(r2);
  if (i2) {
    let n3 = xf.computeFlatOffset(t2, o2);
    return "string" === a2 ? e20.slice(n3, n3 + s2) : e20.subarray(n3, n3 + s2);
  }
  let l2 = uo(r2, a2, "string" === a2 ? Uf.fromUint8ToStringArray(e20) : e20), u2 = uo(n2, a2);
  for (let d2 = 0; u2.size > d2; ++d2) {
    let e21 = u2.indexToLoc(d2), n3 = e21.map((e22, n4) => e22 + t2[n4]);
    u2.set(l2.get(...n3), ...e21);
  }
  return "string" === a2 ? Uf.fromStringArrayToUint8(u2.values) : u2.values;
}
function zb(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { begin: i2, size: s2 } = r2;
  _x(a2, "slice");
  let [o2, l2] = xf.parseSliceParams(a2, i2, s2);
  xf.assertParamsValid(a2, o2, l2);
  let u2 = Pb(n2.data.get(a2.dataId).values, o2, l2, a2.shape, a2.dtype);
  return n2.makeTensorInfo(l2, a2.dtype, u2);
}
var Vb = { kernelName: vr, backendName: "cpu", kernelFunc: zb };
function _b(e20, t2, n2, r2, a2, i2, s2) {
  let o2 = t2[0], l2 = i2[0], u2 = Array(l2), d2 = Array(o2), c2 = t2[1];
  if (0 === l2) {
    if (0 !== o2) throw Error(Uf.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o2));
    return [va.getArrayFromDType(n2, 0), [0, c2], va.getArrayFromDType(a2, 0), u2, d2];
  }
  let h2 = true, p2 = 0, f2 = Array(l2).fill(0);
  for (let A2 = 0; o2 > A2; ++A2) {
    let t3 = e20[A2 * c2];
    if (0 > t3) throw Error(Uf.getSparseFillEmptyRowsNegativeIndexErrorMessage(A2, t3));
    if (t3 >= l2) throw Error(Uf.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(A2, t3, l2));
    ++f2[t3], h2 = h2 && t3 >= p2, p2 = t3;
  }
  let m2 = true;
  for (let A2 = 0; l2 > A2; ++A2) {
    let e21 = 0 === f2[A2];
    u2[A2] = e21, m2 = m2 && !e21, f2[A2] = Math.max(f2[A2], 1), A2 > 0 && (f2[A2] += f2[A2 - 1]);
  }
  if (m2 && h2) {
    let t3 = e20, n3 = r2;
    for (let e21 = 0; o2 > e21; ++e21) d2[e21] = e21;
    return [t3, [o2, c2], n3, u2, d2];
  }
  {
    let t3 = f2[l2 - 1], i3 = va.getArrayFromDType(n2, t3 * c2), h3 = va.getArrayFromDType(a2, t3), p3 = Array(l2).fill(0);
    for (let n3 = 0; o2 > n3; ++n3) {
      let t4 = e20[n3 * c2], a3 = (0 === t4 ? 0 : f2[t4 - 1]) + p3[t4];
      p3[t4]++;
      for (let r3 = 0; c2 > r3; ++r3) i3[a3 * c2 + r3] = e20[n3 * c2 + r3];
      h3[a3] = r2[n3], d2[n3] = a3;
    }
    for (let e21 = 0; l2 > e21; ++e21) if (0 === p3[e21]) {
      let t4 = 0 === e21 ? 0 : f2[e21 - 1];
      i3[t4 * c2 + 0] = e21;
      for (let e22 = 1; c2 > e22; ++e22) i3[t4 * c2 + e22] = 0;
      h3[t4] = s2;
    }
    return [i3, [t3, c2], h3, u2, d2];
  }
}
function Db(e20, t2, n2, r2, a2) {
  let i2 = va.sizeFromShape(r2), s2 = t2[0], o2 = a2.length, l2 = [], u2 = 1, d2 = -1;
  for (let m2 = 0; o2 > m2; ++m2) {
    let e21 = a2[m2];
    if (-1 === e21) {
      if (-1 !== d2) throw Error(Uf.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d2, m2));
      d2 = m2, l2.push(1);
    } else {
      if (0 > e21) throw Error(Uf.getSparseReshapeNegativeOutputDimErrorMessage(m2, e21));
      u2 *= e21, l2.push(e21);
    }
  }
  if (-1 !== d2) {
    if (0 >= u2) throw Error(Uf.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());
    let e21 = Math.trunc(i2 / u2);
    if (u2 * e21 !== i2) throw Error(Uf.getSparseReshapeInputOutputMultipleErrorMessage(r2, l2));
    l2[d2] = e21;
  }
  if (va.sizeFromShape(l2) !== i2) throw Error(Uf.getSparseReshapeInputOutputMismatchErrorMessage(r2, l2));
  let c2 = r2.length, h2 = [];
  if (c2 > 0) {
    h2[c2 - 1] = 1;
    for (let e21 = c2 - 2; e21 >= 0; --e21) h2[e21] = h2[e21 + 1] * r2[e21 + 1];
  }
  let p2 = [];
  if (o2 > 0) {
    p2[o2 - 1] = 1;
    for (let e21 = o2 - 2; e21 >= 0; --e21) p2[e21] = p2[e21 + 1] * l2[e21 + 1];
  }
  let f2 = va.getArrayFromDType(n2, s2 * o2);
  for (let m2 = 0; s2 > m2; ++m2) {
    let t3 = 0;
    for (let n3 = 0; c2 > n3; ++n3) t3 += e20[m2 * c2 + n3] * h2[n3];
    for (let e21 = 0; o2 > e21; ++e21) f2[m2 * o2 + e21] = Math.trunc(t3 / p2[e21]), t3 %= p2[e21];
  }
  return [f2, [s2, o2], l2];
}
function Wb(e20, t2, n2, r2, a2, i2 = false, s2 = 0) {
  let o2 = r2.length, l2 = [t2[0], e20.length / t2[0]], u2 = l2[1], d2 = o2 > 0 ? a2[o2 - 1] + 1 : 0;
  if (0 > d2) throw Error(Uf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
  let c2 = t2.slice();
  c2[0] = d2;
  let h2 = c2.reduce((e21, t3) => e21 * t3, 1), p2 = va.getArrayFromDType(n2, h2);
  if (0 === o2) return d2 > 0 && p2.fill(s2), [p2, c2];
  if (0 >= d2) throw Error(Uf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
  let f2 = 0, m2 = 1, A2 = 0, x2 = a2[f2];
  for (; ; ) {
    let t3 = 0;
    if (o2 > m2) {
      if (t3 = a2[m2], x2 === t3) {
        ++m2;
        continue;
      }
      if (x2 >= t3) throw Error(Uf.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());
    }
    if (0 > x2 || x2 >= d2) throw Error(Uf.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x2, d2));
    x2 > A2 && p2.fill(s2, A2 * u2, x2 * u2);
    for (let n3 = f2; m2 > n3; ++n3) {
      let t4 = r2[n3];
      if (0 > t4 || t4 >= l2[0]) throw Error(Uf.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n3, r2[n3], l2[0]));
      for (let n4 = 0; u2 > n4; n4++) p2[x2 * u2 + n4] += e20[t4 * u2 + n4];
    }
    if (i2) for (let e21 = 0; u2 > e21; e21++) p2[x2 * u2 + e21] /= m2 - f2;
    if (f2 = m2, ++m2, A2 = x2 + 1, x2 = t3, m2 > o2) break;
  }
  return d2 > A2 && p2.fill(s2, A2 * u2, d2 * u2), [p2, c2];
}
var Lb = hy((e20) => Math.sqrt(e20));
var Bb = py(Rr, (e20) => Math.sqrt(e20));
var Ub = { kernelName: Rr, backendName: "cpu", kernelFunc: Bb };
var jb = jx((e20, t2) => {
  let n2 = e20 - t2;
  return n2 * n2;
});
var Gb = ty(Vr, jb);
var Hb = { kernelName: Vr, backendName: "cpu", kernelFunc: Gb };
var Xb = hy((e20, t2) => {
  let { pattern: n2, replaceGlobal: r2, rewrite: a2 } = t2;
  return e20.replace(RegExp(n2, r2 ? "g" : ""), a2);
});
var qb = fy(Dr, Xb);
var Zb = { kernelName: Dr, backendName: "cpu", kernelFunc: qb };
function Kb(e20, t2, n2, r2) {
  let a2 = uo(e20, t2.dtype);
  for (let i2 = 0; a2.size > i2; i2++) {
    let e21 = a2.indexToLoc(i2), s2 = Array(e21.length);
    for (let t3 = 0; s2.length > t3; t3++) s2[t3] = e21[t3] * n2[t3] + r2[t3];
    a2.set(t2.get(...s2), ...e21);
  }
  return a2;
}
var Yb = class {
  constructor(e20, t2, n2, r2, a2, i2) {
    this.separator = va.encodeString(e20), this.nGramWidths = t2, this.leftPad = va.encodeString(n2), this.rightPad = va.encodeString(r2), this.padWidth = a2, this.preserveShort = i2;
  }
  getPadWidth(e20) {
    return Math.min(0 > this.padWidth ? e20 - 1 : this.padWidth, e20 - 1);
  }
  getNumNGrams(e20, t2) {
    let n2 = this.getPadWidth(t2);
    return Math.max(0, e20 + 2 * n2 - t2 + 1);
  }
  createNGrams(e20, t2, n2, r2, a2, i2) {
    for (let s2 = 0; a2 > s2; ++s2) {
      let o2 = this.getPadWidth(i2), l2 = Math.max(0, o2 - s2), u2 = Math.max(0, o2 - (a2 - (s2 + 1))), d2 = i2 - (l2 + u2), c2 = t2 + (l2 > 0 ? 0 : s2 - o2), h2 = 0;
      h2 += l2 * this.leftPad.length;
      for (let t3 = 0; d2 > t3; ++t3) h2 += e20[c2 + t3].length;
      h2 += u2 * this.rightPad.length, h2 += (l2 + u2 + d2 - 1) * this.separator.length, n2[r2 + s2] = new Uint8Array(h2);
      let p2 = n2[r2 + s2], f2 = 0, m2 = (e21) => e21.forEach((e22) => p2[f2++] = e22);
      for (let e21 = 0; l2 > e21; ++e21) m2(this.leftPad), m2(this.separator);
      for (let t3 = 0; d2 - 1 > t3; ++t3) m2(e20[c2 + t3]), m2(this.separator);
      if (d2 > 0) {
        m2(e20[c2 + d2 - 1]);
        for (let e21 = 0; u2 > e21; ++e21) m2(this.separator), m2(this.rightPad);
      } else {
        for (let e21 = 0; u2 - 1 > e21; ++e21) m2(this.rightPad), m2(this.separator);
        m2(this.rightPad);
      }
    }
  }
  compute(e20, t2) {
    let n2 = e20.length, r2 = t2.length;
    if (r2 > 0) {
      let e21 = t2[0];
      if (0 !== e21) throw Error("First split value must be 0, got " + e21);
      for (let a3 = 1; r2 > a3; ++a3) {
        let r3 = t2[a3] >= e21;
        if (r3 = r3 && n2 >= t2[a3], !r3) throw Error(`Invalid split value ${t2[a3]}, must be in [${e21}, ${n2}]`);
        e21 = t2[a3];
      }
      if (e21 !== n2) throw Error(`Last split value must be data size. Expected ${n2}, got ${e21}`);
    }
    let a2 = r2 - 1, i2 = va.getArrayFromDType("int32", r2);
    if (0 === n2 || 0 === r2) {
      let e21 = Array(n2);
      for (let t3 = 0; a2 >= t3; ++t3) i2[t3] = 0;
      return [e21, i2];
    }
    i2[0] = 0;
    for (let o2 = 1; a2 >= o2; ++o2) {
      let e21 = t2[o2] - t2[o2 - 1], n3 = 0;
      this.nGramWidths.forEach((t3) => {
        n3 += this.getNumNGrams(e21, t3);
      }), this.preserveShort && e21 > 0 && 0 === n3 && (n3 = 1), i2[o2] = i2[o2 - 1] + n3;
    }
    let s2 = Array(i2[a2]);
    for (let o2 = 0; a2 > o2; ++o2) {
      let n3 = t2[o2], r3 = i2[o2];
      if (this.nGramWidths.forEach((a3) => {
        let i3 = this.getNumNGrams(t2[o2 + 1] - t2[o2], a3);
        this.createNGrams(e20, n3, s2, r3, i3, a3), r3 += i3;
      }), this.preserveShort && r3 === i2[o2]) {
        let a3 = t2[o2 + 1] - t2[o2];
        if (0 === a3) continue;
        this.createNGrams(e20, n3, s2, r3, 1, a3 + 2 * this.padWidth);
      }
    }
    return [s2, i2];
  }
};
function Jb(e20, t2, n2, r2, a2, i2, s2, o2) {
  return new Yb(n2, r2, a2, i2, s2, o2).compute(e20, t2);
}
function Qb(e20, t2, n2, r2) {
  if (!e20.length) return;
  if (0 === t2.length) {
    for (let t3 = 0; e20.length > t3; ++t3) r2.push(e20.subarray(t3, t3 + 1));
    return;
  }
  if (1 === t2.length) {
    let a3 = t2[0], i2 = e20.indexOf(a3);
    for (; -1 !== i2; ) {
      let t3 = e20.subarray(0, i2);
      (!n2 || 0 !== t3.length) && r2.push(t3), i2 = (e20 = e20.subarray(i2 + 1)).indexOf(a3);
    }
    return void ((!n2 || 0 !== e20.length) && r2.push(e20));
  }
  let a2 = 0;
  for (let i2 = 0; e20.length + 1 > i2; i2++) if (i2 === e20.length || -1 !== t2.indexOf(e20[i2])) {
    let t3 = e20.subarray(a2, i2);
    (!n2 || 0 !== t3.length) && r2.push(t3), a2 = i2 + 1;
  }
}
function eg(e20, t2, n2) {
  let r2 = e20.length, a2 = [], i2 = 0, s2 = 0, o2 = Array(r2);
  for (let h2 = 0; r2 > h2; ++h2) {
    let r3 = a2.length;
    Qb(e20[h2], t2, n2, a2);
    let l3 = a2.length - r3;
    o2[h2] = l3, i2 += l3, s2 = Math.max(s2, l3);
  }
  let l2 = va.getArrayFromDType("int32", 2 * i2), u2 = Array(i2), d2 = [r2, s2], c2 = 0;
  for (let h2 = 0; r2 > h2; ++h2) for (let e21 = 0; o2[h2] > e21; ++e21) l2[2 * c2] = h2, l2[2 * c2 + 1] = e21, u2[c2] = a2[c2], ++c2;
  return [l2, u2, d2];
}
function tg(e20, t2) {
  let n2 = va.getArrayFromDType("int32", e20.length);
  for (let r2 = 0; e20.length > r2; ++r2) n2[r2] = va.fingerPrint64(e20[r2]).modulo(t2).getLowBitsUnsigned();
  return n2;
}
var ng = jx((e20, t2) => e20 - t2);
var rg = ny((e20, t2, n2, r2) => ({ real: e20 - n2, imag: t2 - r2 }));
var ag = ty("Sub", ng, rg);
var ig = { kernelName: "Sub", backendName: "cpu", kernelFunc: ag };
function sg(e20, t2) {
  let n2 = Array(e20.rank);
  for (let a2 = 0; n2.length > a2; a2++) n2[a2] = e20.shape[a2] * t2[a2];
  let r2 = uo(n2, e20.dtype);
  for (let a2 = 0; r2.values.length > a2; ++a2) {
    let t3 = r2.indexToLoc(a2), n3 = Array(e20.rank);
    for (let r3 = 0; n3.length > r3; r3++) n3[r3] = t3[r3] % e20.shape[r3];
    let i2 = e20.locToIndex(n3);
    r2.values[a2] = e20.values[i2];
  }
  return r2;
}
var og = (e20, t2) => {
  let n2 = t2.value - e20.value;
  return 0 === n2 ? e20.index - t2.index : n2;
};
function lg(e20, t2, n2 = 0, r2 = e20.length - 1) {
  for (; r2 > n2; ) {
    if (r2 - n2 > 600) {
      let a3 = r2 - n2 + 1, i3 = t2 - n2 + 1, s3 = Math.log(a3), o2 = 0.5 * Math.exp(2 * s3 / 3), l2 = 0.5 * Math.sqrt(s3 * o2 * (a3 - o2) / a3) * Math.sign(i3 - a3 / 2);
      lg(e20, t2, Math.max(n2, Math.floor(t2 - i3 * o2 / a3 + l2)), Math.min(r2, Math.floor(t2 + (a3 - i3) * o2 / a3 + l2)));
    }
    let a2 = e20[t2], i2 = n2, s2 = r2;
    for (va.swap(e20, n2, t2), og(e20[r2], a2) > 0 && va.swap(e20, n2, r2); s2 > i2; ) {
      for (va.swap(e20, i2, s2), i2++, s2--; 0 > og(e20[i2], a2); ) i2 += 1;
      for (; og(e20[s2], a2) > 0; ) s2 -= 1;
    }
    0 === og(e20[n2], a2) ? va.swap(e20, n2, s2) : (s2 += 1, va.swap(e20, s2, r2)), t2 >= s2 && (n2 = s2 + 1), s2 >= t2 && (r2 = s2 - 1);
  }
}
function ug(e20, t2, n2, r2, a2) {
  let i2 = t2[t2.length - 1], [s2, o2] = [e20.length / i2, i2], l2 = va.getTypedArrayFromDType(n2, s2 * r2), u2 = va.getTypedArrayFromDType("int32", s2 * r2);
  for (let c2 = 0; s2 > c2; c2++) {
    let t3 = c2 * o2, n3 = e20.subarray(t3, t3 + o2), i3 = Array(n3.length);
    n3.forEach((e21, t4) => i3[t4] = { value: e21, index: t4 }), i3.length > r2 && (lg(i3, r2), i3 = i3.slice(0, r2)), a2 && i3.sort(og);
    let s3 = c2 * r2, d3 = l2.subarray(s3, s3 + r2), h2 = u2.subarray(s3, s3 + r2);
    for (let e21 = 0; r2 > e21; e21++) d3[e21] = i3[e21].value, h2[e21] = i3[e21].index;
  }
  let d2 = t2.slice();
  return d2[d2.length - 1] = r2, [uo(d2, n2, l2), uo(d2, "int32", u2)];
}
function dg(e20, t2, n2, r2) {
  let a2 = va.parseAxisParam(t2, n2)[0], i2 = [1, n2[0], 1];
  for (let f2 = 0; a2 > f2; f2++) i2[0] *= n2[f2];
  i2[1] = n2[a2];
  for (let f2 = a2 + 1; n2.length > f2; f2++) i2[2] *= n2[f2];
  let s2 = /* @__PURE__ */ new Map(), o2 = new Int32Array(n2[a2]), l2 = new Qa(i2, r2, e20), u2 = [], d2 = 1 === i2[0] && 1 === i2[2];
  for (let f2 = 0; n2[a2] > f2; f2++) {
    let t3;
    if (d2) t3 = "" + e20[f2];
    else {
      let e21 = [];
      for (let t4 = 0; i2[0] > t4; t4++) for (let n4 = 0; i2[2] > n4; n4++) e21.push(l2.get(t4, f2, n4));
      t3 = e21.join(",");
    }
    let n3 = s2.get(t3);
    if (null != n3) o2[f2] = n3;
    else {
      let e21 = s2.size;
      s2.set(t3, e21), o2[f2] = e21, u2.push(f2);
    }
  }
  let c2 = i2.slice();
  c2[1] = s2.size;
  let h2 = new Qa(c2, r2);
  u2.forEach((e21, t3) => {
    for (let n3 = 0; i2[0] > n3; n3++) for (let r3 = 0; i2[2] > r3; r3++) h2.set(l2.get(n3, e21, r3), n3, t3, r3);
  });
  let p2 = n2.slice();
  return p2[a2] = c2[1], { outputValues: h2.values, outputShape: p2, indices: o2 };
}
var cg = "4.22.0";
ds("cpu", () => new Wx(), 1);
var hg = py("Elu", (e20) => 0 > e20 ? Math.exp(e20) - 1 : e20);
var pg = { kernelName: "Elu", backendName: "cpu", kernelFunc: hg };
function fg(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { alpha: i2 } = r2;
  _x([a2], "leakyRelu");
  let s2 = va.sizeFromShape(a2.shape), o2 = n2.data.get(a2.dataId).values, l2 = va.getTypedArrayFromDType("float32", s2);
  for (let u2 = 0; o2.length > u2; u2++) l2[u2] = 0 > o2[u2] ? i2 * o2[u2] : o2[u2];
  return n2.makeTensorInfo(a2.shape, "float32", l2);
}
var mg = { kernelName: hn, backendName: "cpu", kernelFunc: fg };
var Ag = jx((e20, t2) => 0 > e20 ? t2 * e20 : e20);
function xg(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2, alpha: a2 } = t2;
  _x([r2, a2], "prelu");
  let i2 = n2.data.get(r2.dataId).values, s2 = n2.data.get(a2.dataId).values, [o2, l2] = Ag(r2.shape, a2.shape, i2, s2, "float32");
  return n2.makeTensorInfo(l2, "float32", o2);
}
var yg = { kernelName: Jn, backendName: "cpu", kernelFunc: xg };
var bg = py(sr, (e20) => Math.max(0, e20));
var gg = { kernelName: sr, backendName: "cpu", kernelFunc: bg };
var vg = py(hr, (e20) => Math.min(Math.max(0, e20), 6));
var wg = { kernelName: hr, backendName: "cpu", kernelFunc: vg };
function kg(e20, t2, n2, r2, a2) {
  if ("linear" === n2) return qx({ inputs: { x: t2 }, backend: e20 });
  if ("relu" === n2) return bg({ inputs: { x: t2 }, backend: e20 });
  if ("elu" === n2) return hg({ inputs: { x: t2 }, backend: e20 });
  if ("relu6" === n2) return vg({ inputs: { x: t2 }, backend: e20 });
  if ("prelu" === n2) return xg({ inputs: { x: t2, alpha: r2 }, backend: e20 });
  if ("leakyrelu" === n2) return fg({ inputs: { x: t2 }, backend: e20, attrs: { alpha: a2 } });
  if ("sigmoid" === n2) return Ob({ inputs: { x: t2 }, backend: e20 });
  throw Error(`Activation ${n2} has not been implemented for the CPU backend.`);
}
function Ng(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { shape: i2 } = r2, s2 = va.sizeFromShape(a2.shape), o2 = va.inferFromImplicitShape(i2, s2), l2 = va.sizeFromShape(o2);
  va.assert(s2 === l2, () => `The new shape (${o2}) has ${l2} elements and the old shape (${a2.shape}) has ${s2} elements. The new shape and old shape must have the same number of elements.`), n2.incRef(a2.dataId);
  let u2 = n2.data.get(a2.dataId);
  if (null != u2.complexTensorInfos) {
    let e21 = u2.complexTensorInfos.imag;
    u2.complexTensorInfos.real.shape = o2, e21.shape = o2;
  }
  return { dataId: a2.dataId, shape: o2, dtype: a2.dtype };
}
var Cg = { kernelName: or, backendName: "cpu", kernelFunc: Ng };
function $g(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { a: a2, b: i2 } = t2, { transposeA: s2, transposeB: o2 } = r2;
  _x([a2, i2], "matMul");
  let l2 = a2.shape.length, u2 = i2.shape.length, d2 = s2 ? a2.shape[l2 - 2] : a2.shape[l2 - 1], c2 = o2 ? i2.shape[u2 - 1] : i2.shape[u2 - 2], h2 = s2 ? a2.shape[l2 - 1] : a2.shape[l2 - 2], p2 = o2 ? i2.shape[u2 - 2] : i2.shape[u2 - 1], f2 = a2.shape.slice(0, -2), m2 = i2.shape.slice(0, -2), A2 = va.sizeFromShape(f2), x2 = va.sizeFromShape(m2), y2 = Fl.assertAndGetBroadcastShape(a2.shape.slice(0, -2), i2.shape.slice(0, -2)).concat([h2, p2]);
  va.assert(d2 === c2, () => `Error in matMul: inner shapes (${d2}) and (${c2}) of Tensors with shapes ${a2.shape} and ${i2.shape} and transposeA=${s2} and transposeB=${o2} must match.`);
  let b2 = o2 ? [x2, p2, c2] : [x2, c2, p2], g2 = Ng({ inputs: { x: a2 }, backend: n2, attrs: { shape: s2 ? [A2, d2, h2] : [A2, h2, d2] } }), v2 = Ng({ inputs: { x: i2 }, backend: n2, attrs: { shape: b2 } }), w2 = s2 ? g2.shape[1] : g2.shape[2], k2 = s2 ? g2.shape[2] : g2.shape[1], N2 = o2 ? v2.shape[1] : v2.shape[2], C2 = Math.max(A2, x2), $2 = n2.data.get(g2.dataId).values, R2 = n2.data.get(v2.dataId).values, S2 = va.computeStrides(g2.shape), I2 = va.computeStrides(v2.shape), [E2, T2, M2] = s2 ? [S2[0], 1, S2[1]] : [S2[0], S2[1], 1], [O2, F2, P2] = o2 ? [1, I2[1], I2[0]] : [I2[1], 1, I2[0]], z2 = k2 * N2, V2 = uo([C2, k2, N2], g2.dtype), _2 = V2.values, D2 = n2.blockSize;
  for (let W2 = 0; C2 > W2; W2++) {
    let e21 = W2 % A2, t3 = W2 % x2;
    for (let n3 = 0; k2 > n3; n3 += D2) {
      let r3 = Math.min(n3 + D2, k2);
      for (let a3 = 0; N2 > a3; a3 += D2) {
        let i3 = Math.min(a3 + D2, N2);
        for (let s3 = 0; w2 > s3; s3 += D2) {
          let o3 = Math.min(s3 + D2, w2);
          for (let l3 = n3; r3 > l3; l3++) for (let n4 = a3; i3 > n4; n4++) {
            let r4 = 0;
            for (let a4 = s3; o3 > a4; a4++) r4 += $2[e21 * E2 + l3 * T2 + a4 * M2] * R2[a4 * O2 + n4 * F2 + t3 * P2];
            _2[W2 * z2 + (l3 * N2 + n4)] += r4;
          }
        }
      }
    }
  }
  return n2.disposeIntermediateTensorInfo(g2), n2.disposeIntermediateTensorInfo(v2), n2.makeTensorInfo(y2, V2.dtype, V2.values);
}
var Rg = { kernelName: ot, backendName: "cpu", kernelFunc: $g };
var Sg = { kernelName: ia, backendName: "cpu", kernelFunc(e20) {
  let t2, n2, r2, { inputs: a2, backend: i2, attrs: s2 } = e20, { a: o2, b: l2, bias: u2, preluActivationWeights: d2 } = a2, { transposeA: c2, transposeB: h2, activation: p2, leakyreluAlpha: f2 } = s2, m2 = [];
  t2 = $g({ inputs: { a: o2, b: l2 }, attrs: { transposeA: c2, transposeB: h2 }, backend: i2 }), u2 && (n2 = iy({ inputs: { a: t2, b: u2 }, backend: i2 }), m2.push(t2), t2 = n2), p2 && (r2 = kg(i2, t2, p2, d2, f2), m2.push(t2), t2 = r2);
  for (let A2 of m2) i2.disposeIntermediateTensorInfo(A2);
  return t2;
} };
var Ig = py(je, (e20) => Math.acos(e20));
var Eg = { kernelName: je, backendName: "cpu", kernelFunc: Ig };
var Tg = py(Ge, (e20) => Math.acosh(e20));
var Mg = { kernelName: Ge, backendName: "cpu", kernelFunc: Tg };
var Og = { kernelName: Xe, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, r2 = t2;
  _x(t2, "addN");
  let a2 = r2.map((e21) => n2.data.get(e21.dataId).values), i2 = uo(r2[0].shape, r2[0].dtype), s2 = i2.values;
  for (let o2 = 0; r2.length > o2; o2++) {
    let e21 = a2[o2];
    for (let t3 = 0; s2.length > t3; t3++) s2[t3] += e21[t3];
  }
  return n2.makeTensorInfo(i2.shape, i2.dtype, i2.values);
} };
var Fg = { kernelName: "All", backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2;
  _x(a2, "all");
  let o2 = va.parseAxisParam(i2, a2.shape), l2 = o2, u2 = Uf.getAxesPermutation(l2, a2.shape.length), d2 = a2;
  null != u2 && (d2 = fb({ inputs: { x: a2 }, backend: n2, attrs: { perm: u2 } }), l2 = Uf.getInnerMostAxes(l2.length, a2.shape.length)), Uf.assertAxesAreInnerMostDims("all", l2, d2.shape.length);
  let [c2, h2] = Uf.computeOutAndReduceShapes(d2.shape, l2), p2 = va.sizeFromShape(h2), f2 = va.makeZerosTypedArray(va.sizeFromShape(c2), d2.dtype), m2 = n2.data.get(d2.dataId).values;
  for (let x2 = 0; f2.length > x2; ++x2) {
    let e21 = x2 * p2, t3 = m2[e21];
    for (let n3 = 0; p2 > n3; ++n3) t3 = t3 && m2[e21 + n3];
    f2[x2] = t3;
  }
  null != u2 && n2.disposeIntermediateTensorInfo(d2);
  let A2 = n2.makeTensorInfo(c2, d2.dtype, f2);
  if (s2) {
    let e21 = Ng({ inputs: { x: A2 }, backend: n2, attrs: { shape: Uf.expandShapeToKeepDim(c2, o2) } });
    return n2.disposeIntermediateTensorInfo(A2), e21;
  }
  return A2;
} };
var Pg = { kernelName: "Any", backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2;
  _x(a2, "any");
  let o2 = va.parseAxisParam(i2, a2.shape), l2 = o2, u2 = Uf.getAxesPermutation(l2, a2.shape.length), d2 = a2;
  null != u2 && (d2 = fb({ inputs: { x: a2 }, backend: n2, attrs: { perm: u2 } }), l2 = Uf.getInnerMostAxes(l2.length, a2.shape.length)), Uf.assertAxesAreInnerMostDims("any", l2, d2.shape.length);
  let [c2, h2] = Uf.computeOutAndReduceShapes(d2.shape, l2), p2 = va.sizeFromShape(h2), f2 = va.makeZerosTypedArray(va.sizeFromShape(c2), d2.dtype), m2 = n2.data.get(d2.dataId).values;
  for (let x2 = 0; f2.length > x2; ++x2) {
    let e21 = x2 * p2, t3 = m2[e21];
    for (let n3 = 0; p2 > n3; ++n3) t3 = t3 || m2[e21 + n3];
    f2[x2] = t3;
  }
  null != u2 && n2.disposeIntermediateTensorInfo(d2);
  let A2 = n2.makeTensorInfo(c2, d2.dtype, f2);
  if (s2) {
    let e21 = Ng({ inputs: { x: A2 }, backend: n2, attrs: { shape: Uf.expandShapeToKeepDim(c2, o2) } });
    return n2.disposeIntermediateTensorInfo(A2), e21;
  }
  return A2;
} };
var zg = { kernelName: Ke, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2 } = r2;
  _x(a2, "argMax");
  let s2 = va.parseAxisParam(i2, a2.shape), o2 = Uf.getAxesPermutation(s2, a2.shape.length), l2 = a2, u2 = [];
  null != o2 && (l2 = fb({ inputs: { x: a2 }, backend: n2, attrs: { perm: o2 } }), u2.push(l2), s2 = Uf.getInnerMostAxes(s2.length, l2.shape.length)), s2 = [s2[0]], Uf.assertAxesAreInnerMostDims("argMax", s2, l2.shape.length);
  let [d2, c2] = Uf.computeOutAndReduceShapes(l2.shape, s2), h2 = va.sizeFromShape(d2), p2 = va.makeZerosTypedArray(h2, "int32"), f2 = va.sizeFromShape(c2), m2 = n2.data.get(l2.dataId).values;
  for (let A2 = 0; p2.length > A2; ++A2) {
    let e21 = A2 * f2, t3 = m2[e21], n3 = 0;
    for (let r3 = 0; f2 > r3; ++r3) {
      let a3 = m2[e21 + r3];
      a3 > t3 && (t3 = a3, n3 = r3);
    }
    p2[A2] = n3;
  }
  return u2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), n2.makeTensorInfo(d2, "int32", p2);
} };
var Vg = { kernelName: Ye, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2 } = r2;
  _x(a2, "argMin");
  let s2 = va.parseAxisParam(i2, a2.shape), o2 = Uf.getAxesPermutation(s2, a2.shape.length), l2 = a2, u2 = [];
  null != o2 && (l2 = fb({ inputs: { x: a2 }, backend: n2, attrs: { perm: o2 } }), u2.push(l2), s2 = Uf.getInnerMostAxes(s2.length, l2.shape.length)), s2 = [s2[0]], Uf.assertAxesAreInnerMostDims("argMin", s2, l2.shape.length);
  let [d2, c2] = Uf.computeOutAndReduceShapes(l2.shape, s2), h2 = va.sizeFromShape(d2), p2 = va.makeZerosTypedArray(h2, "int32"), f2 = va.sizeFromShape(c2), m2 = n2.data.get(l2.dataId).values;
  for (let A2 = 0; p2.length > A2; ++A2) {
    let e21 = A2 * f2, t3 = m2[e21], n3 = 0;
    for (let r3 = 0; f2 > r3; ++r3) {
      let a3 = m2[e21 + r3];
      t3 > a3 && (t3 = a3, n3 = r3);
    }
    p2[A2] = n3;
  }
  return u2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), n2.makeTensorInfo(d2, "int32", p2);
} };
var _g = py(Je, (e20) => Math.asin(e20));
var Dg = { kernelName: Je, backendName: "cpu", kernelFunc: _g };
var Wg = py(Qe, (e20) => Math.asinh(e20));
var Lg = { kernelName: Qe, backendName: "cpu", kernelFunc: Wg };
var Bg = py(et, (e20) => Math.atan(e20));
var Ug = { kernelName: et, backendName: "cpu", kernelFunc: Bg };
var jg = jx((e20, t2) => Math.atan2(e20, t2));
var Gg = ty(nt, jg);
var Hg = { kernelName: nt, backendName: "cpu", kernelFunc: Gg };
var Xg = py(tt, (e20) => Math.atanh(e20));
var qg = { kernelName: tt, backendName: "cpu", kernelFunc: Xg };
function Zg(e20, t2, n2, r2, a2, i2) {
  let s2 = a2.strideHeight, o2 = a2.strideWidth, l2 = a2.dilationHeight, u2 = a2.dilationWidth, d2 = a2.effectiveFilterHeight, c2 = a2.effectiveFilterWidth, h2 = a2.padInfo.top, p2 = a2.padInfo.left, f2 = "max" === i2 ? -Infinity : Infinity, m2 = uo(a2.outShape, n2), A2 = m2.values, x2 = a2.outShape[1] * a2.outShape[2] * a2.outShape[3], y2 = a2.outShape[2] * a2.outShape[3], b2 = a2.outShape[3];
  for (let g2 = 0; a2.batchSize > g2; ++g2) {
    let t3 = g2 * x2, n3 = g2 * r2[0];
    for (let m3 = 0; a2.inChannels > m3; ++m3) for (let x3 = 0; a2.outHeight > x3; ++x3) {
      let g3 = x3 * s2 - h2, v2 = Math.max(0, g3), w2 = Math.min(a2.inHeight, d2 + g3), k2 = t3 + x3 * y2;
      for (let t4 = 0; a2.outWidth > t4; ++t4) {
        let s3 = t4 * o2 - p2, d3 = Math.max(0, s3), h3 = Math.min(a2.inWidth, c2 + s3), x4 = f2, y3 = 0, g4 = 0;
        for (let t5 = v2; w2 > t5; t5 += l2) {
          let a3 = n3 + t5 * r2[1];
          for (let t6 = d3; h3 > t6; t6 += u2) {
            let n4 = e20[a3 + t6 * r2[2] + m3];
            "max" === i2 && n4 > x4 ? x4 = n4 : "avg" === i2 && (y3 += n4, g4++);
          }
          if (isNaN(x4)) break;
        }
        A2[k2 + t4 * b2 + m3] = "avg" === i2 ? y3 / g4 : x4;
      }
    }
  }
  return m2;
}
function Kg(e20, t2, n2, r2, a2 = false, i2 = false) {
  let s2 = uo(r2.outShape, "int32"), o2 = r2.strideHeight, l2 = r2.strideWidth, u2 = r2.dilationHeight, d2 = r2.dilationWidth, c2 = r2.effectiveFilterHeight, h2 = r2.effectiveFilterWidth, p2 = r2.padInfo.top, f2 = r2.padInfo.left, m2 = uo(t2, n2, e20);
  for (let A2 = 0; r2.batchSize > A2; ++A2) for (let e21 = 0; r2.inChannels > e21; ++e21) for (let t3 = 0; r2.outHeight > t3; ++t3) {
    let n3 = t3 * o2 - p2, x2 = n3;
    for (; 0 > x2; ) x2 += u2;
    let y2 = Math.min(r2.inHeight, c2 + n3);
    for (let o3 = 0; r2.outWidth > o3; ++o3) {
      let c3 = o3 * l2 - f2, p3 = c3;
      for (; 0 > p3; ) p3 += d2;
      let b2 = Math.min(r2.inWidth, h2 + c3), g2 = -Infinity, v2 = -1;
      for (let t4 = x2; y2 > t4; t4 += u2) {
        let s3 = t4 - n3;
        for (let n4 = p3; b2 > n4; n4 += d2) {
          let o4 = n4 - c3, l3 = m2.get(A2, t4, n4, e21);
          l3 > g2 && (g2 = l3, v2 = a2 ? i2 ? ((A2 * r2.inHeight + t4) * r2.inWidth + n4) * r2.inChannels + e21 : (t4 * r2.inWidth + n4) * r2.inChannels + e21 : s3 * h2 + o4);
        }
      }
      s2.set(v2, A2, t3, o3, e21);
    }
  }
  return s2;
}
function Yg(e20, t2, n2, r2, a2, i2) {
  let s2 = a2.strideDepth, o2 = a2.strideHeight, l2 = a2.strideWidth, u2 = a2.dilationDepth, d2 = a2.dilationHeight, c2 = a2.dilationWidth, h2 = a2.effectiveFilterDepth, p2 = a2.effectiveFilterHeight, f2 = a2.effectiveFilterWidth, m2 = a2.padInfo.front, A2 = a2.padInfo.top, x2 = a2.padInfo.left, y2 = "max" === i2 ? -Infinity : Infinity, b2 = uo(a2.outShape, n2), g2 = b2.values, v2 = a2.outShape[1] * a2.outShape[2] * a2.outShape[3] * a2.outShape[4], w2 = a2.outShape[2] * a2.outShape[3] * a2.outShape[4], k2 = a2.outShape[3] * a2.outShape[4], N2 = a2.outShape[4];
  for (let C2 = 0; a2.batchSize > C2; ++C2) {
    let t3 = C2 * v2, n3 = C2 * r2[0];
    for (let b3 = 0; a2.inChannels > b3; ++b3) for (let v3 = 0; a2.outDepth > v3; ++v3) {
      let C3 = v3 * s2 - m2, $2 = C3;
      for (; 0 > $2; ) $2 += u2;
      let R2 = Math.min(a2.inDepth, h2 + C3), S2 = t3 + v3 * w2;
      for (let t4 = 0; a2.outHeight > t4; ++t4) {
        let s3 = t4 * o2 - A2, h3 = s3;
        for (; 0 > h3; ) h3 += d2;
        let m3 = Math.min(a2.inHeight, p2 + s3), v4 = S2 + t4 * k2;
        for (let t5 = 0; a2.outWidth > t5; ++t5) {
          let s4 = t5 * l2 - x2, o3 = s4;
          for (; 0 > o3; ) o3 += c2;
          let p3 = Math.min(a2.inWidth, f2 + s4), A3 = v4 + t5 * N2, w3 = y2, k3 = 0, C4 = 0;
          for (let t6 = $2; R2 > t6; t6 += u2) {
            let a3 = n3 + t6 * r2[1];
            for (let t7 = h3; m3 > t7; t7 += d2) {
              let n4 = a3 + t7 * r2[2];
              for (let t8 = o3; p3 > t8; t8 += c2) {
                let a4 = e20[n4 + t8 * r2[3] + b3];
                if ("max" === i2 && a4 > w3 ? w3 = a4 : "avg" === i2 && (k3 += a4, C4++), isNaN(w3)) break;
              }
              if (isNaN(w3)) break;
            }
            if (isNaN(w3)) break;
          }
          g2[A3 + b3] = "avg" === i2 ? k3 / Math.max(C4, 1) : w3;
        }
      }
    }
  }
  return b2;
}
var Jg = { kernelName: rt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2;
  _x(a2, "avgPool");
  let { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2 } = r2;
  va.assert(Uf.eitherStridesOrDilationsAreOne(s2, 1), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${s2} and dilations '1'`);
  let u2, d2 = Uf.computePool2DInfo(a2.shape, i2, s2, 1, o2, l2);
  if (1 === d2.filterWidth && 1 === d2.filterHeight && va.arraysEqual(d2.inShape, d2.outShape)) u2 = qx({ inputs: { x: a2 }, backend: n2 });
  else {
    let e21 = n2.data.get(a2.dataId).values, t3 = va.computeStrides(a2.shape), r3 = Zg(e21, 0, a2.dtype, t3, d2, "avg");
    u2 = n2.makeTensorInfo(d2.outShape, a2.dtype, r3.values);
  }
  return u2;
} };
var Qg = { kernelName: it, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2, dataFormat: u2 } = r2;
  _x(a2, "avgPool3d");
  let d2 = Uf.computePool3DInfo(a2.shape, i2, s2, 1, o2, l2, u2), c2 = Yg(n2.data.get(a2.dataId).values, 0, a2.dtype, va.computeStrides(a2.shape), d2, "avg");
  return n2.makeTensorInfo(c2.shape, "float32", c2.values);
} };
var ev = { kernelName: st, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, { filterSize: s2, strides: o2, pad: l2, dimRoundingMode: u2 } = r2;
  _x([a2, i2], "avgPool3DGrad");
  let d2 = Uf.computePool3DInfo(i2.shape, s2, o2, 1, l2, u2), c2 = d2.strideDepth, h2 = d2.strideHeight, p2 = d2.strideWidth, f2 = d2.filterDepth, m2 = d2.filterHeight, A2 = d2.filterWidth, x2 = d2.dilationDepth, y2 = d2.dilationHeight, b2 = d2.dilationWidth, g2 = d2.effectiveFilterDepth, v2 = d2.effectiveFilterHeight, w2 = d2.effectiveFilterWidth, k2 = g2 - 1 - d2.padInfo.front, N2 = w2 - 1 - d2.padInfo.left, C2 = v2 - 1 - d2.padInfo.top, $2 = uo(i2.shape, "float32"), R2 = 1 / (f2 * m2 * A2), S2 = n2.bufferSync(a2);
  for (let I2 = 0; d2.batchSize > I2; ++I2) for (let e21 = 0; d2.inChannels > e21; ++e21) for (let t3 = 0; d2.inDepth > t3; ++t3) for (let n3 = 0; d2.inHeight > n3; ++n3) for (let r3 = 0; d2.inWidth > r3; ++r3) {
    let a3 = t3 - k2, i3 = n3 - C2, s3 = r3 - N2, o3 = 0;
    for (let t4 = 0; g2 > t4; t4 += x2) {
      let n4 = (a3 + t4) / c2;
      if (n4 >= 0 && d2.outDepth > n4 && Math.floor(n4) === n4) for (let t5 = 0; v2 > t5; t5 += y2) {
        let r4 = (i3 + t5) / h2;
        if (r4 >= 0 && d2.outHeight > r4 && Math.floor(r4) === r4) for (let t6 = 0; w2 > t6; t6 += b2) {
          let a4 = (s3 + t6) / p2;
          a4 >= 0 && d2.outWidth > a4 && Math.floor(a4) === a4 && (o3 += S2.get(I2, n4, r4, a4, e21));
        }
      }
    }
    $2.set(o3 * R2, I2, t3, n3, r3, e21);
  }
  return n2.makeTensorInfo($2.shape, $2.dtype, $2.values);
} };
var tv = { kernelName: at, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, s2 = i2;
  _x([a2, i2], "avgPoolGrad");
  let { filterSize: o2, strides: l2, pad: u2 } = r2, d2 = Uf.computePool2DInfo(s2.shape, o2, l2, 1, u2), c2 = d2.strideHeight, h2 = d2.strideWidth, p2 = d2.filterHeight, f2 = d2.filterWidth, m2 = d2.dilationHeight, A2 = d2.dilationWidth, x2 = d2.effectiveFilterHeight, y2 = d2.effectiveFilterWidth, b2 = y2 - 1 - d2.padInfo.left, g2 = x2 - 1 - d2.padInfo.top, v2 = uo(s2.shape, "float32"), w2 = 1 / (p2 * f2), k2 = n2.data.get(a2.dataId).values, N2 = uo(a2.shape, "float32", k2);
  for (let C2 = 0; d2.batchSize > C2; ++C2) for (let e21 = 0; d2.inChannels > e21; ++e21) for (let t3 = 0; d2.inHeight > t3; ++t3) for (let n3 = 0; d2.inWidth > n3; ++n3) {
    let r3 = t3 - g2, a3 = n3 - b2, i3 = 0;
    for (let t4 = 0; x2 > t4; t4 += m2) {
      let n4 = (r3 + t4) / c2;
      if (n4 >= 0 && d2.outHeight > n4 && Math.floor(n4) === n4) for (let t5 = 0; y2 > t5; t5 += A2) {
        let r4 = (a3 + t5) / h2;
        r4 >= 0 && d2.outWidth > r4 && Math.floor(r4) === r4 && (i3 += N2.get(C2, n4, r4, e21));
      }
    }
    v2.set(i3 * w2, C2, t3, n3, e21);
  }
  return n2.makeTensorInfo(v2.shape, v2.dtype, v2.values);
} };
var nv = { kernelName: en, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, scale: i2, offset: s2, mean: o2, variance: l2 } = t2;
  va.assert(o2.shape.length === l2.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), va.assert(null == s2 || o2.shape.length === s2.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), va.assert(null == i2 || o2.shape.length === i2.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), _x([a2, o2, l2, i2, s2], "batchNorm");
  let { varianceEpsilon: u2 } = r2;
  null == u2 && (u2 = 1e-3);
  let d2 = n2.data.get(a2.dataId).values, c2 = n2.data.get(o2.dataId).values, h2 = n2.data.get(l2.dataId).values, p2 = i2 ? n2.data.get(i2.dataId).values : new Float32Array([1]), f2 = s2 ? n2.data.get(s2.dataId).values : new Float32Array([0]), m2 = new Float32Array(d2.length), A2 = f2.length, x2 = p2.length, y2 = h2.length, b2 = c2.length, g2 = 0, v2 = 0, w2 = 0, k2 = 0;
  for (let N2 = 0; d2.length > N2; ++N2) m2[N2] = f2[g2++] + (d2[N2] - c2[v2++]) * p2[w2++] / Math.sqrt(h2[k2++] + u2), g2 >= A2 && (g2 = 0), v2 >= b2 && (v2 = 0), w2 >= x2 && (w2 = 0), k2 >= y2 && (k2 = 0);
  return n2.makeTensorInfo(a2.shape, a2.dtype, m2);
} };
var rv = { kernelName: lt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockShape: i2, crops: s2 } = r2;
  _x([a2], "batchToSpaceND");
  let o2 = i2.reduce((e21, t3) => e21 * t3), l2 = Uf.getReshaped(a2.shape, i2, o2), u2 = Uf.getPermuted(l2.length, i2.length), d2 = Uf.getReshapedPermuted(a2.shape, i2, o2), c2 = Uf.getSliceBeginCoords(s2, i2.length), h2 = Uf.getSliceSize(d2, s2, i2.length), p2 = Ng({ inputs: { x: a2 }, backend: n2, attrs: { shape: l2 } }), f2 = fb({ inputs: { x: p2 }, backend: n2, attrs: { perm: u2 } }), m2 = Ng({ inputs: { x: f2 }, backend: n2, attrs: { shape: d2 } }), A2 = zb({ inputs: { x: m2 }, backend: n2, attrs: { begin: c2, size: h2 } });
  return n2.disposeIntermediateTensorInfo(p2), n2.disposeIntermediateTensorInfo(f2), n2.disposeIntermediateTensorInfo(m2), A2;
} };
var av = { kernelName: ut, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, weights: i2 } = t2, { size: s2 } = r2, o2 = oy(n2.data.get(a2.dataId).values, n2.data.get(i2.dataId).values, i2.dtype, i2.shape, s2);
  return n2.makeTensorInfo([s2], i2.dtype, o2);
} };
var iv = { kernelName: ht, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { s0: r2, s1: a2 } = t2, i2 = n2.data.get(r2.dataId).values, s2 = n2.data.get(a2.dataId).values, o2 = Uf.assertAndGetBroadcastShape(Array.from(i2), Array.from(s2));
  return n2.makeTensorInfo([o2.length], "int32", Int32Array.from(o2));
} };
var sv = py(mt, (e20, t2) => e20 > t2.clipValueMax ? t2.clipValueMax : t2.clipValueMin > e20 ? t2.clipValueMin : e20);
var ov = { kernelName: mt, backendName: "cpu", kernelFunc: sv };
var lv = { kernelName: xt, backendName: "cpu", kernelFunc(e20) {
  let { x: t2 } = e20.inputs, n2 = e20.backend, r2 = new Float32Array(va.sizeFromShape(t2.shape)), a2 = n2.data.get(t2.dataId), i2 = a2.complexTensorInfos.imag, s2 = n2.data.get(a2.complexTensorInfos.real.dataId).values, o2 = n2.data.get(i2.dataId).values;
  for (let l2 = 0; s2.length > l2; l2++) r2[l2] = Math.hypot(s2[l2], o2[l2]);
  return n2.makeOutput(r2, t2.shape, "float32");
} };
function uv(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2, a2 = n2.data.get(r2.dataId).complexTensorInfos.imag, i2 = n2.data.get(a2.dataId).values;
  return n2.makeTensorInfo(a2.shape, a2.dtype, i2);
}
var dv = { kernelName: ln, backendName: "cpu", kernelFunc: uv };
function cv(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { axis: a2 } = r2, i2 = va.parseAxisParam(a2, t2[0].shape)[0], s2 = t2.map((e21) => e21.shape);
  Uf.assertParamsConsistent(s2, i2);
  let o2 = Uf.computeOutShape(t2.map((e21) => e21.shape), i2);
  if (0 === va.sizeFromShape(o2)) return n2.makeTensorInfo(o2, t2[0].dtype, []);
  let l2 = t2.filter((e21) => va.sizeFromShape(e21.shape) > 0);
  if (1 === l2.length) return qx({ inputs: { x: l2[0] }, backend: n2 });
  if ("complex64" === l2[0].dtype) {
    let e21 = l2.map((e22) => Kx({ inputs: { input: e22 }, backend: n2 })), t3 = l2.map((e22) => uv({ inputs: { input: e22 }, backend: n2 })), r3 = cv({ inputs: e21, backend: n2, attrs: { axis: i2 } }), a3 = cv({ inputs: t3, backend: n2, attrs: { axis: i2 } }), s3 = Gx({ inputs: { real: r3, imag: a3 }, backend: n2 });
    return e21.forEach((e22) => n2.disposeIntermediateTensorInfo(e22)), t3.forEach((e22) => n2.disposeIntermediateTensorInfo(e22)), n2.disposeIntermediateTensorInfo(r3), n2.disposeIntermediateTensorInfo(a3), s3;
  }
  let u2 = l2.map((e21) => {
    let t3 = [-1, va.sizeFromShape(e21.shape.slice(i2))];
    return Ng({ inputs: { x: e21 }, backend: n2, attrs: { shape: t3 } });
  }), d2 = u2.map((e21) => ({ vals: n2.data.get(e21.dataId).values, shape: e21.shape }));
  o2 = Uf.computeOutShape(u2.map((e21) => e21.shape), 1);
  let c2 = yy(d2, o2, t2[0].dtype, 1 === u2[0].shape[0]), h2 = Uf.computeOutShape(l2.map((e21) => e21.shape), i2), p2 = n2.makeTensorInfo(h2, t2[0].dtype, c2);
  return u2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), p2;
}
var hv = { kernelName: yt, backendName: "cpu", kernelFunc: cv };
function pv(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dataFormat: l2, dilations: u2, dimRoundingMode: d2 } = r2;
  _x([a2, i2], "conv2d");
  let c2 = Uf.convertConv2DDataFormat(l2), h2 = Uf.computeConv2DInfo(a2.shape, i2.shape, s2, u2, o2, d2, false, c2), p2 = h2.filterHeight, f2 = h2.filterWidth, m2 = h2.dilationHeight, A2 = h2.dilationWidth, x2 = h2.padInfo.left, y2 = h2.padInfo.top, b2 = "channelsLast" === h2.dataFormat, g2 = new Qa(h2.outShape, a2.dtype), v2 = va.computeStrides(a2.shape), w2 = va.computeStrides(i2.shape), k2 = v2[0], N2 = b2 ? v2[1] : v2[2], C2 = b2 ? v2[2] : 1, $2 = b2 ? 1 : v2[1], R2 = g2.strides[0], S2 = b2 ? g2.strides[1] : g2.strides[2], I2 = b2 ? g2.strides[2] : 1, E2 = b2 ? 1 : g2.strides[1], T2 = n2.data.get(a2.dataId).values, M2 = n2.data.get(i2.dataId).values, O2 = g2.values;
  for (let F2 = 0; h2.batchSize > F2; ++F2) {
    let e21 = F2 * k2, t3 = F2 * R2;
    for (let n3 = 0; h2.outHeight > n3; ++n3) {
      let r3 = t3 + n3 * S2, a3 = n3 * h2.strideHeight - y2;
      for (let t4 = 0; p2 > t4; ++t4) {
        let n4 = a3 + t4 * m2;
        if (0 > n4 || n4 >= h2.inHeight) continue;
        let i3 = t4 * w2[0], s3 = e21 + n4 * N2;
        for (let e22 = 0; h2.outWidth > e22; ++e22) {
          let t5 = r3 + e22 * I2, n5 = e22 * h2.strideWidth - x2;
          for (let e23 = 0; f2 > e23; ++e23) {
            let r4 = n5 + e23 * A2;
            if (0 > r4 || r4 >= h2.inWidth) continue;
            let a4 = s3 + r4 * C2, o3 = i3 + e23 * w2[1];
            for (let e24 = 0; h2.inChannels > e24; ++e24) {
              let n6 = T2[a4 + e24 * $2];
              for (let e25 = 0; h2.outChannels > e25; ++e25) O2[t5 + e25 * E2] += n6 * M2[o3 + e25];
              o3 += h2.outChannels;
            }
          }
        }
      }
    }
  }
  return n2.makeTensorInfo(g2.shape, g2.dtype, O2);
}
var fv = { kernelName: bt, backendName: "cpu", kernelFunc: pv };
var mv = { kernelName: gt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, pad: o2, dataFormat: l2, dimRoundingMode: u2, filterShape: d2 } = r2;
  _x([a2, i2], "conv2dBackpropFilter");
  let c2 = Uf.convertConv2DDataFormat(l2), h2 = Uf.computeConv2DInfo(a2.shape, d2, s2, 1, o2, u2, false, c2), { strideHeight: p2, strideWidth: f2, filterHeight: m2, filterWidth: A2 } = h2, x2 = "channelsLast" === h2.dataFormat, y2 = new Qa(h2.filterShape, "float32"), b2 = h2.padInfo.left, g2 = h2.padInfo.top, v2 = n2.data.get(a2.dataId).values, w2 = n2.data.get(i2.dataId).values, k2 = new Qa(a2.shape, a2.dtype, v2), N2 = new Qa(i2.shape, i2.dtype, w2);
  for (let C2 = 0; m2 > C2; ++C2) {
    let e21 = Math.max(0, Math.ceil((g2 - C2) / p2)), t3 = Math.min(h2.outHeight, (h2.inHeight + g2 - C2) / p2);
    for (let n3 = 0; A2 > n3; ++n3) {
      let r3 = Math.max(0, Math.ceil((b2 - n3) / f2)), a3 = Math.min(h2.outWidth, (h2.inWidth + b2 - n3) / f2);
      for (let i3 = 0; h2.inChannels > i3; ++i3) for (let s3 = 0; h2.outChannels > s3; ++s3) {
        let o3 = 0;
        for (let l3 = 0; h2.batchSize > l3; ++l3) for (let u3 = e21; t3 > u3; ++u3) {
          let e22 = C2 + u3 * p2 - g2;
          for (let t4 = r3; a3 > t4; ++t4) {
            let r4 = n3 + t4 * f2 - b2;
            o3 += x2 ? k2.get(l3, e22, r4, i3) * N2.get(l3, u3, t4, s3) : k2.get(l3, i3, e22, r4) * N2.get(l3, s3, u3, t4);
          }
        }
        y2.set(o3, C2, n3, i3, s3);
      }
    }
  }
  return n2.makeTensorInfo(y2.shape, y2.dtype, y2.values);
} };
var Av = { kernelName: vt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = t2, { inputShape: s2, strides: o2, pad: l2, dataFormat: u2, dimRoundingMode: d2 } = r2;
  _x([a2, i2], "conv2dBackpropInput");
  let c2 = va.computeStrides(i2.shape), h2 = va.computeStrides(a2.shape), p2 = Uf.convertConv2DDataFormat(u2), f2 = Uf.computeConv2DInfo(s2, i2.shape, o2, 1, l2, d2, false, p2), m2 = new Qa(f2.inShape, "float32"), A2 = m2.values, x2 = n2.data.get(a2.dataId).values, y2 = n2.data.get(i2.dataId).values, [b2, g2, v2] = c2, { batchSize: w2, filterHeight: k2, filterWidth: N2, inChannels: C2, inHeight: $2, inWidth: R2, outChannels: S2, outHeight: I2, outWidth: E2, strideHeight: T2, strideWidth: M2 } = f2;
  p2 = f2.dataFormat;
  let O2 = k2 - 1 - f2.padInfo.top, F2 = N2 - 1 - f2.padInfo.left, P2 = "channelsLast" === p2, z2 = m2.strides[0], V2 = P2 ? m2.strides[1] : m2.strides[2], _2 = P2 ? m2.strides[2] : 1, D2 = P2 ? 1 : m2.strides[1], W2 = h2[0], L2 = P2 ? h2[1] : h2[2], B2 = P2 ? h2[2] : 1, U2 = P2 ? 1 : h2[1];
  for (let j2 = 0; w2 > j2; ++j2) for (let e21 = 0; C2 > e21; ++e21) for (let t3 = 0; $2 > t3; ++t3) {
    let n3 = t3 - O2, r3 = Math.max(0, Math.ceil(n3 / T2)), a3 = Math.min(I2, (k2 + n3) / T2);
    for (let i3 = 0; R2 > i3; ++i3) {
      let s3 = i3 - F2, o3 = Math.max(0, Math.ceil(s3 / M2)), l3 = Math.min(E2, (N2 + s3) / M2), u3 = 0;
      for (let t4 = r3; a3 > t4; ++t4) {
        let r4 = t4 * T2 - n3;
        for (let n4 = o3; l3 > n4; ++n4) {
          let a4 = W2 * j2 + L2 * t4 + B2 * n4, i4 = b2 * (k2 - 1 - r4) + g2 * (N2 - 1 - (n4 * M2 - s3)) + v2 * e21;
          for (let e22 = 0; S2 > e22; ++e22) u3 += x2[a4 + U2 * e22] * y2[i4 + e22];
        }
      }
      A2[z2 * j2 + V2 * t3 + _2 * i3 + D2 * e21] = u3;
    }
  }
  return n2.makeTensorInfo(m2.shape, m2.dtype, m2.values);
} };
var xv = { kernelName: wt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dilations: l2 } = r2;
  _x([a2, i2], "conv3d");
  let u2 = Uf.computeConv3DInfo(a2.shape, i2.shape, s2, l2, o2), { filterDepth: d2, filterHeight: c2, filterWidth: h2, dilationDepth: p2, dilationHeight: f2, dilationWidth: m2, padInfo: A2 } = u2, x2 = A2.front, y2 = A2.left, b2 = A2.top, g2 = new Qa(u2.outShape, a2.dtype), v2 = n2.data.get(a2.dataId).values, w2 = n2.data.get(i2.dataId).values, k2 = g2.values, N2 = va.computeStrides(a2.shape), C2 = va.computeStrides(i2.shape);
  for (let $2 = 0; u2.batchSize > $2; ++$2) {
    let e21 = $2 * N2[0], t3 = $2 * g2.strides[0];
    for (let n3 = 0; u2.outDepth > n3; ++n3) {
      let r3 = t3 + n3 * g2.strides[1], a3 = n3 * u2.strideDepth - x2;
      for (let t4 = 0; d2 > t4; ++t4) {
        let n4 = a3 + t4 * p2;
        if (0 > n4 || n4 >= u2.inDepth) continue;
        let i3 = t4 * C2[0], s3 = e21 + n4 * N2[1];
        for (let e22 = 0; u2.outHeight > e22; ++e22) {
          let t5 = r3 + e22 * g2.strides[2], n5 = e22 * u2.strideHeight - b2;
          for (let e23 = 0; c2 > e23; ++e23) {
            let r4 = n5 + e23 * f2;
            if (0 > r4 || r4 >= u2.inHeight) continue;
            let a4 = i3 + e23 * C2[1], o3 = s3 + r4 * N2[2];
            for (let e24 = 0; u2.outWidth > e24; ++e24) {
              let n6 = t5 + e24 * u2.outChannels, r5 = e24 * u2.strideWidth - y2;
              for (let e25 = 0; h2 > e25; ++e25) {
                let t6 = r5 + e25 * m2;
                if (0 > t6 || t6 >= u2.inWidth) continue;
                let i4 = o3 + t6 * u2.inChannels, s4 = a4 + e25 * C2[2];
                for (let e26 = 0; u2.inChannels > e26; ++e26) {
                  let t7 = v2[i4 + e26];
                  for (let e27 = 0; u2.outChannels > e27; ++e27) k2[n6 + e27] += t7 * w2[s4 + e27];
                  s4 += u2.outChannels;
                }
              }
            }
          }
        }
      }
    }
  }
  return n2.makeTensorInfo(g2.shape, g2.dtype, g2.values);
} };
var yv = { kernelName: kt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, pad: o2, filterShape: l2 } = r2;
  _x([a2, i2], "conv3dBackpropFilterV2");
  let u2 = va.computeStrides(a2.shape), d2 = va.computeStrides(i2.shape), c2 = Uf.computeConv3DInfo(a2.shape, l2, s2, 1, o2), h2 = c2.strideDepth, p2 = c2.strideHeight, f2 = c2.strideWidth, m2 = c2.filterDepth, A2 = c2.filterHeight, x2 = c2.filterWidth, y2 = new Qa(c2.filterShape, "float32"), b2 = y2.values, [g2, v2, w2, k2] = y2.strides, N2 = n2.data.get(i2.dataId).values, [C2, $2, R2, S2] = d2, I2 = n2.data.get(a2.dataId).values, [E2, T2, M2, O2] = u2, F2 = c2.padInfo.front, P2 = c2.padInfo.left, z2 = c2.padInfo.top;
  for (let V2 = 0; m2 > V2; ++V2) {
    let e21 = Math.max(0, Math.ceil((F2 - V2) / h2)), t3 = Math.min(c2.outDepth, (c2.inDepth + F2 - V2) / h2), n3 = V2 * g2;
    for (let r3 = 0; A2 > r3; ++r3) {
      let a3 = Math.max(0, Math.ceil((z2 - r3) / p2)), i3 = Math.min(c2.outHeight, (c2.inHeight + z2 - r3) / p2), s3 = r3 * v2 + n3;
      for (let n4 = 0; x2 > n4; ++n4) {
        let o3 = Math.max(0, Math.ceil((P2 - n4) / f2)), l3 = Math.min(c2.outWidth, (c2.inWidth + P2 - n4) / f2), u3 = n4 * w2 + s3;
        for (let s4 = 0; c2.inChannels > s4; ++s4) {
          let d3 = s4 * k2 + u3;
          for (let u4 = 0; c2.outChannels > u4; ++u4) {
            let m3 = 0;
            for (let d4 = 0; c2.batchSize > d4; ++d4) {
              let c3 = d4 * E2, A3 = d4 * C2;
              for (let d5 = e21; t3 > d5; ++d5) {
                let e22 = (V2 + d5 * h2 - F2) * T2 + c3, t4 = d5 * $2 + A3;
                for (let d6 = a3; i3 > d6; ++d6) {
                  let a4 = (r3 + d6 * p2 - z2) * M2 + e22, i4 = d6 * R2 + t4;
                  for (let e23 = o3; l3 > e23; ++e23) m3 += I2[(n4 + e23 * f2 - P2) * O2 + a4 + s4] * N2[e23 * S2 + i4 + u4];
                }
              }
            }
            b2[d3 + u4] = m3;
          }
        }
      }
    }
  }
  return n2.makeTensorInfo(y2.shape, y2.dtype, y2.values);
} };
var bv = { kernelName: Nt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = t2, { pad: s2, strides: o2, inputShape: l2 } = r2;
  _x([a2], "conv3dBackpropInputV2");
  let u2 = va.computeStrides(a2.shape), d2 = va.computeStrides(i2.shape), c2 = Uf.computeConv3DInfo(l2, i2.shape, o2, 1, s2), h2 = new Qa(c2.inShape, "float32"), p2 = h2.values, [f2, m2, A2, x2] = h2.strides, y2 = n2.data.get(a2.dataId).values, [b2, g2, v2, w2] = u2, k2 = n2.data.get(i2.dataId).values, [N2, C2, $2, R2] = d2, { batchSize: S2, filterDepth: I2, filterHeight: E2, filterWidth: T2, inChannels: M2, inDepth: O2, inHeight: F2, inWidth: P2, outChannels: z2, outDepth: V2, outHeight: _2, outWidth: D2, strideDepth: W2, strideHeight: L2, strideWidth: B2 } = c2, U2 = I2 - 1 - c2.padInfo.front, j2 = E2 - 1 - c2.padInfo.top, G2 = T2 - 1 - c2.padInfo.left;
  for (let H2 = 0; S2 > H2; ++H2) for (let e21 = 0; M2 > e21; ++e21) for (let t3 = 0; O2 > t3; ++t3) {
    let n3 = t3 - U2, r3 = Math.max(0, Math.ceil(n3 / W2)), a3 = Math.min(V2, (I2 + n3) / W2);
    for (let i3 = 0; F2 > i3; ++i3) {
      let s3 = i3 - j2, o3 = Math.max(0, Math.ceil(s3 / L2)), l3 = Math.min(_2, (E2 + s3) / L2);
      for (let u3 = 0; P2 > u3; ++u3) {
        let d3 = u3 - G2, c3 = Math.max(0, Math.ceil(d3 / B2)), h3 = Math.min(D2, (T2 + d3) / B2), S3 = 0;
        for (let t4 = r3; a3 > t4; ++t4) {
          let r4 = t4 * W2 - n3;
          for (let n4 = o3; l3 > n4; ++n4) {
            let a4 = n4 * L2 - s3;
            for (let i4 = c3; h3 > i4; ++i4) {
              let s4 = b2 * H2 + g2 * t4 + v2 * n4 + w2 * i4, o4 = N2 * (I2 - 1 - r4) + C2 * (E2 - 1 - a4) + $2 * (T2 - 1 - (i4 * B2 - d3)) + R2 * e21;
              for (let e22 = 0; z2 > e22; ++e22) S3 += y2[s4 + e22] * k2[o4 + e22];
            }
          }
        }
        p2[f2 * H2 + m2 * t3 + A2 * i3 + x2 * u3 + e21] = S3;
      }
    }
  }
  return n2.makeTensorInfo(h2.shape, h2.dtype, h2.values);
} };
var gv = py("Cos", (e20) => Math.cos(e20));
var vv = { kernelName: "Cos", backendName: "cpu", kernelFunc: gv };
var wv = py($t, (e20) => Math.cosh(e20));
var kv = { kernelName: $t, backendName: "cpu", kernelFunc: wv };
var Nv = { kernelName: It, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { image: a2, boxes: i2, boxInd: s2 } = t2, { cropSize: o2, method: l2, extrapolationValue: u2 } = r2, [d2, c2, h2, p2] = a2.shape, f2 = i2.shape[0], [m2, A2] = o2, x2 = uo([f2, m2, A2, p2], "float32"), y2 = n2.data.get(i2.dataId).values, b2 = n2.data.get(s2.dataId).values, g2 = n2.data.get(a2.dataId).values, v2 = va.computeStrides(a2.shape), w2 = va.computeStrides(x2.shape);
  for (let k2 = 0; f2 > k2; k2++) {
    let e21 = 4 * k2, t3 = y2[e21], n3 = y2[e21 + 1], r3 = y2[e21 + 2], a3 = y2[e21 + 3], i3 = b2[k2];
    if (i3 >= d2) continue;
    let s3 = m2 > 1 ? (r3 - t3) * (c2 - 1) / (m2 - 1) : 0, o3 = A2 > 1 ? (a3 - n3) * (h2 - 1) / (A2 - 1) : 0;
    for (let d3 = 0; m2 > d3; d3++) {
      let e22 = m2 > 1 ? t3 * (c2 - 1) + d3 * s3 : 0.5 * (t3 + r3) * (c2 - 1);
      if (0 > e22 || e22 > c2 - 1) for (let t4 = 0; A2 > t4; t4++) for (let e23 = 0; p2 > e23; e23++) x2.values[e23 + t4 * w2[2] + d3 * w2[1] + k2 * w2[0]] = u2;
      else if ("bilinear" === l2) {
        let t4 = Math.floor(e22), r4 = Math.ceil(e22), s4 = e22 - t4;
        for (let e23 = 0; A2 > e23; e23++) {
          let l3 = A2 > 1 ? n3 * (h2 - 1) + e23 * o3 : 0.5 * (n3 + a3) * (h2 - 1);
          if (0 > l3 || l3 > h2 - 1) {
            for (let t5 = 0; p2 > t5; t5++) x2.values[t5 + e23 * w2[2] + d3 * w2[1] + k2 * w2[0]] = u2;
            continue;
          }
          let c3 = Math.floor(l3), f3 = Math.ceil(l3), m3 = l3 - c3;
          for (let n4 = 0; p2 > n4; n4++) {
            let a4 = n4 + c3 * v2[2] + t4 * v2[1] + i3 * v2[0], o4 = g2[a4];
            a4 = n4 + f3 * v2[2] + t4 * v2[1] + i3 * v2[0];
            let l4 = g2[a4];
            a4 = n4 + c3 * v2[2] + r4 * v2[1] + i3 * v2[0];
            let u3 = g2[a4];
            a4 = n4 + f3 * v2[2] + r4 * v2[1] + i3 * v2[0];
            let h3 = g2[a4], p3 = o4 + (l4 - o4) * m3;
            a4 = n4 + e23 * w2[2] + d3 * w2[1] + k2 * w2[0], x2.values[a4] = p3 + (u3 + (h3 - u3) * m3 - p3) * s4;
          }
        }
      } else for (let t4 = 0; A2 > t4; ++t4) {
        let r4 = A2 > 1 ? n3 * (h2 - 1) + t4 * o3 : 0.5 * (n3 + a3) * (h2 - 1);
        if (0 > r4 || r4 > h2 - 1) {
          for (let e23 = 0; p2 > e23; e23++) x2.values[e23 + t4 * w2[2] + d3 * w2[1] + k2 * w2[0]] = u2;
          continue;
        }
        let s4 = Math.round(r4), l3 = Math.round(e22);
        for (let e23 = 0; p2 > e23; e23++) x2.values[e23 + t4 * w2[2] + d3 * w2[1] + k2 * w2[0]] = g2[e23 + s4 * v2[2] + l3 * v2[1] + i3 * v2[0]];
      }
    }
  }
  return n2.makeTensorInfo(x2.shape, x2.dtype, x2.values);
} };
var Cv = { kernelName: Rt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, exclusive: s2, reverse: o2 } = r2;
  _x(a2, "cumprod");
  let l2 = Uf.getAxesPermutation([i2], a2.shape.length), u2 = a2;
  null != l2 && (u2 = fb({ inputs: { x: a2 }, backend: n2, attrs: { perm: l2 } }));
  let d2 = Uf.getInnerMostAxes(1, a2.shape.length)[0];
  if (d2 !== u2.shape.length - 1) throw Error(`backend.cumprod in CPU expects an inner-most axis=${u2.shape.length - 1} but got axis=${d2}`);
  let c2 = pi(u2.dtype, "int32"), h2 = va.makeOnesTypedArray(va.sizeFromShape(u2.shape), c2), p2 = n2.data.get(u2.dataId).values, f2 = u2.shape[u2.shape.length - 1], m2 = o2 ? (e21, t3) => e21 + f2 - t3 - 1 : (e21, t3) => e21 + t3;
  for (let x2 = 0; p2.length > x2; x2 += f2) for (let e21 = 0; f2 > e21; e21++) {
    let t3 = m2(x2, e21);
    if (0 === e21) h2[t3] = s2 ? 1 : p2[t3];
    else {
      let n3 = m2(x2, e21 - 1);
      h2[t3] = s2 ? p2[n3] * h2[n3] : p2[t3] * h2[n3];
    }
  }
  let A2 = n2.makeTensorInfo(u2.shape, c2, h2);
  if (null != l2) {
    let e21 = fb({ inputs: { x: A2 }, backend: n2, attrs: { perm: Uf.getUndoAxesPermutation(l2) } });
    return n2.disposeIntermediateTensorInfo(A2), n2.disposeIntermediateTensorInfo(u2), e21;
  }
  return A2;
} };
var $v = { kernelName: St, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, exclusive: s2, reverse: o2 } = r2;
  _x(a2, "cumsum");
  let l2 = Uf.getAxesPermutation([i2], a2.shape.length), u2 = a2;
  null != l2 && (u2 = fb({ inputs: { x: a2 }, backend: n2, attrs: { perm: l2 } }));
  let d2 = Uf.getInnerMostAxes(1, a2.shape.length)[0];
  if (d2 !== u2.shape.length - 1) throw Error(`backend.cumsum in CPU expects an inner-most axis=${u2.shape.length - 1} but got axis=${d2}`);
  let c2 = pi(u2.dtype, "int32"), h2 = va.makeZerosTypedArray(va.sizeFromShape(u2.shape), c2), p2 = n2.data.get(u2.dataId).values, f2 = u2.shape[u2.shape.length - 1], m2 = o2 ? (e21, t3) => e21 + f2 - t3 - 1 : (e21, t3) => e21 + t3;
  for (let x2 = 0; p2.length > x2; x2 += f2) for (let e21 = 0; f2 > e21; e21++) {
    let t3 = m2(x2, e21);
    if (0 === e21) h2[t3] = s2 ? 0 : p2[t3];
    else {
      let n3 = m2(x2, e21 - 1);
      h2[t3] = s2 ? p2[n3] + h2[n3] : p2[t3] + h2[n3];
    }
  }
  let A2 = n2.makeTensorInfo(u2.shape, c2, h2);
  if (null != l2) {
    let e21 = fb({ inputs: { x: A2 }, backend: n2, attrs: { perm: Uf.getUndoAxesPermutation(l2) } });
    return n2.disposeIntermediateTensorInfo(A2), n2.disposeIntermediateTensorInfo(u2), e21;
  }
  return A2;
} };
var Rv = { kernelName: Et, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, weights: i2 } = t2, { size: s2, binaryOutput: o2 } = r2;
  if (1 === a2.shape.length) {
    let e21 = oy(n2.data.get(a2.dataId).values, n2.data.get(i2.dataId).values, i2.dtype, i2.shape, s2);
    return n2.makeTensorInfo([s2], i2.dtype, e21);
  }
  if (2 === a2.shape.length) {
    let e21 = ly(n2.bufferSync(a2), n2.bufferSync(i2), s2, o2);
    return n2.makeTensorInfo(e21.shape, i2.dtype, e21.values);
  }
  throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${a2.shape.length}.`);
} };
var Sv = { kernelName: Tt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockSize: i2, dataFormat: s2 } = r2;
  va.assert("NHWC" === s2, () => "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + s2);
  let o2 = a2.shape[0], l2 = a2.shape[1], u2 = a2.shape[2], d2 = a2.shape[3], c2 = l2 * i2, h2 = u2 * i2, p2 = d2 / (i2 * i2), f2 = n2.data.get(a2.dataId).values, m2 = new Float32Array(o2 * c2 * h2 * p2), A2 = 0;
  for (let x2 = 0; o2 > x2; ++x2) for (let e21 = 0; c2 > e21; ++e21) {
    let t3 = Math.floor(e21 / i2), n3 = e21 % i2;
    for (let e22 = 0; h2 > e22; ++e22) {
      let r3 = Math.floor(e22 / i2), a3 = (n3 * i2 + e22 % i2) * p2;
      for (let e23 = 0; p2 > e23; ++e23) m2[A2++] = f2[e23 + a3 + d2 * (r3 + u2 * (t3 + l2 * x2))];
    }
  }
  return n2.makeTensorInfo([o2, c2, h2, p2], a2.dtype, m2);
} };
function Iv(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dilations: l2, dimRoundingMode: u2 } = r2;
  _x([a2, i2], "depthwiseConv2DNative");
  let d2 = va.computeStrides(a2.shape), c2 = va.computeStrides(i2.shape), h2 = l2;
  null == h2 && (h2 = [1, 1]), va.assert(Uf.eitherStridesOrDilationsAreOne(s2, h2), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s2} and dilations '${h2}'`);
  let p2 = Uf.computeConv2DInfo(a2.shape, i2.shape, s2, h2, o2, u2, true), { filterHeight: f2, filterWidth: m2, dilationHeight: A2, dilationWidth: x2, padInfo: y2 } = p2, b2 = y2.left, g2 = y2.top, v2 = p2.outChannels / p2.inChannels, w2 = new Qa(p2.outShape, a2.dtype), k2 = n2.data.get(a2.dataId).values, N2 = n2.data.get(i2.dataId).values, C2 = w2.values;
  for (let $2 = 0; p2.batchSize > $2; ++$2) {
    let e21 = $2 * d2[0], t3 = $2 * w2.strides[0];
    for (let n3 = 0; p2.outHeight > n3; ++n3) {
      let r3 = t3 + n3 * w2.strides[1], a3 = n3 * p2.strideHeight - g2;
      for (let t4 = 0; f2 > t4; ++t4) {
        let n4 = a3 + t4 * A2;
        if (0 > n4 || n4 >= p2.inHeight) continue;
        let i3 = t4 * c2[0], s3 = e21 + n4 * d2[1];
        for (let e22 = 0; p2.outWidth > e22; ++e22) {
          let t5 = r3 + e22 * w2.strides[2], n5 = e22 * p2.strideWidth - b2;
          for (let e23 = 0; m2 > e23; ++e23) {
            let r4 = n5 + e23 * x2;
            if (0 > r4 || r4 >= p2.inWidth) continue;
            let a4 = s3 + r4 * p2.inChannels, o3 = t5, l3 = i3 + e23 * c2[1];
            for (let e24 = 0; p2.inChannels > e24; ++e24) {
              let t6 = k2[a4 + e24];
              for (let e25 = 0; v2 > e25; ++e25) C2[o3 + e25] += t6 * N2[l3 + e25];
              o3 += v2, l3 += v2;
            }
          }
        }
      }
    }
  }
  return n2.makeTensorInfo(w2.shape, w2.dtype, w2.values);
}
var Ev = { kernelName: Mt, backendName: "cpu", kernelFunc: Iv };
var Tv = { kernelName: Ot, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, dilations: o2, pad: l2, dimRoundingMode: u2, filterShape: d2 } = r2;
  _x([a2, i2], "depthwiseConv2dNativeBackpropFilter");
  let c2 = Uf.computeConv2DInfo(a2.shape, d2, s2, o2, l2, u2, true), { strideHeight: h2, strideWidth: p2, filterHeight: f2, filterWidth: m2 } = c2, A2 = new Qa(c2.filterShape, "float32"), x2 = c2.padInfo.left, y2 = c2.padInfo.top, b2 = c2.outChannels / c2.inChannels, g2 = n2.data.get(a2.dataId).values, v2 = new Qa(a2.shape, a2.dtype, g2), w2 = n2.data.get(i2.dataId).values, k2 = new Qa(i2.shape, i2.dtype, w2);
  for (let N2 = 0; f2 > N2; ++N2) {
    let e21 = Math.max(0, Math.ceil((y2 - N2) / h2)), t3 = Math.min(c2.outHeight, (c2.inHeight + y2 - N2) / h2);
    for (let n3 = 0; m2 > n3; ++n3) {
      let r3 = Math.max(0, Math.ceil((x2 - n3) / p2)), a3 = Math.min(c2.outWidth, (c2.inWidth + x2 - n3) / p2);
      for (let i3 = 0; c2.outChannels > i3; ++i3) {
        let s3 = Math.trunc(i3 / b2), o3 = i3 % b2, l3 = 0;
        for (let u3 = 0; c2.batchSize > u3; ++u3) for (let o4 = e21; t3 > o4; ++o4) {
          let e22 = N2 + o4 * h2 - y2;
          for (let t4 = r3; a3 > t4; ++t4) l3 += v2.get(u3, e22, n3 + t4 * p2 - x2, s3) * k2.get(u3, o4, t4, i3);
        }
        A2.set(l3, N2, n3, s3, o3);
      }
    }
  }
  return n2.makeTensorInfo(A2.shape, A2.dtype, A2.values);
} };
var Mv = { kernelName: Ft, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = t2, { strides: s2, dilations: o2, pad: l2, dimRoundingMode: u2, inputShape: d2 } = r2;
  _x([a2, i2], "depthwiseConv2DNativeBackpropInput");
  let c2 = va.computeStrides(a2.shape), h2 = va.computeStrides(i2.shape), p2 = Uf.computeConv2DInfo(d2, i2.shape, s2, o2, l2, u2, true), f2 = new Qa(p2.inShape, "float32"), m2 = f2.values, [A2, x2, y2] = f2.strides, b2 = n2.data.get(a2.dataId).values, [g2, v2, w2] = c2, k2 = n2.data.get(i2.dataId).values, [N2, C2, $2] = h2, { batchSize: R2, filterHeight: S2, filterWidth: I2, inChannels: E2, inHeight: T2, inWidth: M2, outChannels: O2, outHeight: F2, outWidth: P2, strideHeight: z2, strideWidth: V2 } = p2, _2 = S2 - 1 - p2.padInfo.top, D2 = I2 - 1 - p2.padInfo.left, W2 = O2 / E2;
  for (let L2 = 0; R2 > L2; ++L2) for (let e21 = 0; E2 > e21; ++e21) for (let t3 = 0; T2 > t3; ++t3) {
    let n3 = t3 - _2, r3 = Math.max(0, Math.ceil(n3 / z2)), a3 = Math.min(F2, (S2 + n3) / z2);
    for (let i3 = 0; M2 > i3; ++i3) {
      let s3 = i3 - D2, o3 = Math.max(0, Math.ceil(s3 / V2)), l3 = Math.min(P2, (I2 + s3) / V2), u3 = 0;
      for (let t4 = r3; a3 > t4; ++t4) {
        let r4 = t4 * z2 - n3;
        for (let n4 = o3; l3 > n4; ++n4) {
          let a4 = g2 * L2 + v2 * t4 + w2 * n4, i4 = N2 * (S2 - 1 - r4) + C2 * (I2 - 1 - (n4 * V2 - s3)) + $2 * e21;
          for (let t5 = 0; W2 > t5; ++t5) u3 += b2[a4 + (e21 * W2 + t5)] * k2[i4 + t5];
        }
      }
      m2[A2 * L2 + x2 * t3 + y2 * i3 + e21] = u3;
    }
  }
  return n2.makeTensorInfo(f2.shape, f2.dtype, f2.values);
} };
var Ov = { kernelName: Pt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2, a2 = va.sizeFromShape(r2.shape), i2 = n2.data.get(r2.dataId).values, s2 = uo([a2, a2], r2.dtype), o2 = s2.values;
  for (let u2 = 0; i2.length > u2; u2++) o2[u2 * a2 + u2] = i2[u2];
  let l2 = [...r2.shape, ...r2.shape];
  return n2.makeTensorInfo(l2, s2.dtype, s2.values);
} };
var Fv = { kernelName: zt, backendName: "cpu", kernelFunc({ inputs: e20, backend: t2, attrs: n2 }) {
  let { x: r2, filter: a2 } = e20, { strides: i2, pad: s2, dilations: o2 } = n2, l2 = t2, u2 = l2.data.get(r2.dataId).values, d2 = r2.shape.length, c2 = l2.data.get(a2.dataId).values, h2 = a2.shape.length, { batchSize: p2, inHeight: f2, inWidth: m2, inChannels: A2, outHeight: x2, outWidth: y2, padInfo: b2, strideHeight: g2, strideWidth: v2, filterHeight: w2, filterWidth: k2, dilationHeight: N2, dilationWidth: C2, outShape: $2 } = Uf.computeDilation2DInfo(r2.shape, a2.shape, i2, s2, "NHWC", o2), R2 = va.sizeFromShape($2), S2 = $2.length, I2 = va.getArrayFromDType(r2.dtype, R2);
  for (let E2 = 0; p2 > E2; ++E2) for (let e21 = 0; x2 > e21; ++e21) {
    let t3 = e21 * g2 - b2.top;
    for (let n3 = 0; y2 > n3; ++n3) {
      let i3 = n3 * v2 - b2.left;
      for (let s3 = 0; A2 > s3; ++s3) {
        let o3 = Number.MIN_SAFE_INTEGER;
        for (let e22 = 0; w2 > e22; ++e22) {
          let n4 = t3 + e22 * N2;
          if (n4 >= 0 && f2 > n4) for (let t4 = 0; k2 > t4; ++t4) {
            let l3 = i3 + t4 * C2;
            if (l3 >= 0 && m2 > l3) {
              let i4 = va.locToIndex([E2, n4, l3, s3], d2, va.computeStrides(r2.shape)), p3 = va.locToIndex([e22, t4, s3], h2, va.computeStrides(a2.shape)), f3 = u2[i4] + c2[p3];
              f3 > o3 && (o3 = f3);
            }
          }
        }
        I2[va.locToIndex([E2, e21, n3, s3], S2, va.computeStrides($2))] = o3;
      }
    }
  }
  return { dataId: l2.write(va.toTypedArray(I2, r2.dtype), $2, r2.dtype), shape: $2, dtype: r2.dtype };
} };
var Pv = { kernelName: _t, backendName: "cpu", kernelFunc({ inputs: e20, backend: t2, attrs: n2 }) {
  let { x: r2, filter: a2, dy: i2 } = e20, { strides: s2, pad: o2, dilations: l2 } = n2, u2 = t2, d2 = va.toNestedArray(r2.shape, u2.data.get(r2.dataId).values), c2 = va.toNestedArray(a2.shape, u2.data.get(a2.dataId).values), { batchSize: h2, inHeight: p2, inWidth: f2, inChannels: m2, outHeight: A2, outWidth: x2, padInfo: y2, strideHeight: b2, strideWidth: g2, filterHeight: v2, filterWidth: w2, dilationHeight: k2, dilationWidth: N2, outShape: C2 } = Uf.computeDilation2DInfo(r2.shape, a2.shape, s2, o2, "NHWC", l2);
  va.assert(i2.rank === C2.length, () => `Error in ${_t}, dy must have the same rank as output ${C2.length}, but got ${i2.rank}`);
  let $2 = va.toNestedArray(C2, u2.data.get(i2.dataId).values), R2 = va.makeZerosNestedTypedArray(a2.shape, a2.dtype);
  for (let S2 = 0; h2 > S2; ++S2) for (let e21 = 0; A2 > e21; ++e21) {
    let t3 = e21 * b2 - y2.top;
    for (let n3 = 0; x2 > n3; ++n3) {
      let r3 = n3 * g2 - y2.left;
      for (let a3 = 0; m2 > a3; ++a3) {
        let i3 = Number.MIN_SAFE_INTEGER, s3 = 0, o3 = 0;
        for (let e22 = 0; v2 > e22; ++e22) {
          let n4 = t3 + e22 * k2;
          if (n4 >= 0 && p2 > n4) for (let t4 = 0; w2 > t4; ++t4) {
            let l3 = r3 + t4 * N2;
            if (l3 >= 0 && f2 > l3) {
              let r4 = d2[S2][n4][l3][a3] + c2[e22][t4][a3];
              r4 > i3 && (i3 = r4, s3 = e22, o3 = t4);
            }
          }
        }
        R2[s3][o3][a3] += $2[S2][e21][n3][a3];
      }
    }
  }
  return { dataId: u2.write(va.toTypedArray(R2, r2.dtype), a2.shape, a2.dtype), shape: a2.shape, dtype: a2.dtype };
} };
var zv = { kernelName: Vt, backendName: "cpu", kernelFunc({ inputs: e20, backend: t2, attrs: n2 }) {
  let { x: r2, filter: a2, dy: i2 } = e20, { strides: s2, pad: o2, dilations: l2 } = n2, u2 = t2, d2 = va.toNestedArray(r2.shape, u2.data.get(r2.dataId).values), c2 = va.toNestedArray(a2.shape, u2.data.get(a2.dataId).values), { batchSize: h2, inHeight: p2, inWidth: f2, inChannels: m2, outHeight: A2, outWidth: x2, padInfo: y2, strideHeight: b2, strideWidth: g2, filterHeight: v2, filterWidth: w2, dilationHeight: k2, dilationWidth: N2, outShape: C2 } = Uf.computeDilation2DInfo(r2.shape, a2.shape, s2, o2, "NHWC", l2);
  va.assert(i2.rank === C2.length, () => `Error in ${Vt}, dy must have the same rank as output ${C2.length}, but got ${i2.rank}`);
  let $2 = va.toNestedArray(C2, u2.data.get(i2.dataId).values), R2 = va.makeZerosNestedTypedArray(r2.shape, r2.dtype);
  for (let S2 = 0; h2 > S2; ++S2) for (let e21 = 0; A2 > e21; ++e21) {
    let t3 = e21 * b2 - y2.top;
    for (let n3 = 0; x2 > n3; ++n3) {
      let r3 = n3 * g2 - y2.left;
      for (let a3 = 0; m2 > a3; ++a3) {
        let i3 = Number.MIN_SAFE_INTEGER, s3 = 0 > t3 ? 0 : t3, o3 = 0 > r3 ? 0 : r3;
        for (let e22 = 0; v2 > e22; ++e22) {
          let n4 = t3 + e22 * k2;
          if (n4 >= 0 && p2 > n4) for (let t4 = 0; w2 > t4; ++t4) {
            let l3 = r3 + t4 * N2;
            if (l3 >= 0 && f2 > l3) {
              let r4 = d2[S2][n4][l3][a3] + c2[e22][t4][a3];
              r4 > i3 && (i3 = r4, s3 = n4, o3 = l3);
            }
          }
        }
        R2[S2][s3][o3][a3] += $2[S2][e21][n3][a3];
      }
    }
  }
  return { dataId: u2.write(va.toTypedArray(R2, r2.dtype), r2.shape, r2.dtype), shape: r2.shape, dtype: r2.dtype };
} };
var Vv = { kernelName: Dt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { image: a2 } = t2, { canvas: i2, options: s2 } = r2, { contextOptions: o2, imageOptions: l2 } = s2 || {}, u2 = (null == l2 ? void 0 : l2.alpha) || 1, d2 = (null == o2 ? void 0 : o2.contextType) || "2d";
  if ("2d" !== d2) throw Error(`Context type ${o2.contextType} is not supported by the CPU backend.`);
  let c2 = i2.getContext(d2, (null == o2 ? void 0 : o2.contextAttributes) || {});
  if (null == c2) throw Error(`Could not get the context with ${d2} type.`);
  let [h2, p2] = a2.shape.slice(0, 2), f2 = 2 === a2.shape.length ? 1 : a2.shape[2], m2 = n2.data.get(a2.dataId).values, A2 = "float32" === a2.dtype ? 255 : 1, x2 = new Uint8ClampedArray(p2 * h2 * 4);
  for (let b2 = 0; h2 * p2 > b2; ++b2) {
    let e21 = [0, 0, 0, 255 * u2];
    for (let n3 = 0; f2 > n3; n3++) {
      let t4 = m2[b2 * f2 + n3];
      if ("float32" === a2.dtype) {
        if (0 > t4 || t4 > 1) throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t4}.`);
      } else if ("int32" === a2.dtype && (0 > t4 || t4 > 255)) throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t4}.`);
      1 === f2 ? (e21[0] = t4 * A2, e21[1] = t4 * A2, e21[2] = t4 * A2) : e21[n3] = t4 * A2;
    }
    let t3 = 4 * b2;
    x2[t3 + 0] = Math.round(e21[0]), x2[t3 + 1] = Math.round(e21[1]), x2[t3 + 2] = Math.round(e21[2]), x2[t3 + 3] = Math.round(e21[3]);
  }
  i2.width = p2, i2.height = h2;
  let y2 = new ImageData(x2, p2, h2);
  return c2.putImageData(y2, 0, 0), a2;
} };
function _v(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2 } = n2, { axis: s2, keepDims: o2 } = a2;
  _x(i2, "sum"), t2 = "bool" === i2.dtype ? Qx({ inputs: { x: i2 }, backend: r2, attrs: { dtype: "int32" } }) : qx({ inputs: { x: i2 }, backend: r2 });
  let l2 = t2.shape.length, u2 = va.parseAxisParam(s2, t2.shape), d2 = Uf.getAxesPermutation(u2, l2), c2 = u2, h2 = t2;
  null != d2 && (h2 = fb({ inputs: { x: t2 }, backend: r2, attrs: { perm: d2 } }), c2 = Uf.getInnerMostAxes(c2.length, l2)), Uf.assertAxesAreInnerMostDims("sum", c2, h2.shape.length);
  let [p2, f2] = Uf.computeOutAndReduceShapes(h2.shape, c2), m2 = Xx(r2, p2, Uf.upcastType(h2.dtype, "int32")), A2 = va.sizeFromShape(f2), x2 = r2.data.get(m2.dataId).values, y2 = r2.data.get(h2.dataId).values;
  for (let b2 = 0; x2.length > b2; ++b2) {
    let e21 = b2 * A2, t3 = 0;
    for (let n3 = 0; A2 > n3; ++n3) t3 += y2[e21 + n3];
    x2[b2] = t3;
  }
  if (o2) {
    let e21 = m2;
    m2 = Ng({ inputs: { x: m2 }, backend: r2, attrs: { shape: Uf.expandShapeToKeepDim(m2.shape, u2) } }), r2.disposeIntermediateTensorInfo(e21);
  }
  return r2.disposeIntermediateTensorInfo(t2), null != d2 && r2.disposeIntermediateTensorInfo(h2), m2;
}
var Dv = { kernelName: "Sum", backendName: "cpu", kernelFunc: _v };
var Wv = { kernelName: Lt, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { equation: a2 } = r2, i2 = t2, { allDims: s2, summedDims: o2, idDims: l2 } = Uf.decodeEinsumEquation(a2, i2.length);
  Uf.checkEinsumDimSizes(s2.length, l2, i2);
  let { path: u2, steps: d2 } = Uf.getEinsumComputePath(o2, l2), c2 = d2.length, h2 = null, p2 = s2.length, f2 = [];
  for (let m2 = 0; c2 > m2; ++m2) {
    for (let e21 of d2[m2]) {
      let t3, { permutationIndices: r3, expandDims: a3 } = Uf.getEinsumPermutation(p2, l2[e21]);
      Uf.isIdentityPermutation(r3) ? t3 = i2[e21] : (t3 = fb({ inputs: { x: i2[e21] }, backend: n2, attrs: { perm: r3 } }), f2.push(t3));
      let s3 = t3.shape.slice();
      for (let e22 = 0; a3.length > e22; ++e22) s3.splice(a3[e22], 0, 1);
      va.arraysEqual(t3.shape, s3) || (t3 = Ng({ inputs: { x: t3 }, backend: n2, attrs: { shape: s3 } }), f2.push(t3)), null === h2 ? h2 = t3 : (h2 = sb({ inputs: { a: t3, b: h2 }, backend: n2 }), f2.push(h2));
    }
    c2 - 1 > m2 && (u2[m2] >= 0 && (h2 = _v({ inputs: { x: h2 }, backend: n2, attrs: { axis: u2[m2] - (s2.length - p2), keepDims: false } }), f2.push(h2)), p2--);
  }
  for (let m2 of f2) m2 !== h2 && n2.disposeIntermediateTensorInfo(m2);
  return h2;
} };
var Lv = { kernelName: Ut, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { dy: r2, y: a2 } = t2;
  _x([r2, a2], "eluGrad");
  let i2 = new Float32Array(va.sizeFromShape(a2.shape)), s2 = n2.data.get(a2.dataId).values, o2 = n2.data.get(r2.dataId).values;
  for (let l2 = 0; s2.length > l2; ++l2) {
    let e21 = s2[l2];
    i2[l2] = 0 > e21 ? o2[l2] * (e21 + 1) : o2[l2];
  }
  return n2.makeTensorInfo(a2.shape, "float32", i2);
} };
var Bv = Uf.ERF_P;
var Uv = Uf.ERF_A1;
var jv = Uf.ERF_A2;
var Gv = Uf.ERF_A3;
var Hv = Uf.ERF_A4;
var Xv = Uf.ERF_A5;
var qv = py("Erf", (e20) => {
  let t2 = Math.sign(e20), n2 = Math.abs(e20), r2 = 1 / (1 + Bv * n2);
  return t2 * (1 - ((((Xv * r2 + Hv) * r2 + Gv) * r2 + jv) * r2 + Uv) * r2 * Math.exp(-n2 * n2));
});
var Zv = { kernelName: "Erf", backendName: "cpu", kernelFunc: qv };
function Kv(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { input: a2 } = t2, { dim: i2 } = r2, s2 = a2.shape.length, o2 = a2.shape.slice(), l2 = i2;
  return 0 > i2 && (va.assert(i2 >= -(s2 + 1), () => `Axis must be in the interval [${-(s2 + 1)}, ${s2}]`), l2 = s2 + i2 + 1), o2.splice(l2, 0, 1), Ng({ inputs: { x: a2 }, backend: n2, attrs: { shape: o2 } });
}
var Yv = { kernelName: Xt, backendName: "cpu", kernelFunc: Kv };
var Jv = jx((e20, t2) => e20 / t2);
var Qv = ty(Wt, Jv);
var ew = { kernelName: Wt, backendName: "cpu", kernelFunc: Qv };
function tw(e20, t2, n2) {
  let r2 = e20.shape, a2 = r2[0], i2 = r2[1], s2 = n2.data.get(e20.dataId), o2 = s2.complexTensorInfos.real, l2 = s2.complexTensorInfos.imag, u2 = [a2, i2], d2 = va.sizeFromShape(u2), c2 = va.getTypedArrayFromDType("float32", d2), h2 = va.getTypedArrayFromDType("float32", d2);
  for (let A2 = 0; a2 > A2; A2++) {
    let e21 = zb({ inputs: { x: o2 }, backend: n2, attrs: { begin: [A2, 0], size: [1, i2] } }), r3 = zb({ inputs: { x: l2 }, backend: n2, attrs: { begin: [A2, 0], size: [1, i2] } }), a3 = Gx({ inputs: { real: e21, imag: r3 }, backend: n2 }), { real: s3, imag: u3 } = nw(a3, t2, n2), d3 = Uf.mergeRealAndImagArrays(s3, u3);
    for (let t3 = 0; i2 > t3; t3++) {
      let e22 = Uf.getComplexWithIndex(d3, t3);
      c2[A2 * i2 + t3] = e22.real, h2[A2 * i2 + t3] = e22.imag;
    }
    n2.disposeIntermediateTensorInfo(e21), n2.disposeIntermediateTensorInfo(r3), n2.disposeIntermediateTensorInfo(a3);
  }
  let p2 = n2.makeTensorInfo(u2, "float32", c2), f2 = n2.makeTensorInfo(u2, "float32", h2), m2 = Gx({ inputs: { real: p2, imag: f2 }, backend: n2 });
  return n2.disposeIntermediateTensorInfo(p2), n2.disposeIntermediateTensorInfo(f2), m2;
}
function nw(e20, t2, n2) {
  let r2 = va.sizeFromShape(e20.shape), a2 = n2.data.get(e20.dataId), i2 = n2.data.get(a2.complexTensorInfos.real.dataId).values, s2 = n2.data.get(a2.complexTensorInfos.imag.dataId).values;
  if (((e21) => !(e21 & e21 - 1))(r2)) {
    let a3 = rw(i2, s2, r2, t2, n2), o2 = [e20.shape[0], e20.shape[1]];
    if (t2) {
      let e21 = n2.makeTensorInfo(o2, "float32", a3.real), t3 = n2.makeTensorInfo(o2, "float32", a3.imag), i3 = n2.makeTensorInfo([], "float32", va.createScalarValue(r2, "float32")), s3 = qx({ inputs: { x: i3 }, backend: n2 }), l2 = ew.kernelFunc({ inputs: { a: e21, b: i3 }, backend: n2 }), u2 = ew.kernelFunc({ inputs: { a: t3, b: s3 }, backend: n2 }), d2 = n2.data.get(l2.dataId).values, c2 = n2.data.get(u2.dataId).values;
      return n2.disposeIntermediateTensorInfo(e21), n2.disposeIntermediateTensorInfo(t3), n2.disposeIntermediateTensorInfo(i3), n2.disposeIntermediateTensorInfo(s3), n2.disposeIntermediateTensorInfo(l2), n2.disposeIntermediateTensorInfo(u2), { real: d2, imag: c2 };
    }
    return a3;
  }
  {
    let e21 = ((e22, t3, n3) => {
      let r3 = new Float32Array(2 * t3);
      for (let a3 = 0; t3 > a3; a3++) {
        let i3 = 0, s3 = 0;
        for (let r4 = 0; t3 > r4; r4++) {
          let o2 = Uf.exponent(a3 * r4, t3, n3), l2 = Uf.getComplexWithIndex(e22, r4);
          i3 += l2.real * o2.real - l2.imag * o2.imag, s3 += l2.real * o2.imag + l2.imag * o2.real;
        }
        n3 && (i3 /= t3, s3 /= t3), Uf.assignToTypedArray(r3, i3, s3, a3);
      }
      return r3;
    })(Uf.mergeRealAndImagArrays(i2, s2), r2, t2);
    return Uf.splitRealAndImagArrays(e21);
  }
}
function rw(e20, t2, n2, r2, a2) {
  if (1 === n2) return { real: e20, imag: t2 };
  let i2 = Uf.mergeRealAndImagArrays(e20, t2), s2 = n2 / 2, o2 = Uf.complexWithEvenIndex(i2), l2 = o2.real, u2 = o2.imag, d2 = [l2.length], c2 = a2.makeTensorInfo(d2, "float32", l2), h2 = a2.makeTensorInfo(d2, "float32", u2), p2 = Gx({ inputs: { real: c2, imag: h2 }, backend: a2 }), f2 = Uf.complexWithOddIndex(i2), m2 = f2.real, A2 = f2.imag, x2 = [m2.length], y2 = a2.makeTensorInfo(x2, "float32", m2), b2 = a2.makeTensorInfo(x2, "float32", A2), g2 = Gx({ inputs: { real: y2, imag: b2 }, backend: a2 }), v2 = rw(l2, u2, s2, r2, a2), w2 = v2.real, k2 = v2.imag, N2 = [w2.length], C2 = a2.makeTensorInfo(N2, "float32", w2), $2 = a2.makeTensorInfo(N2, "float32", k2), R2 = Gx({ inputs: { real: C2, imag: $2 }, backend: a2 }), S2 = rw(m2, A2, s2, r2, a2), I2 = S2.real, E2 = S2.imag, T2 = [I2.length], M2 = a2.makeTensorInfo(T2, "float32", I2), O2 = a2.makeTensorInfo(T2, "float32", E2), F2 = Gx({ inputs: { real: M2, imag: O2 }, backend: a2 }), P2 = Uf.exponents(n2, r2), z2 = [P2.real.length], V2 = a2.makeTensorInfo(z2, "float32", P2.real), _2 = a2.makeTensorInfo(z2, "float32", P2.imag), D2 = Gx({ inputs: { real: V2, imag: _2 }, backend: a2 }), W2 = sb({ inputs: { a: D2, b: F2 }, backend: a2 }), L2 = iy({ inputs: { a: R2, b: W2 }, backend: a2 }), B2 = ag({ inputs: { a: R2, b: W2 }, backend: a2 }), U2 = Kx({ inputs: { input: L2 }, backend: a2 }), j2 = Kx({ inputs: { input: B2 }, backend: a2 }), G2 = uv({ inputs: { input: L2 }, backend: a2 }), H2 = uv({ inputs: { input: B2 }, backend: a2 }), X2 = cv({ inputs: [U2, j2], backend: a2, attrs: { axis: 0 } }), q2 = cv({ inputs: [G2, H2], backend: a2, attrs: { axis: 0 } }), Z2 = a2.data.get(X2.dataId).values, K2 = a2.data.get(q2.dataId).values;
  return a2.disposeIntermediateTensorInfo(c2), a2.disposeIntermediateTensorInfo(h2), a2.disposeIntermediateTensorInfo(p2), a2.disposeIntermediateTensorInfo(y2), a2.disposeIntermediateTensorInfo(b2), a2.disposeIntermediateTensorInfo(g2), a2.disposeIntermediateTensorInfo(C2), a2.disposeIntermediateTensorInfo($2), a2.disposeIntermediateTensorInfo(R2), a2.disposeIntermediateTensorInfo(M2), a2.disposeIntermediateTensorInfo(O2), a2.disposeIntermediateTensorInfo(F2), a2.disposeIntermediateTensorInfo(V2), a2.disposeIntermediateTensorInfo(_2), a2.disposeIntermediateTensorInfo(D2), a2.disposeIntermediateTensorInfo(W2), a2.disposeIntermediateTensorInfo(L2), a2.disposeIntermediateTensorInfo(B2), a2.disposeIntermediateTensorInfo(U2), a2.disposeIntermediateTensorInfo(G2), a2.disposeIntermediateTensorInfo(j2), a2.disposeIntermediateTensorInfo(H2), a2.disposeIntermediateTensorInfo(X2), a2.disposeIntermediateTensorInfo(q2), { real: Z2, imag: K2 };
}
var aw = { kernelName: "FFT", backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2, a2 = va.sizeFromShape(r2.shape), i2 = r2.shape[r2.shape.length - 1], s2 = Ng({ inputs: { x: r2 }, backend: n2, attrs: { shape: [a2 / i2, i2] } }), o2 = tw(s2, false, n2), l2 = Ng({ inputs: { x: o2 }, backend: n2, attrs: { shape: r2.shape } });
  return n2.disposeIntermediateTensorInfo(s2), n2.disposeIntermediateTensorInfo(o2), l2;
} };
function iw(e20) {
  let { backend: t2, attrs: n2 } = e20, { shape: r2, value: a2, dtype: i2 } = n2, s2 = i2 || va.inferDtype(a2), o2 = va.getArrayFromDType(s2, va.sizeFromShape(r2));
  return ((e21, t3) => {
    e21.fill(t3);
  })(o2, a2), t2.makeTensorInfo(r2, s2, o2);
}
var sw = { kernelName: Kt, backendName: "cpu", kernelFunc: iw };
var ow = { kernelName: Yt, backendName: "cpu", kernelFunc({ inputs: e20, backend: t2 }) {
  let { image: n2 } = e20, r2 = t2, a2 = va.getTypedArrayFromDType(n2.dtype, va.sizeFromShape(n2.shape)), [i2, s2, o2, l2] = n2.shape, u2 = r2.data.get(n2.dataId).values;
  for (let d2 = 0; i2 > d2; d2++) {
    let e21 = d2 * o2 * s2 * l2;
    for (let t3 = 0; s2 > t3; t3++) {
      let n3 = t3 * o2 * l2;
      for (let t4 = 0; o2 > t4; t4++) {
        let r3 = t4 * l2;
        for (let i3 = 0; l2 > i3; i3++) {
          let s3 = Math.round(o2 - t4 - 1), d3 = e21 + n3 + r3 + i3, c2 = u2[d3];
          s3 >= 0 && o2 > s3 && (c2 = u2[e21 + n3 + s3 * l2 + i3]), a2[d3] = c2;
        }
      }
    }
  }
  return { dataId: r2.write(a2, n2.shape, n2.dtype), shape: n2.shape, dtype: n2.dtype };
} };
var lw = { kernelName: sa, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2, bias: s2, preluActivationWeights: o2 } = t2, { strides: l2, pad: u2, dataFormat: d2, dilations: c2, dimRoundingMode: h2, activation: p2, leakyreluAlpha: f2 } = r2, m2 = pv({ inputs: { x: a2, filter: i2 }, backend: n2, attrs: { strides: l2, pad: u2, dataFormat: d2, dilations: c2, dimRoundingMode: h2 } });
  if (s2) {
    let e21 = m2;
    if ("NCHW" === d2 && 1 === s2.shape.length && 1 !== s2.shape[0]) {
      let e22 = Ng({ inputs: { x: s2 }, backend: n2, attrs: { shape: [s2.shape[0], 1, 1] } });
      m2 = iy({ inputs: { a: m2, b: e22 }, backend: n2 }), n2.disposeIntermediateTensorInfo(e22);
    } else m2 = iy({ inputs: { a: m2, b: s2 }, backend: n2 });
    n2.disposeIntermediateTensorInfo(e21);
  }
  if (p2) {
    let e21 = m2;
    if ("NCHW" === d2 && "prelu" === p2 && 1 === o2.shape.length && 1 !== o2.shape[0]) {
      let e22 = Ng({ inputs: { x: o2 }, backend: n2, attrs: { shape: [o2.shape[0], 1, 1] } });
      m2 = kg(n2, m2, p2, e22, f2), n2.disposeIntermediateTensorInfo(e22);
    } else m2 = kg(n2, m2, p2, o2, f2);
    n2.disposeIntermediateTensorInfo(e21);
  }
  return m2;
} };
var uw = { kernelName: oa, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2, bias: s2, preluActivationWeights: o2 } = t2, { strides: l2, pad: u2, dataFormat: d2, dilations: c2, dimRoundingMode: h2, activation: p2, leakyreluAlpha: f2 } = r2, m2 = Iv({ inputs: { x: a2, filter: i2 }, backend: n2, attrs: { strides: l2, pad: u2, dataFormat: d2, dilations: c2, dimRoundingMode: h2 } });
  if (s2) {
    let e21 = m2;
    m2 = iy({ inputs: { a: m2, b: s2 }, backend: n2 }), n2.disposeIntermediateTensorInfo(e21);
  }
  if (p2) {
    let e21 = m2;
    m2 = kg(n2, m2, p2, o2, f2), n2.disposeIntermediateTensorInfo(e21);
  }
  return m2;
} };
var dw = { kernelName: nn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { params: r2, indices: a2 } = t2, i2 = va.sizeFromShape(r2.shape), s2 = a2.shape, o2 = s2[s2.length - 1], [l2, u2, d2, c2] = Uf.prepareAndValidate(r2, a2);
  if (0 === u2) return n2.makeTensorInfo(l2, r2.dtype, []);
  let h2 = Fy(n2.data.get(a2.dataId).values, n2.bufferSync(r2), r2.dtype, u2, o2, d2, c2, r2.shape, i2);
  return n2.makeTensorInfo(l2, r2.dtype, h2.values);
} };
var cw = { kernelName: tn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, indices: i2 } = t2, { axis: s2, batchDims: o2 } = r2;
  _x([a2, i2], "gatherV2");
  let l2 = va.parseAxisParam(s2, a2.shape)[0], u2 = n2.data.get(i2.dataId).values, d2 = a2.shape[l2];
  for (let b2 = 0; u2.length > b2; ++b2) {
    let e21 = u2[b2];
    va.assert(d2 - 1 >= e21 && e21 >= 0, () => `GatherV2: the index value ${e21} is not in [0, ${d2 - 1}]`);
  }
  let c2 = o2;
  null == o2 && (c2 = 0);
  let h2 = va.sizeFromShape(i2.shape), p2 = Uf.segment_util.collectGatherOpShapeInfo(a2, i2, l2, c2), f2 = Ng({ inputs: { x: a2 }, backend: n2, attrs: { shape: [p2.batchSize, p2.outerSize, p2.dimSize, p2.sliceSize] } }), m2 = Ng({ inputs: { x: i2 }, backend: n2, attrs: { shape: [p2.batchSize, h2 / p2.batchSize] } }), A2 = [p2.batchSize, p2.outerSize, h2 / p2.batchSize, p2.sliceSize], x2 = n2.bufferSync(m2), y2 = Py(n2.bufferSync(f2), x2, A2);
  return n2.disposeIntermediateTensorInfo(f2), n2.disposeIntermediateTensorInfo(m2), n2.makeTensorInfo(p2.outputShape, y2.dtype, y2.values);
} };
var hw = { kernelName: on, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2, a2 = va.sizeFromShape(r2.shape), i2 = r2.shape[r2.shape.length - 1], s2 = Ng({ inputs: { x: r2 }, backend: n2, attrs: { shape: [a2 / i2, i2] } }), o2 = tw(s2, true, n2), l2 = Ng({ inputs: { x: o2 }, backend: n2, attrs: { shape: r2.shape } });
  return n2.disposeIntermediateTensorInfo(s2), n2.disposeIntermediateTensorInfo(o2), l2;
} };
var pw = py(un, (e20) => Number.isFinite(e20) ? 1 : 0, "bool");
var fw = { kernelName: un, backendName: "cpu", kernelFunc: pw };
var mw = py(dn, (e20) => Math.abs(e20) === 1 / 0 ? 1 : 0, "bool");
var Aw = { kernelName: dn, backendName: "cpu", kernelFunc: mw };
var xw = py(cn, (e20) => Number.isNaN(e20) ? 1 : 0, "bool");
var yw = { kernelName: cn, backendName: "cpu", kernelFunc: xw };
var bw = { kernelName: mn, backendName: "cpu", kernelFunc(e20) {
  let { backend: t2, attrs: n2 } = e20, { start: r2, stop: a2, num: i2 } = n2, s2 = qy(r2, a2, i2);
  return t2.makeTensorInfo([s2.length], "float32", s2);
} };
var gw = py(xn, (e20) => Math.log1p(e20));
var vw = { kernelName: xn, backendName: "cpu", kernelFunc: gw };
var ww = jx((e20, t2) => e20 && t2);
var kw = ty(yn, ww, null, "bool");
var Nw = { kernelName: yn, backendName: "cpu", kernelFunc: kw };
var Cw = py(bn, (e20) => e20 ? 0 : 1, "bool");
var $w = { kernelName: bn, backendName: "cpu", kernelFunc: Cw };
var Rw = jx((e20, t2) => e20 || t2);
var Sw = ty(gn, Rw, null, "bool");
var Iw = { kernelName: gn, backendName: "cpu", kernelFunc: Sw };
var Ew = { kernelName: "LRN", backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { depthRadius: i2, bias: s2, alpha: o2, beta: l2 } = r2;
  _x(a2, "LRN");
  let u2 = a2.shape[3], d2 = u2 - 1, c2 = n2.data.get(a2.dataId).values, h2 = va.sizeFromShape(a2.shape), p2 = new Float32Array(h2);
  function f2(e21) {
    let t3 = e21 % u2, n3 = e21 - t3 + Math.max(0, t3 - i2), r3 = e21 - t3 + Math.min(t3 + i2, d2), a3 = 0;
    for (; r3 >= n3; n3++) {
      let e22 = c2[n3];
      a3 += e22 * e22;
    }
    return a3;
  }
  for (let m2 = 0; h2 > m2; m2++) {
    let e21 = f2(m2);
    p2[m2] = c2[m2] * Math.pow(s2 + o2 * e21, -l2);
  }
  return n2.makeTensorInfo(a2.shape, a2.dtype, p2);
} };
var Tw = { kernelName: Cn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, y: i2, dy: s2 } = t2, { depthRadius: o2, bias: l2, alpha: u2, beta: d2 } = r2;
  _x(s2, "LRNGrad");
  let c2 = va.sizeFromShape(s2.shape), h2 = s2.shape[3], p2 = n2.data.get(s2.dataId).values, f2 = n2.data.get(a2.dataId).values, m2 = n2.data.get(i2.dataId).values, A2 = new Float32Array(c2), x2 = c2;
  for (let y2 = 0; x2 > y2; y2++) {
    let e21 = y2 % h2, t3 = y2 - e21 + Math.max(0, e21 - o2), n3 = y2 - e21 + Math.min(h2, e21 + o2 + 1), r3 = 0;
    for (let a3 = t3; n3 > a3; a3++) r3 += Math.pow(f2[a3], 2);
    r3 = u2 * r3 + l2;
    for (let a3 = t3; n3 > a3; a3++) {
      let e22 = -2 * u2 * d2 * f2[a3] * m2[y2] / r3;
      y2 === a3 && (e22 += Math.pow(r3, -d2)), e22 *= p2[y2], A2[a3] += e22;
    }
  }
  return n2.makeTensorInfo(s2.shape, a2.dtype, A2);
} };
function Mw(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { reductionIndices: i2, keepDims: s2 } = r2, o2 = n2, l2 = a2.shape, u2 = l2.length, d2 = va.parseAxisParam(i2, l2), c2 = d2, h2 = Uf.getAxesPermutation(c2, u2), p2 = o2.data.get(a2.dataId).values;
  if (null != h2) {
    let e21 = Array(u2);
    for (let t3 = 0; e21.length > t3; t3++) e21[t3] = l2[h2[t3]];
    p2 = pb(p2, l2, a2.dtype, h2, e21), c2 = Uf.getInnerMostAxes(c2.length, u2), l2 = e21;
  }
  _x(a2, "max"), Uf.assertAxesAreInnerMostDims("max", c2, u2);
  let [f2, m2] = Uf.computeOutAndReduceShapes(l2, c2), A2 = Yy(p2, va.sizeFromShape(m2), f2, a2.dtype), x2 = o2.write(A2, f2, a2.dtype), y2 = f2;
  return s2 && (y2 = Uf.expandShapeToKeepDim(f2, d2)), { dataId: x2, shape: y2, dtype: a2.dtype };
}
var Ow = { kernelName: "Max", backendName: "cpu", kernelFunc: Mw };
var Fw = { kernelName: In, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2;
  _x(a2, "maxPool");
  let { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2 } = r2;
  va.assert(Uf.eitherStridesOrDilationsAreOne(s2, 1), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s2} and dilations '1'`);
  let u2, d2 = Uf.computePool2DInfo(a2.shape, i2, s2, 1, o2, l2);
  if (1 === d2.filterWidth && 1 === d2.filterHeight && va.arraysEqual(d2.inShape, d2.outShape)) u2 = qx({ inputs: { x: a2 }, backend: n2 });
  else {
    let e21 = n2.data.get(a2.dataId).values, t3 = va.computeStrides(a2.shape), r3 = Zg(e21, 0, a2.dtype, t3, d2, "max");
    u2 = n2.makeTensorInfo(d2.outShape, a2.dtype, r3.values);
  }
  return u2;
} };
var Pw = { kernelName: Tn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2, dataFormat: u2 } = r2;
  _x(a2, "maxPool3d");
  let d2 = Uf.computePool3DInfo(a2.shape, i2, s2, 1, o2, l2, u2), c2 = Yg(n2.data.get(a2.dataId).values, 0, a2.dtype, va.computeStrides(a2.shape), d2, "max");
  return n2.makeTensorInfo(c2.shape, "float32", c2.values);
} };
var zw = { kernelName: Mn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, { filterSize: s2, strides: o2, pad: l2, dimRoundingMode: u2 } = r2;
  _x([a2, i2], "maxPool3DGrad");
  let d2 = Uf.computePool3DInfo(i2.shape, s2, o2, 1, l2, u2), c2 = ((e21, t3) => {
    let n3 = uo(t3.outShape, "int32"), r3 = t3.strideDepth, a3 = t3.strideHeight, i3 = t3.strideWidth, s3 = t3.dilationDepth, o3 = t3.dilationHeight, l3 = t3.dilationWidth, u3 = t3.effectiveFilterDepth, d3 = t3.effectiveFilterHeight, c3 = t3.effectiveFilterWidth, h3 = t3.padInfo.front, p3 = t3.padInfo.top, f3 = t3.padInfo.left;
    for (let m3 = 0; t3.batchSize > m3; ++m3) for (let A3 = 0; t3.inChannels > A3; ++A3) for (let x3 = 0; t3.outDepth > x3; ++x3) {
      let y3 = x3 * r3 - h3, b3 = y3;
      for (; 0 > b3; ) b3 += s3;
      let g3 = Math.min(t3.inDepth, u3 + y3);
      for (let r4 = 0; t3.outHeight > r4; ++r4) {
        let u4 = r4 * a3 - p3, h4 = u4;
        for (; 0 > h4; ) h4 += o3;
        let v3 = Math.min(t3.inHeight, d3 + u4);
        for (let a4 = 0; t3.outWidth > a4; ++a4) {
          let p4 = a4 * i3 - f3, w3 = p4;
          for (; 0 > w3; ) w3 += l3;
          let k3 = Math.min(t3.inWidth, c3 + p4), N3 = -Infinity, C3 = -1;
          for (let t4 = b3; g3 > t4; t4 += s3) {
            let n4 = t4 - y3;
            for (let r5 = h4; v3 > r5; r5 += o3) {
              let a5 = r5 - u4;
              for (let i4 = w3; k3 > i4; i4 += l3) {
                let s4 = i4 - p4, o4 = e21.get(m3, t4, r5, i4, A3);
                o4 >= N3 && (N3 = o4, C3 = n4 * d3 * c3 + a5 * d3 + s4);
              }
            }
          }
          n3.set(C3, m3, x3, r4, a4, A3);
        }
      }
    }
    return n3;
  })(n2.bufferSync(i2), d2), h2 = d2.strideDepth, p2 = d2.strideHeight, f2 = d2.strideWidth, m2 = d2.dilationDepth, A2 = d2.dilationHeight, x2 = d2.dilationWidth, y2 = d2.effectiveFilterDepth, b2 = d2.effectiveFilterHeight, g2 = d2.effectiveFilterWidth, v2 = y2 - 1 - d2.padInfo.front, w2 = g2 - 1 - d2.padInfo.left, k2 = b2 - 1 - d2.padInfo.top, N2 = uo(i2.shape, "float32"), C2 = n2.bufferSync(a2);
  for (let $2 = 0; d2.batchSize > $2; ++$2) for (let e21 = 0; d2.inChannels > e21; ++e21) for (let t3 = 0; d2.inDepth > t3; ++t3) for (let n3 = 0; d2.inHeight > n3; ++n3) for (let r3 = 0; d2.inWidth > r3; ++r3) {
    let a3 = t3 - v2, i3 = n3 - k2, s3 = r3 - w2, o3 = 0;
    for (let t4 = 0; y2 > t4; t4 += m2) {
      let n4 = (a3 + t4) / h2;
      if (n4 >= 0 && d2.outDepth > n4 && Math.floor(n4) === n4) for (let r4 = 0; b2 > r4; r4 += A2) {
        let a4 = (i3 + r4) / p2;
        if (a4 >= 0 && d2.outHeight > a4 && Math.floor(a4) === a4) for (let i4 = 0; g2 > i4; i4 += x2) {
          let l3 = (s3 + i4) / f2;
          if (0 > l3 || l3 >= d2.outWidth || Math.floor(l3) !== l3) continue;
          let u3 = y2 * b2 * g2 - 1 - c2.get($2, n4, a4, l3, e21) === t4 * b2 * g2 + r4 * g2 + i4 ? 1 : 0;
          0 !== u3 && (o3 += C2.get($2, n4, a4, l3, e21) * u3);
        }
      }
    }
    N2.set(o3, $2, t3, n3, r3, e21);
  }
  return n2.makeTensorInfo(N2.shape, N2.dtype, N2.values);
} };
var Vw = { kernelName: En, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2, output: s2 } = t2, o2 = i2;
  _x([i2, s2], "maxPoolGrad");
  let { filterSize: l2, strides: u2, pad: d2, dimRoundingMode: c2 } = r2, h2 = Uf.computePool2DInfo(o2.shape, l2, u2, 1, d2, c2), p2 = n2.data.get(o2.dataId).values, f2 = uo(h2.outShape, o2.dtype, Kg(p2, o2.shape, o2.dtype, h2).values), m2 = h2.strideHeight, A2 = h2.strideWidth, x2 = h2.dilationHeight, y2 = h2.dilationWidth, b2 = h2.effectiveFilterHeight, g2 = h2.effectiveFilterWidth, v2 = g2 - 1 - h2.padInfo.left, w2 = b2 - 1 - h2.padInfo.top, k2 = uo(o2.shape, "float32"), N2 = n2.data.get(a2.dataId).values, C2 = uo(a2.shape, "float32", N2);
  for (let $2 = 0; h2.batchSize > $2; ++$2) for (let e21 = 0; h2.inChannels > e21; ++e21) for (let t3 = 0; h2.inHeight > t3; ++t3) for (let n3 = 0; h2.inWidth > n3; ++n3) {
    let r3 = t3 - w2, a3 = n3 - v2, i3 = 0;
    for (let t4 = 0; b2 > t4; t4 += x2) {
      let n4 = (r3 + t4) / m2;
      if (n4 >= 0 && h2.outHeight > n4 && Math.floor(n4) === n4) for (let r4 = 0; g2 > r4; r4 += y2) {
        let s3 = (a3 + r4) / A2;
        if (0 > s3 || s3 >= h2.outWidth || Math.floor(s3) !== s3) continue;
        let o3 = b2 * g2 - 1 - f2.get($2, n4, s3, e21) === t4 * g2 + r4 ? 1 : 0;
        0 !== o3 && (i3 += C2.get($2, n4, s3, e21) * o3);
      }
    }
    k2.set(i3, $2, t3, n3, e21);
  }
  return n2.makeTensorInfo(k2.shape, k2.dtype, k2.values);
} };
var _w = { kernelName: On, backendName: "cpu", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { x: r2 } = e20, { filterSize: a2, strides: i2, pad: s2, includeBatchInIndex: o2 } = t2, l2 = n2;
  _x(r2, "MaxPoolWithArgmax");
  let u2 = l2.data.get(r2.dataId).values, d2 = Uf.computePool2DInfo(r2.shape, a2, i2, [1, 1], s2), [c2, h2] = ((e21, t3, n3, r3, a3) => {
    let i3 = Zg(e21, 0, n3, va.computeStrides(t3), a3, "max"), s3 = Kg(e21, t3, n3, a3, true, r3);
    return [i3.values, s3.values];
  })(u2, r2.shape, r2.dtype, o2, d2), p2 = l2.write(c2, d2.outShape, r2.dtype), f2 = l2.write(h2, d2.outShape, r2.dtype);
  return [{ dataId: p2, shape: d2.outShape, dtype: r2.dtype }, { dataId: f2, shape: d2.outShape, dtype: "int32" }];
} };
var Dw = { kernelName: Fn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2, o2 = va.parseAxisParam(i2, a2.shape), l2 = Uf.computeOutAndReduceShapes(a2.shape, o2)[1], u2 = va.sizeFromShape(l2), d2 = [], c2 = n2.makeTensorInfo([], "float32", new Float32Array([u2]));
  d2.push(c2);
  let h2 = Qx({ inputs: { x: a2 }, backend: n2, attrs: { dtype: "float32" } });
  d2.push(h2);
  let p2 = Qv({ inputs: { a: h2, b: c2 }, backend: n2 });
  d2.push(p2);
  let f2 = _v({ inputs: { x: p2 }, backend: n2, attrs: { axis: i2, keepDims: s2 } });
  return d2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), f2;
} };
var Ww = { kernelName: "Min", backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2;
  _x(a2, "min");
  let o2 = va.parseAxisParam(i2, a2.shape), l2 = o2, u2 = Uf.getAxesPermutation(l2, a2.shape.length), d2 = a2;
  null != u2 && (d2 = fb({ inputs: { x: a2 }, backend: n2, attrs: { perm: u2 } }), l2 = Uf.getInnerMostAxes(l2.length, a2.shape.length)), Uf.assertAxesAreInnerMostDims("min", l2, d2.shape.length);
  let [c2, h2] = Uf.computeOutAndReduceShapes(d2.shape, l2), p2 = va.sizeFromShape(h2), f2 = va.makeZerosTypedArray(va.sizeFromShape(c2), d2.dtype), m2 = n2.data.get(d2.dataId).values;
  for (let x2 = 0; f2.length > x2; ++x2) {
    let e21 = x2 * p2, t3 = m2[e21];
    for (let n3 = 0; p2 > n3; ++n3) {
      let r3 = m2[e21 + n3];
      (Number.isNaN(r3) || t3 > r3) && (t3 = r3);
    }
    f2[x2] = t3;
  }
  null != u2 && n2.disposeIntermediateTensorInfo(d2);
  let A2 = n2.makeTensorInfo(c2, d2.dtype, f2);
  if (s2) {
    let e21 = Ng({ inputs: { x: A2 }, backend: n2, attrs: { shape: Uf.expandShapeToKeepDim(c2, o2) } });
    return n2.disposeIntermediateTensorInfo(A2), e21;
  }
  return A2;
} };
var Lw = { kernelName: Vn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { paddings: i2, mode: s2 } = r2;
  _x(a2, "mirrorPad");
  let o2 = i2.map((e21, t3) => e21[0] + a2.shape[t3] + e21[1]), l2 = i2.map((e21) => e21[0]), u2 = i2.map((e21, t3) => e21[0] + a2.shape[t3]), d2 = "reflect" === s2 ? 0 : 1, c2 = n2.data.get(a2.dataId).values, h2 = a2.shape.length, p2 = va.computeStrides(a2.shape), f2 = va.sizeFromShape(o2), m2 = o2.length, A2 = va.computeStrides(o2), x2 = va.getTypedArrayFromDType(a2.dtype, f2);
  for (let y2 = 0; f2 > y2; y2++) {
    let e21 = va.indexToLoc(y2, m2, A2);
    for (let n3 = 0; m2 > n3; n3++) l2[n3] > e21[n3] ? e21[n3] = 2 * l2[n3] - e21[n3] - d2 : e21[n3] >= u2[n3] && (e21[n3] = 2 * (u2[n3] - 1) - e21[n3] + d2);
    e21 = e21.map((e22, t4) => e22 - l2[t4]);
    let t3 = va.locToIndex(e21, h2, p2);
    x2[y2] = c2[t3];
  }
  return { dataId: n2.write(x2, o2, a2.dtype), shape: o2, dtype: a2.dtype };
} };
var Bw = jx((e20, t2) => {
  let n2 = e20 % t2;
  return 0 > e20 && 0 > t2 || e20 >= 0 && t2 >= 0 ? n2 : (n2 + t2) % t2;
});
var Uw = { kernelName: "Mod", backendName: "cpu", kernelFunc: ty("Mod", Bw) };
var jw = x(I());
function Gw(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { logits: a2 } = t2, { dim: i2 } = r2, s2 = a2.shape.length, o2 = i2;
  if (-1 === o2 && (o2 = s2 - 1), o2 !== s2 - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${s2} and dim was ${o2}`);
  let l2 = va.parseAxisParam([o2], a2.shape), u2 = Mw({ inputs: { x: a2 }, backend: n2, attrs: { reductionIndices: l2, keepDims: false } }), d2 = Uf.expandShapeToKeepDim(u2.shape, l2), c2 = Ng({ inputs: { x: u2 }, backend: n2, attrs: { shape: d2 } }), h2 = ag({ inputs: { a: a2, b: c2 }, backend: n2 }), p2 = ky({ inputs: { x: h2 }, backend: n2 }), f2 = _v({ inputs: { x: p2 }, backend: n2, attrs: { axis: l2, keepDims: false } }), m2 = Ng({ inputs: { x: f2 }, backend: n2, attrs: { shape: d2 } }), A2 = Qv({ inputs: { a: p2, b: m2 }, backend: n2 });
  return n2.disposeIntermediateTensorInfo(u2), n2.disposeIntermediateTensorInfo(c2), n2.disposeIntermediateTensorInfo(h2), n2.disposeIntermediateTensorInfo(p2), n2.disposeIntermediateTensorInfo(f2), n2.disposeIntermediateTensorInfo(m2), A2;
}
var Hw = { kernelName: Tr, backendName: "cpu", kernelFunc: Gw };
var Xw = { kernelName: Dn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { logits: a2 } = t2, { numSamples: i2, seed: s2, normalized: o2 } = r2;
  _x(a2, "multinomial");
  let l2 = o2 ? a2 : Gw({ inputs: { logits: a2 }, backend: n2, attrs: { dim: -1 } }), u2 = l2.shape[0], d2 = l2.shape[1], c2 = n2.data.get(l2.dataId).values, h2 = [u2, i2], p2 = va.makeZerosTypedArray(va.sizeFromShape(h2), "int32");
  for (let f2 = 0; u2 > f2; ++f2) {
    let e21 = f2 * d2, t3 = new Float32Array(d2 - 1);
    t3[0] = c2[e21];
    for (let a3 = 1; t3.length > a3; ++a3) t3[a3] = t3[a3 - 1] + c2[e21 + a3];
    let n3 = jw.alea("" + s2), r3 = f2 * i2;
    for (let a3 = 0; i2 > a3; ++a3) {
      let e22 = n3();
      p2[r3 + a3] = t3.length;
      for (let n4 = 0; t3.length > n4; n4++) if (t3[n4] > e22) {
        p2[r3 + a3] = n4;
        break;
      }
    }
  }
  return o2 || n2.disposeIntermediateTensorInfo(l2), n2.makeTensorInfo(h2, "int32", p2);
} };
var qw = Ym.nonMaxSuppressionV3Impl;
var Zw = { kernelName: Un, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { boxes: a2, scores: i2 } = t2, { maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2 } = r2;
  _x(a2, "NonMaxSuppression");
  let u2 = n2.data.get(a2.dataId).values, d2 = n2.data.get(i2.dataId).values, { selectedIndices: c2 } = qw(u2, d2, s2, o2, l2);
  return n2.makeTensorInfo([c2.length], "int32", new Int32Array(c2));
} };
var Kw = Ym.nonMaxSuppressionV4Impl;
var Yw = { kernelName: jn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { boxes: a2, scores: i2 } = t2, { maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2, padToMaxOutputSize: u2 } = r2;
  _x(a2, "NonMaxSuppressionPadded");
  let d2 = n2.data.get(a2.dataId).values, c2 = n2.data.get(i2.dataId).values, { selectedIndices: h2, validOutputs: p2 } = Kw(d2, c2, s2, o2, l2, u2);
  return [n2.makeTensorInfo([h2.length], "int32", new Int32Array(h2)), n2.makeTensorInfo([], "int32", new Int32Array([p2]))];
} };
var Jw = Ym.nonMaxSuppressionV5Impl;
var Qw = { kernelName: Gn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { boxes: a2, scores: i2 } = t2, { maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2, softNmsSigma: u2 } = r2;
  _x(a2, "NonMaxSuppressionWithScore");
  let d2 = n2.data.get(a2.dataId).values, c2 = n2.data.get(i2.dataId).values, h2 = s2, p2 = o2, f2 = l2, m2 = u2, { selectedIndices: A2, selectedScores: x2 } = Jw(d2, c2, h2, p2, f2, m2);
  return [n2.makeTensorInfo([A2.length], "int32", new Int32Array(A2)), n2.makeTensorInfo([x2.length], "float32", new Float32Array(x2))];
} };
var ek = { kernelName: Xn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { indices: a2 } = t2, { dtype: i2, depth: s2, onValue: o2, offValue: l2 } = r2;
  _x(a2, "oneHot");
  let u2 = va.sizeFromShape(a2.shape), d2 = new Float32Array(u2 * s2);
  d2.fill(l2);
  let c2 = n2.data.get(a2.dataId).values;
  for (let h2 = 0; u2 > h2; ++h2) c2[h2] >= 0 && s2 > c2[h2] && (d2[h2 * s2 + c2[h2]] = o2);
  return n2.makeTensorInfo([...a2.shape, s2], i2, d2);
} };
function tk(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2;
  if ("string" === r2.dtype) throw Error("zerosLike is not supported for string tensors");
  if ("complex64" === r2.dtype) {
    let e21 = Kx({ inputs: { input: r2 }, backend: n2 }), t3 = tk({ inputs: { x: e21 }, backend: n2 }), a2 = uv({ inputs: { input: r2 }, backend: n2 }), i2 = tk({ inputs: { x: a2 }, backend: n2 }), s2 = Gx({ inputs: { real: t3, imag: i2 }, backend: n2 });
    return n2.disposeIntermediateTensorInfo(e21), n2.disposeIntermediateTensorInfo(t3), n2.disposeIntermediateTensorInfo(a2), n2.disposeIntermediateTensorInfo(i2), s2;
  }
  return iw({ backend: n2, attrs: { shape: r2.shape, value: 0, dtype: r2.dtype } });
}
var nk = { kernelName: ta, backendName: "cpu", kernelFunc: tk };
var rk = { kernelName: Hn, backendName: "cpu", kernelFunc: function e12(t2) {
  let { inputs: n2, backend: r2 } = t2, { x: a2 } = n2;
  if ("string" === a2.dtype) throw Error("onesLike is not supported for string tensors");
  if ("complex64" === a2.dtype) {
    let t3 = Kx({ inputs: { input: a2 }, backend: r2 }), n3 = e12({ inputs: { x: t3 }, backend: r2 }), i2 = uv({ inputs: { input: a2 }, backend: r2 }), s2 = tk({ inputs: { x: i2 }, backend: r2 }), o2 = Gx({ inputs: { real: n3, imag: s2 }, backend: r2 });
    return r2.disposeIntermediateTensorInfo(t3), r2.disposeIntermediateTensorInfo(n3), r2.disposeIntermediateTensorInfo(i2), r2.disposeIntermediateTensorInfo(s2), o2;
  }
  return iw({ backend: r2, attrs: { shape: a2.shape, value: 1, dtype: a2.dtype } });
} };
function ak(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { axis: a2 } = r2;
  if (1 === t2.length) return Kv({ inputs: { input: t2[0] }, backend: n2, attrs: { dim: a2 } });
  let i2 = t2[0].shape, s2 = t2[0].dtype;
  t2.forEach((e21) => {
    va.assertShapesMatch(i2, e21.shape, "All tensors passed to stack must have matching shapes"), va.assert(s2 === e21.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  let o2 = [], l2 = cv({ inputs: t2.map((e21) => {
    let t3 = Kv({ inputs: { input: e21 }, backend: n2, attrs: { dim: a2 } });
    return o2.push(t3), t3;
  }), backend: n2, attrs: { axis: a2 } });
  return o2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), l2;
}
var ik = { kernelName: qn, backendName: "cpu", kernelFunc: ak };
var sk = { kernelName: Zn, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { paddings: i2, constantValue: s2 } = r2;
  _x(a2, "pad");
  let o2 = i2.map((e21, t3) => e21[0] + a2.shape[t3] + e21[1]), l2 = i2.map((e21) => e21[0]), u2 = n2.data.get(a2.dataId).values, d2 = va.sizeFromShape(a2.shape), c2 = a2.shape.length, h2 = va.computeStrides(a2.shape), p2 = va.sizeFromShape(o2), f2 = o2.length, m2 = va.computeStrides(o2), A2 = va.getTypedArrayFromDType(a2.dtype, p2);
  0 !== s2 && A2.fill(s2);
  for (let x2 = 0; d2 > x2; x2++) {
    let e21 = va.indexToLoc(x2, c2, h2).map((e22, t3) => e22 + l2[t3]);
    A2[va.locToIndex(e21, f2, m2)] = u2[x2];
  }
  return { dataId: n2.write(A2, o2, a2.dtype), shape: o2, dtype: a2.dtype };
} };
var ok = jx((e20, t2) => Math.pow(e20, t2));
var lk = { kernelName: "Pow", backendName: "cpu", kernelFunc: ty("Pow", ok) };
var uk = { kernelName: er, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { paramsNestedSplits: r2, paramsDenseValues: a2, indices: i2 } = t2, s2 = r2.map((e21) => n2.data.get(e21.dataId).values), o2 = r2.map((e21) => e21.shape), l2 = n2.data.get(a2.dataId).values, u2 = n2.data.get(i2.dataId).values, [d2, c2, h2] = bb(s2, o2, l2, a2.shape, a2.dtype, u2, i2.shape), p2 = d2.map((e21) => n2.makeTensorInfo([e21.length], "int32", e21)), f2 = n2.makeTensorInfo(h2, a2.dtype, c2);
  return p2.concat([f2]);
} };
var dk = { kernelName: tr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { starts: r2, limits: a2, deltas: i2 } = t2, s2 = n2.data.get(r2.dataId).values, o2 = n2.data.get(a2.dataId).values, l2 = n2.data.get(i2.dataId).values, [u2, d2] = vb(s2, r2.shape, r2.dtype, o2, a2.shape, l2, i2.shape);
  return [n2.makeTensorInfo([u2.length], "int32", u2), n2.makeTensorInfo([d2.length], r2.dtype, d2)];
} };
var ck = { kernelName: nr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { shape: a2, values: i2, defaultValue: s2, rowPartitionTensors: o2 } = t2, { rowPartitionTypes: l2 } = r2, u2 = n2.data.get(a2.dataId).values, d2 = n2.data.get(i2.dataId).values, c2 = n2.data.get(s2.dataId).values, h2 = o2.map((e21) => n2.data.get(e21.dataId).values), p2 = o2.map((e21) => e21.shape), [f2, m2] = $b(u2, a2.shape, d2, i2.shape, i2.dtype, c2, s2.shape, h2, p2, l2);
  return n2.makeTensorInfo(f2, i2.dtype, m2);
} };
var hk = { kernelName: rr, backendName: "cpu", kernelFunc(e20) {
  let { backend: t2, attrs: n2 } = e20, { start: r2, stop: a2, dtype: i2, step: s2 } = n2, o2 = Rb(r2, a2, s2, i2);
  return t2.makeTensorInfo([o2.length], i2, o2);
} };
var pk = py(ir, (e20) => 1 / e20);
var fk = { kernelName: ir, backendName: "cpu", kernelFunc: pk };
var mk = { kernelName: dr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2 } = t2, { alignCorners: i2, halfPixelCenters: s2, size: o2 } = r2;
  _x(a2, "resizeBilinear");
  let l2 = va.computeStrides(a2.shape), [u2, d2] = o2, [c2, h2, p2, f2] = a2.shape, m2 = n2.data.get(a2.dataId).values, A2 = new Float32Array(va.sizeFromShape([c2, u2, d2, f2])), x2 = [i2 && u2 > 1 ? h2 - 1 : h2, i2 && d2 > 1 ? p2 - 1 : p2], y2 = [i2 && u2 > 1 ? u2 - 1 : u2, i2 && d2 > 1 ? d2 - 1 : d2], b2 = 0, g2 = x2[0] / y2[0], v2 = x2[1] / y2[1];
  for (let w2 = 0; c2 > w2; w2++) for (let e21 = 0; u2 > e21; e21++) {
    let t3;
    t3 = s2 ? g2 * (e21 + 0.5) - 0.5 : g2 * e21;
    let n3 = Math.max(0, Math.floor(t3)), r3 = t3 - n3, a3 = w2 * l2[0] + n3 * l2[1], i3 = w2 * l2[0] + Math.min(h2 - 1, Math.ceil(t3)) * l2[1];
    for (let e22 = 0; d2 > e22; e22++) {
      let t4;
      t4 = s2 ? v2 * (e22 + 0.5) - 0.5 : v2 * e22;
      let n4 = Math.max(0, Math.floor(t4)), o3 = t4 - n4, u3 = Math.min(p2 - 1, Math.ceil(t4)), d3 = a3 + n4 * l2[2], c3 = i3 + n4 * l2[2], h3 = a3 + u3 * l2[2], x3 = i3 + u3 * l2[2];
      for (let e23 = 0; f2 > e23; e23++) {
        let t5 = m2[d3 + e23], n5 = m2[c3 + e23], a4 = t5 + (m2[h3 + e23] - t5) * o3;
        A2[b2++] = a4 + (n5 + (m2[x3 + e23] - n5) * o3 - a4) * r3;
      }
    }
  }
  return n2.makeTensorInfo([c2, u2, d2, f2], "float32", A2);
} };
var Ak = { kernelName: cr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2, dy: i2 } = t2, { alignCorners: s2 } = r2;
  _x([i2, a2], "resizeBilinearGrad");
  let o2 = va.computeStrides(a2.shape), [l2, u2, d2, c2] = a2.shape, [, h2, p2] = i2.shape, f2 = new Float32Array(l2 * u2 * d2 * c2), m2 = [s2 && h2 > 1 ? u2 - 1 : u2, s2 && p2 > 1 ? d2 - 1 : d2], A2 = [s2 && h2 > 1 ? h2 - 1 : h2, s2 && p2 > 1 ? p2 - 1 : p2], x2 = m2[0] / A2[0], y2 = m2[1] / A2[1], b2 = n2.data.get(i2.dataId).values, g2 = 0;
  for (let v2 = 0; l2 > v2; v2++) {
    let e21 = v2 * o2[0];
    for (let t3 = 0; h2 > t3; t3++) {
      let n3 = t3 * x2, r3 = Math.floor(n3), a3 = e21 + r3 * o2[1], i3 = e21 + Math.min(Math.ceil(n3), u2 - 1) * o2[1], s3 = n3 - r3, l3 = 1 - s3;
      for (let e22 = 0; p2 > e22; e22++) {
        let t4 = e22 * y2, n4 = Math.floor(t4), r4 = Math.min(Math.ceil(t4), d2 - 1), u3 = t4 - n4, h3 = 1 - u3, p3 = a3 + n4 * o2[2], m3 = a3 + r4 * o2[2], A3 = i3 + n4 * o2[2], x3 = i3 + r4 * o2[2], v3 = l3 * h3, w2 = l3 * u3, k2 = s3 * h3, N2 = s3 * u3;
        for (let e23 = 0; c2 > e23; e23++) {
          let t5 = b2[g2++];
          f2[p3 + e23] += t5 * v3, f2[m3 + e23] += t5 * w2, f2[A3 + e23] += t5 * k2, f2[x3 + e23] += t5 * N2;
        }
      }
    }
  }
  return n2.makeTensorInfo([l2, d2, u2, c2], "float32", f2);
} };
var xk = { kernelName: lr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2 } = t2, { alignCorners: i2, halfPixelCenters: s2, size: o2 } = r2;
  _x(a2, "resizeNearestNeighbor");
  let l2 = va.computeStrides(a2.shape), [u2, d2] = o2, [c2, h2, p2, f2] = a2.shape, m2 = n2.data.get(a2.dataId).values, A2 = new Float32Array(c2 * u2 * d2 * f2), x2 = [i2 && u2 > 1 ? h2 - 1 : h2, i2 && d2 > 1 ? p2 - 1 : p2], y2 = [i2 && u2 > 1 ? u2 - 1 : u2, i2 && d2 > 1 ? d2 - 1 : d2], b2 = x2[0] / y2[0], g2 = x2[1] / y2[1], v2 = 0;
  for (let w2 = 0; c2 > w2; w2++) {
    let e21 = w2 * l2[0];
    for (let t3 = 0; u2 > t3; t3++) {
      let n3 = s2 ? b2 * (t3 + 0.5) : b2 * t3, r3 = Math.min(h2 - 1, i2 ? Math.round(n3) : Math.floor(n3));
      s2 && (r3 = Math.max(0, r3));
      let a3 = e21 + r3 * l2[1];
      for (let e22 = 0; d2 > e22; e22++) {
        let t4 = s2 ? g2 * (e22 + 0.5) : g2 * e22, n4 = Math.min(p2 - 1, i2 ? Math.round(t4) : Math.floor(t4));
        s2 && (n4 = Math.max(0, n4));
        let r4 = a3 + n4 * l2[2];
        for (let e23 = 0; f2 > e23; e23++) A2[v2++] = m2[r4 + e23];
      }
    }
  }
  return n2.makeTensorInfo([c2, u2, d2, f2], a2.dtype, A2);
} };
var yk = { kernelName: ur, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2, dy: i2 } = t2, { alignCorners: s2 } = r2;
  _x([i2, a2], "resizeNearestNeighborGrad");
  let o2 = va.computeStrides(a2.shape), l2 = va.computeStrides(i2.shape), [u2, d2, c2, h2] = a2.shape, [, p2, f2] = i2.shape, m2 = new Float32Array(u2 * d2 * c2 * h2), A2 = n2.data.get(i2.dataId).values, x2 = [s2 && p2 > 1 ? d2 - 1 : d2, s2 && f2 > 1 ? c2 - 1 : c2], y2 = [s2 && p2 > 1 ? p2 - 1 : p2, s2 && f2 > 1 ? f2 - 1 : f2], b2 = x2[0] / y2[0], g2 = x2[1] / y2[1], v2 = 1 / b2, w2 = 1 / g2, k2 = 2 * Math.ceil(v2) + 2, N2 = 2 * Math.ceil(w2) + 2;
  for (let C2 = 0; u2 > C2; C2++) {
    let e21 = C2 * o2[0];
    for (let t3 = 0; d2 > t3; t3++) {
      let n3 = e21 + t3 * o2[1], r3 = Math.floor(Math.floor(t3 * v2) - k2 / 2);
      for (let a3 = 0; c2 > a3; a3++) {
        let i3 = n3 + a3 * o2[2], u3 = Math.floor(Math.floor(a3 * w2) - N2 / 2);
        for (let n4 = 0; h2 > n4; n4++) {
          let o3 = 0;
          for (let i4 = 0; k2 > i4; i4++) {
            let h3 = i4 + r3;
            if (0 > h3 || h3 >= p2) continue;
            let m3 = e21 + h3 * l2[1], x3 = h3 * b2;
            if (t3 === Math.min(d2 - 1, s2 ? Math.round(x3) : Math.floor(x3))) for (let e22 = 0; N2 > e22; e22++) {
              let t4 = e22 + u3;
              if (0 > t4 || t4 >= f2) continue;
              let r4 = m3 + t4 * l2[2], i5 = t4 * g2;
              a3 === Math.min(c2 - 1, s2 ? Math.round(i5) : Math.floor(i5)) && (o3 += A2[r4 + n4]);
            }
          }
          m2[i3 + n4] = o3;
        }
      }
    }
  }
  return n2.makeTensorInfo(a2.shape, a2.dtype, m2);
} };
var bk = { kernelName: pr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { dims: i2 } = r2;
  _x(a2, "reverse");
  let s2 = a2.shape.length, o2 = va.parseAxisParam(i2, a2.shape);
  if (0 === s2) return qx({ inputs: { x: a2 }, backend: n2 });
  let l2 = new Qa(a2.shape, a2.dtype), u2 = n2.bufferSync(a2);
  for (let d2 = 0; l2.size > d2; d2++) {
    let e21 = l2.indexToLoc(d2), t3 = e21.slice();
    o2.forEach((e22) => t3[e22] = a2.shape[e22] - 1 - t3[e22]), l2.set(u2.get(...t3), ...e21);
  }
  return n2.makeTensorInfo(l2.shape, l2.dtype, l2.values);
} };
var gk = { kernelName: aa, backendName: "cpu", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { image: r2 } = e20, { radians: a2, fillValue: i2, center: s2 } = t2, o2 = n2, l2 = va.getTypedArrayFromDType(r2.dtype, va.sizeFromShape(r2.shape)), [u2, d2, c2, h2] = r2.shape, [p2, f2] = Uf.getImageCenter(s2, d2, c2), m2 = Math.sin(a2), A2 = Math.cos(a2), x2 = o2.data.get(r2.dataId).values;
  for (let y2 = 0; u2 > y2; y2++) {
    let e21 = y2 * c2 * d2 * h2;
    for (let t3 = 0; d2 > t3; t3++) {
      let n3 = t3 * c2 * h2;
      for (let r3 = 0; c2 > r3; r3++) {
        let a3 = r3 * h2;
        for (let s3 = 0; h2 > s3; s3++) {
          let o3 = [u2, t3, r3, s3], y3 = o3[2], b2 = o3[1], g2 = (y3 - p2) * A2 - (b2 - f2) * m2, v2 = (y3 - p2) * m2 + (b2 - f2) * A2;
          g2 = Math.round(g2 + p2), v2 = Math.round(v2 + f2);
          let w2 = i2;
          "number" != typeof i2 && (w2 = 3 === s3 ? 255 : i2[s3]), g2 >= 0 && c2 > g2 && v2 >= 0 && d2 > v2 && (w2 = x2[e21 + v2 * c2 * h2 + g2 * h2 + s3]), l2[e21 + n3 + a3 + s3] = w2;
        }
      }
    }
  }
  return { dataId: o2.write(l2, r2.shape, r2.dtype), shape: r2.shape, dtype: r2.dtype };
} };
var vk = py(fr, (e20) => {
  let t2 = Math.floor(e20);
  return 0.5 > e20 - t2 ? Math.floor(e20) : e20 - t2 > 0.5 ? Math.ceil(e20) : t2 % 2 == 0 ? t2 : t2 + 1;
});
var wk = { kernelName: fr, backendName: "cpu", kernelFunc: vk };
var kk = { kernelName: Ar, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { indices: a2, updates: i2 } = t2, { shape: s2 } = r2, { sliceRank: o2, numUpdates: l2, sliceSize: u2, strides: d2, outputSize: c2 } = Uf.calculateShapes(i2, a2, s2), h2 = Tb(n2.bufferSync(a2), n2.bufferSync(i2), s2, c2, u2, l2, o2, d2, 0, true);
  return n2.makeTensorInfo(s2, h2.dtype, h2.values);
} };
function Nk(e20, t2) {
  let n2 = 0, r2 = e20.length, a2 = 0;
  for (; r2 > n2; ) a2 = Math.floor((n2 + r2) / 2), t2 > e20[a2] ? n2 = a2 + 1 : r2 = a2;
  return r2;
}
function Ck(e20, t2) {
  let n2 = 0, r2 = e20.length, a2 = 0;
  for (; r2 > n2; ) a2 = Math.floor((n2 + r2) / 2), e20[a2] > t2 ? r2 = a2 : n2 = a2 + 1;
  return r2;
}
var $k = { kernelName: yr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { sortedSequence: a2, values: i2 } = t2, { side: s2 } = r2, o2 = ((e21, t3, n3, r3, a3, i3) => {
    let s3 = va.getArrayFromDType("int32", n3 * a3);
    for (let o3 = 0; n3 > o3; ++o3) {
      let n4 = e21.slice(o3 * r3, (o3 + 1) * r3), l2 = o3 * a3;
      for (let e22 = 0; a3 > e22; ++e22) s3[l2 + e22] = "left" === i3 ? Nk(n4, t3[e22 + l2]) : Ck(n4, t3[e22 + l2]);
    }
    return s3;
  })(n2.data.get(a2.dataId).values, n2.data.get(i2.dataId).values, a2.shape[0], a2.shape[1], i2.shape[1], s2);
  return n2.makeTensorInfo(i2.shape, "int32", o2);
} };
var Rk = { kernelName: br, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { condition: r2, t: a2, e: i2 } = t2;
  _x([r2, a2, i2], "select");
  let s2 = r2.shape.length, o2 = n2.data.get(r2.dataId).values, l2 = n2.data.get(a2.dataId).values, u2 = n2.data.get(i2.dataId).values, d2 = pi(a2.dtype, i2.dtype), c2 = va.makeZerosTypedArray(va.sizeFromShape(a2.shape), d2), h2 = 0, p2 = 0 === s2 || s2 > 1 || 1 === a2.shape.length ? 1 : va.sizeFromShape(a2.shape.slice(1));
  for (let f2 = 0; o2.length > f2; f2++) for (let e21 = 0; p2 > e21; e21++) c2[h2++] = 1 === o2[f2] ? l2[f2] : u2[f2];
  return n2.makeTensorInfo(a2.shape, d2, c2);
} };
var Sk = Uf.SELU_SCALEALPHA;
var Ik = Uf.SELU_SCALE;
var Ek = py(gr, (e20) => 0 > e20 ? Sk * (Math.exp(e20) - 1) : Ik * e20);
var Tk = { kernelName: gr, backendName: "cpu", kernelFunc: Ek };
var Mk = py(Nr, (e20) => 0 > e20 ? -1 : e20 > 0 ? 1 : 0);
var Ok = { kernelName: Nr, backendName: "cpu", kernelFunc: Mk };
var Fk = py("Sin", (e20) => Math.sin(e20));
var Pk = { kernelName: "Sin", backendName: "cpu", kernelFunc: Fk };
var zk = py(kr, (e20) => Math.sinh(e20));
var Vk = { kernelName: kr, backendName: "cpu", kernelFunc: zk };
var _k = -13.942385152878742;
var Dk = py($r, (e20) => {
  let t2, n2 = e20 > -_k, r2 = _k > e20, a2 = Math.exp(e20);
  return t2 = r2 ? a2 : n2 ? e20 : Math.log(1 + a2), t2;
});
var Wk = { kernelName: $r, backendName: "cpu", kernelFunc: Dk };
var Lk = { kernelName: Ir, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockShape: i2, paddings: s2 } = r2;
  _x([a2], "spaceToBatchND");
  let o2 = va.sizeFromShape(i2), l2 = [[0, 0]];
  l2.push(...s2);
  for (let A2 = 1 + i2.length; a2.shape.length > A2; ++A2) l2.push([0, 0]);
  let u2 = sk.kernelFunc({ inputs: { x: a2 }, backend: n2, attrs: { paddings: l2, constantValue: 0 } }), d2 = Uf.getReshaped(u2.shape, i2, o2, false), c2 = Uf.getPermuted(d2.length, i2.length, false), h2 = Uf.getReshapedPermuted(u2.shape, i2, o2, false), p2 = Ng({ inputs: { x: u2 }, backend: n2, attrs: { shape: d2 } }), f2 = fb({ inputs: { x: p2 }, backend: n2, attrs: { perm: c2 } }), m2 = Ng({ inputs: { x: f2 }, backend: n2, attrs: { shape: h2 } });
  return n2.disposeIntermediateTensorInfo(u2), n2.disposeIntermediateTensorInfo(p2), n2.disposeIntermediateTensorInfo(f2), m2;
} };
var Bk = { kernelName: Mr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { indices: r2, values: a2, denseShape: i2, defaultValue: s2 } = t2;
  if (1 !== i2.shape.length) throw Error("Dense shape must be a vector, saw:\n        " + i2.shape);
  if (2 !== r2.shape.length) throw Error("Indices must be a matrix, saw:\n        " + r2.shape);
  if (1 !== a2.shape.length) throw Error("Values must be a vector, saw:\n        " + a2.shape);
  if (0 !== s2.shape.length) throw Error("Default value must be a scalar, saw:\n        " + s2.shape);
  let o2 = n2.data.get(r2.dataId).values, l2 = n2.data.get(a2.dataId).values, u2 = n2.data.get(i2.dataId).values, d2 = n2.data.get(s2.dataId).values[0], [c2, h2, p2, f2, m2] = _b(o2, r2.shape, r2.dtype, l2, a2.dtype, u2, d2);
  return [n2.makeTensorInfo(h2, r2.dtype, c2), n2.makeTensorInfo([h2[0]], a2.dtype, p2), n2.makeTensorInfo([f2.length], "bool", new Uint8Array(f2.map((e21) => +e21))), n2.makeTensorInfo([m2.length], r2.dtype, new Int32Array(m2))];
} };
var Uk = { kernelName: Or, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { inputIndices: r2, inputShape: a2, newShape: i2 } = t2;
  if (2 !== r2.shape.length) throw Error("Input indices should be a matrix but received shape\n        " + r2.shape);
  if (1 !== a2.shape.length) throw Error("Input shape should be a vector but received shape\n        " + a2.shape);
  if (1 !== i2.shape.length) throw Error("Target shape should be a vector but received shape " + i2.shape);
  let s2 = Array.from(n2.data.get(a2.dataId).values), o2 = n2.data.get(r2.dataId).values, l2 = Array.from(n2.data.get(i2.dataId).values), [u2, d2, c2] = Db(o2, r2.shape, r2.dtype, s2, l2);
  return [n2.makeTensorInfo(d2, r2.dtype, u2), n2.makeTensorInfo([c2.length], i2.dtype, new Int32Array(c2))];
} };
var jk = { kernelName: Fr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { data: r2, indices: a2, segmentIds: i2 } = t2;
  if (1 > r2.shape.length) throw Error("Data should be at least 1 dimensional but received scalar");
  if (1 !== a2.shape.length) throw Error("Indices should be a vector but received shape\n          " + a2.shape);
  if (1 !== i2.shape.length) throw Error("Segment ids should be a vector but received shape\n          " + i2.shape);
  if (a2.shape[0] !== i2.shape[0]) throw Error("segmentIds and indices should have same size.");
  let s2 = n2.data.get(r2.dataId).values, o2 = n2.data.get(a2.dataId).values, l2 = n2.data.get(i2.dataId).values, [u2, d2] = Wb(s2, r2.shape, r2.dtype, o2, l2, true);
  return n2.makeTensorInfo(d2, r2.dtype, u2);
} };
var Gk = { kernelName: Pr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { data: r2, indices: a2, segmentIds: i2 } = t2;
  if (1 > r2.shape.length) throw Error("Data should be at least 1 dimensional but received scalar");
  if (1 !== a2.shape.length) throw Error("Indices should be a vector but received shape\n         " + a2.shape);
  if (1 !== i2.shape.length) throw Error("Segment ids should be a vector but received shape\n         " + i2.shape);
  if (a2.shape[0] !== i2.shape[0]) throw Error("segmentIds and indices should have same size.");
  let s2 = n2.data.get(r2.dataId).values, o2 = n2.data.get(a2.dataId).values, l2 = n2.data.get(i2.dataId).values, [u2, d2] = Wb(s2, r2.shape, r2.dtype, o2, l2);
  return n2.makeTensorInfo(d2, r2.dtype, u2);
} };
var Hk = { kernelName: zr, backendName: "cpu", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { sparseIndices: i2, sparseValues: s2, defaultValue: o2 } = n2, { outputShape: l2 } = a2, { sliceRank: u2, numUpdates: d2, sliceSize: c2, strides: h2, outputSize: p2 } = Uf.calculateShapes(s2, i2, l2), f2 = false, m2 = r2.bufferSync(i2);
  switch (s2.dtype) {
    case "bool":
      t2 = Tb(m2, r2.bufferSync(s2), l2, p2, c2, d2, u2, h2, !!r2.data.get(o2.dataId).values[0], f2);
      break;
    case "float32":
    case "int32":
      t2 = Tb(m2, r2.bufferSync(s2), l2, p2, c2, d2, u2, h2, r2.data.get(o2.dataId).values[0], f2);
      break;
    case "string":
      t2 = Tb(m2, r2.bufferSync(s2), l2, p2, c2, d2, u2, h2, va.decodeString(r2.data.get(o2.dataId).values[0]), f2);
      break;
    default:
      throw Error("Unsupported type " + s2.dtype);
  }
  return r2.makeTensorInfo(l2, t2.dtype, t2.values);
} };
var Xk = { kernelName: Er, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { numOrSizeSplits: i2, axis: s2 } = r2, o2 = va.parseAxisParam(s2, a2.shape)[0], l2 = Uf.prepareSplitSize(a2, i2, o2), u2 = Array(a2.shape.length).fill(0), d2 = a2.shape.slice();
  return l2.map((e21) => {
    let t3 = [...d2];
    t3[o2] = e21;
    let r3 = zb({ inputs: { x: a2 }, backend: n2, attrs: { begin: u2, size: t3 } });
    return u2[o2] += e21, r3;
  });
} };
var qk = { kernelName: _r, backendName: "cpu", kernelFunc({ inputs: e20, backend: t2 }) {
  let { x: n2 } = e20, r2 = t2;
  _x(n2, "square");
  let a2 = r2.data.get(n2.dataId).values, i2 = new Float32Array(a2.length);
  for (let s2 = 0; a2.length > s2; ++s2) {
    let e21 = a2[s2];
    i2[s2] = e21 * e21;
  }
  return { dataId: r2.write(i2, n2.shape, n2.dtype), shape: n2.shape, dtype: n2.dtype };
} };
var Zk = py(na, (e20, t2) => {
  let n2 = t2;
  return isNaN(e20) ? NaN : e20 > 0 ? 1 : n2.alpha;
});
var Kk = { kernelName: na, backendName: "cpu", kernelFunc: Zk };
var Yk = { kernelName: Wr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { begin: i2, end: s2, strides: o2, beginMask: l2, endMask: u2, ellipsisMask: d2, newAxisMask: c2, shrinkAxisMask: h2 } = r2;
  _x(a2, "stridedSlice");
  let p2, { finalShapeSparse: f2, finalShape: m2, isIdentity: A2, sliceDim0: x2, isSimpleSlice: y2, begin: b2, end: g2, strides: v2 } = xf.sliceInfo(a2.shape, i2, s2, o2, l2, u2, d2, c2, h2);
  if (A2) p2 = Ng({ inputs: { x: a2 }, backend: n2, attrs: { shape: m2 } });
  else if (x2 || y2) {
    va.assert(a2.shape.length >= 1, () => "Input must have rank at least 1, got: " + a2.shape.length);
    let e21 = xf.computeOutShape(b2, g2, v2), t3 = zb({ inputs: { x: a2 }, backend: n2, attrs: { begin: b2, size: e21 } });
    p2 = Ng({ inputs: { x: t3 }, backend: n2, attrs: { shape: m2 } }), n2.disposeIntermediateTensorInfo(t3);
  } else {
    let e21 = Kb(f2, n2.bufferSync(a2), v2, b2);
    p2 = n2.makeTensorInfo(m2, e21.dtype, e21.values);
  }
  return p2;
} };
var Jk = { kernelName: Lr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { separator: a2, nGramWidths: i2, leftPad: s2, rightPad: o2, padWidth: l2, preserveShortSequences: u2 } = r2, { data: d2, dataSplits: c2 } = t2, h2 = n2.data.get(d2.dataId).values, p2 = n2.data.get(c2.dataId).values, [f2, m2] = Jb(h2, p2, a2, i2, s2, o2, l2, u2);
  return [n2.makeTensorInfo([f2.length], "string", f2), n2.makeTensorInfo(c2.shape, "int32", m2)];
} };
var Qk = { kernelName: Br, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { skipEmpty: a2 } = r2, { input: i2, delimiter: s2 } = t2;
  if ("string" !== i2.dtype) throw Error("Input must be of datatype string");
  if (1 !== i2.shape.length) throw Error("Input must be a vector, got shape: " + i2.shape);
  if (0 !== s2.shape.length) throw Error("Delimiter must be a scalar, got shape: " + s2.shape);
  let o2 = n2.data.get(i2.dataId).values, l2 = n2.data.get(s2.dataId).values[0], [u2, d2, c2] = eg(o2, l2, a2), h2 = d2.length;
  return [n2.makeTensorInfo([h2, 2], "int32", u2), n2.makeTensorInfo([h2], "string", d2), n2.makeTensorInfo([2], "int32", new Int32Array(c2))];
} };
var eN = { kernelName: Ur, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { numBuckets: a2 } = r2, { input: i2 } = t2;
  if ("string" !== i2.dtype) throw Error("Input must be of datatype string");
  if (0 >= a2) throw Error("Number of buckets must be at least 1");
  let s2 = tg(n2.data.get(i2.dataId).values, a2);
  return n2.makeTensorInfo(i2.shape, "int32", s2);
} };
var tN = py("Tan", (e20) => Math.tan(e20));
var nN = { kernelName: "Tan", backendName: "cpu", kernelFunc: tN };
var rN = py(Hr, (e20) => Math.tanh(e20));
var aN = { kernelName: Hr, backendName: "cpu", kernelFunc: rN };
var iN = { kernelName: xr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { tensor: r2, indices: a2, updates: i2 } = t2, { sliceRank: s2, numUpdates: o2, sliceSize: l2, strides: u2, outputSize: d2 } = Uf.calculateShapes(i2, a2, r2.shape), c2 = n2.bufferSync(a2), h2 = n2.bufferSync(i2), p2 = n2.bufferSync(r2), f2 = Tb(c2, h2, r2.shape, d2, l2, o2, s2, u2, p2, false);
  return n2.makeTensorInfo(r2.shape, f2.dtype, f2.values);
} };
var sN = { kernelName: Xr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { reps: i2 } = r2;
  _x(a2, "tile");
  let s2 = sg(n2.bufferSync(a2), i2);
  return n2.makeTensorInfo(s2.shape, s2.dtype, s2.values);
} };
var oN = { kernelName: qr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { k: i2, sorted: s2 } = r2;
  _x(a2, "topk");
  let o2 = n2.data.get(a2.dataId).values, [l2, u2] = ug(o2, a2.shape, a2.dtype, i2, s2);
  return [n2.makeTensorInfo(l2.shape, l2.dtype, l2.values), n2.makeTensorInfo(u2.shape, u2.dtype, u2.values)];
} };
var lN = { kernelName: Zr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { image: a2, transforms: i2 } = t2, { interpolation: s2, fillMode: o2, fillValue: l2, outputShape: u2 } = n2, [d2, c2, h2, p2] = a2.shape, [f2, m2] = null != u2 ? u2 : [c2, h2], A2 = [d2, f2, m2, p2], x2 = va.computeStrides(a2.shape), y2 = x2[0], b2 = x2[1], g2 = x2[2], v2 = va.computeStrides(A2), w2 = v2[0], k2 = v2[1], N2 = v2[2], C2 = va.getTypedArrayFromDType(a2.dtype, va.sizeFromShape(A2));
  C2.fill(l2);
  let $2 = r2.data.get(a2.dataId).values, R2 = r2.data.get(i2.dataId).values;
  for (let S2 = 0; d2 > S2; ++S2) {
    let e21 = 1 === i2.shape[0] ? R2 : R2.subarray(8 * S2, 8 * S2 + 8);
    for (let t3 = 0; f2 > t3; ++t3) for (let n3 = 0; m2 > n3; ++n3) for (let r3 = 0; p2 > r3; ++r3) {
      let a3, i3 = e21[6] * n3 + e21[7] * t3 + 1;
      if (0 === i3) continue;
      let u3 = (e21[3] * n3 + e21[4] * t3 + e21[5]) / i3, d3 = uN((e21[0] * n3 + e21[1] * t3 + e21[2]) / i3, h2, o2), p3 = uN(u3, c2, o2);
      switch (s2) {
        case "nearest":
          a3 = cN($2, c2, h2, y2, b2, g2, S2, p3, d3, r3, l2);
          break;
        case "bilinear":
          a3 = hN($2, c2, h2, y2, b2, g2, S2, p3, d3, r3, l2);
          break;
        default:
          throw Error("Error in Transform: Expect 'nearest' or 'bilinear', but got " + s2);
      }
      C2[S2 * w2 + t3 * k2 + n3 * N2 + r3] = a3;
    }
    return r2.makeTensorInfo(A2, a2.dtype, C2);
  }
  return { dataId: r2.write(C2, A2, a2.dtype), shape: a2.shape, dtype: a2.dtype };
} };
function uN(e20, t2, n2) {
  switch (n2) {
    case "reflect":
      return ((e21, t3) => {
        let n3 = e21;
        if (0 > n3) if (t3 > 1) {
          let e22 = 2 * t3;
          e22 > n3 && (n3 = e22 * Math.trunc(-n3 / e22) + n3), n3 = -t3 > n3 ? n3 + e22 : -n3 - 1;
        } else n3 = 0;
        else if (n3 > t3 - 1) if (t3 > 1) {
          let e22 = 2 * t3;
          n3 -= e22 * Math.trunc(n3 / e22), n3 >= t3 && (n3 = e22 - n3 - 1);
        } else n3 = 0;
        return va.clamp(0, n3, t3 - 1);
      })(e20, t2);
    case "wrap":
      return ((e21, t3) => {
        let n3 = e21;
        return 0 > n3 ? t3 > 1 ? n3 += t3 * (Math.trunc(-n3 / (t3 - 1)) + 1) : n3 = 0 : n3 > t3 - 1 && (t3 > 1 ? n3 -= t3 * Math.trunc(n3 / (t3 - 1)) : n3 = 0), va.clamp(0, n3, t3 - 1);
      })(e20, t2);
    case "nearest":
      return ((e21, t3) => va.clamp(0, e21, t3 - 1))(e20, t2);
    default:
      return e20;
  }
}
function dN(e20, t2, n2, r2, a2, i2, s2, o2, l2, u2, d2) {
  return o2 >= 0 && t2 > o2 && l2 >= 0 && n2 > l2 ? e20[s2 * r2 + o2 * a2 + l2 * i2 + u2] : d2;
}
function cN(e20, t2, n2, r2, a2, i2, s2, o2, l2, u2, d2) {
  return dN(e20, t2, n2, r2, a2, i2, s2, Math.round(o2), Math.round(l2), u2, d2);
}
function hN(e20, t2, n2, r2, a2, i2, s2, o2, l2, u2, d2) {
  let c2 = Math.floor(o2), h2 = Math.floor(l2), p2 = c2 + 1, f2 = h2 + 1;
  return (p2 - o2) * ((f2 - l2) * dN(e20, t2, n2, r2, a2, i2, s2, c2, h2, u2, d2) + (l2 - h2) * dN(e20, t2, n2, r2, a2, i2, s2, c2, f2, u2, d2)) + (o2 - c2) * ((f2 - l2) * dN(e20, t2, n2, r2, a2, i2, s2, p2, h2, u2, d2) + (l2 - h2) * dN(e20, t2, n2, r2, a2, i2, s2, p2, f2, u2, d2));
}
var pN = { kernelName: Yr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { axis: a2 } = n2, { x: i2 } = t2;
  _x(i2, "unique");
  let s2 = r2.data.get(i2.dataId).values, { outputValues: o2, outputShape: l2, indices: u2 } = dg(s2, a2, i2.shape, i2.dtype);
  return [r2.makeTensorInfo(l2, i2.dtype, o2), r2.makeTensorInfo([u2.length], "int32", u2)];
} };
var fN = { kernelName: Jr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { value: a2 } = t2, { axis: i2 } = r2;
  0 > i2 && (i2 += a2.shape.length);
  let s2 = a2.shape.length, o2 = a2.shape[i2], l2 = Array(s2 - 1), u2 = 0;
  for (let p2 = 0; s2 > p2; p2++) p2 !== i2 && (l2[u2++] = a2.shape[p2]);
  let d2 = Array(s2).fill(0), c2 = a2.shape.slice();
  c2[i2] = 1;
  let h2 = Array(o2);
  for (let p2 = 0; h2.length > p2; p2++) {
    d2[i2] = p2;
    let e21 = zb({ inputs: { x: a2 }, backend: n2, attrs: { begin: d2, size: c2 } });
    h2[p2] = Ng({ inputs: { x: e21 }, backend: n2, attrs: { shape: l2 } }), n2.disposeIntermediateTensorInfo(e21);
  }
  return h2;
} };
var mN = { kernelName: Qr, backendName: "cpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, segmentIds: i2 } = t2, { numSegments: s2 } = r2;
  _x(a2, "unsortedSegmentSum");
  let o2 = [], l2 = [], u2 = a2.shape.length - i2.shape.length, d2 = i2;
  for (let h2 = 0; u2 > h2; ++h2) {
    let e21 = Kv({ inputs: { input: d2 }, backend: n2, attrs: { dim: h2 + 1 } });
    d2 = e21, l2.push(e21);
  }
  for (let h2 = 0; s2 > h2; ++h2) {
    let e21 = va.createScalarValue(h2, "int32"), t3 = n2.makeTensorInfo([], "int32", e21), r3 = gy({ inputs: { a: t3, b: d2 }, backend: n2 }), i3 = Qx({ inputs: { x: r3 }, backend: n2, attrs: { dtype: "float32" } }), s3 = sb({ inputs: { a: i3, b: a2 }, backend: n2 }), u3 = _v({ inputs: { x: s3 }, backend: n2, attrs: { axis: 0, keepDims: false } });
    o2.push(u3), l2.push(t3), l2.push(r3), l2.push(i3), l2.push(s3), l2.push(u3);
  }
  let c2 = ak({ inputs: o2, backend: n2, attrs: { axis: 0 } });
  return l2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), c2;
} };
var AN = [Sg, Ux, Eg, Mg, sy, Og, Fg, Pg, zg, Vg, Dg, Lg, Ug, Hg, qg, Jg, Qg, ev, tv, Rg, nv, rv, av, cy, iv, ey, xy, ov, Hx, lv, hv, fv, mv, Av, xv, yv, bv, vv, kv, Nv, Cv, $v, Rv, Sv, Ev, Tv, Mv, Ov, Fv, Pv, zv, Vv, Wv, pg, Lv, vy, Zv, Ny, Yv, Ry, aw, sw, ow, Ey, Oy, lw, uw, dw, cw, _y, Ly, Zx, hw, dv, fw, Aw, yw, mg, jy, Xy, bw, Ky, vw, Nw, $w, Iw, Ew, Tw, Ow, eb, Fw, Pw, zw, Vw, _w, Dw, Ww, rb, Lw, Uw, Xw, ob, ub, Zw, Yw, Qw, hb, ek, rk, ik, sk, lk, yg, xb, uk, dk, ck, hk, Yx, ew, fk, gg, wg, Cg, mk, Ak, xk, yk, bk, gk, wk, Eb, kk, $k, Rk, Tk, Fb, Ok, Pk, Vk, Vb, Hw, Wk, Lk, Bk, Uk, jk, Gk, Hk, Xk, Ub, qk, Hb, Zb, Kk, Yk, Jk, Qk, eN, ig, Dv, nN, aN, iN, sN, oN, lN, mb, pN, fN, mN, nk];
for (let a0 of AN) ma(a0);
var xN = {};
A(xN, { assertNotComplex() {
  return $C;
}, bindCanvasToFramebuffer() {
  return nC;
}, bindColorTextureToFramebuffer() {
  return rC;
}, bindTextureToProgramUniformSampler() {
  return tC;
}, bindTextureUnit() {
  return YN;
}, bindVertexBufferToProgramAttribute() {
  return KN;
}, callAndCheck() {
  return IN;
}, canBeRepresented() {
  return MN;
}, createFragmentShader() {
  return zN;
}, createFramebuffer() {
  return ZN;
}, createProgram() {
  return LN;
}, createStaticIndexBuffer() {
  return GN;
}, createStaticVertexBuffer() {
  return jN;
}, createTexture() {
  return XN;
}, createVertexShader() {
  return PN;
}, getBatchDim() {
  return uC;
}, getExtensionOrThrow() {
  return FN;
}, getFramebufferErrorMessage() {
  return sC;
}, getMaxTexturesInShader() {
  return yC;
}, getNumChannels() {
  return HN;
}, getProgramUniformLocation() {
  return eC;
}, getProgramUniformLocationOrThrow() {
  return QN;
}, getRowsCols() {
  return dC;
}, getShapeAs3D() {
  return cC;
}, getTextureShapeFromLogicalShape() {
  return hC;
}, getWebGLDisjointQueryTimerVersion() {
  return bC;
}, getWebGLErrorMessage() {
  return ON;
}, getWebGLMaxTextureSize() {
  return mC;
}, hasExtension() {
  return gC;
}, isCapableOfRenderingToFloatTexture() {
  return wC;
}, isDownloadFloatTextureEnabled() {
  return kC;
}, isReshapeFree() {
  return fC;
}, isWebGLFenceEnabled() {
  return CC;
}, isWebGLVersionEnabled() {
  return vC;
}, linkProgram() {
  return BN;
}, logShaderSourceAndInfoLog() {
  return WN;
}, resetMaxTextureSize() {
  return AC;
}, resetMaxTexturesInShader() {
  return xC;
}, unbindColorTextureFromFramebuffer() {
  return aC;
}, unbindTextureUnit() {
  return JN;
}, validateFramebuffer() {
  return iC;
}, validateProgram() {
  return UN;
}, validateTextureSize() {
  return qN;
} });
var yN;
var bN;
var gN;
var vN = {};
var wN = { alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true };
function kN(e20, t2) {
  vN[e20] = t2;
}
function NN(e20, t2) {
  if (!(e20 in vN) || null != t2) {
    let n3 = ((e21, t3) => {
      if (1 !== e21 && 2 !== e21) throw Error("Cannot get WebGL rendering context, WebGL is disabled.");
      let n4 = t3 ?? ((e22) => {
        if (!_e().getBool("IS_SAFARI") && "undefined" != typeof OffscreenCanvas && 2 === e22) return new OffscreenCanvas(300, 150);
        if ("undefined" != typeof document) return document.createElement("canvas");
        throw Error("Cannot create a canvas in this context");
      })(e21);
      return n4.addEventListener("webglcontextlost", (t4) => {
        t4.preventDefault(), delete vN[e21];
      }, false), _e().getBool("SOFTWARE_WEBGL_ENABLED") && (wN.failIfMajorPerformanceCaveat = false), 1 === e21 ? n4.getContext("webgl", wN) || n4.getContext("experimental-webgl", wN) : n4.getContext("webgl2", wN);
    })(e20, t2);
    if (null === n3) return console.log("Could not get context for WebGL version", e20), null;
    vN[e20] = n3;
  }
  let n2 = vN[e20];
  return null == n2 || n2.isContextLost() ? (delete vN[e20], NN(e20)) : (n2.disable(n2.DEPTH_TEST), n2.disable(n2.STENCIL_TEST), n2.disable(n2.BLEND), n2.disable(n2.DITHER), n2.disable(n2.POLYGON_OFFSET_FILL), n2.disable(n2.SAMPLE_COVERAGE), n2.enable(n2.SCISSOR_TEST), n2.enable(n2.CULL_FACE), n2.cullFace(n2.BACK), vN[e20]);
}
function CN(e20, t2) {
  return [t2, e20];
}
function $N(e20) {
  let t2 = va.sizeFromShape(e20);
  return va.sizeToSquarishShape(Math.ceil(t2 / 4));
}
function RN(e20, t2) {
  return [Math.max(1, Math.ceil(t2 / 2)), Math.max(1, Math.ceil(e20 / 2))];
}
function SN(e20, t2) {
  let n2, r2, a2, i2, s2, o2, l2, u2, d2, c2, h2 = e20;
  return 2 === _e().getNumber("WEBGL_VERSION") ? (n2 = h2.R32F, r2 = h2.R16F, a2 = h2.RGBA16F, i2 = h2.RGBA32F, s2 = h2.RED, l2 = 4, u2 = 1, d2 = h2.HALF_FLOAT, c2 = h2.FLOAT, o2 = h2.RGBA8) : (n2 = e20.RGBA, r2 = e20.RGBA, a2 = e20.RGBA, i2 = h2.RGBA, s2 = e20.RGBA, l2 = 4, u2 = 4, d2 = null != t2 ? t2.HALF_FLOAT_OES : null, c2 = e20.FLOAT, o2 = e20.RGBA), { internalFormatFloat: n2, internalFormatHalfFloat: r2, internalFormatPackedHalfFloat: a2, internalFormatPackedFloat: i2, textureFormatFloat: s2, downloadTextureFormat: o2, downloadUnpackNumChannels: l2, defaultNumChannels: u2, textureTypeHalfFloat: d2, textureTypeFloat: c2 };
}
function IN(e20, t2) {
  let n2 = t2();
  return _e().getBool("DEBUG") && ((e21) => {
    let t3 = e21.getError();
    if (t3 !== e21.NO_ERROR) throw Error("WebGL Error: " + ON(e21, t3));
  })(e20), n2;
}
((e20) => {
  e20[e20.DENSE = 0] = "DENSE", e20[e20.SHARED_BATCH = 1] = "SHARED_BATCH";
})(yN || (yN = {})), ((e20) => {
  e20[e20.RENDER = 0] = "RENDER", e20[e20.UPLOAD = 1] = "UPLOAD", e20[e20.PIXELS = 2] = "PIXELS", e20[e20.DOWNLOAD = 3] = "DOWNLOAD";
})(bN || (bN = {})), ((e20) => {
  e20[e20.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e20[e20.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e20[e20.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e20[e20.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e20[e20.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
})(gN || (gN = {}));
var EN = 596e-10;
var TN = 65504;
function MN(e20) {
  return !!(_e().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === e20 || Math.abs(e20) > EN && TN > Math.abs(e20));
}
function ON(e20, t2) {
  switch (t2) {
    case e20.NO_ERROR:
      return "NO_ERROR";
    case e20.INVALID_ENUM:
      return "INVALID_ENUM";
    case e20.INVALID_VALUE:
      return "INVALID_VALUE";
    case e20.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case e20.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case e20.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case e20.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return "Unknown error code " + t2;
  }
}
function FN(e20, t2) {
  return oC(e20, () => e20.getExtension(t2), 'Extension "' + t2 + '" not supported on this browser.');
}
function PN(e20, t2) {
  let n2 = oC(e20, () => e20.createShader(e20.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
  if (IN(e20, () => e20.shaderSource(n2, t2)), IN(e20, () => e20.compileShader(n2)), false === e20.getShaderParameter(n2, e20.COMPILE_STATUS)) throw console.log(e20.getShaderInfoLog(n2)), Error("Failed to compile vertex shader.");
  return n2;
}
function zN(e20, t2) {
  let n2 = oC(e20, () => e20.createShader(e20.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
  if (IN(e20, () => e20.shaderSource(n2, t2)), IN(e20, () => e20.compileShader(n2)), _e().get("ENGINE_COMPILE_ONLY")) return n2;
  if (false === e20.getShaderParameter(n2, e20.COMPILE_STATUS)) throw WN(t2, e20.getShaderInfoLog(n2)), Error("Failed to compile fragment shader.");
  return n2;
}
var VN;
var _N;
var DN = /ERROR: [0-9]+:([0-9]+):/g;
function WN(e20, t2) {
  let n2 = DN.exec(t2);
  if (null == n2) return console.log("Couldn't parse line number in error: " + t2), void console.log(e20);
  let r2 = +n2[1], a2 = e20.split("\n"), i2 = ("" + a2.length).length + 2, s2 = a2.map((e21, t3) => va.rightPad("" + (t3 + 1), i2) + e21), o2 = 0;
  for (let c2 = 0; s2.length > c2; c2++) o2 = Math.max(s2[c2].length, o2);
  let l2 = s2.slice(0, r2 - 1), u2 = s2.slice(r2 - 1, r2), d2 = s2.slice(r2);
  console.log(l2.join("\n")), console.log(t2.split("\n")[0]), console.log("%c " + va.rightPad(u2[0], o2), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(d2.join("\n"));
}
function LN(e20) {
  return oC(e20, () => e20.createProgram(), "Unable to create WebGLProgram.");
}
function BN(e20, t2) {
  if (IN(e20, () => e20.linkProgram(t2)), !_e().get("ENGINE_COMPILE_ONLY") && false === e20.getProgramParameter(t2, e20.LINK_STATUS)) throw console.log(e20.getProgramInfoLog(t2)), Error("Failed to link vertex and fragment shaders.");
}
function UN(e20, t2) {
  if (IN(e20, () => e20.validateProgram(t2)), false === e20.getProgramParameter(t2, e20.VALIDATE_STATUS)) throw console.log(e20.getProgramInfoLog(t2)), Error("Shader program validation failed.");
}
function jN(e20, t2) {
  let n2 = oC(e20, () => e20.createBuffer(), "Unable to create WebGLBuffer");
  return IN(e20, () => e20.bindBuffer(e20.ARRAY_BUFFER, n2)), IN(e20, () => e20.bufferData(e20.ARRAY_BUFFER, t2, e20.STATIC_DRAW)), n2;
}
function GN(e20, t2) {
  let n2 = oC(e20, () => e20.createBuffer(), "Unable to create WebGLBuffer");
  return IN(e20, () => e20.bindBuffer(e20.ELEMENT_ARRAY_BUFFER, n2)), IN(e20, () => e20.bufferData(e20.ELEMENT_ARRAY_BUFFER, t2, e20.STATIC_DRAW)), n2;
}
function HN() {
  return 2 === _e().getNumber("WEBGL_VERSION") ? 1 : 4;
}
function XN(e20) {
  return oC(e20, () => e20.createTexture(), "Unable to create WebGLTexture.");
}
function qN(e20, t2) {
  let n2 = _e().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (0 >= e20 || 0 >= t2) throw Error(`Requested texture size [${e20}x${t2}] is invalid.`);
  if (e20 > n2 || t2 > n2) throw Error(`Requested texture size [${e20}x${t2}] greater than WebGL maximum on this browser / GPU [${n2}x${n2}].`);
}
function ZN(e20) {
  return oC(e20, () => e20.createFramebuffer(), "Unable to create WebGLFramebuffer.");
}
function KN(e20, t2, n2, r2, a2, i2, s2) {
  let o2 = e20.getAttribLocation(t2, n2);
  return -1 !== o2 && (IN(e20, () => e20.bindBuffer(e20.ARRAY_BUFFER, r2)), IN(e20, () => e20.vertexAttribPointer(o2, a2, e20.FLOAT, false, i2, s2)), IN(e20, () => e20.enableVertexAttribArray(o2)), true);
}
function YN(e20, t2, n2) {
  lC(e20, n2), IN(e20, () => e20.activeTexture(e20.TEXTURE0 + n2)), IN(e20, () => e20.bindTexture(e20.TEXTURE_2D, t2));
}
function JN(e20, t2) {
  lC(e20, t2), IN(e20, () => e20.activeTexture(e20.TEXTURE0 + t2)), IN(e20, () => e20.bindTexture(e20.TEXTURE_2D, null));
}
function QN(e20, t2, n2) {
  return oC(e20, () => e20.getUniformLocation(t2, n2), 'uniform "' + n2 + '" not present in program.');
}
function eC(e20, t2, n2) {
  return e20.getUniformLocation(t2, n2);
}
function tC(e20, t2, n2, r2) {
  IN(e20, () => YN(e20, t2, r2)), IN(e20, () => e20.uniform1i(n2, r2));
}
function nC(e20) {
  IN(e20, () => e20.bindFramebuffer(e20.FRAMEBUFFER, null)), IN(e20, () => e20.viewport(0, 0, e20.canvas.width, e20.canvas.height)), IN(e20, () => e20.scissor(0, 0, e20.canvas.width, e20.canvas.height));
}
function rC(e20, t2, n2) {
  IN(e20, () => e20.bindFramebuffer(e20.FRAMEBUFFER, n2)), IN(e20, () => e20.framebufferTexture2D(e20.FRAMEBUFFER, e20.COLOR_ATTACHMENT0, e20.TEXTURE_2D, t2, 0));
}
function aC(e20, t2) {
  IN(e20, () => e20.bindFramebuffer(e20.FRAMEBUFFER, t2)), IN(e20, () => e20.framebufferTexture2D(e20.FRAMEBUFFER, e20.COLOR_ATTACHMENT0, e20.TEXTURE_2D, null, 0));
}
function iC(e20) {
  let t2 = e20.checkFramebufferStatus(e20.FRAMEBUFFER);
  if (t2 !== e20.FRAMEBUFFER_COMPLETE) throw Error("Error binding framebuffer: " + sC(e20, t2));
}
function sC(e20, t2) {
  switch (t2) {
    case e20.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case e20.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case e20.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case e20.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return "unknown error " + t2;
  }
}
function oC(e20, t2, n2) {
  let r2 = IN(e20, () => t2());
  if (null == r2) throw Error(n2);
  return r2;
}
function lC(e20, t2) {
  let n2 = e20.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r2 = t2 + e20.TEXTURE0;
  if (e20.TEXTURE0 > r2 || r2 > n2) throw Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n2}].`);
}
function uC(e20, t2 = 2) {
  return va.sizeFromShape(e20.slice(0, e20.length - t2));
}
function dC(e20) {
  if (0 === e20.length) throw Error("Cannot get rows and columns of an empty shape array.");
  return [e20.length > 1 ? e20[e20.length - 2] : 1, e20[e20.length - 1]];
}
function cC(e20) {
  let t2 = [1, 1, 1];
  return 0 === e20.length || 1 === e20.length && 1 === e20[0] || (t2 = [uC(e20), ...dC(e20)]), t2;
}
function hC(e20, t2 = false) {
  let n2 = _e().getNumber("WEBGL_MAX_TEXTURE_SIZE"), r2 = _e().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
  r2 === 1 / 0 && _e().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (r2 = n2 / 2), t2 && (n2 *= 2, r2 *= 2, 1 === (e20 = e20.map((t3, n3) => e20.length - 2 > n3 ? e20[n3] : va.nearestLargerEven(e20[n3]))).length && (e20 = [2, e20[0]])), 2 !== e20.length && (e20 = va.squeezeShape(e20).newShape);
  let a2 = va.sizeFromShape(e20), i2 = null;
  e20.length > 1 || a2 > n2 ? 2 !== e20.length || e20[0] > n2 || e20[1] > n2 ? 3 !== e20.length || e20[0] * e20[1] > n2 || e20[2] > n2 ? 3 !== e20.length || e20[0] > n2 || e20[1] * e20[2] > n2 ? 4 !== e20.length || e20[0] * e20[1] * e20[2] > n2 || e20[3] > n2 ? 4 === e20.length && n2 >= e20[0] && n2 >= e20[1] * e20[2] * e20[3] && (i2 = [e20[0], e20[1] * e20[2] * e20[3]]) : i2 = [e20[0] * e20[1] * e20[2], e20[3]] : i2 = [e20[0], e20[1] * e20[2]] : i2 = [e20[0] * e20[1], e20[2]] : i2 = e20 : i2 = [1, a2];
  let s2 = null != i2 && Math.max(...i2) > r2 && Math.min(...i2) <= (t2 ? 2 : 1) && Math.min(...i2) > 0;
  if (null == i2 || s2) if (t2) {
    let t3 = uC(e20), n3 = 2, r3 = 2;
    e20.length && ([n3, r3] = dC(e20)), a2 = t3 * (n3 / 2) * (r3 / 2), i2 = va.sizeToSquarishShape(a2).map((e21) => 2 * e21);
  } else i2 = va.sizeToSquarishShape(a2);
  return i2;
}
function pC(e20) {
  return e20 % 2 == 0;
}
function fC(e20, t2) {
  if (e20 = e20.slice(-2), t2 = t2.slice(-2), va.arraysEqual(e20, t2) || !e20.length || !t2.length || 0 === e20[0] || 0 === e20[1] || 0 === t2[0] || 0 === t2[1]) return true;
  if (e20.length !== t2.length) {
    let n2 = e20[e20.length - 1], r2 = t2[t2.length - 1];
    if (n2 === r2 || pC(n2) && pC(r2) && (1 === e20[0] || 1 === t2[0])) return true;
  }
  return e20[1] === t2[1] && pC(e20[0]) && pC(t2[0]);
}
function mC(e20) {
  if (null == VN) {
    let t2 = NN(e20);
    VN = t2.getParameter(t2.MAX_TEXTURE_SIZE);
  }
  return VN;
}
function AC() {
  VN = null;
}
function xC() {
  _N = null;
}
function yC(e20) {
  if (null == _N) {
    let t2 = NN(e20);
    _N = t2.getParameter(t2.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, _N);
}
function bC(e20) {
  if (0 === e20) return 0;
  let t2, n2 = NN(e20);
  return t2 = gC(n2, "EXT_disjoint_timer_query_webgl2") && 2 === e20 ? 2 : gC(n2, "EXT_disjoint_timer_query") ? 1 : 0, t2;
}
function gC(e20, t2) {
  return null != e20.getExtension(t2);
}
function vC(e20) {
  try {
    if (null != NN(e20)) return true;
  } catch (t2) {
    return console.log("Error when getting WebGL context: ", t2), false;
  }
  return false;
}
function wC(e20) {
  if (0 === e20) return false;
  let t2 = NN(e20);
  if (1 === e20) {
    if (!gC(t2, "OES_texture_float")) return false;
  } else if (!gC(t2, "EXT_color_buffer_float")) return false;
  return NC(t2);
}
function kC(e20) {
  if (0 === e20) return false;
  let t2 = NN(e20);
  if (1 !== e20) {
    if (gC(t2, "EXT_color_buffer_float")) return NC(t2);
    let e21 = "EXT_color_buffer_half_float";
    if (gC(t2, e21)) {
      let n2 = t2.getExtension(e21);
      return ((e22, t3) => {
        let n3 = SN(e22, t3), r2 = e22.createTexture();
        e22.bindTexture(e22.TEXTURE_2D, r2), e22.texImage2D(e22.TEXTURE_2D, 0, n3.internalFormatHalfFloat, 1, 1, 0, n3.textureFormatFloat, n3.textureTypeHalfFloat, null);
        let a2 = e22.createFramebuffer();
        e22.bindFramebuffer(e22.FRAMEBUFFER, a2), e22.framebufferTexture2D(e22.FRAMEBUFFER, e22.COLOR_ATTACHMENT0, e22.TEXTURE_2D, r2, 0);
        let i2 = e22.checkFramebufferStatus(e22.FRAMEBUFFER) === e22.FRAMEBUFFER_COMPLETE;
        return e22.bindTexture(e22.TEXTURE_2D, null), e22.bindFramebuffer(e22.FRAMEBUFFER, null), e22.deleteTexture(r2), e22.deleteFramebuffer(a2), i2;
      })(t2, n2);
    }
    return false;
  }
  return !(!gC(t2, "OES_texture_float") || !gC(t2, "WEBGL_color_buffer_float")) && NC(t2);
}
function NC(e20) {
  let t2 = SN(e20), n2 = e20.createTexture();
  e20.bindTexture(e20.TEXTURE_2D, n2), e20.texImage2D(e20.TEXTURE_2D, 0, t2.internalFormatFloat, 1, 1, 0, t2.textureFormatFloat, t2.textureTypeFloat, null);
  let r2 = e20.createFramebuffer();
  e20.bindFramebuffer(e20.FRAMEBUFFER, r2), e20.framebufferTexture2D(e20.FRAMEBUFFER, e20.COLOR_ATTACHMENT0, e20.TEXTURE_2D, n2, 0);
  let a2 = e20.checkFramebufferStatus(e20.FRAMEBUFFER) === e20.FRAMEBUFFER_COMPLETE;
  return e20.bindTexture(e20.TEXTURE_2D, null), e20.bindFramebuffer(e20.FRAMEBUFFER, null), e20.deleteTexture(n2), e20.deleteFramebuffer(r2), a2;
}
function CC(e20) {
  return 2 === e20 && null != NN(e20).fenceSync;
}
function $C(e20, t2) {
  Array.isArray(e20) || (e20 = [e20]), e20.forEach((e21) => {
    null != e21 && va.assert("complex64" !== e21.dtype, () => t2 + " does not support complex64 tensors in the WebGL backend.");
  });
}
var RC = _e();
function SC() {
  let e20, t2, n2, r2, a2, i2, s2, o2, l2, u2;
  return 2 === _e().getNumber("WEBGL_VERSION") ? (e20 = "#version 300 es", t2 = "in", n2 = "out", r2 = "in", a2 = "texture", i2 = "outputColor", s2 = "out vec4 outputColor;", o2 = _e().getBool("WEBGL2_ISNAN_CUSTOM") ? "\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    " : "", l2 = "", u2 = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (e20 = "", t2 = "attribute", n2 = "varying", r2 = "varying", a2 = "texture2D", i2 = "gl_FragColor", s2 = "", o2 = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", l2 = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", u2 = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), { version: e20, attribute: t2, varyingVs: n2, varyingFs: r2, texture2D: a2, output: i2, defineOutput: s2, defineSpecialNaN: o2, defineSpecialInf: l2, defineRound: u2 };
}
function IC(e20, t2, n2 = "index") {
  let r2 = va.computeStrides(t2);
  return r2.map((t3, a2) => `int ${e20[a2]} = ${n2} / ${t3}; ${a2 === r2.length - 1 ? `int ${e20[a2 + 1]} = ${n2} - ${e20[a2]} * ${t3}` : `index -= ${e20[a2]} * ${t3}`};`).join("");
}
function EC(e20, t2, n2 = "index") {
  let r2 = va.computeStrides(t2);
  return r2.map((t3, a2) => `int ${e20[a2]} = ${n2} / outShapeStrides[${a2}]; ${a2 === r2.length - 1 ? `int ${e20[a2 + 1]} = ${n2} - ${e20[a2]} * outShapeStrides[${a2}]` : `index -= ${e20[a2]} * outShapeStrides[${a2}]`};`).join("");
}
function TC(e20) {
  let t2 = va.computeStrides(e20).map((e21) => "" + e21);
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t2[0]} + coords.y * ${t2[1]} + coords.z;
  }
`;
}
RC.registerFlag("HAS_WEBGL", () => RC.getNumber("WEBGL_VERSION") > 0), RC.registerFlag("WEBGL_VERSION", () => vC(2) ? 2 : vC(1) ? 1 : 0), RC.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false), RC.registerFlag("WEBGL_BUFFER_SUPPORTED", () => 2 === RC.get("WEBGL_VERSION")), RC.registerFlag("WEBGL_CPU_FORWARD", () => true), RC.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false), RC.registerFlag("WEBGL_PACK", () => RC.getBool("HAS_WEBGL")), RC.registerFlag("WEBGL_PACK_NORMALIZATION", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_PACK_CLIP", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_PACK_REDUCE", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_LAZILY_UNPACK", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_CONV_IM2COL", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", () => RC.getBool("WEBGL_PACK")), RC.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => mC(RC.getNumber("WEBGL_VERSION"))), RC.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => yC(RC.getNumber("WEBGL_VERSION"))), RC.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
  let e20 = RC.getNumber("WEBGL_VERSION");
  return 0 === e20 ? 0 : bC(e20);
}), RC.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => RC.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !Ii.isMobile()), RC.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => wC(RC.getNumber("WEBGL_VERSION"))), RC.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => !RC.getBool("WEBGL_FORCE_F16_TEXTURES") && RC.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")), RC.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => kC(RC.getNumber("WEBGL_VERSION"))), RC.registerFlag("WEBGL_FENCE_API_ENABLED", () => CC(RC.getNumber("WEBGL_VERSION"))), RC.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => RC.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0), RC.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, (e20) => {
  if ("number" != typeof e20) throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e20}.`);
  if (0 > e20 && -1 !== e20) throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e20}.`);
}), RC.registerFlag("WEBGL_FLUSH_THRESHOLD", () => Ii.isMobile() ? 1 : -1, (e20) => {
  if ("number" != typeof e20) throw Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e20}.`);
  if (0 > e20 && -1 !== e20) throw Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e20}.`);
}), RC.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128), RC.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false), RC.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5), RC.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128), RC.registerFlag("WEBGL_EXP_CONV", () => false), RC.registerFlag("SOFTWARE_WEBGL_ENABLED", () => RC.getBool("IS_TEST")), RC.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => 1 / 0), RC.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false), RC.registerFlag("WEBGL2_ISNAN_CUSTOM", () => false), RC.registerFlag("ENGINE_COMPILE_ONLY", () => false);
var MC = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
var { getBroadcastDims: OC } = Uf;
function FC(e20, t2, n2) {
  let r2 = [];
  if (e20.forEach((e21) => {
    let t3 = va.sizeFromShape(e21.shapeInfo.logicalShape);
    if (e21.shapeInfo.isUniform ? r2.push(`uniform float ${e21.name}${t3 > 1 ? `[${t3}]` : ""};`) : (r2.push(`uniform sampler2D ${e21.name};`), r2.push(`uniform int offset${e21.name};`)), n2.enableShapeUniforms) {
      let { uniformShape: t4 } = jC(n2.packedInputs, e21.shapeInfo.logicalShape, e21.shapeInfo.texShape);
      switch (t4.length) {
        case 1:
          r2.push(`uniform int ${e21.name}Shape;`);
          break;
        case 2:
          r2.push(`uniform ivec2 ${e21.name}Shape;`);
          break;
        case 3:
          r2.push(`uniform ivec3 ${e21.name}Shape;`);
          break;
        case 4:
          r2.push(`uniform ivec4 ${e21.name}Shape;`);
      }
      r2.push(`uniform ivec2 ${e21.name}TexShape;`);
    }
  }), n2.enableShapeUniforms) {
    switch (t2.logicalShape.length) {
      case 1:
        r2.push("uniform int outShape;");
        break;
      case 2:
        r2.push("uniform ivec2 outShape;"), r2.push("uniform int outShapeStrides;");
        break;
      case 3:
        r2.push("uniform ivec3 outShape;"), r2.push("uniform ivec2 outShapeStrides;");
        break;
      case 4:
        r2.push("uniform ivec4 outShape;"), r2.push("uniform ivec3 outShapeStrides;");
    }
    r2.push("uniform ivec2 outTexShape;");
  }
  n2.customUniforms && n2.customUniforms.forEach((e21) => {
    r2.push(`uniform ${e21.type} ${e21.name}${e21.arrayIndex ? `[${e21.arrayIndex}]` : ""};`);
  });
  let a2, i2, s2 = r2.join("\n"), o2 = e20.map((e21) => ((e22, t3, n3 = false, r3) => {
    let a3 = "";
    return a3 += n3 ? zC(e22, r3) : PC(e22, r3), t3.logicalShape.length >= e22.shapeInfo.logicalShape.length && (a3 += n3 ? ((e23, t4) => {
      let n4, r4 = e23.name, a4 = r4.charAt(0).toUpperCase() + r4.slice(1), i3 = "get" + a4 + "AtOutCoords", s3 = e23.shapeInfo.logicalShape.length, o3 = t4.logicalShape.length, l3 = OC(e23.shapeInfo.logicalShape, t4.logicalShape), u3 = UC(o3), d3 = o3 - s3, c3 = ["x", "y", "z", "w", "u", "v"];
      n4 = 0 === s3 ? "" : 2 > o3 && l3.length >= 1 ? "coords = 0;" : l3.map((e24) => `coords.${c3[e24 + d3]} = 0;`).join("\n");
      let h2 = "";
      h2 = 2 > o3 && s3 > 0 ? "coords" : e23.shapeInfo.logicalShape.map((e24, t5) => "coords." + c3[t5 + d3]).join(", ");
      let p2 = "return outputValue;", f2 = 1 === va.sizeFromShape(e23.shapeInfo.logicalShape), m2 = 1 === va.sizeFromShape(t4.logicalShape);
      if (1 !== s3 || f2 || m2) {
        if (f2 && !m2) p2 = 1 === o3 ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
        else if (l3.length) {
          let e24 = s3 - 2, t5 = s3 - 1;
          l3.indexOf(e24) > -1 && l3.indexOf(t5) > -1 ? p2 = "return vec4(outputValue.x);" : l3.indexOf(e24) > -1 ? p2 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : l3.indexOf(t5) > -1 && (p2 = "return vec4(outputValue.xx, outputValue.zz);");
        }
      } else p2 = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
      return `
    vec4 ${i3}() {
      ${u3} coords = getOutputCoords();
      ${n4}
      vec4 outputValue = get${a4}(${h2});
      ${p2}
    }
  `;
    })(e22, t3) : ((e23, t4) => {
      let n4 = e23.name, r4 = n4.charAt(0).toUpperCase() + n4.slice(1), a4 = "get" + r4 + "AtOutCoords", i3 = e23.shapeInfo.logicalShape.length, s3 = t4.logicalShape.length;
      if (!e23.shapeInfo.isUniform && i3 === s3 && null == e23.shapeInfo.flatOffset && va.arraysEqual(e23.shapeInfo.texShape, t4.texShape)) return `
      float ${a4}() {
        return sampleTexture(${n4}, resultUV);
      }
    `;
      let o3, l3 = UC(s3), u3 = OC(e23.shapeInfo.logicalShape, t4.logicalShape), d3 = s3 - i3, c3 = ["x", "y", "z", "w", "u", "v"];
      o3 = 0 === i3 ? "" : 2 > s3 && u3.length >= 1 ? "coords = 0;" : u3.map((e24) => `coords.${c3[e24 + d3]} = 0;`).join("\n");
      let h2 = "";
      return h2 = 2 > s3 && i3 > 0 ? "coords" : e23.shapeInfo.logicalShape.map((e24, t5) => "coords." + c3[t5 + d3]).join(", "), `
    float ${a4}() {
      ${l3} coords = getOutputCoords();
      ${o3}
      return get${r4}(${h2});
    }
  `;
    })(e22, t3)), a3;
  })(e21, t2, n2.packedInputs, n2.enableShapeUniforms)).join("\n"), l2 = t2.texShape, u2 = SC(), d2 = ((e21) => `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e21.texture2D}(textureSampler, uv).r;
    }
  `)(u2), c2 = ((e21) => `${e21.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e21.varyingFs} vec2 resultUV;
    ${e21.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e21.defineSpecialNaN}
    ${e21.defineSpecialInf}
    ${e21.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${VC}
    ${_C}
    ${DC}
  `)(u2);
  return t2.isPacked ? (a2 = ((e21, t3, n3) => {
    switch (e21.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
      case 1:
        return ((e22, t4, n4) => {
          let r3 = [Math.ceil(t4[0] / 2), Math.ceil(t4[1] / 2)];
          return 1 === r3[0] ? n4 ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    " : `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r3[1]}.0);
      }
    ` : 1 === r3[1] ? n4 ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    " : `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r3[0]}.0);
      }
    ` : n4 ? "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  " : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r3[0]}, ${r3[1]}));
      return 2 * (resTexRC.x * ${r3[1]} + resTexRC.y);
    }
  `;
        })(0, t3, n3);
      case 2:
        return ((e22, t4, n4) => {
          let r3 = [Math.ceil(t4[0] / 2), Math.ceil(t4[1] / 2)];
          if (va.arraysEqual(e22, t4)) return n4 ? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    " : `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r3[0]}, ${r3[1]}));
      }
    `;
          let a3 = Math.ceil(e22[1] / 2);
          return n4 ? "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  " : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r3[0]}, ${r3[1]}));

      int index = resTexRC.x * ${r3[1]} + resTexRC.y;
      int r = 2 * (index / ${a3});
      int c = imod(index, ${a3}) * 2;

      return ivec2(r, c);
    }
  `;
        })(e21, t3, n3);
      case 3:
        return ((e22, t4, n4) => {
          if (n4) return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
          let r3 = [Math.ceil(t4[0] / 2), Math.ceil(t4[1] / 2)], a3 = Math.ceil(e22[2] / 2), i3 = a3 * Math.ceil(e22[1] / 2);
          return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r3[0]}, ${r3[1]}));
      int index = resTexRC.x * ${r3[1]} + resTexRC.y;

      int b = index / ${i3};
      index -= b * ${i3};

      int r = 2 * (index / ${a3});
      int c = imod(index, ${a3}) * 2;

      return ivec3(b, r, c);
    }
  `;
        })(e21, t3, n3);
      default:
        return ((e22, t4, n4) => {
          if (n4) return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
          let r3 = [Math.ceil(t4[0] / 2), Math.ceil(t4[1] / 2)], a3 = Math.ceil(e22[e22.length - 1] / 2), i3 = a3 * Math.ceil(e22[e22.length - 2] / 2), s3 = i3, o3 = "", l3 = "b, r, c";
          for (let u3 = 2; e22.length - 1 > u3; u3++) s3 *= e22[e22.length - u3 - 1], o3 = `
      int b${u3} = index / ${s3};
      index -= b${u3} * ${s3};
    ` + o3, l3 = `b${u3}, ` + l3;
          return `
    ivec${e22.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r3[0]}, ${r3[1]}));
      int index = resTexRC.x * ${r3[1]} + resTexRC.y;

      ${o3}

      int b = index / ${i3};
      index -= b * ${i3};

      int r = 2 * (index / ${a3});
      int c = imod(index, ${a3}) * 2;

      return ivec${e22.length}(${l3});
    }
  `;
        })(e21, t3, n3);
    }
  })(t2.logicalShape, l2, n2.enableShapeUniforms), i2 = ((e21) => `
    void setOutput(vec4 val) {
      ${e21.output} = val;
    }
  `)(u2)) : (a2 = ((e21, t3, n3) => {
    switch (e21.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
      case 1:
        return ((e22, t4, n4) => 1 === t4[0] ? n4 ? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    " : `
      int getOutputCoords() {
        return int(resultUV.x * ${t4[1]}.0);
      }
    ` : 1 === t4[1] ? n4 ? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    " : `
      int getOutputCoords() {
        return int(resultUV.y * ${t4[0]}.0);
      }
    ` : n4 ? "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  " : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t4[0]}, ${t4[1]}));
      return resTexRC.x * ${t4[1]} + resTexRC.y;
    }
  `)(0, t3, n3);
      case 2:
        return ((e22, t4, n4) => va.arraysEqual(e22, t4) ? n4 ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    " : `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t4[0]}, ${t4[1]}));
      }
    ` : 1 === e22[1] ? n4 ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t4[0]}, ${t4[1]}));
        int index = resTexRC.x * ${t4[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : 1 === e22[0] ? n4 ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t4[0]}, ${t4[1]}));
        int index = resTexRC.x * ${t4[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    ` : n4 ? "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  " : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t4[0]}, ${t4[1]}));
      int index = resTexRC.x * ${t4[1]} + resTexRC.y;
      int r = index / ${e22[1]};
      int c = index - r * ${e22[1]};
      return ivec2(r, c);
    }
  `)(e21, t3, n3);
      case 3:
        return ((e22, t4, n4) => {
          if (n4) return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${EC(["r", "c", "d"], e22)}
    return ivec3(r, c, d);
  }
`;
          let r3 = IC(["r", "c", "d"], e22);
          return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t4[0]}, ${t4[1]}));
      int index = resTexRC.x * ${t4[1]} + resTexRC.y;
      ${r3}
      return ivec3(r, c, d);
    }
  `;
        })(e21, t3, n3);
      case 4:
        return ((e22, t4, n4) => {
          if (n4) return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${EC(["r", "c", "d", "d2"], e22)}
      return ivec4(r, c, d, d2);
    }
  `;
          let r3 = IC(["r", "c", "d", "d2"], e22);
          return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t4[0]}, ${t4[1]}));
      int index = resTexRC.x * ${t4[1]} + resTexRC.y;
      ${r3}
      return ivec4(r, c, d, d2);
    }
  `;
        })(e21, t3, n3);
      case 5:
        return ((e22, t4) => {
          let n4 = IC(["r", "c", "d", "d2", "d3"], e22);
          return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t4[0]},
                             ${t4[1]}));

      int index = resTexRC.x * ${t4[1]} + resTexRC.y;

      ${n4}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
        })(e21, t3);
      case 6:
        return ((e22, t4) => {
          let n4 = IC(["r", "c", "d", "d2", "d3", "d4"], e22);
          return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t4[0]}, ${t4[1]}));
      int index = resTexRC.x * ${t4[1]} + resTexRC.y;

      ${n4}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
        })(e21, t3);
      default:
        throw Error(e21.length + "-D output sampling is not yet supported");
    }
  })(t2.logicalShape, l2, n2.enableShapeUniforms), i2 = ((e21) => `
    void setOutput(float val) {
      ${e21.output} = vec4(val, 0, 0, 0);
    }
  `)(u2)), n2.packedInputs && (c2 += WC), [c2, d2, i2, s2, a2, o2, n2.userCode].join("\n");
}
function PC(e20, t2 = false) {
  let n2 = e20.shapeInfo.logicalShape;
  switch (n2.length) {
    case 0:
      return ((e21, t3) => {
        let n3 = e21.name, r2 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1);
        if (e21.shapeInfo.isUniform) return `float ${r2}() {return ${n3};}`;
        let [a2, i2] = e21.shapeInfo.texShape;
        if (1 === a2 && 1 === i2) return `
      float ${r2}() {
        return sampleTexture(${n3}, halfCR);
      }
    `;
        let s2 = LC(n3);
        if (t3) return `
    float ${r2}() {
      vec2 uv = uvFromFlat(${n3}TexShape[0], ${n3}TexShape[1], ${s2});
      return sampleTexture(${n3}, uv);
    }
  `;
        let [o2, l2] = e21.shapeInfo.texShape;
        return `
    float ${r2}() {
      vec2 uv = uvFromFlat(${o2}, ${l2}, ${s2});
      return sampleTexture(${n3}, uv);
    }
  `;
      })(e20, t2);
    case 1:
      return ((e21, t3) => {
        let n3 = e21.name, r2 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1);
        if (e21.shapeInfo.isUniform) return `
      float ${r2}(int index) {
        ${BC(e21)}
      }
    `;
        let a2 = e21.shapeInfo.texShape, i2 = a2[0], s2 = a2[1];
        if (1 === s2 && 1 === i2) return `
      float ${r2}(int index) {
        return sampleTexture(${n3}, halfCR);
      }
    `;
        let o2 = LC(n3);
        return 1 === s2 ? t3 ? `
      float ${r2}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o2}) + 0.5) / float(${n3}TexShape[0]));
        return sampleTexture(${n3}, uv);
      }
    ` : `
      float ${r2}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o2}) + 0.5) / ${i2}.0);
        return sampleTexture(${n3}, uv);
      }
    ` : 1 === i2 ? t3 ? `
      float ${r2}(int index) {
        vec2 uv = vec2((float(index + ${o2}) + 0.5) / float(${n3}TexShape[1]), 0.5);
        return sampleTexture(${n3}, uv);
      }
    ` : `
      float ${r2}(int index) {
        vec2 uv = vec2((float(index + ${o2}) + 0.5) / ${s2}.0, 0.5);
        return sampleTexture(${n3}, uv);
      }
    ` : t3 ? `
    float ${r2}(int index) {
      vec2 uv = uvFromFlat(${n3}TexShape[0], ${n3}TexShape[1], index + ${o2});
      return sampleTexture(${n3}, uv);
    }
  ` : `
    float ${r2}(int index) {
      vec2 uv = uvFromFlat(${i2}, ${s2}, index + ${o2});
      return sampleTexture(${n3}, uv);
    }
  `;
      })(e20, t2);
    case 2:
      return ((e21, t3) => {
        let n3 = e21.shapeInfo.logicalShape, r2 = e21.name, a2 = "get" + r2.charAt(0).toUpperCase() + r2.slice(1), i2 = e21.shapeInfo.texShape;
        if (null != i2 && va.arraysEqual(n3, i2)) return t3 ? `
      float ${a2}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r2}TexShape[1], ${r2}TexShape[0]);
        return sampleTexture(${r2}, uv);
      }
    ` : `
    float ${a2}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i2[1]}.0, ${i2[0]}.0);
      return sampleTexture(${r2}, uv);
    }
  `;
        let { newShape: s2, keptDims: o2 } = va.squeezeShape(n3);
        if (n3.length > s2.length) {
          let n4 = ["row", "col"];
          return `
      ${PC(GC(e21, s2), t3)}
      float ${a2}(int row, int col) {
        return ${a2}(${HC(n4, o2)});
      }
    `;
        }
        if (e21.shapeInfo.isUniform) return `
      float ${a2}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n3[1]}, 1)));
        ${BC(e21)}
      }
    `;
        let l2 = i2[0], u2 = i2[1], d2 = LC(r2);
        return 1 === u2 ? t3 ? `
      float ${a2}(int row, int col) {
        float index = dot(vec3(row, col, ${d2}), vec3(${r2}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r2}TexShape[0]));
        return sampleTexture(${r2}, uv);
      }
    ` : `
    float ${a2}(int row, int col) {
      float index = dot(vec3(row, col, ${d2}), vec3(${n3[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l2}.0);
      return sampleTexture(${r2}, uv);
    }
  ` : 1 === l2 ? t3 ? `
      float ${a2}(int row, int col) {
        float index = dot(vec3(row, col, ${d2}), vec3(${r2}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r2}TexShape[1]), 0.5);
        return sampleTexture(${r2}, uv);
      }
    ` : `
    float ${a2}(int row, int col) {
      float index = dot(vec3(row, col, ${d2}), vec3(${n3[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u2}.0, 0.5);
      return sampleTexture(${r2}, uv);
    }
  ` : t3 ? `
      float ${a2}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r2}Shape[1] + col + ${d2};
        vec2 uv = uvFromFlat(${r2}TexShape[0], ${r2}TexShape[1], index);
        return sampleTexture(${r2}, uv);
      }
    ` : `
  float ${a2}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n3[1]} + col + ${d2};
    vec2 uv = uvFromFlat(${l2}, ${u2}, index);
    return sampleTexture(${r2}, uv);
  }
`;
      })(e20, t2);
    case 3:
      return ((e21, t3) => {
        let n3 = e21.shapeInfo.logicalShape, r2 = e21.name, a2 = "get" + r2.charAt(0).toUpperCase() + r2.slice(1), i2 = n3[1] * n3[2], s2 = n3[2], { newShape: o2, keptDims: l2 } = va.squeezeShape(n3);
        if (n3.length > o2.length) {
          let n4 = ["row", "col", "depth"];
          return `
        ${PC(GC(e21, o2), t3)}
        float ${a2}(int row, int col, int depth) {
          return ${a2}(${HC(n4, l2)});
        }
      `;
        }
        if (e21.shapeInfo.isUniform) return `
      float ${a2}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i2}, ${s2}, 1)));
        ${BC(e21)}
      }
    `;
        let u2 = e21.shapeInfo.texShape, d2 = u2[0], c2 = u2[1], h2 = e21.shapeInfo.flatOffset;
        if (c2 === i2 && null == h2) return t3 ? `
      float ${a2}(int row, int col, int depth) {
        int stride1 = ${r2}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r2}TexShape[1], ${r2}TexShape[0]);
        return sampleTexture(${r2}, uv);
      }
    ` : `
        float ${a2}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${s2}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${c2}.0, ${d2}.0);
          return sampleTexture(${r2}, uv);
        }
      `;
        if (c2 === s2 && null == h2) return t3 ? `
      float ${a2}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r2}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r2}TexShape[1], ${r2}TexShape[0]);
        return sampleTexture(${r2}, uv);
      }
    ` : `
    float ${a2}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n3[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c2}.0, ${d2}.0);
      return sampleTexture(${r2}, uv);
    }
  `;
        let p2 = LC(r2);
        return t3 ? `
    float ${a2}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r2}Shape[1] * ${r2}Shape[2];
      int stride1 = ${r2}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p2};
      vec2 uv = uvFromFlat(${r2}TexShape[0], ${r2}TexShape[1], index);
      return sampleTexture(${r2}, uv);
    }
    ` : `
      float ${a2}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i2} + col * ${s2} + depth + ${p2};
        vec2 uv = uvFromFlat(${d2}, ${c2}, index);
        return sampleTexture(${r2}, uv);
      }
  `;
      })(e20, t2);
    case 4:
      return ((e21, t3) => {
        let n3 = e21.shapeInfo.logicalShape, r2 = e21.name, a2 = "get" + r2.charAt(0).toUpperCase() + r2.slice(1), i2 = n3[3], s2 = n3[2] * i2, o2 = n3[1] * s2, { newShape: l2, keptDims: u2 } = va.squeezeShape(n3);
        if (n3.length > l2.length) {
          let n4 = ["row", "col", "depth", "depth2"];
          return `
      ${PC(GC(e21, l2), t3)}
      float ${a2}(int row, int col, int depth, int depth2) {
        return ${a2}(${HC(n4, u2)});
      }
    `;
        }
        if (e21.shapeInfo.isUniform) return `
      float ${a2}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o2}, ${s2}, ${i2}, 1)));
        ${BC(e21)}
      }
    `;
        let d2 = e21.shapeInfo.flatOffset, c2 = e21.shapeInfo.texShape, h2 = c2[0], p2 = c2[1], f2 = `int stride2 = ${r2}Shape[3];`, m2 = `int stride1 = ${r2}Shape[2] * stride2;`, A2 = `int stride0 = ${r2}Shape[1] * stride1;`;
        if (p2 === o2 && null == d2) return t3 ? `
      float ${a2}(int row, int col, int depth, int depth2) {
        ${f2}
        ${m2}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r2}TexShape[1], ${r2}TexShape[0]);
        return sampleTexture(${r2}, uv);
      }
    ` : `
      float ${a2}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${s2}, ${i2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p2}.0, ${h2}.0);
        return sampleTexture(${r2}, uv);
      }
    `;
        if (p2 === i2 && null == d2) return t3 ? `
      float ${a2}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r2}Shape[1] * ${r2}Shape[2], ${r2}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r2}TexShape[1], ${r2}TexShape[0]);
        return sampleTexture(${r2}, uv);
      }
    ` : `
      float ${a2}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n3[1] * n3[2]}, ${n3[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p2}.0, ${h2}.0);
        return sampleTexture(${r2}, uv);
      }
    `;
        let x2 = LC(r2);
        return t3 ? `
    float ${a2}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f2}
      ${m2}
      ${A2}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r2}TexShape[0], ${r2}TexShape[1], index + ${x2});
      return sampleTexture(${r2}, uv);
    }
  ` : `
    float ${a2}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o2} + col * ${s2} +
          depth * ${i2} + depth2;
      vec2 uv = uvFromFlat(${h2}, ${p2}, index + ${x2});
      return sampleTexture(${r2}, uv);
    }
  `;
      })(e20, t2);
    case 5:
      return ((e21) => {
        let t3 = e21.shapeInfo.logicalShape, n3 = e21.name, r2 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), a2 = t3[4], i2 = t3[3] * a2, s2 = t3[2] * i2, o2 = t3[1] * s2, { newShape: l2, keptDims: u2 } = va.squeezeShape(t3);
        if (t3.length > l2.length) {
          let t4 = ["row", "col", "depth", "depth2", "depth3"];
          return `
      ${PC(GC(e21, l2))}
      float ${r2}(int row, int col, int depth, int depth2, int depth3) {
        return ${r2}(${HC(t4, u2)});
      }
    `;
        }
        if (e21.shapeInfo.isUniform) return `
      float ${r2}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o2}, ${s2}, ${i2}, ${a2})) +
          depth3;
        ${BC(e21)}
      }
    `;
        let d2 = e21.shapeInfo.flatOffset, c2 = e21.shapeInfo.texShape, h2 = c2[0], p2 = c2[1];
        return p2 === o2 && null == d2 ? `
      float ${r2}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${s2}, ${i2}, ${a2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p2}.0, ${h2}.0);
        return sampleTexture(${n3}, uv);
      }
    ` : p2 === a2 && null == d2 ? `
      float ${r2}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t3[1] * t3[2] * t3[3]},
               ${t3[2] * t3[3]}, ${t3[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p2}.0, ${h2}.0);
        return sampleTexture(${n3}, uv);
      }
    ` : `
    float ${r2}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o2} + col * ${s2} + depth * ${i2} +
          depth2 * ${a2} + depth3 + ${LC(n3)};
      vec2 uv = uvFromFlat(${h2}, ${p2}, index);
      return sampleTexture(${n3}, uv);
    }
  `;
      })(e20);
    case 6:
      return ((e21) => {
        let t3 = e21.shapeInfo.logicalShape, n3 = e21.name, r2 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), { newShape: a2, keptDims: i2 } = va.squeezeShape(t3);
        if (t3.length > a2.length) {
          let t4 = ["row", "col", "depth", "depth2", "depth3", "depth4"];
          return `
      ${PC(GC(e21, a2))}
      float ${r2}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r2}(${HC(t4, i2)});
      }
    `;
        }
        let s2 = t3[5], o2 = t3[4] * s2, l2 = t3[3] * o2, u2 = t3[2] * l2, d2 = t3[1] * u2;
        if (e21.shapeInfo.isUniform) return `
      float ${r2}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${d2}, ${u2}, ${l2}, ${o2})) +
          dot(
            vec2(depth3, depth4),
            vec2(${s2}, 1)));
        ${BC(e21)}
      }
    `;
        let c2 = e21.shapeInfo.flatOffset, h2 = e21.shapeInfo.texShape, p2 = h2[0], f2 = h2[1];
        return f2 === d2 && null == c2 ? `
      float ${r2}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u2}, ${l2}, ${o2}, ${s2})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f2}.0, ${p2}.0);
        return sampleTexture(${n3}, uv);
      }
    ` : f2 === s2 && null == c2 ? `
      float ${r2}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t3[1] * t3[2] * t3[3] * t3[4]},
               ${t3[2] * t3[3] * t3[4]},
               ${t3[3] * t3[4]},
               ${t3[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f2}.0, ${p2}.0);
        return sampleTexture(${n3}, uv);
      }
    ` : `
    float ${r2}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d2} + col * ${u2} + depth * ${l2} +
          depth2 * ${o2} + depth3 * ${s2} + depth4 + ${LC(n3)};
      vec2 uv = uvFromFlat(${p2}, ${f2}, index);
      return sampleTexture(${n3}, uv);
    }
  `;
      })(e20);
    default:
      throw Error(n2.length + "-D input sampling is not yet supported");
  }
}
function zC(e20, t2) {
  switch (e20.shapeInfo.logicalShape.length) {
    case 0:
      return ((e21) => {
        let t3 = e21.name;
        return `
    vec4 ${"get" + t3.charAt(0).toUpperCase() + t3.slice(1)}() {
      return ${SC().texture2D}(${t3}, halfCR);
    }
  `;
      })(e20);
    case 1:
      return ((e21, t3) => {
        let n2 = e21.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), a2 = e21.shapeInfo.texShape, i2 = SC();
        if (t3) return `
    vec4 ${r2}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n2}TexShape[0]) / 2.0), ceil(float(${n2}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i2.texture2D}(${n2}, uv);
    }
  `;
        let s2 = [Math.ceil(a2[0] / 2), Math.ceil(a2[1] / 2)];
        return `
    vec4 ${r2}(int index) {
      vec2 uv = packedUVfrom1D(
        ${s2[0]}, ${s2[1]}, index);
      return ${i2.texture2D}(${n2}, uv);
    }
  `;
      })(e20, t2);
    case 2:
      return ((e21, t3) => {
        let n2 = e21.shapeInfo.logicalShape, r2 = e21.name, a2 = "get" + r2.charAt(0).toUpperCase() + r2.slice(1), i2 = e21.shapeInfo.texShape, s2 = i2[0], o2 = i2[1], l2 = SC();
        if (null != i2 && va.arraysEqual(n2, i2)) return t3 ? `
      vec4 ${a2}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r2}TexShape[1], ${r2}TexShape[0]);

        return ${l2.texture2D}(${r2}, uv);
      }
    ` : `
      vec4 ${a2}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o2}.0, ${s2}.0);

        return ${l2.texture2D}(${r2}, uv);
      }
    `;
        if (t3) return `
    vec4 ${a2}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r2}TexShape[0]) / 2.0), ceil(float(${r2}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r2}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l2.texture2D}(${r2}, uv);
    }
  `;
        let u2 = [Math.ceil(i2[0] / 2), Math.ceil(i2[1] / 2)];
        return `
    vec4 ${a2}(int row, int col) {
      vec2 uv = packedUVfrom2D(${Math.ceil(n2[1] / 2)}, ${u2[0]}, ${u2[1]}, row, col);
      return ${l2.texture2D}(${r2}, uv);
    }
  `;
      })(e20, t2);
    case 3:
      return ((e21, t3) => {
        let n2 = e21.shapeInfo.logicalShape, r2 = e21.name, a2 = "get" + r2.charAt(0).toUpperCase() + r2.slice(1), i2 = e21.shapeInfo.texShape, s2 = [Math.ceil(i2[0] / 2), Math.ceil(i2[1] / 2)];
        if (1 === n2[0]) {
          let r3 = [1, 2], i3 = ["b", "row", "col"];
          return `
        ${zC(GC(e21, n2.slice(1)), t3)}
        vec4 ${a2}(int b, int row, int col) {
          return ${a2}(${HC(i3, r3)});
        }
      `;
        }
        let o2 = SC();
        if (t3) return `
    vec4 ${a2}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r2}TexShape[0]) / 2.0), ceil(float(${r2}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r2}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r2}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o2.texture2D}(${r2}, uv);
    }
  `;
        let l2 = s2[0], u2 = s2[1], d2 = Math.ceil(n2[2] / 2);
        return `
    vec4 ${a2}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l2}, ${u2}, ${d2 * Math.ceil(n2[1] / 2)}, ${d2}, b, row, col);
      return ${o2.texture2D}(${r2}, uv);
    }
  `;
      })(e20, t2);
    default:
      return ((e21, t3) => {
        let n2 = e21.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), a2 = SC();
        if (t3) return `
    vec4 ${r2}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n2}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n2}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n2}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n2}TexShape[0]) / 2.0), ceil(float(${n2}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a2.texture2D}(${n2}, uv);
    }
  `;
        let i2 = e21.shapeInfo.logicalShape, s2 = i2.length, o2 = e21.shapeInfo.texShape, l2 = [Math.ceil(o2[0] / 2), Math.ceil(o2[1] / 2)], u2 = l2[0], d2 = l2[1], c2 = Math.ceil(i2[s2 - 1] / 2), h2 = c2 * Math.ceil(i2[s2 - 2] / 2), p2 = "int b, int row, int col", f2 = `b * ${h2} + (row / 2) * ${c2} + (col / 2)`;
        for (let m2 = 2; s2 - 1 > m2; m2++) p2 = `int b${m2}, ` + p2, h2 *= i2[s2 - m2 - 1], f2 = `b${m2} * ${h2} + ` + f2;
        return `
    vec4 ${r2}(${p2}) {
      int index = ${f2};
      int texR = index / ${d2};
      int texC = index - texR * ${d2};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d2}, ${u2});
      return ${a2.texture2D}(${n2}, uv);
    }
  `;
      })(e20, t2);
  }
}
var VC = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var _C = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var DC = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var WC = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
function LC(e20) {
  return "offset" + e20;
}
function BC(e20) {
  let t2 = e20.name, n2 = va.sizeFromShape(e20.shapeInfo.logicalShape);
  return 2 > n2 ? `return ${t2};` : `
    for (int i = 0; i < ${n2}; i++) {
      if (i == index) {
        return ${t2}[i];
      }
    }
  `;
}
function UC(e20) {
  if (1 >= e20) return "int";
  if (2 === e20) return "ivec2";
  if (3 === e20) return "ivec3";
  if (4 === e20) return "ivec4";
  if (5 === e20) return "ivec5";
  if (6 === e20) return "ivec6";
  throw Error(`GPU for rank ${e20} is not yet supported`);
}
function jC(e20, t2, n2) {
  let { newShape: r2, keptDims: a2 } = va.squeezeShape(t2), i2 = t2.length, s2 = e20 && 3 === i2 && 1 === t2[0], o2 = s2 ? t2.slice(1) : r2, l2 = !e20 && i2 > 1 && !va.arraysEqual(t2, n2) && i2 > r2.length || s2;
  return { useSqueezeShape: l2, uniformShape: l2 ? o2 : t2, keptDims: a2 };
}
function GC(e20, t2) {
  let n2 = JSON.parse(JSON.stringify(e20));
  return n2.shapeInfo.logicalShape = t2, n2;
}
function HC(e20, t2) {
  return t2.map((t3) => e20[t3]).join(", ");
}
function XC(e20, t2, n2) {
  let r2, a2, i2, s2 = [], o2 = [], l2 = null, u2 = null;
  u2 = e20.getUniformLocation(n2, "NAN", false), 1 === _e().getNumber("WEBGL_VERSION") && (l2 = e20.getUniformLocation(n2, "INFINITY", false));
  let d2 = false;
  for (let c2 of t2.variableNames) {
    let r3 = { name: c2, uniform: e20.getUniformLocation(n2, c2, d2), offset: e20.getUniformLocation(n2, "offset" + c2, d2) };
    t2.enableShapeUniforms && (r3.shape = e20.getUniformLocation(n2, c2 + "Shape", d2), r3.texShape = e20.getUniformLocation(n2, c2 + "TexShape", d2)), s2.push(r3);
  }
  if (t2.enableShapeUniforms && (r2 = e20.getUniformLocation(n2, "outShape", d2), i2 = e20.getUniformLocation(n2, "outShapeStrides", d2), a2 = e20.getUniformLocation(n2, "outTexShape", d2)), t2.customUniforms) for (let c2 of t2.customUniforms) o2.push(e20.getUniformLocation(n2, c2.name, d2));
  return { variablesLocations: s2, customUniformLocations: o2, infLoc: l2, nanLoc: u2, outShapeLocation: r2, outShapeStridesLocation: i2, outTexShapeLocation: a2 };
}
function qC(e20, t2) {
  if (e20.length !== t2.length) throw Error(`Binary was compiled with ${e20.length} inputs, but was executed with ${t2.length} inputs`);
  e20.forEach((e21, n2) => {
    let r2 = e21.logicalShape, a2 = t2[n2], i2 = a2.shape;
    if (!va.arraysEqual(r2, i2)) throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r2} and ${i2} must match`);
    if (e21.isUniform && a2.isUniform) return;
    let s2 = e21.texShape, o2 = a2.isUniform ? null : a2.texData.texShape;
    if (!va.arraysEqual(s2, o2)) throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${s2} and ${o2} must match`);
  });
}
function ZC(e20) {
  return _e().getBool("WEBGL_USE_SHAPES_UNIFORMS") && 4 >= e20;
}
var KC = class {
  constructor(e20) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = yN.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    let t2 = SC();
    this.outputShape = e20, this.enableShapeUniforms = ZC(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? EC(["r", "c", "d"], e20) : IC(["r", "c", "d"], e20)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t2.output} = result;
      }
    `;
  }
};
var YC = class {
  constructor(e20) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = yN.DENSE, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    let t2 = SC();
    this.outputShape = e20, this.enableShapeUniforms = ZC(this.outputShape.length), this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? EC(["r", "c", "d"], e20) : IC(["r", "c", "d"], e20)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t2.output} = result;
      }
    `;
  }
};
var JC = class {
  constructor(e20) {
    this.variableNames = ["A"], this.outTexUsage = bN.DOWNLOAD;
    let t2 = SC();
    this.outputShape = e20, this.userCode = `
      ${MC}

      void main() {
        float x = getAAtOutCoords();
        ${t2.output} = encode_float(x);
      }
    `;
  }
};
var QC = class {
  constructor(e20) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = bN.DOWNLOAD;
    let t2 = SC();
    this.outputShape = e20, this.userCode = `
      ${MC}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t2.output} = encode_float(x);
      }
    `;
  }
};
var e$ = { R: 0, G: 1, B: 2, A: 3 };
var t$ = class {
  constructor(e20, t2 = false, n2 = "RGBA") {
    this.variableNames = ["A"], this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    let r2 = SC();
    this.outputShape = e20, this.enableShapeUniforms = ZC(this.outputShape.length);
    let a2 = "result";
    t2 && (a2 = "floor(result * 255. + 0.5)");
    let i2 = "";
    for (let s2 = 0; n2.length > s2; s2++) i2 += `
          if(offset == ${s2}) {
            result = values[${e$[n2[s2]]}];
          }`;
    this.userCode = `
      ${this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : TC(e20)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n2.length});

        flatIndex = idiv(flatIndex, ${n2.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r2.texture2D}(A, uv);
          ${i2}
        }
        ${r2.output} = vec4(${a2}, 0., 0., 0.);
      }
    `;
  }
};
var n$ = class {
  constructor(e20, t2 = false) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    let n2 = SC();
    this.outputShape = e20, this.enableShapeUniforms = ZC(this.outputShape.length);
    let r2 = "", a2 = "result";
    t2 && (a2 = "floor(result * 255. + 0.5)");
    for (let i2 = 0; 1 >= i2; i2++) for (let t3 = 0; 1 >= t3; t3++) {
      let a3 = 2 * i2 + t3;
      r2 += `
          localCoords = coords;
          if(localCoords[2] + ${t3} < ${this.enableShapeUniforms ? "outShape[2]" : "" + e20[2]}) {
          localCoords[2] += ${t3};
          if (localCoords[1] + ${i2} < ${this.enableShapeUniforms ? "outShape[1]" : "" + e20[1]}) {
            localCoords[1] += ${i2};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n2.texture2D}(A, uv);

            if (offset == 0) {
              result[${a3}] = values[0];
            } else if (offset == 1) {
              result[${a3}] = values[1];
            } else if (offset == 2) {
              result[${a3}] = values[2];
            } else {
              result[${a3}] = values[3];
            }
          }
        }
        `;
    }
    this.userCode = `
        ${this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : TC(e20)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r2}

          ${n2.output} = ${a2};
        }
    `;
  }
};
var r$ = {};
function a$(e20) {
  let t2 = SC();
  return PN(e20, `${t2.version}
    precision highp float;
    ${t2.attribute} vec3 clipSpacePos;
    ${t2.attribute} vec2 uv;
    ${t2.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`);
}
function i$(e20) {
  return jN(e20, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
}
function s$(e20) {
  return GN(e20, new Uint16Array([0, 1, 2, 2, 1, 3]));
}
function o$(e20, t2, n2, r2, a2, i2) {
  qN(t2, n2);
  let s2 = XN(e20), o2 = e20.TEXTURE_2D;
  return IN(e20, () => e20.bindTexture(o2, s2)), IN(e20, () => e20.texParameteri(o2, e20.TEXTURE_WRAP_S, e20.CLAMP_TO_EDGE)), IN(e20, () => e20.texParameteri(o2, e20.TEXTURE_WRAP_T, e20.CLAMP_TO_EDGE)), IN(e20, () => e20.texParameteri(o2, e20.TEXTURE_MIN_FILTER, e20.NEAREST)), IN(e20, () => e20.texParameteri(o2, e20.TEXTURE_MAG_FILTER, e20.NEAREST)), 1 === _e().getNumber("WEBGL_VERSION") ? IN(e20, () => e20.texImage2D(o2, 0, r2, t2, n2, 0, a2, i2, null)) : IN(e20, () => e20.texStorage2D(o2, 1, r2, t2, n2)), IN(e20, () => e20.bindTexture(e20.TEXTURE_2D, null)), { texture: s2, texShape: [n2, t2] };
}
function l$(e20) {
  return e20.internalFormatFloat;
}
function u$(e20, t2, n2, r2) {
  let [a2, i2] = CN(t2, n2);
  return o$(e20, a2, i2, l$(r2), r2.textureFormatFloat, e20.FLOAT);
}
function d$(e20) {
  return e20.internalFormatHalfFloat;
}
function c$(e20, t2, n2, r2) {
  let [a2, i2] = CN(t2, n2);
  return o$(e20, a2, i2, d$(r2), r2.textureFormatFloat, r2.textureTypeHalfFloat);
}
function h$(e20) {
  return e20.downloadTextureFormat;
}
function p$(e20, t2, n2, r2) {
  let [a2, i2] = CN(t2, n2);
  return o$(e20, a2, i2, h$(r2), e20.RGBA, e20.UNSIGNED_BYTE);
}
function f$(e20) {
  return e20.internalFormatPackedFloat;
}
function m$(e20, t2, n2, r2) {
  let [a2, i2] = RN(t2, n2);
  return o$(e20, a2, i2, f$(r2), e20.RGBA, e20.FLOAT);
}
function A$(e20) {
  return e20.internalFormatPackedHalfFloat;
}
function x$(e20, t2, n2, r2) {
  let [a2, i2] = RN(t2, n2);
  return o$(e20, a2, i2, A$(r2), e20.RGBA, r2.textureTypeHalfFloat);
}
function y$(e20, t2, n2) {
  return IN(e20, () => e20.bindBuffer(e20.ARRAY_BUFFER, n2)), KN(e20, t2, "clipSpacePos", n2, 3, 20, 0) && KN(e20, t2, "uv", n2, 2, 20, 12);
}
function b$(e20, t2, n2, r2, a2, i2) {
  let s2, o2, l2;
  IN(e20, () => e20.bindTexture(e20.TEXTURE_2D, t2)), a2 instanceof Uint8Array ? (s2 = new Uint8Array(n2 * r2 * 4), o2 = e20.UNSIGNED_BYTE, l2 = e20.RGBA) : (s2 = new Float32Array(n2 * r2 * 4), o2 = e20.FLOAT, l2 = i2.internalFormatPackedFloat), s2.set(a2), 2 === _e().getNumber("WEBGL_VERSION") ? IN(e20, () => e20.texSubImage2D(e20.TEXTURE_2D, 0, 0, 0, n2, r2, e20.RGBA, o2, s2)) : IN(e20, () => e20.texImage2D(e20.TEXTURE_2D, 0, l2, n2, r2, 0, e20.RGBA, o2, s2)), IN(e20, () => e20.bindTexture(e20.TEXTURE_2D, null));
}
function g$(e20, t2, n2) {
  IN(e20, () => e20.bindTexture(e20.TEXTURE_2D, t2)), n2.data instanceof Uint8Array ? 2 === _e().getNumber("WEBGL_VERSION") ? IN(e20, () => e20.texSubImage2D(e20.TEXTURE_2D, 0, 0, 0, n2.width, n2.height, e20.RGBA, e20.UNSIGNED_BYTE, n2.data)) : IN(e20, () => e20.texImage2D(e20.TEXTURE_2D, 0, e20.RGBA, n2.width, n2.height, 0, e20.RGBA, e20.UNSIGNED_BYTE, n2.data)) : 2 === _e().getNumber("WEBGL_VERSION") ? IN(e20, () => e20.texSubImage2D(e20.TEXTURE_2D, 0, 0, 0, e20.RGBA, e20.UNSIGNED_BYTE, n2)) : IN(e20, () => e20.texImage2D(e20.TEXTURE_2D, 0, e20.RGBA, e20.RGBA, e20.UNSIGNED_BYTE, n2)), IN(e20, () => e20.bindTexture(e20.TEXTURE_2D, null));
}
function v$(e20, t2, n2, r2) {
  let a2 = e20.createBuffer();
  IN(e20, () => e20.bindBuffer(e20.PIXEL_PACK_BUFFER, a2));
  let i2 = 16 * t2 * n2;
  return IN(e20, () => e20.bufferData(e20.PIXEL_PACK_BUFFER, i2, e20.STREAM_READ)), IN(e20, () => e20.readPixels(0, 0, n2, t2, e20.RGBA, e20.FLOAT, 0)), IN(e20, () => e20.bindBuffer(e20.PIXEL_PACK_BUFFER, null)), a2;
}
function w$(e20, t2, n2) {
  let r2 = e20, a2 = new Float32Array(n2);
  return r2.bindBuffer(r2.PIXEL_PACK_BUFFER, t2), r2.getBufferSubData(r2.PIXEL_PACK_BUFFER, 0, a2), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, null), a2;
}
function k$(e20, t2, n2, r2) {
  let [a2, i2] = CN(t2, n2), s2 = new Uint8Array(((e21) => 4 * e21)(t2 * n2));
  return IN(e20, () => e20.readPixels(0, 0, a2, i2, r2.downloadTextureFormat, e20.UNSIGNED_BYTE, s2)), new Float32Array(s2.buffer);
}
function N$(e20, t2, n2, r2, a2, i2, s2, o2) {
  let l2 = e20, u2 = new Float32Array(((e21, t3) => {
    let [n3, r3] = RN(e21, t3);
    return n3 * r3 * 4;
  })(i2, s2));
  return l2.bindBuffer(l2.PIXEL_PACK_BUFFER, t2), l2.getBufferSubData(l2.PIXEL_PACK_BUFFER, 0, u2), l2.bindBuffer(l2.PIXEL_PACK_BUFFER, null), u2;
}
function C$(e20, t2, n2) {
  let r2 = new Float32Array(t2 * n2 * 4);
  return IN(e20, () => e20.readPixels(0, 0, n2, t2, e20.RGBA, e20.FLOAT, r2)), r2;
}
A(r$, { bindVertexProgramAttributeStreams() {
  return y$;
}, createBufferFromOutputTexture() {
  return v$;
}, createFloat16MatrixTexture() {
  return c$;
}, createFloat16PackedMatrixTexture() {
  return x$;
}, createFloat32MatrixTexture() {
  return u$;
}, createIndexBuffer() {
  return s$;
}, createPackedMatrixTexture() {
  return m$;
}, createUnsignedBytesMatrixTexture() {
  return p$;
}, createVertexBuffer() {
  return i$;
}, createVertexShader() {
  return a$;
}, downloadByteEncodedFloatMatrixFromOutputTexture() {
  return k$;
}, downloadFloat32MatrixFromBuffer() {
  return w$;
}, downloadMatrixFromPackedOutputTexture() {
  return C$;
}, downloadPackedMatrixFromBuffer() {
  return N$;
}, getInternalFormatForFloat16MatrixTexture() {
  return d$;
}, getInternalFormatForFloat16PackedMatrixTexture() {
  return A$;
}, getInternalFormatForFloat32MatrixTexture() {
  return l$;
}, getInternalFormatForPackedMatrixTexture() {
  return f$;
}, getInternalFormatForUnsignedBytesMatrixTexture() {
  return h$;
}, uploadDenseMatrixToTexture() {
  return b$;
}, uploadPixelDataToTexture() {
  return g$;
} });
var $$ = class {
  constructor(e20) {
    this.outputTexture = null, this.program = null, this.disposed = false, this.itemsToPoll = [];
    let t2 = _e().getNumber("WEBGL_VERSION");
    if (null != e20 ? (this.gl = e20, kN(t2, e20)) : this.gl = NN(t2), e20 = this.gl, 2 === _e().getNumber("WEBGL_VERSION")) {
      let t3 = e20;
      this.createVertexArray = () => IN(t3, () => t3.createVertexArray()), this.bindVertexArray = (e21) => IN(t3, () => t3.bindVertexArray(e21)), this.deleteVertexArray = (e21) => IN(t3, () => t3.deleteVertexArray(e21)), this.getVertexArray = () => IN(t3, () => t3.getParameter(t3.VERTEX_ARRAY_BINDING));
    } else if (null != e20) {
      let t3 = e20.getExtension("OES_vertex_array_object");
      if (null == t3) throw Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
      this.createVertexArray = () => IN(e20, () => t3.createVertexArrayOES()), this.bindVertexArray = (n3) => IN(e20, () => t3.bindVertexArrayOES(n3)), this.deleteVertexArray = (n3) => IN(e20, () => t3.deleteVertexArrayOES(n3)), this.getVertexArray = () => IN(e20, () => e20.getParameter(t3.VERTEX_ARRAY_BINDING_OES));
    }
    let n2 = "WEBGL_color_buffer_float", r2 = "EXT_color_buffer_half_float";
    if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), 1 === _e().getNumber("WEBGL_VERSION")) {
      let e21 = "OES_texture_half_float";
      if (this.textureFloatExtension = FN(this.gl, "OES_texture_float"), gC(this.gl, e21)) this.textureHalfFloatExtension = FN(this.gl, e21);
      else if (_e().get("WEBGL_FORCE_F16_TEXTURES")) throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(n2), gC(this.gl, r2)) this.colorBufferHalfFloatExtension = FN(this.gl, r2);
      else if (_e().get("WEBGL_FORCE_F16_TEXTURES")) throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (n2 = "EXT_color_buffer_float", gC(this.gl, n2)) this.colorBufferFloatExtension = this.gl.getExtension(n2);
    else {
      if (!gC(this.gl, r2)) throw Error("GL context does not support color renderable floats");
      this.colorBufferHalfFloatExtension = this.gl.getExtension(r2);
    }
    this.vertexBuffer = i$(this.gl), this.indexBuffer = s$(this.gl), this.framebuffer = ZN(this.gl), this.textureConfig = SN(this.gl, this.textureHalfFloatExtension);
  }
  get debug() {
    return _e().getBool("DEBUG");
  }
  dispose() {
    if (this.disposed) return;
    null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
    let e20 = this.gl;
    IN(e20, () => e20.finish()), IN(e20, () => e20.bindFramebuffer(e20.FRAMEBUFFER, null)), IN(e20, () => e20.deleteFramebuffer(this.framebuffer)), IN(e20, () => e20.bindBuffer(e20.ARRAY_BUFFER, null)), IN(e20, () => e20.bindBuffer(e20.ELEMENT_ARRAY_BUFFER, null)), IN(e20, () => e20.deleteBuffer(this.indexBuffer)), this.disposed = true;
  }
  createFloat32MatrixTexture(e20, t2) {
    return this.throwIfDisposed(), u$(this.gl, e20, t2, this.textureConfig);
  }
  createFloat16MatrixTexture(e20, t2) {
    return this.throwIfDisposed(), c$(this.gl, e20, t2, this.textureConfig);
  }
  createUnsignedBytesMatrixTexture(e20, t2) {
    return this.throwIfDisposed(), p$(this.gl, e20, t2, this.textureConfig);
  }
  uploadPixelDataToTexture(e20, t2) {
    this.throwIfDisposed(), g$(this.gl, e20, t2);
  }
  uploadDenseMatrixToTexture(e20, t2, n2, r2) {
    this.throwIfDisposed(), b$(this.gl, e20, t2, n2, r2, this.textureConfig);
  }
  createFloat16PackedMatrixTexture(e20, t2) {
    return this.throwIfDisposed(), x$(this.gl, e20, t2, this.textureConfig);
  }
  createPackedMatrixTexture(e20, t2) {
    return this.throwIfDisposed(), m$(this.gl, e20, t2, this.textureConfig);
  }
  deleteMatrixTexture(e20) {
    this.throwIfDisposed(), this.outputTexture === e20 && (aC(this.gl, this.framebuffer), this.outputTexture = null), IN(this.gl, () => this.gl.deleteTexture(e20));
  }
  downloadByteEncodedFloatMatrixFromOutputTexture(e20, t2, n2) {
    return this.downloadMatrixDriver(e20, () => k$(this.gl, t2, n2, this.textureConfig));
  }
  downloadPackedMatrixFromBuffer(e20, t2, n2, r2, a2, i2) {
    return N$(this.gl, e20, 0, 0, 0, a2, i2);
  }
  downloadFloat32MatrixFromBuffer(e20, t2) {
    return w$(this.gl, e20, t2);
  }
  createBufferFromTexture(e20, t2, n2) {
    this.bindTextureToFrameBuffer(e20);
    let r2 = v$(this.gl, t2, n2);
    return this.unbindTextureToFrameBuffer(), r2;
  }
  createAndWaitForFence() {
    let e20 = this.createFence(this.gl);
    return this.pollFence(e20);
  }
  createFence(e20) {
    let t2, n2;
    if (_e().getBool("WEBGL_FENCE_API_ENABLED")) {
      let r2 = e20, a2 = r2.fenceSync(r2.SYNC_GPU_COMMANDS_COMPLETE, 0);
      e20.flush(), n2 = () => {
        let e21 = r2.clientWaitSync(a2, 0, 0);
        return e21 === r2.ALREADY_SIGNALED || e21 === r2.CONDITION_SATISFIED;
      }, t2 = a2;
    } else _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t2 = this.beginQuery(), this.endQuery(), n2 = () => this.isQueryAvailable(t2, _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : n2 = () => true;
    return { query: t2, isFencePassed: n2 };
  }
  downloadMatrixFromPackedTexture(e20, t2, n2) {
    return this.downloadMatrixDriver(e20, () => C$(this.gl, t2, n2));
  }
  createProgram(e20) {
    this.throwIfDisposed();
    let t2 = this.gl;
    null == this.vertexShader && (this.vertexShader = a$(t2));
    let n2 = LN(t2);
    IN(t2, () => t2.attachShader(n2, this.vertexShader)), IN(t2, () => t2.attachShader(n2, e20)), BN(t2, n2);
    let r2 = Object.assign(n2, { vao: this.createVertexArray() });
    return this.debug && UN(t2, r2), r2;
  }
  buildVao(e20) {
    this.setProgram(e20), this.bindVertexArray(e20.vao);
    let t2 = this.gl;
    IN(t2, () => t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, this.indexBuffer)), y$(t2, e20, this.vertexBuffer);
  }
  deleteProgram(e20) {
    this.throwIfDisposed(), e20 === this.program && (this.program = null), null != e20 && (IN(this.gl, () => this.gl.deleteProgram(e20)), this.deleteVertexArray(e20.vao));
  }
  setProgram(e20) {
    this.throwIfDisposed(), this.program = e20, null != this.program && this.debug && UN(this.gl, this.program), IN(this.gl, () => this.gl.useProgram(e20));
  }
  getUniformLocation(e20, t2, n2 = true) {
    return this.throwIfDisposed(), n2 ? QN(this.gl, e20, t2) : eC(this.gl, e20, t2);
  }
  getAttributeLocation(e20, t2) {
    return this.throwIfDisposed(), IN(this.gl, () => this.gl.getAttribLocation(e20, t2));
  }
  getUniformLocationNoThrow(e20, t2) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(e20, t2);
  }
  setInputMatrixTexture(e20, t2, n2) {
    this.throwIfDisposed(), this.throwIfNoProgram(), tC(this.gl, e20, t2, n2);
  }
  setOutputMatrixTexture(e20, t2, n2) {
    this.setOutputMatrixTextureDriver(e20, n2, t2);
  }
  setOutputPackedMatrixTexture(e20, t2, n2) {
    this.throwIfDisposed();
    let [r2, a2] = RN(t2, n2);
    this.setOutputMatrixTextureDriver(e20, r2, a2);
  }
  setOutputMatrixWriteRegion(e20, t2, n2, r2) {
    this.setOutputMatrixWriteRegionDriver(n2, e20, r2, t2);
  }
  setOutputPackedMatrixWriteRegion(e20, t2, n2, r2) {
    throw Error("setOutputPackedMatrixWriteRegion not implemented.");
  }
  debugValidate() {
    null != this.program && UN(this.gl, this.program), iC(this.gl);
  }
  executeProgram() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    let e20 = this.gl;
    if (this.debug) {
      let e21 = this.getVertexArray();
      console.assert(e21 === this.program.vao, "VAO changed between setProgram and executeProgram!"), this.debugValidate();
    }
    IN(e20, () => e20.drawElements(e20.TRIANGLES, 6, e20.UNSIGNED_SHORT, 0));
  }
  blockUntilAllProgramsCompleted() {
    this.throwIfDisposed(), IN(this.gl, () => this.gl.finish());
  }
  getQueryTimerExtension() {
    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = FN(this.gl, 2 === _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }
  getQueryTimerExtensionWebGL2() {
    return this.getQueryTimerExtension();
  }
  getQueryTimerExtensionWebGL1() {
    return this.getQueryTimerExtension();
  }
  beginQuery() {
    if (2 === _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      let e21 = this.gl, t3 = this.getQueryTimerExtensionWebGL2(), n2 = e21.createQuery();
      return e21.beginQuery(t3.TIME_ELAPSED_EXT, n2), n2;
    }
    let e20 = this.getQueryTimerExtensionWebGL1(), t2 = e20.createQueryEXT();
    return e20.beginQueryEXT(e20.TIME_ELAPSED_EXT, t2), t2;
  }
  endQuery() {
    if (2 === _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      let e21 = this.gl, t2 = this.getQueryTimerExtensionWebGL2();
      return void e21.endQuery(t2.TIME_ELAPSED_EXT);
    }
    let e20 = this.getQueryTimerExtensionWebGL1();
    e20.endQueryEXT(e20.TIME_ELAPSED_EXT);
  }
  waitForQueryAndGetTime(e20) {
    return __async(this, null, function* () {
      return yield va.repeatedTry(() => this.disposed || this.isQueryAvailable(e20, _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this.getQueryTime(e20, _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    });
  }
  getQueryTime(e20, t2) {
    if (0 === t2) return null;
    if (2 === t2) {
      let t3 = this.gl;
      return t3.getQueryParameter(e20, t3.QUERY_RESULT) / 1e6;
    }
    {
      let t3 = this.getQueryTimerExtensionWebGL1();
      return t3.getQueryObjectEXT(e20, t3.QUERY_RESULT_EXT) / 1e6;
    }
  }
  isQueryAvailable(e20, t2) {
    if (0 === t2) return true;
    if (2 === t2) {
      let t3 = this.gl, n2 = this.getQueryTimerExtensionWebGL2(), r2 = t3.getQueryParameter(e20, t3.QUERY_RESULT_AVAILABLE);
      return null == this.disjoint && (this.disjoint = this.gl.getParameter(n2.GPU_DISJOINT_EXT)), r2 && !this.disjoint;
    }
    {
      let t3 = this.getQueryTimerExtensionWebGL1(), n2 = t3.getQueryObjectEXT(e20, t3.QUERY_RESULT_AVAILABLE_EXT);
      return null == this.disjoint && (this.disjoint = this.gl.getParameter(t3.GPU_DISJOINT_EXT)), n2 && !this.disjoint;
    }
  }
  pollFence(e20) {
    return new Promise((t2) => {
      this.addItemToPoll(() => e20.isFencePassed(), () => t2());
    });
  }
  pollItems() {
    let e20 = ((e21) => {
      let t2 = 0;
      for (; e21.length > t2 && e21[t2](); ++t2) ;
      return t2 - 1;
    })(this.itemsToPoll.map((e21) => e21.isDoneFn));
    for (let t2 = 0; e20 >= t2; ++t2) {
      let { resolveFn: e21 } = this.itemsToPoll[t2];
      e21();
    }
    this.itemsToPoll = this.itemsToPoll.slice(e20 + 1);
  }
  addItemToPoll(e20, t2) {
    if (this.itemsToPoll.push({ isDoneFn: e20, resolveFn: t2 }), this.itemsToPoll.length > 1) return;
    let n2;
    "setTimeoutCustom" in _e().platform && (n2 = _e().platform.setTimeoutCustom.bind(_e().platform)), va.repeatedTry(() => (this.pollItems(), 0 === this.itemsToPoll.length), () => 0, null, n2);
  }
  bindTextureToFrameBuffer(e20) {
    this.throwIfDisposed(), rC(this.gl, e20, this.framebuffer), this.debug && iC(this.gl);
  }
  unbindTextureToFrameBuffer() {
    null != this.outputTexture ? (rC(this.gl, this.outputTexture, this.framebuffer), this.debug && iC(this.gl)) : aC(this.gl, this.framebuffer);
  }
  downloadMatrixDriver(e20, t2) {
    this.bindTextureToFrameBuffer(e20);
    let n2 = t2();
    return this.unbindTextureToFrameBuffer(), n2;
  }
  setOutputMatrixTextureDriver(e20, t2, n2) {
    this.throwIfDisposed();
    let r2 = this.gl;
    rC(r2, e20, this.framebuffer), this.debug && iC(r2), this.outputTexture = e20, IN(r2, () => r2.viewport(0, 0, t2, n2)), IN(r2, () => r2.scissor(0, 0, t2, n2));
  }
  setOutputMatrixWriteRegionDriver(e20, t2, n2, r2) {
    this.throwIfDisposed(), IN(this.gl, () => this.gl.scissor(e20, t2, n2, r2));
  }
  throwIfDisposed() {
    if (this.disposed) throw Error("Attempted to use disposed GPGPUContext.");
  }
  throwIfNoProgram() {
    if (null == this.program) throw Error("No GPU program is currently set.");
  }
};
var { addImpl: R$, bincountImpl: S$, bincountReduceImpl: I$, bitwiseAndImpl: E$, castImpl: T$, ceilImpl: M$, concatImpl: O$, equalImpl: F$, expImpl: P$, expm1Impl: z$, floorImpl: V$, gatherNdImpl: _$, gatherV2Impl: D$, greaterImpl: W$, greaterEqualImpl: L$, lessImpl: B$, lessEqualImpl: U$, linSpaceImpl: j$, logImpl: G$, maxImpl: H$, maximumImpl: X$, minimumImpl: q$, multiplyImpl: Z$, negImpl: K$, notEqualImpl: Y$, prodImpl: J$, raggedGatherImpl: Q$, raggedRangeImpl: eR, raggedTensorToTensorImpl: tR, rangeImpl: nR, rsqrtImpl: rR, scatterImpl: aR, sigmoidImpl: iR, simpleAbsImpl: sR, sliceImpl: oR, sparseFillEmptyRowsImpl: lR, sparseReshapeImpl: uR, sparseSegmentReductionImpl: dR, sqrtImpl: cR, staticRegexReplaceImpl: hR, stridedSliceImpl: pR, stringNGramsImpl: fR, stringSplitImpl: mR, stringToHashBucketFastImpl: AR, subImpl: xR, tileImpl: yR, topKImpl: bR, transposeImpl: gR, uniqueImpl: vR } = Lx;
function wR(e20, t2) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, t2).map((t3) => `${e20}.${t3}`);
}
function kR(e20, t2) {
  return 1 === t2 ? [e20] : wR(e20, t2);
}
var NR = class {
  constructor(e20) {
    if (this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = e20, this.rank = e20.length, this.enableShapeUniforms = ZC(this.outputShape.length), 0 === this.rank) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
    else {
      let e21 = kR("rc", this.rank), t2 = UC(this.rank), n2 = this.getOutOfBoundsCondition(e21), r2 = this.getSetup(e21), a2 = this.getOutput(e21);
      this.userCode = `
        void main() {
          ${t2} rc = getOutputCoords();

          if(${n2}) {
            setOutput(vec4(0));
          } else {
            ${r2}

            setOutput(vec4(${a2}));
          }
        }
      `;
    }
  }
  getSourceCoordsArr(e20) {
    let t2 = [];
    for (let n2 = 0; 1 >= n2; n2++) for (let r2 = 0; 1 >= r2; r2++) {
      let a2 = `${0 === n2 ? "r" : "rp1"}, ${0 === r2 ? "c" : "cp1"}`;
      for (let t3 = 2; this.rank > t3; t3++) a2 = e20[e20.length - 1 - t3] + "," + a2;
      t2.push(a2);
    }
    return t2;
  }
  getOutOfBoundsCondition(e20) {
    if (1 === this.rank) return "rc > " + (this.enableShapeUniforms ? "outShape" : this.outputShape[0]);
    let t2 = "";
    for (let n2 = this.rank - 2; this.rank > n2; n2++) t2 += `${e20[n2]} >= ${this.enableShapeUniforms ? `outShape[${n2}]` : this.outputShape[n2]}`, this.rank - 1 > n2 && (t2 += "||");
    return t2;
  }
  getSetup(e20) {
    if (1 === this.rank) return "";
    let t2 = e20.slice(-2);
    return `
      int r = ${t2[0]};
      int c = ${t2[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1]};
      bool rEdge = rp1 >= ${this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2]};
    `;
  }
  getOutput(e20) {
    let t2 = this.getSourceCoordsArr(e20);
    return 1 === this.rank ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${t2[0]}),
            cEdge ? 0. : getA(${t2[1]}),
            rEdge ? 0. : getA(${t2[2]}),
            rEdge || cEdge ? 0. : getA(${t2[3]})`;
  }
};
var CR = class {
  constructor(e20, t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec3" }], this.outputShape = e20, this.enableShapeUniforms = ZC(this.outputShape.length);
    let n2 = "";
    for (let r2 = 0; 4 > r2; r2++) {
      let e21 = "thisRC = rc;";
      r2 % 2 == 1 && (e21 += "thisRC.z += 1;"), r2 > 1 && (e21 += "thisRC.y += 1;"), n2 += `
        ${e21}
        ${r2 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r2}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r2 > 0 ? "}" : ""}
      `;
    }
    this.userCode = `
      ${((e21) => `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${this.enableShapeUniforms ? ((e22, t3, n3 = "index") => {
      let r2 = ((e23, t4) => {
        let n4 = e23.length, r3 = e23.map((e24) => `${t4}[${e24}]`), a2 = Array(n4 - 1);
        a2[n4 - 2] = r3[n4 - 1];
        for (let i2 = n4 - 3; i2 >= 0; --i2) a2[i2] = `(${a2[i2 + 1]} * ${r3[i2 + 1]})`;
        return a2;
      })(e22.map((e23, t4) => t4), t3);
      return r2.map((t4, a2) => `int ${e22[a2]} = ${n3} / ${r2[a2]}; ${a2 === r2.length - 1 ? `int ${e22[a2 + 1]} = ${n3} - ${e22[a2]} * ${r2[a2]}` : `index -= ${e22[a2]} * ${r2[a2]}`};`).join("");
    })(["r", "c", "d"], "inputShape") : IC(["r", "c", "d"], e21)}
      return ivec3(r, c, d);
    }
  `)(t2)}
      ${this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : TC(e20)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : e20[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : e20[2]};

        ${n2}

        setOutput(result);
      }
    `;
  }
};
var $R = class {
  constructor(e20) {
    this.gpgpu = e20, this.numUsedTextures = 0, this.numFreeTextures = 0, this.mr = 0, this.Ar = 0, this.freeTextures = {}, this.usedTextures = {}, this.logEnabled = false;
  }
  acquireTexture(e20, t2, n2) {
    let r2 = SR(t2, n2), a2 = IR(e20, r2, n2);
    a2 in this.freeTextures || (this.freeTextures[a2] = []), a2 in this.usedTextures || (this.usedTextures[a2] = []);
    let i2, s2 = RR(e20, r2, this.gpgpu.gl, this.gpgpu.textureConfig, n2);
    if (this.freeTextures[a2].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this.Ar -= s2, this.log();
      let e21 = this.freeTextures[a2].pop();
      return this.usedTextures[a2].push(e21), e21;
    }
    return r2 === gN.PACKED_2X2_FLOAT32 ? i2 = this.gpgpu.createPackedMatrixTexture(e20[0], e20[1]) : r2 === gN.PACKED_2X2_FLOAT16 ? i2 = this.gpgpu.createFloat16PackedMatrixTexture(e20[0], e20[1]) : r2 === gN.UNPACKED_FLOAT32 ? i2 = this.gpgpu.createFloat32MatrixTexture(e20[0], e20[1]) : r2 === gN.UNPACKED_FLOAT16 ? i2 = this.gpgpu.createFloat16MatrixTexture(e20[0], e20[1]) : r2 === gN.PACKED_4X1_UNSIGNED_BYTE && (i2 = this.gpgpu.createUnsignedBytesMatrixTexture(e20[0], e20[1])), this.usedTextures[a2].push(i2), this.numUsedTextures++, this.mr += s2, this.log(), i2;
  }
  releaseTexture(e20, t2, n2, r2) {
    if (null == this.freeTextures) return;
    let a2 = SR(n2, r2), i2 = IR(t2, a2, r2);
    i2 in this.freeTextures || (this.freeTextures[i2] = []);
    let s2 = RR(t2, a2, this.gpgpu.gl, this.gpgpu.textureConfig, r2), o2 = _e().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
    -1 !== o2 && this.mr > o2 ? (this.gpgpu.deleteMatrixTexture(e20.texture), this.mr -= s2) : (this.freeTextures[i2].push(e20), this.numFreeTextures++, this.Ar += s2), this.numUsedTextures--;
    let l2 = this.usedTextures[i2], u2 = l2 && l2.indexOf(e20);
    if (null == u2 || 0 > u2) throw Error("Cannot release a texture that was never provided by this texture manager");
    l2[u2] = l2[l2.length - 1], l2.pop(), this.log();
  }
  log() {
    if (!this.logEnabled) return;
    console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${this.numFreeTextures + this.numUsedTextures})`);
    let e20 = this.Ar / this.mr;
    console.log("Bytes allocated: " + this.mr), console.log(`Bytes unused: ${this.Ar} (${Math.round(100 * e20)}%)`);
  }
  get numBytesAllocated() {
    return this.mr;
  }
  get numBytesFree() {
    return this.Ar;
  }
  getNumUsedTextures() {
    return this.numUsedTextures;
  }
  getNumFreeTextures() {
    return this.numFreeTextures;
  }
  dispose() {
    if (null != this.freeTextures) {
      for (let e20 in this.freeTextures) this.freeTextures[e20].forEach((e21) => {
        this.gpgpu.deleteMatrixTexture(e21.texture);
      });
      for (let e20 in this.usedTextures) this.usedTextures[e20].forEach((e21) => {
        this.gpgpu.deleteMatrixTexture(e21.texture);
      });
      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this.mr = 0, this.Ar = 0;
    }
  }
};
function RR(e20, t2, n2, r2, a2) {
  let i2, s2 = ((e21, t3) => {
    switch (e21) {
      case gN.PACKED_2X2_FLOAT32:
        return f$(t3);
      case gN.PACKED_2X2_FLOAT16:
        return A$(t3);
      case gN.UNPACKED_FLOAT32:
        return l$(t3);
      case gN.UNPACKED_FLOAT16:
        return d$(t3);
      case gN.PACKED_4X1_UNSIGNED_BYTE:
        return h$(t3);
      default:
        throw Error("Unknown physical texture type " + e21);
    }
  })(t2, r2);
  if (a2) {
    let [t3, n3] = RN(e20[0], e20[1]);
    i2 = t3 * n3;
  } else {
    let [t3, n3] = CN(e20[0], e20[1]);
    i2 = t3 * n3;
  }
  let o2 = ((e21, t3) => {
    if (t3 === e21.R32F) return 4;
    if (t3 === e21.R16F) return 2;
    if (t3 === e21.RGBA32F) return 16;
    if (t3 === e21.RGBA) return 16;
    if (t3 === e21.RGBA16F) return 8;
    if (t3 === e21.RGBA8) return 4;
    throw Error("Unknown internal format " + t3);
  })(n2, s2);
  return i2 * o2;
}
function SR(e20, t2) {
  if (e20 === bN.UPLOAD) return gN.PACKED_2X2_FLOAT32;
  if (e20 === bN.RENDER || null == e20) return ((e21) => _e().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e21 ? gN.PACKED_2X2_FLOAT32 : gN.UNPACKED_FLOAT32 : e21 ? gN.PACKED_2X2_FLOAT16 : gN.UNPACKED_FLOAT16)(t2);
  if (e20 === bN.DOWNLOAD || e20 === bN.PIXELS) return gN.PACKED_4X1_UNSIGNED_BYTE;
  throw Error("Unknown logical texture type " + e20);
}
function IR(e20, t2, n2) {
  return `${e20[0]}_${e20[1]}_${t2}_${n2}`;
}
var ER = class {
  constructor(e20, t2) {
    this.variableNames = ["A"], this.outputShape = e20, this.enableShapeUniforms = ZC(this.outputShape.length), this.userCode = `
      float unaryOperation(float x) {
        ${t2}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
};
var TR = "if (isnan(x)) return x;";
var MR = "return abs(x);";
var OR = TR + "\n  return (x < 0.0) ? 0.0 : x;\n";
var FR = TR + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
var PR = "return x;";
var zR = class {
  constructor(e20, t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e20, this.enableShapeUniforms = ZC(this.outputShape.length), this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${t2}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
};
var VR = class {
  constructor(e20) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = e20, this.enableShapeUniforms = ZC(this.outputShape.length);
    let t2 = e20.length, n2 = kR("rc", t2), r2 = UC(t2), a2 = ((e21, t3) => {
      if (1 === e21) return "rc";
      let n3 = "";
      for (let r3 = 0; e21 > r3; r3++) n3 += t3[r3], e21 - 1 > r3 && (n3 += ",");
      return n3;
    })(t2, n2), i2 = n2.slice(-2), s2 = t2 > 1 ? `vec2(${i2.join(",")})` : "rc";
    this.userCode = `
      void main() {
        ${r2} rc = getOutputCoords();
        vec4 packedInput = getA(${a2});

        setOutput(getChannel(packedInput, ${s2}));
      }
    `;
  }
};
var _R = Ym.whereImpl;
var DR = {};
var WR = _e().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
var LR = class e13 extends D {
  nextDataId() {
    return e13.nextDataId++;
  }
  constructor(e20) {
    if (super(), this.pendingRead = /* @__PURE__ */ new WeakMap(), this.pendingDisposal = /* @__PURE__ */ new WeakSet(), this.dataRefCount = /* @__PURE__ */ new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = false, this.pendingDeletes = 0, this.disposed = false, !_e().getBool("HAS_WEBGL")) throw Error("WebGL is not supported on this device");
    let t2;
    if (null != e20) {
      if (e20 instanceof $$) t2 = e20;
      else {
        let n2 = NN(_e().getNumber("WEBGL_VERSION"), e20);
        t2 = new $$(n2);
      }
      this.binaryCache = {}, this.gpgpuCreatedLocally = false;
    } else {
      let e21 = NN(_e().getNumber("WEBGL_VERSION"));
      t2 = new $$(e21), this.binaryCache = ((e22) => (e22 in DR || (DR[e22] = {}), DR[e22]))(_e().getNumber("WEBGL_VERSION")), this.gpgpuCreatedLocally = true;
    }
    this.gpgpu = t2, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new $R(this.gpgpu), this.numMBBeforeWarning = null == _e().global.screen ? 1024 : _e().global.screen.height * _e().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024, this.texData = new _(this, Yi());
  }
  numDataIds() {
    return this.texData.numDataIds() - this.pendingDeletes;
  }
  writeTexture(e20, t2, n2, r2, a2, i2) {
    let s2 = this.makeTensorInfo(t2, n2), o2 = this.texData.get(s2.dataId);
    o2.isPacked = false, o2.texture = { texture: e20, texShape: [r2, a2] }, o2.texShape = [r2, a2];
    let l2 = cC(t2), u2 = new t$(l2, false, i2), d2 = this.runWebGLProgram(u2, [s2], n2, [[r2, a2]]);
    return d2.shape = t2, o2.texture = null, this.disposeIntermediateTensorInfo(s2), d2.dataId;
  }
  write(e20, t2, n2) {
    if ((_e().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || _e().getBool("DEBUG")) && this.checkNumericalProblems(e20), "complex64" === n2 && null != e20) throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    let r2 = { id: this.nextDataId() };
    return this.texData.set(r2, { shape: t2, dtype: n2, values: e20, usage: bN.UPLOAD, refCount: 1 }), r2;
  }
  refCount(e20) {
    return this.texData.has(e20) ? this.texData.get(e20).refCount : 0;
  }
  incRef(e20) {
    this.texData.get(e20).refCount++;
  }
  decRef(e20) {
    this.texData.has(e20) && this.texData.get(e20).refCount--;
  }
  move(e20, t2, n2, r2, a2) {
    if (_e().getBool("DEBUG") && this.checkNumericalProblems(t2), "complex64" === r2) throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(e20, { shape: n2, dtype: r2, values: t2, usage: bN.UPLOAD, refCount: a2 });
  }
  disposeIntermediateTensorInfo(e20) {
    this.disposeData(e20.dataId);
  }
  readSync(e20) {
    let t2 = this.texData.get(e20), { values: n2, dtype: r2, complexTensorInfos: a2, slice: i2, shape: s2, isPacked: o2 } = t2;
    if (null != i2) {
      let t3;
      t3 = o2 ? new zR(s2, PR) : new ER(s2, PR);
      let n3 = this.runWebGLProgram(t3, [{ dataId: e20, shape: s2, dtype: r2 }], r2), a3 = this.readSync(n3.dataId);
      return this.disposeIntermediateTensorInfo(n3), a3;
    }
    if (null != n2) return this.convertAndCacheOnCPU(e20);
    if ("string" === r2) return n2;
    let l2, u2, d2 = null != this.activeTimers;
    if (d2 && (l2 = va.now()), "complex64" === r2) {
      let e21 = this.readSync(a2.real.dataId), t3 = this.readSync(a2.imag.dataId);
      u2 = Uf.mergeRealAndImagArrays(e21, t3);
    } else u2 = this.getValuesFromTexture(e20);
    return d2 && (this.downloadWaitMs += va.now() - l2), this.convertAndCacheOnCPU(e20, u2);
  }
  read(e20) {
    return __async(this, null, function* () {
      if (this.pendingRead.has(e20)) {
        let t3 = this.pendingRead.get(e20);
        return new Promise((e21) => t3.push(e21));
      }
      let t2 = this.texData.get(e20), { values: n2, shape: r2, slice: a2, dtype: i2, complexTensorInfos: s2, isPacked: o2 } = t2;
      if (null != a2) {
        let t3;
        t3 = o2 ? new zR(r2, PR) : new ER(r2, PR);
        let n3 = this.runWebGLProgram(t3, [{ dataId: e20, shape: r2, dtype: i2 }], i2), a3 = this.read(n3.dataId);
        return this.disposeIntermediateTensorInfo(n3), a3;
      }
      if (null != n2) return this.convertAndCacheOnCPU(e20);
      if (_e().getBool("DEBUG") && !_e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === _e().getNumber("WEBGL_VERSION")) throw Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
      let l2, u2, d2 = null;
      if ("complex64" !== i2 && _e().get("WEBGL_BUFFER_SUPPORTED")) {
        l2 = this.decode(e20);
        let t3 = this.texData.get(l2.dataId);
        d2 = this.gpgpu.createBufferFromTexture(t3.texture.texture, ...$N(r2));
      }
      if (this.pendingRead.set(e20, []), "complex64" !== i2 && (yield this.gpgpu.createAndWaitForFence()), "complex64" === i2) {
        let e21 = yield Promise.all([this.read(s2.real.dataId), this.read(s2.imag.dataId)]);
        u2 = Uf.mergeRealAndImagArrays(e21[0], e21[1]);
      } else if (null == d2) u2 = this.getValuesFromTexture(e20);
      else {
        let e21 = va.sizeFromShape(r2);
        u2 = this.gpgpu.downloadFloat32MatrixFromBuffer(d2, e21);
      }
      if (null != l2 && this.disposeIntermediateTensorInfo(l2), null != d2) {
        let e21 = this.gpgpu.gl;
        IN(e21, () => e21.deleteBuffer(d2));
      }
      let c2 = this.convertAndCacheOnCPU(e20, u2), h2 = this.pendingRead.get(e20);
      return this.pendingRead.delete(e20), h2.forEach((e21) => e21(c2)), this.pendingDisposal.has(e20) && (this.pendingDisposal.delete(e20), this.disposeData(e20) && Yi().removeDataId(e20, this), this.pendingDeletes--), c2;
    });
  }
  readToGPU(e20, t2 = {}) {
    let n2 = this.texData.get(e20), { values: r2, shape: a2, slice: i2, dtype: s2, isPacked: o2, texture: l2 } = n2;
    if ("complex64" === s2) throw Error("Does not support reading texture for complex64 dtype.");
    if (null != i2) {
      let n3;
      n3 = o2 ? new zR(a2, PR) : new ER(a2, PR);
      let r3 = this.runWebGLProgram(n3, [{ dataId: e20, shape: a2, dtype: s2 }], s2), i3 = this.readToGPU(r3, t2);
      return this.disposeIntermediateTensorInfo(r3), i3;
    }
    if (null == l2) throw Error(null != r2 ? "Data is not on GPU but on CPU." : "There is no data on GPU or CPU.");
    let u2 = this.decode(e20, t2.customTexShape), d2 = Yi().makeTensorFromTensorInfo(u2), c2 = this.texData.get(u2.dataId);
    return Object.assign({ tensorRef: d2 }, c2.texture);
  }
  bufferSync(e20) {
    let t2 = this.readSync(e20.dataId);
    if ("string" === e20.dtype) try {
      let n2 = t2.map((e21) => va.decodeString(e21));
      return uo(e20.shape, e20.dtype, n2);
    } catch (n2) {
      throw Error("Failed to decode encoded string bytes into utf-8");
    }
    return uo(e20.shape, e20.dtype, t2);
  }
  checkNumericalProblems(e20) {
    if (null != e20) for (let t2 = 0; e20.length > t2; t2++) {
      let n2 = e20[t2];
      if (!MN(n2)) throw _e().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${n2} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${n2} cannot be represented on this device.`);
    }
  }
  getValuesFromTexture(e20) {
    let { shape: t2, dtype: n2, isPacked: r2 } = this.texData.get(e20), a2 = va.sizeFromShape(t2);
    if (_e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      let n3 = this.decode(e20), r3 = this.texData.get(n3.dataId), i3 = this.gpgpu.downloadMatrixFromPackedTexture(r3.texture.texture, ...$N(t2)).subarray(0, a2);
      return this.disposeIntermediateTensorInfo(n3), i3;
    }
    let i2 = _e().getBool("WEBGL_PACK") && true === r2, s2 = i2 ? cC(t2) : t2, o2 = i2 ? new QC(s2) : new JC(s2), l2 = this.runWebGLProgram(o2, [{ shape: s2, dtype: n2, dataId: e20 }], "float32"), u2 = this.texData.get(l2.dataId), d2 = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u2.texture.texture, u2.texShape[0], u2.texShape[1]).subarray(0, a2);
    return this.disposeIntermediateTensorInfo(l2), d2;
  }
  timerAvailable() {
    return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
  }
  time(e20) {
    let t2 = this.activeTimers, n2 = [], r2 = false;
    null == this.programTimersStack ? (this.programTimersStack = n2, r2 = true) : this.activeTimers.push(n2), this.activeTimers = n2, e20();
    let a2 = va.flatten(this.activeTimers.map((e21) => e21.query)).filter((e21) => null != e21), i2 = va.flatten(this.activeTimers.map((e21) => e21.name)).filter((e21) => null != e21);
    this.activeTimers = t2, r2 && (this.programTimersStack = null);
    let s2 = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null };
    return (() => __async(this, null, function* () {
      if (_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        let e21 = yield Promise.all(a2);
        s2.kernelMs = va.sum(e21), s2.getExtraProfileInfo = () => e21.map((e22, t3) => ({ name: i2[t3], ms: e22 })).map((e22) => `${e22.name}: ${e22.ms}`).join(", ");
      } else s2.kernelMs = { error: "WebGL query timers are not supported in this environment." };
      return this.uploadWaitMs = 0, this.downloadWaitMs = 0, s2;
    }))();
  }
  memory() {
    return { unreliable: false, numBytesInGPU: this.numBytesInGPU, numBytesInGPUAllocated: this.textureManager.numBytesAllocated, numBytesInGPUFree: this.textureManager.numBytesFree };
  }
  startTimer() {
    return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: va.now(), endMs: null };
  }
  endTimer(e20) {
    return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e20) : (e20.endMs = va.now(), e20);
  }
  getQueryTime(e20) {
    return __async(this, null, function* () {
      return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.waitForQueryAndGetTime(e20) : e20.endMs - e20.startMs;
    });
  }
  disposeData(e20, t2 = false) {
    if (this.pendingDisposal.has(e20)) return false;
    if (!this.texData.has(e20)) return true;
    if (t2 ? this.texData.get(e20).refCount = 0 : this.texData.get(e20).refCount--, !t2 && this.texData.get(e20).refCount > 0) return false;
    if (this.pendingRead.has(e20)) return this.pendingDisposal.add(e20), this.pendingDeletes++, false;
    this.releaseGPUData(e20);
    let { complexTensorInfos: n2 } = this.texData.get(e20);
    return null != n2 && (this.disposeData(n2.real.dataId, t2), this.disposeData(n2.imag.dataId, t2)), this.texData.delete(e20), true;
  }
  releaseGPUData(e20) {
    let { texture: t2, dtype: n2, texShape: r2, usage: a2, isPacked: i2, slice: s2 } = this.texData.get(e20), o2 = s2 && s2.origDataId || e20, l2 = this.dataRefCount.get(o2);
    l2 > 1 ? this.dataRefCount.set(o2, l2 - 1) : (this.dataRefCount.delete(o2), null != t2 && (this.numBytesInGPU -= this.computeBytes(r2, n2), this.textureManager.releaseTexture(t2, r2, a2, i2)));
    let u2 = this.texData.get(e20);
    u2.texture = null, u2.texShape = null, u2.isPacked = false, u2.slice = null;
  }
  getTexture(e20) {
    return this.uploadToGPU(e20), this.texData.get(e20).texture.texture;
  }
  getDataInfo(e20) {
    return this.texData.get(e20);
  }
  shouldExecuteOnCPU(e20, t2 = WR) {
    return _e().getBool("WEBGL_CPU_FORWARD") && e20.every((e21) => null == this.texData.get(e21.dataId).texture && va.sizeFromShape(e21.shape) < t2);
  }
  getGPGPUContext() {
    return this.gpgpu;
  }
  where(e20) {
    Uf.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    let t2 = e20.dataSync();
    return _R(e20.shape, t2);
  }
  packedUnaryOp(e20, t2, n2) {
    let r2 = new zR(e20.shape, t2), a2 = this.compileAndRun(r2, [e20], n2);
    return Yi().makeTensorFromTensorInfo(a2);
  }
  abs(e20) {
    if (this.shouldExecuteOnCPU([e20]) && "complex64" !== e20.dtype) {
      let t3 = sR(this.texData.get(e20.dataId).values);
      return this.makeOutput(e20.shape, e20.dtype, t3);
    }
    if (_e().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e20, MR, e20.dtype);
    let t2 = new ER(e20.shape, MR), n2 = this.compileAndRun(t2, [e20]);
    return Yi().makeTensorFromTensorInfo(n2);
  }
  makeTensorInfo(e20, t2, n2) {
    let r2;
    if ("string" === t2 && null != n2 && n2.length > 0 && va.isString(n2[0])) {
      let a2 = n2.map((e21) => va.encodeString(e21));
      r2 = this.write(a2, e20, t2);
    } else r2 = this.write(n2, e20, t2);
    return this.texData.get(r2).usage = null, { dataId: r2, shape: e20, dtype: t2 };
  }
  makeOutput(e20, t2, n2) {
    return Yi().makeTensorFromTensorInfo(this.makeTensorInfo(e20, t2, n2), this);
  }
  unpackTensor(e20) {
    let t2 = new VR(e20.shape);
    return this.runWebGLProgram(t2, [e20], e20.dtype);
  }
  packTensor(e20) {
    let t2 = new NR(e20.shape);
    return this.runWebGLProgram(t2, [e20], e20.dtype, null, true);
  }
  packedReshape(e20, t2) {
    let n2 = [uC(e20.shape), ...dC(e20.shape)], r2 = { dtype: e20.dtype, shape: n2, dataId: e20.dataId }, a2 = [uC(t2), ...dC(t2)], i2 = new CR(a2, n2), s2 = this.runWebGLProgram(i2, [r2], e20.dtype, [n2], true);
    return { dataId: s2.dataId, shape: t2, dtype: s2.dtype };
  }
  decode(e20, t2) {
    let n2 = this.texData.get(e20), { isPacked: r2, shape: a2, dtype: i2 } = n2;
    if (null != t2) {
      let e21 = va.sizeFromShape(a2);
      va.assert(t2[0] * t2[1] * 4 >= e21, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
    }
    let s2, o2 = cC(a2);
    s2 = r2 ? new YC(o2) : new KC(o2);
    let l2 = [null != t2 ? t2 : $N(o2)];
    return { dtype: i2, shape: a2, dataId: this.runWebGLProgram(s2, [{ shape: o2, dtype: i2, dataId: e20 }], i2, l2, true, t2).dataId };
  }
  runWebGLProgram(e20, t2, n2, r2, a2 = false, i2) {
    let s2 = this.makeTensorInfo(e20.outputShape, n2), o2 = this.texData.get(s2.dataId);
    if (e20.packedOutput && (o2.isPacked = true), e20.outPackingScheme === yN.DENSE) {
      let t3 = null != i2 ? i2 : $N(e20.outputShape);
      o2.texShape = t3.map((e21) => 2 * e21);
    }
    if (null != e20.outTexUsage && (o2.usage = e20.outTexUsage), 0 === va.sizeFromShape(s2.shape)) return o2.values = va.getTypedArrayFromDType(s2.dtype, 0), s2;
    let l2 = [], u2 = t2.map((t3) => {
      if ("complex64" === t3.dtype) throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      let n3 = this.texData.get(t3.dataId);
      if (null == n3.texture) {
        if (!e20.packedInputs && va.sizeFromShape(t3.shape) <= _e().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return { shape: t3.shape, texData: null, isUniform: true, uniformValues: n3.values };
        e20.packedInputs && (n3.isPacked = true, n3.shape = t3.shape);
      }
      if (this.uploadToGPU(t3.dataId), !!n3.isPacked != !!e20.packedInputs) t3 = n3.isPacked ? this.unpackTensor(t3) : this.packTensor(t3), l2.push(t3), n3 = this.texData.get(t3.dataId);
      else if (n3.isPacked && !fC(n3.shape, t3.shape)) {
        let e21 = t3, r3 = t3.shape;
        t3.shape = n3.shape, t3 = this.packedReshape(t3, r3), l2.push(t3), n3 = this.texData.get(t3.dataId), e21.shape = r3;
      }
      return { shape: t3.shape, texData: n3, isUniform: false };
    });
    this.uploadToGPU(s2.dataId);
    let d2, c2 = { shape: s2.shape, texData: o2, isUniform: false }, h2 = ((e21, t3, n3) => {
      let r3 = "";
      t3.concat(n3).forEach((t4) => {
        let a4 = null != t4.texData && null != t4.texData.slice && t4.texData.slice.flatOffset > 0;
        if (e21.enableShapeUniforms && !t4.isUniform) {
          let i3 = t4.texData.texShape, { useSqueezeShape: s3, uniformShape: o3, keptDims: l3 } = jC(e21.packedInputs, t4.shape, i3), u3 = "", d3 = "", c3 = "";
          if (1 === o3.length && e21.packedInputs) {
            let e22 = [Math.ceil(i3[0] / 2), Math.ceil(i3[1] / 2)];
            u3 = `${e22[0] > 1}_${e22[1] > 1}`;
          } else if (2 !== o3.length || e21.packedInputs) {
            if (o3.length > 2 && !e21.packedInputs) {
              let e22 = va.computeStrides(o3);
              c3 = `${e22[0] === i3[1]}_${e22[e22.length - 1] === i3[1]}`;
            }
          } else d3 = `${o3[0] > 1}_${o3[1] > 1}`;
          let h3 = t4.shape.length, p3 = 2 === o3.length && va.arraysEqual(t4.shape, i3), f3 = 1 === va.sizeFromShape(t4.shape), m3 = Uf.getBroadcastDims(t4.shape, n3.shape), A2 = !e21.packedInputs && h3 === n3.shape.length && va.arraysEqual(i3, n3.texData.texShape);
          r3 += `${h3}_${A2}_${s3 ? l3 : ""}_${o3.length}_${f3}_${m3}_${p3}_${u3}_${d3}_${c3}_${e21.packedInputs || o3.length > 2 ? "" : `${i3[0] > 1}_${i3[1] > 1}`}_${a4}`;
        } else r3 += `${t4.shape}_${t4.isUniform ? "uniform" : t4.texData.texShape}_${a4}`;
      });
      let a3 = e21.constructor.name;
      return a3 += "_" + r3 + "_" + e21.userCode + _e().getNumber("WEBGL_VERSION"), a3;
    })(e20, u2, c2), p2 = this.getAndSaveBinary(h2, () => ((e21, t3, n3, r3) => {
      let a3 = n3.map((e22, n4) => {
        let r4 = { logicalShape: e22.shape, texShape: e22.isUniform ? null : e22.texData.texShape, isUniform: e22.isUniform, isPacked: !e22.isUniform && e22.texData.isPacked, flatOffset: null };
        return null != e22.texData && null != e22.texData.slice && e22.texData.slice.flatOffset > 0 && (r4.flatOffset = e22.texData.slice.flatOffset), { name: t3.variableNames[n4], shapeInfo: r4 };
      }), i3 = a3.map((e22) => e22.shapeInfo), s3 = { logicalShape: r3.shape, texShape: r3.texData.texShape, isUniform: false, isPacked: r3.texData.isPacked, flatOffset: null }, o3 = FC(a3, s3, t3), l3 = zN(e21.gl, o3), u3 = e21.createProgram(l3);
      return _e().get("ENGINE_COMPILE_ONLY") ? { program: t3, fragmentShader: l3, source: o3, webGLProgram: u3, inShapeInfos: i3, outShapeInfo: s3, variablesLocations: null, customUniformLocations: null, infLoc: null, nanLoc: null, outShapeLocation: null, outShapeStridesLocation: null, outTexShapeLocation: null } : (e21.buildVao(u3), Object.assign({ program: t3, fragmentShader: l3, source: o3, webGLProgram: u3, inShapeInfos: i3, outShapeInfo: s3 }, XC(e21, t3, u3)));
    })(this.gpgpu, e20, u2, c2)), f2 = null != this.activeTimers;
    f2 && (d2 = this.startTimer()), _e().get("ENGINE_COMPILE_ONLY") || ((e21, t3, n3, r3, a3) => {
      t3.program.enableShapeUniforms || (qC(t3.inShapeInfos, n3), qC([t3.outShapeInfo], [r3]));
      let i3 = r3.texData.texture, s3 = r3.texData.texShape;
      r3.texData.isPacked ? e21.setOutputPackedMatrixTexture(i3.texture, s3[0], s3[1]) : e21.setOutputMatrixTexture(i3.texture, s3[0], s3[1]), e21.setProgram(t3.webGLProgram), e21.bindVertexArray(t3.webGLProgram.vao), 1 === _e().getNumber("WEBGL_VERSION") && null !== t3.infLoc && e21.gl.uniform1f(t3.infLoc, 1 / 0), null !== t3.nanLoc && e21.gl.uniform1f(t3.nanLoc, NaN);
      for (let l3 = 0; n3.length > l3; ++l3) {
        let r4 = n3[l3], { uniform: a4, offset: i4, shape: s4, texShape: o4 } = t3.variablesLocations[l3];
        if (s4) {
          let { uniformShape: n4 } = jC(t3.program.packedInputs, r4.shape, r4.texData.texShape);
          switch (n4.length) {
            case 1:
              e21.gl.uniform1iv(s4, new Int32Array(n4));
              break;
            case 2:
              e21.gl.uniform2iv(s4, new Int32Array(n4));
              break;
            case 3:
              e21.gl.uniform3iv(s4, new Int32Array(n4));
              break;
            case 4:
              e21.gl.uniform4iv(s4, new Int32Array(n4));
          }
        }
        if (o4 && e21.gl.uniform2i(o4, r4.texData.texShape[0], r4.texData.texShape[1]), null != a4) {
          if (r4.isUniform) {
            if (2 > va.sizeFromShape(r4.shape)) e21.gl.uniform1f(a4, r4.uniformValues[0]);
            else {
              let t4 = r4.uniformValues;
              t4 instanceof Float32Array || (t4 = new Float32Array(t4)), e21.gl.uniform1fv(a4, t4);
            }
            continue;
          }
          null != r4.texData.slice && null != i4 && e21.gl.uniform1i(i4, r4.texData.slice.flatOffset), e21.setInputMatrixTexture(r4.texData.texture.texture, a4, l3);
        }
      }
      let o3 = t3.outShapeLocation;
      if (o3) switch (r3.shape.length) {
        case 1:
          e21.gl.uniform1iv(o3, new Int32Array(r3.shape));
          break;
        case 2:
          e21.gl.uniform2iv(o3, new Int32Array(r3.shape));
          break;
        case 3:
          e21.gl.uniform3iv(o3, new Int32Array(r3.shape));
          break;
        case 4:
          e21.gl.uniform4iv(o3, new Int32Array(r3.shape));
      }
      if (t3.outShapeStridesLocation) {
        let n4 = va.computeStrides(r3.shape);
        switch (r3.shape.length) {
          case 2:
            e21.gl.uniform1iv(t3.outShapeStridesLocation, new Int32Array(n4));
            break;
          case 3:
            e21.gl.uniform2iv(t3.outShapeStridesLocation, new Int32Array(n4));
            break;
          case 4:
            e21.gl.uniform3iv(t3.outShapeStridesLocation, new Int32Array(n4));
        }
      }
      if (t3.outTexShapeLocation && e21.gl.uniform2i(t3.outTexShapeLocation, r3.texData.texShape[0], r3.texData.texShape[1]), t3.program.customUniforms && a3) for (let l3 = 0; t3.program.customUniforms.length > l3; ++l3) {
        let n4 = t3.program.customUniforms[l3], r4 = t3.customUniformLocations[l3], i4 = a3[l3];
        if ("float" === n4.type) e21.gl.uniform1fv(r4, i4);
        else if ("vec2" === n4.type) e21.gl.uniform2fv(r4, i4);
        else if ("vec3" === n4.type) e21.gl.uniform3fv(r4, i4);
        else if ("vec4" === n4.type) e21.gl.uniform4fv(r4, i4);
        else if ("int" === n4.type) e21.gl.uniform1iv(r4, i4);
        else if ("ivec2" === n4.type) e21.gl.uniform2iv(r4, i4);
        else if ("ivec3" === n4.type) e21.gl.uniform3iv(r4, i4);
        else {
          if ("ivec4" !== n4.type) throw Error(`uniform type ${n4.type} is not supported yet.`);
          e21.gl.uniform4iv(r4, i4);
        }
      }
      e21.executeProgram();
    })(this.gpgpu, p2, u2, c2, r2), l2.forEach((e21) => this.disposeIntermediateTensorInfo(e21)), f2 && (d2 = this.endTimer(d2), this.activeTimers.push({ name: e20.constructor.name, query: this.getQueryTime(d2) }));
    let m2 = _e().getNumber("WEBGL_FLUSH_THRESHOLD");
    if (m2 > 0) {
      let e21 = va.now();
      e21 - this.lastGlFlushTime > m2 && (this.gpgpu.gl.flush(), this.lastGlFlushTime = e21);
    }
    if (!_e().getBool("WEBGL_LAZILY_UNPACK") && o2.isPacked && false === a2) {
      let e21 = this.unpackTensor(s2);
      return this.disposeIntermediateTensorInfo(s2), e21;
    }
    return s2;
  }
  compileAndRun(e20, t2, n2, r2, a2 = false) {
    return this.runWebGLProgram(e20, t2, n2 = n2 || t2[0].dtype, r2, a2);
  }
  getAndSaveBinary(e20, t2) {
    return e20 in this.binaryCache || (this.binaryCache[e20] = t2()), this.binaryCache[e20];
  }
  getTextureManager() {
    return this.textureManager;
  }
  dispose() {
    this.disposed || (_e().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach((e20) => {
      this.gpgpu.deleteProgram(this.binaryCache[e20].webGLProgram), delete this.binaryCache[e20];
    }), this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
  }
  floatPrecision() {
    return null == this.floatPrecisionValue && (this.floatPrecisionValue = es(() => {
      if (!_e().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        let e20 = _e().getBool("DEBUG");
        _e().set("DEBUG", false);
        let t2 = this.abs(au(1e-8)).dataSync()[0];
        if (_e().set("DEBUG", e20), t2 > 0) return 32;
      }
      return 16;
    })), this.floatPrecisionValue;
  }
  epsilon() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }
  uploadToGPU(e20) {
    let t2 = this.texData.get(e20), { shape: n2, dtype: r2, values: a2, texture: i2, usage: s2, isPacked: o2 } = t2;
    if (null != i2) return;
    let l2, u2 = null != this.activeTimers;
    u2 && (l2 = va.now());
    let d2 = t2.texShape;
    if (null == d2 && (d2 = hC(n2, o2), t2.texShape = d2), null != a2) {
      let e21, i3 = cC(n2), s3 = d2[1], c2 = d2[0], h2 = a2 instanceof Uint8Array || a2 instanceof Uint8ClampedArray;
      (o2 || !h2) && ([s3, c2] = RN(d2[0], d2[1])), e21 = o2 ? new n$(i3, h2) : new t$(i3, h2);
      let p2 = h2 ? [c2, s3] : d2, f2 = this.makeTensorInfo(p2, r2), m2 = this.texData.get(f2.dataId);
      m2.usage = h2 ? bN.PIXELS : bN.UPLOAD, m2.texShape = p2, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f2.dataId), s3, c2, a2);
      let A2 = this.runWebGLProgram(e21, [f2], r2, [[c2, s3]], true), x2 = this.texData.get(A2.dataId);
      t2.texShape = x2.texShape, t2.isPacked = x2.isPacked, t2.usage = x2.usage, _e().get("ENGINE_COMPILE_ONLY") ? this.disposeData(A2.dataId) : (t2.texture = x2.texture, t2.values = null, this.texData.delete(A2.dataId)), this.disposeIntermediateTensorInfo(f2), u2 && (this.uploadWaitMs += va.now() - l2);
    } else {
      let e21 = this.acquireTexture(d2, s2, r2, o2);
      t2.texture = e21;
    }
  }
  convertAndCacheOnCPU(e20, t2) {
    let n2 = this.texData.get(e20), { dtype: r2 } = n2;
    return null != t2 && (n2.values = ((e21, t3) => {
      if ("float32" === t3 || "complex64" === t3) return e21;
      if ("int32" === t3 || "bool" === t3) {
        let n3 = "int32" === t3 ? new Int32Array(e21.length) : new Uint8Array(e21.length);
        for (let t4 = 0; n3.length > t4; ++t4) n3[t4] = Math.round(e21[t4]);
        return n3;
      }
      throw Error("Unknown dtype " + t3);
    })(t2, r2)), n2.values;
  }
  acquireTexture(e20, t2, n2, r2) {
    if (this.numBytesInGPU += this.computeBytes(e20, n2), !this.warnedAboutMemory && this.numBytesInGPU > 1048576 * this.numMBBeforeWarning) {
      let e21 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = true, console.warn(`High memory usage in GPU: ${e21} MB, most likely due to a memory leak`);
    }
    return this.textureManager.acquireTexture(e20, t2, r2);
  }
  computeBytes(e20, t2) {
    return e20[0] * e20[1] * va.bytesPerElement(t2);
  }
  checkCompileCompletion() {
    for (let [, e20] of Object.entries(this.binaryCache)) this.checkCompletion_(e20);
  }
  checkCompileCompletionAsync() {
    return __async(this, null, function* () {
      let e20 = [];
      if (this.gpgpu.parallelCompilationExtension) {
        for (let [, t2] of Object.entries(this.binaryCache)) e20.push(this.checkCompletionAsync_(t2));
        return Promise.all(e20);
      }
      for (let [, t2] of Object.entries(this.binaryCache)) {
        let n2 = new Promise((e21) => {
          try {
            this.checkCompletion_(t2), e21(true);
          } catch (n3) {
            throw n3;
          }
        });
        e20.push(n2);
      }
      return Promise.all(e20);
    });
  }
  checkCompletionAsync_(e20) {
    return __async(this, null, function* () {
      return this.gpgpu.gl.getProgramParameter(e20.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(e20) : (yield Lf(), this.checkCompletionAsync_(e20));
    });
  }
  checkCompletion_(e20) {
    if (false === this.gpgpu.gl.getProgramParameter(e20.webGLProgram, this.gpgpu.gl.LINK_STATUS)) throw console.log(this.gpgpu.gl.getProgramInfoLog(e20.webGLProgram)), false === this.gpgpu.gl.getShaderParameter(e20.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) ? (WN(e20.source, this.gpgpu.gl.getShaderInfoLog(e20.fragmentShader)), Error("Failed to compile fragment shader.")) : Error("Failed to link vertex and fragment shaders.");
    return true;
  }
  getUniformLocations() {
    for (let e20 of Object.values(this.binaryCache)) {
      this.gpgpu.buildVao(e20.webGLProgram);
      let { variablesLocations: t2, customUniformLocations: n2, infLoc: r2, nanLoc: a2, outShapeLocation: i2, outShapeStridesLocation: s2, outTexShapeLocation: o2 } = XC(this.gpgpu, e20.program, e20.webGLProgram);
      e20.variablesLocations = t2, e20.customUniformLocations = n2, e20.infLoc = r2, e20.nanLoc = a2, e20.outShapeLocation = i2, e20.outShapeStridesLocation = s2, e20.outTexShapeLocation = o2;
    }
  }
  createTensorFromGPUData(e20, t2, n2) {
    e20.channels = e20.channels || "RGBA";
    let { texture: r2, height: a2, width: i2, channels: s2 } = e20, o2 = Yi().backend;
    if (!o2.gpgpu.gl.isTexture(r2)) throw Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
    let l2 = o2.writeTexture(r2, t2, n2, a2, i2, s2);
    return Yi().makeTensorFromDataId(l2, t2, n2, o2);
  }
};
LR.nextDataId = 0;
var BR = "4.22.0";
function UR() {
  _e().set("WEBGL_FORCE_F16_TEXTURES", true);
}
Ii.isBrowser() && ds("webgl", () => new LR(), 2);
var jR = { forceHalfFloat: UR };
var GR = "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";
var HR = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["A", "B"], this.outputShape = Uf.assertAndGetBroadcastShape(t2, n2), this.enableShapeUniforms = ZC(this.outputShape.length), this.userCode = `
      float binaryOperation(float a, float b) {
        ${e20}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
  }
};
var XR = "\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";
var qR = class {
  constructor(e20, t2, n2, r2 = false) {
    this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = Uf.assertAndGetBroadcastShape(t2, n2);
    let a2 = this.outputShape.length;
    this.enableShapeUniforms = ZC(a2);
    let i2 = "";
    if (r2) if (0 === a2 || 1 === va.sizeFromShape(this.outputShape)) i2 = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
    else if (i2 = `
          ${UC(a2)} coords = getOutputCoords();
        `, 1 === a2) i2 += this.enableShapeUniforms ? "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          " : `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
    else {
      let e21 = kR("coords", a2);
      i2 += this.enableShapeUniforms ? `
            bool nextRowOutOfBounds =
              (${e21[a2 - 2]} + 1) >= outShape[${a2} - 2];
            bool nextColOutOfBounds =
              (${e21[a2 - 1]} + 1) >= outShape[${a2} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          ` : `
            bool nextRowOutOfBounds =
              (${e21[a2 - 2]} + 1) >= ${this.outputShape[a2 - 2]};
            bool nextColOutOfBounds =
              (${e21[a2 - 1]} + 1) >= ${this.outputShape[a2 - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
    }
    this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e20}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i2}

        setOutput(result);
      }
    `;
  }
};
function ZR(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2;
  return n2.incRef(r2.dataId), { dataId: r2.dataId, shape: r2.shape, dtype: r2.dtype };
}
var KR = { kernelName: sn, backendName: "webgl", kernelFunc: ZR };
function YR(e20) {
  let { inputs: t2, backend: n2 } = e20, { real: r2, imag: a2 } = t2, i2 = n2.makeTensorInfo(r2.shape, "complex64"), s2 = n2.texData.get(i2.dataId), o2 = ZR({ inputs: { x: r2 }, backend: n2 }), l2 = ZR({ inputs: { x: a2 }, backend: n2 });
  return s2.complexTensorInfos = { real: o2, imag: l2 }, i2;
}
var JR = { kernelName: At, backendName: "webgl", kernelFunc: YR };
var QR = "return (a < 0.) ? b * a : a;";
var eS = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
var tS = { kernelName: hn, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { alpha: i2 } = r2, s2 = n2.makeTensorInfo([], "float32", va.createScalarValue(i2, "float32")), o2 = _e().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new qR(eS, a2.shape, s2.shape) : new HR(QR, a2.shape, s2.shape), l2 = n2.runWebGLProgram(o2, [a2, s2], "float32");
  return n2.disposeIntermediateTensorInfo(s2), l2;
} };
var nS = "return (a < 0.) ? b * a : a;";
var rS = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
var aS = { kernelName: Jn, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2, alpha: a2 } = t2, i2 = _e().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new qR(rS, r2.shape, a2.shape) : new HR(nS, r2.shape, a2.shape);
  return n2.runWebGLProgram(i2, [r2, a2], "float32");
} };
var iS = "if (isnan(x)) return x;";
function sS({ opSnippet: e20, packedOpSnippet: t2, cpuKernelImpl: n2, dtype: r2 }) {
  return ({ inputs: a2, backend: i2 }) => {
    let s2, { x: o2 } = a2, l2 = i2, u2 = r2 || o2.dtype;
    if (l2.shouldExecuteOnCPU([o2]) && null != n2) {
      let e21 = l2.texData.get(o2.dataId), t3 = n2(e21.values, u2);
      return l2.makeTensorInfo(o2.shape, u2, t3);
    }
    return s2 = _e().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != t2 ? new zR(o2.shape, t2) : new ER(o2.shape, e20), l2.runWebGLProgram(s2, [o2], u2);
  };
}
function oS({ opSnippet: e20, packedOpSnippet: t2, checkOutOfBounds: n2 = false, supportsComplex: r2 = false, cpuKernelImpl: a2, dtype: i2 }) {
  return ({ inputs: s2, backend: o2 }) => {
    let { a: l2, b: u2 } = s2, d2 = o2;
    if (r2 && "complex64" === l2.dtype) {
      let t3 = d2.texData.get(l2.dataId), n3 = d2.texData.get(u2.dataId), [r3, a3] = [[t3.complexTensorInfos.real, n3.complexTensorInfos.real], [t3.complexTensorInfos.imag, n3.complexTensorInfos.imag]].map((t4) => {
        let [n4, r4] = t4, a4 = { dataId: n4.dataId, dtype: n4.dtype, shape: l2.shape }, i4 = { dataId: r4.dataId, dtype: r4.dtype, shape: u2.shape }, s3 = new HR(e20, l2.shape, u2.shape);
        return d2.runWebGLProgram(s3, [a4, i4], pi(n4.dtype, r4.dtype));
      }), i3 = YR({ inputs: { real: r3, imag: a3 }, backend: d2 });
      return d2.disposeIntermediateTensorInfo(r3), d2.disposeIntermediateTensorInfo(a3), i3;
    }
    let c2, h2 = i2 || pi(l2.dtype, u2.dtype);
    if (("string" === l2.dtype || "string" === u2.dtype || d2.shouldExecuteOnCPU([l2, u2])) && null != a2) {
      let e21 = d2.texData.get(l2.dataId).values, t3 = d2.texData.get(u2.dataId).values, n3 = "string" === l2.dtype ? Uf.fromUint8ToStringArray(e21) : e21, r3 = "string" === l2.dtype ? Uf.fromUint8ToStringArray(t3) : t3, [i3, s3] = a2(l2.shape, u2.shape, n3, r3, h2), o3 = d2.makeTensorInfo(s3, h2);
      return d2.texData.get(o3.dataId).values = i3, o3;
    }
    return c2 = _e().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != t2 ? new qR(t2, l2.shape, u2.shape, n2) : new HR(e20, l2.shape, u2.shape), d2.runWebGLProgram(c2, [l2, u2], h2);
  };
}
function lS(e20, t2 = false) {
  if ("linear" === e20) return "return x;";
  if ("relu" === e20) return t2 ? "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : OR;
  if ("elu" === e20) return t2 ? "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n" : "return (x >= 0.0) ? x : (exp(x) - 1.0);";
  if ("relu6" === e20) return t2 ? "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : FR;
  if ("prelu" === e20) return t2 ? rS : nS;
  if ("leakyrelu" === e20) return t2 ? eS : QR;
  if ("sigmoid" === e20) return "return 1.0 / (1.0 + exp(-1.0 * x));";
  throw Error(`Activation ${e20} has not been implemented for the WebGL backend.`);
}
var uS = class {
  constructor(e20, t2, n2, r2 = false, a2 = false, i2 = false, s2 = null, o2 = false, l2 = false) {
    this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = n2, this.enableShapeUniforms = ZC(this.outputShape.length);
    let u2 = Math.ceil((r2 ? e20[1] : e20[2]) / 2), d2 = r2 ? "i * 2, rc.y" : "rc.y, i * 2", c2 = a2 ? "rc.z, i * 2" : "i * 2, rc.z", h2 = r2 ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], p2 = a2 ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], f2 = "", m2 = "";
    s2 && (f2 = o2 ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s2}
        }` : l2 ? `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s2}
        }` : `vec4 activation(vec4 x) {
          ${s2}
        }`, m2 = "result = activation(result);");
    let A2 = i2 ? "result += getBiasAtOutCoords();" : "";
    i2 && this.variableNames.push("bias"), o2 && this.variableNames.push("preluActivationWeights"), l2 && this.variableNames.push("leakyreluAlpha");
    let x2 = "rc.x", y2 = "rc.x";
    t2[0] > e20[0] ? x2 = `imod(rc.x, ${e20[0]})` : e20[0] > t2[0] && (y2 = `imod(rc.x, ${t2[0]})`), this.userCode = `
      ${f2}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u2}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x2};
        int batchB = ${y2};
        for (int i = 0; i < ${u2}; i++) {
          vec4 a = getMatrixA(batchA, ${d2});
          vec4 b = getMatrixB(batchB, ${c2});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h2[0]} * ${p2[0]});
          result += (${h2[1]} * ${p2[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${A2}

        ${m2}

        setOutput(result);
      }
    `;
  }
};
var dS = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = Uf.assertAndGetBroadcastShape(t2, n2), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e20}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
  }
};
var cS = "return a * b;";
function hS(e20) {
  let t2, { inputs: n2, backend: r2 } = e20, { a: a2, b: i2 } = n2, s2 = Uf.upcastType(a2.dtype, i2.dtype);
  if ("complex64" === a2.dtype) {
    let e21 = r2.texData.get(a2.dataId), t3 = r2.texData.get(i2.dataId), n3 = new dS("return areal * breal - aimag * bimag;", a2.shape, i2.shape), s3 = new dS("return areal * bimag + aimag * breal;", a2.shape, i2.shape), o2 = [{ dataId: e21.complexTensorInfos.real.dataId, dtype: e21.complexTensorInfos.real.dtype, shape: a2.shape }, { dataId: e21.complexTensorInfos.imag.dataId, dtype: e21.complexTensorInfos.imag.dtype, shape: a2.shape }, { dataId: t3.complexTensorInfos.real.dataId, dtype: t3.complexTensorInfos.real.dtype, shape: i2.shape }, { dataId: t3.complexTensorInfos.imag.dataId, dtype: t3.complexTensorInfos.imag.dtype, shape: i2.shape }], l2 = r2.runWebGLProgram(n3, o2, "float32"), u2 = r2.runWebGLProgram(s3, o2, "float32"), d2 = YR({ inputs: { real: l2, imag: u2 }, backend: r2 });
    return r2.disposeIntermediateTensorInfo(l2), r2.disposeIntermediateTensorInfo(u2), d2;
  }
  if (r2.shouldExecuteOnCPU([a2, i2])) {
    let e21 = r2.texData.get(a2.dataId), t3 = r2.texData.get(i2.dataId), [n3, o2] = Z$(a2.shape, i2.shape, e21.values, t3.values, s2), l2 = r2.makeTensorInfo(o2, s2);
    return r2.texData.get(l2.dataId).values = n3, l2;
  }
  return t2 = _e().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new qR(cS, a2.shape, i2.shape) : new HR(cS, a2.shape, i2.shape), r2.runWebGLProgram(t2, [a2, i2], s2);
}
var pS = { kernelName: Wn, backendName: "webgl", kernelFunc: hS };
function fS(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { shape: i2 } = r2, s2 = n2, o2 = va.sizeFromShape(a2.shape), l2 = va.inferFromImplicitShape(i2, o2), u2 = va.sizeFromShape(l2);
  va.assert(o2 === u2, () => `The new shape (${l2}) has ${u2} elements and the old shape (${a2.shape}) has ${o2} elements. The new shape and old shape must have the same number of elements.`);
  let d2 = s2.texData.get(a2.dataId);
  return !d2.isPacked || fC(a2.shape, l2) || null !== d2.texture && fC(d2.shape, l2) ? (s2.incRef(a2.dataId), { dataId: a2.dataId, shape: l2, dtype: a2.dtype }) : ((e21, t3, n3) => {
    let r3 = [uC(e21.shape), ...dC(e21.shape)], a3 = { dtype: e21.dtype, shape: r3, dataId: e21.dataId }, i3 = [uC(t3), ...dC(t3)], s3 = new CR(i3, r3), o3 = n3.runWebGLProgram(s3, [a3], e21.dtype, [r3], true);
    return { dataId: o3.dataId, shape: t3, dtype: o3.dtype };
  })(a2, l2, s2);
}
var mS = { kernelName: or, backendName: "webgl", kernelFunc: fS };
var AS = class {
  constructor(e20, t2) {
    this.variableNames = ["x"];
    let { windowSize: n2, batchSize: r2, inSize: a2, outSize: i2 } = e20;
    this.outputShape = [r2, i2];
    let s2 = 4 * Math.floor(n2 / 4), o2 = n2 % 4, l2 = "sumValue += dot(values, ones);";
    if (null != t2) {
      let e21 = 1 / t2;
      l2 = `sumValue += dot(values * ${va.isInt(e21) ? e21.toPrecision(2) : e21}, ones);`;
    }
    let u2 = "";
    a2 % n2 > 0 && (u2 = `
        if (inIdx < 0 || inIdx >= ${a2}) {
          return 0.0;
        }
      `), this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u2}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n2};

        float sumValue = 0.0;

        for (int i = 0; i < ${s2}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l2}
        }

        int inIdx = inOffset + ${s2};
        if (${1 === o2}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l2}
        } else if (${2 === o2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l2}
        } else if (${3 === o2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l2}
        }
        setOutput(sumValue);
      }
    `;
  }
};
var xS = class {
  constructor(e20, t2) {
    this.variableNames = ["x"];
    let { windowSize: n2, batchSize: r2, inSize: a2, outSize: i2 } = e20;
    this.outputShape = [r2, i2];
    let s2 = "0.0", o2 = "";
    "prod" === t2 ? s2 = "1.0" : "min" === t2 ? (s2 = "1.0 / 1e-20", o2 = "min") : "max" === t2 && (s2 = "-1.0 / 1e-20", o2 = "max");
    let l2 = `${t2}(${t2}(${t2}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    "sum" === t2 ? l2 = "sumValue" : "prod" === t2 ? l2 = "prodValue" : "all" === t2 ? l2 = "allValue" : "any" === t2 && (l2 = "anyValue");
    let u2 = 4 * Math.floor(n2 / 4), d2 = n2 % 4, c2 = `
      if (${"sum" === t2}) {
        sumValue += dot(values, ones);
      } else if (${"prod" === t2}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o2}(values, minMaxValue);
        if (${"min" === t2} || ${"max" === t2}) {
          minMaxValue = ${o2}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `, h2 = "vec4";
    "all" === t2 ? (s2 = "1.0", c2 = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", h2 = "bvec4") : "any" === t2 && (s2 = "0.0", c2 = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", h2 = "bvec4");
    let p2 = "";
    a2 % n2 > 0 && (p2 = `
        if (inIdx < 0 || inIdx >= ${a2}) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ${s2};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p2}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n2};

        vec4 minMaxValue = vec4(${s2});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u2}; i += 4) {
          int inIdx = inOffset + i;
          ${h2} values = ${h2}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c2}
        }

        int inIdx = inOffset + ${u2};
        if (${1 === d2}) {
          ${h2} values = ${h2}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${c2}
        } else if (${2 === d2}) {
          ${h2} values = ${h2}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${c2}
        } else if (${3 === d2}) {
          ${h2} values = ${h2}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${c2}
        }
        setOutput(${l2});
      }
    `;
  }
};
function yS(e20, t2, n2, r2) {
  let a2 = ((e21) => {
    let t3 = [];
    for (; 0 === t3.length || 1 !== t3[t3.length - 1].outSize; ) {
      let n3 = t3.length ? t3[t3.length - 1].outSize : e21[1], r3 = Uf.computeOptimalWindowSize(n3);
      t3.push({ inSize: n3, windowSize: r3, outSize: Math.ceil(n3 / r3) });
    }
    return t3;
  })(e20.shape), i2 = e20;
  for (let s2 = 0; a2.length > s2; s2++) {
    let o2, l2, { inSize: u2, windowSize: d2, outSize: c2 } = a2[s2];
    o2 = "mean" === n2 ? 0 === s2 ? new AS({ windowSize: d2, inSize: u2, batchSize: e20.shape[0], outSize: c2 }, u2) : new AS({ windowSize: d2, inSize: u2, batchSize: e20.shape[0], outSize: c2 }) : new xS({ windowSize: d2, inSize: u2, batchSize: e20.shape[0], outSize: c2 }, n2), l2 = i2, i2 = r2.runWebGLProgram(o2, [i2], t2), l2.dataId !== e20.dataId && r2.disposeIntermediateTensorInfo(l2);
  }
  return i2;
}
var bS = class {
  constructor(e20, t2) {
    this.variableNames = ["A"];
    let n2 = Array(e20.length);
    for (let i2 = 0; n2.length > i2; i2++) n2[i2] = e20[t2[i2]];
    this.outputShape = n2, this.rank = n2.length;
    let r2 = UC(this.rank), a2 = ((e21) => {
      let t3 = e21.length;
      if (t3 > 6) throw Error(`Transpose for rank ${t3} is not yet supported`);
      let n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r3 = Array(t3);
      for (let a3 = 0; e21.length > a3; a3++) r3[e21[a3]] = n3[a3];
      return r3.join();
    })(t2);
    this.userCode = `
    void main() {
      ${r2} resRC = getOutputCoords();
      setOutput(getA(${a2}));
    }
    `;
  }
};
var gS = class {
  constructor(e20, t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
    let n2 = Array(e20.length);
    for (let u2 = 0; n2.length > u2; u2++) n2[u2] = e20[t2[u2]];
    if (this.outputShape = n2, this.rank = n2.length, this.rank > 6) throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
    let r2 = UC(this.rank), a2 = wR("rc", this.rank), i2 = Array(this.rank);
    for (let u2 = 0; t2.length > u2; u2++) i2[t2[u2]] = a2[u2];
    let s2 = `vec2(${i2.slice(-2).join()})`, o2 = `++${a2[this.rank - 1]} < ${n2[this.rank - 1]}`, l2 = `getChannel(getA(${i2.join()}), ${s2})`;
    this.userCode = `
    void main() {
      ${r2} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l2};
      if(${o2}) {
        result[1] = ${l2};
      }
      --${a2[this.rank - 1]};
      if(++${a2[this.rank - 2]} < ${n2[this.rank - 2]}) {
        result[2] = ${l2};
        if(${o2}) {
          result[3] = ${l2};
        }
      }
      setOutput(result);
    }
    `;
  }
};
function vS(e20, t2, n2) {
  let r2 = _e().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new gS(e20.shape, t2) : new bS(e20.shape, t2);
  return n2.runWebGLProgram(r2, [e20], e20.dtype);
}
function wS(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2;
  return ((e21, t3, n3, r3) => {
    let a3 = e21.shape.length, i3 = va.parseAxisParam(t3, e21.shape), s3 = i3, o2 = Uf.getAxesPermutation(s3, a3), l2 = null != o2, u2 = e21;
    l2 && (u2 = vS(e21, o2, r3), s3 = Uf.getInnerMostAxes(s3.length, a3)), Uf.assertAxesAreInnerMostDims("sum", s3, a3);
    let [d2, c2] = Uf.computeOutAndReduceShapes(u2.shape, s3), h2 = d2;
    n3 && (h2 = Uf.expandShapeToKeepDim(d2, i3));
    let p2 = va.sizeFromShape(c2), f2 = fS({ inputs: { x: u2 }, attrs: { shape: [va.sizeFromShape(e21.shape) / p2, p2] }, backend: r3 }), m2 = yS(f2, fi(e21.dtype), "sum", r3), A2 = fS({ inputs: { x: m2 }, attrs: { shape: h2 }, backend: r3 });
    return r3.disposeIntermediateTensorInfo(f2), r3.disposeIntermediateTensorInfo(m2), l2 && r3.disposeIntermediateTensorInfo(u2), A2;
  })(a2, i2, s2, n2);
}
var kS = { kernelName: "Sum", backendName: "webgl", kernelFunc: wS };
function NS(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2 } = n2, { perm: s2 } = a2, o2 = r2, l2 = Array(i2.shape.length);
  for (let u2 = 0; l2.length > u2; u2++) l2[u2] = i2.shape[s2[u2]];
  if (o2.shouldExecuteOnCPU([i2])) {
    let e21 = o2.texData.get(i2.dataId).values, n3 = gR(e21, i2.shape, i2.dtype, s2, l2);
    t2 = o2.makeTensorInfo(l2, i2.dtype), o2.texData.get(t2.dataId).values = n3;
  } else t2 = vS(i2, s2, o2);
  return t2;
}
var CS = { kernelName: Kr, backendName: "webgl", kernelFunc: NS };
function $S({ a: e20, b: t2, transposeA: n2, transposeB: r2, backend: a2, bias: i2 = null, preluActivationWeights: s2 = null, leakyreluAlpha: o2 = 0, activation: l2 = null }) {
  let u2 = e20.shape.length, d2 = t2.shape.length, c2 = n2 ? e20.shape[u2 - 2] : e20.shape[u2 - 1], h2 = r2 ? t2.shape[d2 - 1] : t2.shape[d2 - 2], p2 = n2 ? e20.shape[u2 - 1] : e20.shape[u2 - 2], f2 = r2 ? t2.shape[d2 - 2] : t2.shape[d2 - 1], m2 = e20.shape.slice(0, -2), A2 = t2.shape.slice(0, -2), x2 = va.sizeFromShape(m2), y2 = va.sizeFromShape(A2), b2 = Fl.assertAndGetBroadcastShape(e20.shape.slice(0, -2), t2.shape.slice(0, -2)).concat([p2, f2]);
  va.assert(c2 === h2, () => `Error in matMul: inner shapes (${c2}) and (${h2}) of Tensors with shapes ${e20.shape} and ${t2.shape} and transposeA=${n2} and transposeB=${r2} must match.`);
  let g2, v2 = n2 ? [x2, c2, p2] : [x2, p2, c2], w2 = r2 ? [y2, f2, h2] : [y2, h2, f2], k2 = fS({ inputs: { x: e20 }, backend: a2, attrs: { shape: v2 } }), N2 = fS({ inputs: { x: t2 }, backend: a2, attrs: { shape: w2 } }), C2 = [k2, N2], $2 = Math.max(x2, y2), R2 = n2 ? k2.shape[1] : k2.shape[2], S2 = null != i2, I2 = null != s2, E2 = "leakyrelu" === l2, T2 = null != l2 ? lS(l2, true) : null;
  if (1 !== p2 && 1 !== f2 || 1e3 >= R2 || false !== (S2 || I2 || E2 || null != T2)) {
    let l3 = pi(e20.dtype, t2.dtype), u3 = new uS(v2, w2, [$2, p2, f2], n2, r2, S2, T2, I2, E2), d3 = [k2, N2];
    if (null != i2 && d3.push(i2), I2 && d3.push(s2), E2) {
      let e21 = a2.makeTensorInfo([], "float32", va.createScalarValue(o2, "float32"));
      d3.push(e21), C2.push(e21);
    }
    g2 = a2.runWebGLProgram(u3, d3, l3);
  } else {
    let e21 = k2, t3 = N2;
    n2 && (e21 = NS({ inputs: { x: k2 }, backend: a2, attrs: { perm: [0, 2, 1] } }), C2.push(e21)), r2 && (t3 = NS({ inputs: { x: N2 }, backend: a2, attrs: { perm: [0, 2, 1] } }), C2.push(t3));
    let i3 = 1 === f2, s3 = e21;
    1 !== f2 && (s3 = fS({ inputs: { x: e21 }, backend: a2, attrs: { shape: [$2, R2, 1] } }), C2.push(s3));
    let o3 = 1 === f2 ? 2 : 1, l3 = t3;
    i3 && (l3 = fS({ inputs: { x: t3 }, backend: a2, attrs: { shape: [$2, 1, R2] } }), C2.push(l3));
    let u3 = hS({ inputs: { a: s3, b: l3 }, backend: a2 });
    g2 = wS({ inputs: { x: u3 }, backend: a2, attrs: { axis: o3, keepDims: true } }), C2.push(u3);
  }
  let M2 = fS({ inputs: { x: g2 }, backend: a2, attrs: { shape: b2 } });
  C2.push(g2);
  for (let O2 of C2) a2.disposeIntermediateTensorInfo(O2);
  return M2;
}
var RS = { kernelName: ia, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { a: a2, b: i2, bias: s2, preluActivationWeights: o2 } = t2, { transposeA: l2, transposeB: u2, activation: d2, leakyreluAlpha: c2 } = r2;
  return $S({ a: a2, b: i2, transposeA: l2, transposeB: u2, backend: n2, bias: s2, preluActivationWeights: o2, leakyreluAlpha: c2, activation: d2 });
} };
var SS = "return abs(x);";
var IS = { kernelName: "Abs", backendName: "webgl", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2 } = e20, { x: a2 } = n2;
  if (r2.shouldExecuteOnCPU([a2]) && "complex64" !== a2.dtype) {
    let e21 = r2.texData.get(a2.dataId), t3 = sR(e21.values);
    return r2.makeTensorInfo(a2.shape, a2.dtype, t3);
  }
  return t2 = _e().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new zR(a2.shape, SS) : new ER(a2.shape, SS), r2.runWebGLProgram(t2, [a2], a2.dtype);
} };
var ES = sS({ opSnippet: TR + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n" });
var TS = { kernelName: je, backendName: "webgl", kernelFunc: ES };
var MS = sS({ opSnippet: TR + "\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));" });
var OS = { kernelName: Ge, backendName: "webgl", kernelFunc: MS };
var FS = "return a + b;";
var PS = { kernelName: "Add", backendName: "webgl", kernelFunc: oS({ opSnippet: FS, packedOpSnippet: FS, supportsComplex: true, cpuKernelImpl: R$ }) };
var zS = class {
  constructor(e20, t2) {
    this.outputShape = [], this.outputShape = e20, this.variableNames = t2.map((e21, t3) => "T" + t3);
    let n2 = [];
    this.variableNames.forEach((e21) => {
      n2.push(`float v${e21} = get${e21}AtOutCoords();`);
    });
    let r2 = this.variableNames.map((e21) => "v" + e21).join(" + ");
    this.userCode = `
      void main() {
        ${n2.join("\n        ")}

        float result = ${r2};
        setOutput(result);
      }
    `;
  }
};
var VS = class {
  constructor(e20, t2) {
    this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = e20, this.variableNames = t2.map((e21, t3) => "T" + t3);
    let n2 = [];
    this.variableNames.forEach((e21) => {
      n2.push(`vec4 v${e21} = get${e21}AtOutCoords();`);
    });
    let r2 = this.variableNames.map((e21) => "v" + e21).join(" + ");
    this.userCode = `
      void main() {
        ${n2.join("\n        ")}

        vec4 result = ${r2};
        setOutput(result);
      }
    `;
  }
};
var _S = { kernelName: Xe, backendName: "webgl", kernelFunc: function e14(t2) {
  let { inputs: n2, backend: r2 } = t2, a2 = n2;
  if (1 === a2.length) return ZR({ inputs: { x: a2[0] }, backend: r2 });
  if (a2.length > _e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    let t3 = Math.floor(a2.length / 2), n3 = e14({ inputs: a2.slice(0, t3), backend: r2 }), i3 = e14({ inputs: a2.slice(t3), backend: r2 });
    return e14({ inputs: [n3, i3], backend: r2 });
  }
  let i2 = a2.map((e20) => e20.dtype).reduce((e20, t3) => pi(e20, t3)), s2 = a2.map((e20) => e20.shape), o2 = _e().getBool("WEBGL_PACK") ? new VS(a2[0].shape, s2) : new zS(a2[0].shape, s2);
  return r2.runWebGLProgram(o2, a2, i2);
} };
var DS = { kernelName: "All", backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2, o2 = a2.shape.length, l2 = va.parseAxisParam(i2, a2.shape), u2 = l2, d2 = Uf.getAxesPermutation(u2, o2), c2 = a2;
  null != d2 && (c2 = NS({ inputs: { x: a2 }, backend: n2, attrs: { perm: d2 } }), u2 = Uf.getInnerMostAxes(u2.length, o2)), Uf.assertAxesAreInnerMostDims("all", u2, o2);
  let h2, [p2, f2] = Uf.computeOutAndReduceShapes(c2.shape, u2), m2 = fS({ inputs: { x: c2 }, backend: n2, attrs: { shape: [-1, va.sizeFromShape(f2)] } }), A2 = yS(m2, m2.dtype, "all", n2);
  return h2 = fS(s2 ? { inputs: { x: A2 }, backend: n2, attrs: { shape: Uf.expandShapeToKeepDim(p2, l2) } } : { inputs: { x: A2 }, backend: n2, attrs: { shape: p2 } }), n2.disposeIntermediateTensorInfo(m2), n2.disposeIntermediateTensorInfo(A2), null != d2 && n2.disposeIntermediateTensorInfo(c2), h2;
} };
var WS = { kernelName: "Any", backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2, o2 = a2.shape.length, l2 = va.parseAxisParam(i2, a2.shape), u2 = l2, d2 = Uf.getAxesPermutation(u2, o2), c2 = a2;
  null != d2 && (c2 = NS({ inputs: { x: a2 }, backend: n2, attrs: { perm: d2 } }), u2 = Uf.getInnerMostAxes(u2.length, o2)), Uf.assertAxesAreInnerMostDims("any", u2, o2);
  let h2, [p2, f2] = Uf.computeOutAndReduceShapes(c2.shape, u2), m2 = fS({ inputs: { x: c2 }, backend: n2, attrs: { shape: [-1, va.sizeFromShape(f2)] } }), A2 = yS(m2, m2.dtype, "any", n2);
  return h2 = fS(s2 ? { inputs: { x: A2 }, backend: n2, attrs: { shape: Uf.expandShapeToKeepDim(p2, l2) } } : { inputs: { x: A2 }, backend: n2, attrs: { shape: p2 } }), n2.disposeIntermediateTensorInfo(m2), n2.disposeIntermediateTensorInfo(A2), null != d2 && n2.disposeIntermediateTensorInfo(c2), h2;
} };
var LS = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["A"];
    let { windowSize: r2, batchSize: a2, outSize: i2 } = e20;
    n2 || this.variableNames.push("bestIndicesA"), this.outputShape = [a2, i2], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r2};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r2}; i++) {
          int inIdx = ${n2 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));"};
          float candidate = getA(batch, inIdx);
          if (candidate ${"max" === t2 ? ">" : "<"} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
  }
};
var BS = class {
  constructor(e20, t2, n2, r2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, va.assert(e20.length > 2, () => `Packed arg${n2.charAt(0).toUpperCase() + n2.slice(1)} supports only inputs with rank above 2.`);
    let a2 = Math.ceil(e20[e20.length - 1] / t2);
    this.outputShape = e20.slice(0, -1), a2 > 1 && this.outputShape.push(a2), r2 || this.variableNames.push("bestIndicesA");
    let i2, s2, o2 = this.outputShape, l2 = o2.length, u2 = UC(l2), d2 = kR("coords", l2);
    if (1 === a2) {
      s2 = l2 + 1;
      let e21 = UC(s2);
      i2 = `
        ${e21} sourceLocR = ${e21}(${d2.join()}, 0);
        ++${d2[l2 - 1]};
        ${e21} sourceLocG = ${e21}(${d2.join()}, 0);
        ++${d2[l2 - 2]};
        ${e21} sourceLocA = ${e21}(${d2.join()}, 0);
        --${d2[l2 - 1]};
        ${e21} sourceLocB = ${e21}(${d2.join()}, 0);
        --${d2[l2 - 2]};`;
    } else s2 = l2, i2 = `
        ${u2} sourceLocR = coords;
        ++${d2[l2 - 1]};
        ${u2} sourceLocG = coords;
        ++${d2[l2 - 2]};
        ${u2} sourceLocA = coords;
        --${d2[l2 - 1]};
        ${u2} sourceLocB = coords;
        --${d2[l2 - 2]};`;
    let c2 = ["x", "y", "z", "w", "u", "v"].slice(0, s2), h2 = "." + c2[s2 - 1], p2 = c2.map((e21) => "int " + e21), f2 = kR("sourceLocR", s2 - 1).concat("inIdx.r"), m2 = kR("sourceLocG", s2 - 1).concat("inIdx.g"), A2 = kR("sourceLocB", s2 - 1).concat("inIdx.b"), x2 = kR("sourceLocA", s2 - 1).concat("inIdx.a"), y2 = "max" === n2 ? "greaterThan" : "lessThan", b2 = r2 ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${f2.join()}),
                             getBestIndicesAChannel(${m2.join()}),
                             getBestIndicesAChannel(${A2.join()}),
                             getBestIndicesAChannel(${x2.join()})));`, g2 = `vec4(
            getAChannel(${f2.join()}),
            hasNextCol ? getAChannel(${m2.join()}) : 0.,
            hasNextRow ? getAChannel(${A2.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x2.join()}) : 0.)`, v2 = r2 ? "" : `
      float getBestIndicesAChannel(${p2.join()}) {
        return getChannel(getBestIndicesA(${c2.join()}),
                                          vec2(${c2.slice(-2).join()}));
      }`;
    this.userCode = `
      float getAChannel(${p2.join()}) {
        return getChannel(getA(${c2.join()}),
                               vec2(${c2.slice(-2).join()}));
      }
      ${v2}
      void main() {
        ${u2} coords = getOutputCoords();
        bool hasNextCol = ${d2[l2 - 1]} < ${o2[l2 - 1] - 1};
        bool hasNextRow = ${d2[l2 - 2]} < ${o2[l2 - 2] - 1};
        ${i2}
        ivec4 srcIdx = ivec4(sourceLocR${h2}, sourceLocG${h2},
          sourceLocB${h2}, sourceLocA${h2}) * ${t2};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${g2};

        for (int i = 0; i < ${t2}; i++) {
          inIdx = srcIdx;
          ${b2}
          vec4 candidate = ${g2};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${y2}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
  }
};
function US(e20, t2, n2, r2 = null) {
  let a2 = t2.shape[0], i2 = t2.shape[1];
  null != r2 && (a2 = r2.shape[0], i2 = r2.shape[1]);
  let s2 = Uf.computeOptimalWindowSize(i2), o2 = new LS({ windowSize: s2, inSize: i2, batchSize: a2, outSize: Math.ceil(i2 / s2) }, n2, null == r2), l2 = [t2];
  null != r2 && l2.push(r2);
  let u2 = e20.runWebGLProgram(o2, l2, "int32");
  if (1 === u2.shape[1]) return u2;
  let d2 = US(e20, t2, n2, u2);
  return e20.disposeIntermediateTensorInfo(u2), d2;
}
function jS(e20, t2, n2, r2 = null) {
  let a2 = null != r2 ? r2.shape : t2.shape, i2 = Uf.computeOptimalWindowSize(a2[a2.length - 1]), s2 = new BS(a2, i2, n2, null == r2), o2 = e20.runWebGLProgram(s2, null == r2 ? [t2] : [t2, r2], "int32");
  if (o2.shape.length === t2.shape.length) {
    let r3 = jS(e20, t2, n2, o2);
    return e20.disposeIntermediateTensorInfo(o2), r3;
  }
  return o2;
}
function GS(e20, t2, n2, r2) {
  let a2 = [n2];
  if (Uf.assertAxesAreInnerMostDims("arg" + r2.charAt(0).toUpperCase() + r2.slice(1), a2, t2.shape.length), !_e().getBool("WEBGL_PACK_REDUCE") || 2 >= t2.shape.length) {
    let n3 = [], i2 = e20.texData.get(t2.dataId), s2 = t2;
    null !== i2 && i2.isPacked && (s2 = e20.unpackTensor(t2), n3.push(s2));
    let [o2, l2] = Uf.computeOutAndReduceShapes(s2.shape, a2), u2 = va.sizeFromShape(l2), d2 = fS({ inputs: { x: s2 }, backend: e20, attrs: { shape: [-1, u2] } });
    n3.push(d2);
    let c2 = US(e20, d2, r2);
    n3.push(c2);
    let h2 = fS({ inputs: { x: c2 }, backend: e20, attrs: { shape: o2 } });
    return n3.forEach((t3) => e20.disposeIntermediateTensorInfo(t3)), h2;
  }
  return jS(e20, t2, r2);
}
var HS = { kernelName: Ke, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2 } = r2, s2 = va.parseAxisParam(i2, a2.shape), o2 = Uf.getAxesPermutation(s2, a2.shape.length), l2 = a2, u2 = [];
  null != o2 && (l2 = NS({ inputs: { x: a2 }, backend: n2, attrs: { perm: o2 } }), u2.push(l2), s2 = Uf.getInnerMostAxes(s2.length, l2.shape.length)), Uf.assertAxesAreInnerMostDims("argMax", [s2[0]], l2.shape.length);
  let d2 = GS(n2, l2, s2[0], "max");
  return u2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), d2;
} };
var XS = { kernelName: Ye, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2 } = r2, s2 = va.parseAxisParam(i2, a2.shape), o2 = Uf.getAxesPermutation(s2, a2.shape.length), l2 = a2, u2 = [];
  null != o2 && (l2 = NS({ inputs: { x: a2 }, backend: n2, attrs: { perm: o2 } }), u2.push(l2), s2 = Uf.getInnerMostAxes(s2.length, l2.shape.length)), Uf.assertAxesAreInnerMostDims("argMin", [s2[0]], l2.shape.length);
  let d2 = GS(n2, l2, s2[0], "min");
  return u2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), d2;
} };
var qS = sS({ opSnippet: TR + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n" });
var ZS = { kernelName: Je, backendName: "webgl", kernelFunc: qS };
var KS = sS({ opSnippet: TR + "return log(x + sqrt(x * x + 1.0));" });
var YS = { kernelName: Qe, backendName: "webgl", kernelFunc: KS };
var JS = sS({ opSnippet: TR + "\n  return atan(x);\n" });
var QS = { kernelName: et, backendName: "webgl", kernelFunc: JS };
var eI = oS({ opSnippet: GR + "\n  return atan(a, b);\n", packedOpSnippet: "\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  " + XR + "\n  return result;\n" });
var tI = { kernelName: nt, backendName: "webgl", kernelFunc: eI };
var nI = sS({ opSnippet: TR + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;" });
var rI = { kernelName: tt, backendName: "webgl", kernelFunc: nI };
var aI = class {
  constructor(e20, t2, n2, r2 = false, a2 = false) {
    if (this.variableNames = ["x"], "avg" === t2 && n2) throw Error("Cannot compute positions for average pool.");
    let i2 = e20.filterWidth, s2 = e20.strideHeight, o2 = e20.strideWidth, l2 = e20.dilationHeight, u2 = e20.dilationWidth, d2 = e20.effectiveFilterHeight, c2 = e20.effectiveFilterWidth, h2 = e20.padInfo.top, p2 = e20.padInfo.left;
    this.outputShape = e20.outShape;
    let f2 = "avg" === t2, m2 = "0.0";
    if (f2 || (m2 = "-1.0 / 1e-20"), n2) return void (this.userCode = `
        const ivec2 strides = ivec2(${s2}, ${o2});
        const ivec2 pads = ivec2(${h2}, ${p2});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d2};
              wR += ${l2}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e20.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${c2};
                wC += ${u2}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e20.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r2 ? a2 ? `((batch  * ${e20.inHeight} + xR) * ${e20.inWidth} + xC) * ${e20.inChannels} + d` : `(xR * ${e20.inWidth} + xC) * ${e20.inChannels} + d` : `wR * ${c2} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `);
    let A2 = `${t2}(${t2}(${t2}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    "avg" === t2 && (A2 = "avgValue / max(count, 1.0)");
    let x2 = 4 * Math.floor(i2 / 4), y2 = i2 % 4, b2 = `
      if (${f2}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec2 strides = ivec2(${s2}, ${o2});
      const ivec2 pads = ivec2(${h2}, ${p2});
      const float initializationValue = ${m2};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e20.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${m2});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d2};
            wR += ${l2}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e20.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${x2}; wC += 4) {
            int xC = xCCorner + wC * ${u2};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u2}, d),
              getValue(batch, xR, xC + 2 * ${u2}, d),
              getValue(batch, xR, xC + 3 * ${u2}, d)
            );

            ${b2}
          }

          int xC = xCCorner + ${x2};
          if (${1 === y2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${b2}
          } else if (${2 === y2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u2}, d),
              initializationValue,
              initializationValue
            );

            ${b2}
          } else if (${3 === y2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u2}, d),
              getValue(batch, xR, xC + 2 * ${u2}, d),
              initializationValue
            );

            ${b2}
          }
        }
        setOutput(${A2});
      }
    `;
  }
};
var iI = class {
  constructor(e20, t2, n2, r2 = false, a2 = false) {
    if (this.variableNames = ["x"], "avg" === t2 && n2) throw Error("Cannot compute positions for average pool.");
    let i2 = e20.filterWidth, s2 = e20.strideDepth, o2 = e20.strideHeight, l2 = e20.strideWidth, u2 = e20.dilationDepth, d2 = e20.dilationHeight, c2 = e20.dilationWidth, h2 = e20.effectiveFilterDepth, p2 = e20.effectiveFilterHeight, f2 = e20.effectiveFilterWidth, m2 = e20.padInfo.front, A2 = e20.padInfo.top, x2 = e20.padInfo.left;
    this.outputShape = e20.outShape;
    let y2 = "avg" === t2, b2 = "0.0";
    if (y2 || (b2 = "-1.0 / 1e-20"), n2) return void (this.userCode = `
        const ivec3 strides =
            ivec3(${s2}, ${o2}, ${l2});
        const ivec3 pads = ivec3(${m2}, ${A2}, ${x2});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h2};
              wD += ${u2}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e20.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p2};
                wR += ${d2}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e20.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f2};
                  wC += ${c2}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e20.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r2 ? a2 ? `(((batch * ${e20.inDepth} + xD) * ${e20.inHeight} + xR) * ${e20.inWidth} + xC) * ${e20.inChannels} + ch` : `((xD * ${e20.inHeight} + xR) * ${e20.inWidth} + xC) * ${e20.inChannels} + ch` : `wD * ${p2} * ${f2} +
                      wR * ${f2} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `);
    let g2 = `${t2}(${t2}(${t2}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
    "avg" === t2 && (g2 = "avgValue / max(count, 1.0)");
    let v2 = 4 * Math.floor(i2 / 4), w2 = i2 % 4, k2 = `
      if (${y2}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec3 strides =
        ivec3(${s2}, ${o2}, ${l2});
      const ivec3 pads = ivec3(${m2}, ${A2}, ${x2});
      const float initializationValue = ${b2};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e20.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b2});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h2};
            wD += ${u2}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e20.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p2};
            wR += ${d2}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e20.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${v2}; wC += 4) {
              int xC = xCCorner + wC * ${c2};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c2}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c2}, ch),
                getValue(batch, xD, xR, xC + 3 * ${c2}, ch)
              );

              ${k2}
            }

            int xC = xCCorner + ${v2};
            if (${1 === w2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${k2}
            } else if (${2 === w2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c2}, ch),
                initializationValue,
                initializationValue
              );

              ${k2}
            } else if (${3 === w2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c2}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c2}, ch),
                initializationValue
              );

              ${k2}
            }
          }
        }
        setOutput(${g2});
      }
    `;
  }
};
var sI = { kernelName: rt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2;
  $C(a2, "avgPool");
  let { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2 } = r2;
  va.assert(Uf.eitherStridesOrDilationsAreOne(s2, 1), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${s2} and dilations '1'`);
  let u2 = Uf.computePool2DInfo(a2.shape, i2, s2, 1, o2, l2);
  if (1 === u2.filterWidth && 1 === u2.filterHeight && va.arraysEqual(u2.inShape, u2.outShape)) return ZR({ inputs: { x: a2 }, backend: n2 });
  let d2 = new aI(u2, "avg", false);
  return n2.runWebGLProgram(d2, [a2], "float32");
} };
var oI = { kernelName: it, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2, dataFormat: u2 } = r2, d2 = Uf.computePool3DInfo(a2.shape, i2, s2, [1, 1, 1], o2, l2, u2), c2 = new iI(d2, "avg", false);
  return n2.runWebGLProgram(c2, [a2], "float32");
} };
var lI = class {
  constructor(e20) {
    this.variableNames = ["dy"], this.outputShape = e20.inShape;
    let t2 = e20.effectiveFilterHeight, n2 = e20.effectiveFilterWidth;
    this.userCode = `
      const ivec2 pads = ivec2(${t2 - 1 - e20.padInfo.top}, ${n2 - 1 - e20.padInfo.left});
      const float avgMultiplier = float(${1 / (e20.filterHeight * e20.filterWidth)});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t2};
            wR += ${e20.dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${e20.strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${e20.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${n2};
            wC+= ${e20.dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${e20.strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${e20.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var uI = class {
  constructor(e20) {
    this.variableNames = ["dy"], this.outputShape = e20.inShape;
    let t2 = e20.effectiveFilterDepth, n2 = e20.effectiveFilterHeight, r2 = e20.effectiveFilterWidth;
    this.userCode = `
      const ivec3 pads = ivec3(${t2 - 1 - e20.padInfo.front}, ${n2 - 1 - e20.padInfo.top}, ${r2 - 1 - e20.padInfo.left});
      const float avgMultiplier = float(${1 / (e20.filterDepth * e20.filterHeight * e20.filterWidth)});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${t2};
            wD += ${e20.dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${e20.strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${e20.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${n2};
              wR += ${e20.dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${e20.strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${e20.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${r2};
                wC += ${e20.dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${e20.strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${e20.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var dI = { kernelName: st, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, s2 = i2, { filterSize: o2, strides: l2, pad: u2, dimRoundingMode: d2 } = r2, c2 = Uf.computePool3DInfo(s2.shape, o2, l2, [1, 1, 1], u2, d2), h2 = new uI(c2);
  return n2.runWebGLProgram(h2, [a2], s2.dtype);
} };
var cI = { kernelName: at, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, s2 = i2;
  $C([a2, i2], "avgPoolGrad");
  let { filterSize: o2, strides: l2, pad: u2 } = r2, d2 = Uf.computePool2DInfo(s2.shape, o2, l2, 1, u2), c2 = new lI(d2);
  return n2.runWebGLProgram(c2, [a2], s2.dtype);
} };
var hI = { kernelName: ot, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { a: a2, b: i2 } = t2, { transposeA: s2, transposeB: o2 } = r2;
  return $S({ a: a2, b: i2, transposeA: s2, transposeB: o2, backend: n2 });
} };
var pI = class {
  constructor(e20, t2, n2, r2, a2, i2) {
    this.outputShape = [], this.variableNames = ["x", "mean", "variance"], Uf.assertAndGetBroadcastShape(e20, t2), Uf.assertAndGetBroadcastShape(e20, n2);
    let s2 = "0.0";
    null != r2 && (Uf.assertAndGetBroadcastShape(e20, r2), this.variableNames.push("offset"), s2 = "getOffsetAtOutCoords()");
    let o2 = "1.0";
    null != a2 && (Uf.assertAndGetBroadcastShape(e20, a2), this.variableNames.push("scale"), o2 = "getScaleAtOutCoords()"), this.outputShape = e20, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${s2};
        float scale = ${o2};
        float inv = scale * inversesqrt(variance + float(${i2}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
  }
};
var fI = class {
  constructor(e20, t2, n2, r2, a2, i2) {
    this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], Uf.assertAndGetBroadcastShape(e20, t2), Uf.assertAndGetBroadcastShape(e20, n2);
    let s2 = "vec4(0.0)";
    null != r2 && (Uf.assertAndGetBroadcastShape(e20, r2), this.variableNames.push("offset"), s2 = "getOffsetAtOutCoords()");
    let o2 = "vec4(1.0)";
    null != a2 && (Uf.assertAndGetBroadcastShape(e20, a2), this.variableNames.push("scale"), o2 = "getScaleAtOutCoords()"), this.outputShape = e20, this.userCode = `
      void main() {
        vec4 offset = ${s2};
        vec4 scale = ${o2};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i2}));

        setOutput((x - mean) * inv + offset);
      }
    `;
  }
};
var mI = { kernelName: en, backendName: "webgl", kernelFunc({ inputs: e20, backend: t2, attrs: n2 }) {
  let { x: r2, mean: a2, variance: i2, offset: s2, scale: o2 } = e20;
  va.assert(a2.shape.length === i2.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), va.assert(null == s2 || a2.shape.length === s2.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), va.assert(null == o2 || a2.shape.length === o2.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  let { varianceEpsilon: l2 } = n2;
  null == l2 && (l2 = 1e-3);
  let u2 = [r2, a2, i2], d2 = null;
  null != s2 && (d2 = s2.shape, u2.push(s2));
  let c2 = null;
  null != o2 && (c2 = o2.shape, u2.push(o2));
  let h2 = _e().getBool("WEBGL_PACK_NORMALIZATION") ? new fI(r2.shape, a2.shape, i2.shape, d2, c2, l2) : new pI(r2.shape, a2.shape, i2.shape, d2, c2, l2);
  return t2.runWebGLProgram(h2, u2, u2[0].dtype);
} };
var AI = class {
  constructor(e20) {
    this.variableNames = ["source"], this.outputShape = e20, this.rank = e20.length;
    let t2 = UC(this.rank);
    this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    let n2, r2 = ((e21) => {
      if (1 === e21) return "sourceLoc";
      if (6 >= e21) return xI.slice(0, e21).map((e22) => "sourceLoc." + e22).join(",");
      throw Error(`Slicing for rank ${e21} is not yet supported`);
    })(this.rank);
    n2 = `
        ${t2} sourceLoc;
        ${t2} coords = getOutputCoords();
        ${e20.map((e21, t3) => `sourceLoc.${xI[t3]} = start[${t3}] + coords.${xI[t3]};`).join("\n")}
      `, this.userCode = `
      void main() {
        ${n2}
        setOutput(getSource(${r2}));
      }
    `;
  }
};
var xI = ["x", "y", "z", "w", "u", "v"];
var yI = class {
  constructor(e20) {
    this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e20, this.rank = e20.length, this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    let t2 = UC(this.rank), n2 = kR("coords", this.rank), r2 = kR("sourceLoc", this.rank), a2 = 1 === this.rank ? "sourceLoc" : `vec2(${r2.slice(-2).join()})`, i2 = `getChannel(getSource(${r2.join()}), ${a2})`, s2 = `
      result.x = ${i2};
      if (++${n2[this.rank - 1]} < ${e20[this.rank - 1]}) {
        ++${r2[this.rank - 1]};
        result.y = ${i2};
        --${r2[this.rank - 1]};
      }
    `, o2 = 1 === this.rank ? "" : `
      --${n2[this.rank - 1]};
      if (++${n2[this.rank - 2]} < ${e20[this.rank - 2]}) {
        ++${r2[this.rank - 2]};
        result.z = ${i2};
        if (++${n2[this.rank - 1]} < ${e20[this.rank - 1]}) {
          ++${r2[this.rank - 1]};
          result.w = ${i2};
        }
      }
    `, l2 = this.rank > 4 ? e20.map((e21, t3) => `${r2[t3]} = ${n2[t3]} + start[${t3}];`).join("\n") : `sourceLoc = coords +
            ${t2}(${e20.map((e21, t3) => `start[${t3}]`).join()});`;
    this.userCode = `
      void main() {
        ${t2} coords = getOutputCoords();
        ${t2} sourceLoc;
        ${l2}
        vec4 result = vec4(0.);
        ${s2}
        ${o2}
        setOutput(result);
      }
    `;
  }
};
function bI(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { begin: i2, size: s2 } = r2, [o2, l2] = xf.parseSliceParams(a2, i2, s2);
  if (xf.assertParamsValid(a2, o2, l2), 0 === va.sizeFromShape(l2)) return n2.makeTensorInfo(l2, a2.dtype, []);
  if (n2.shouldExecuteOnCPU([a2]) || "string" === a2.dtype) {
    let e21 = n2.texData.get(a2.dataId), t3 = oR(e21.values, o2, l2, a2.shape, a2.dtype);
    return n2.makeTensorInfo(l2, a2.dtype, t3);
  }
  let { isPacked: u2 } = n2.texData.get(a2.dataId), d2 = xf.isSliceContinous(a2.shape, o2, l2);
  if (u2 || !d2) {
    let e21 = _e().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new yI(l2) : new AI(l2);
    return n2.runWebGLProgram(e21, [a2], a2.dtype, [o2]);
  }
  return n2.uploadToGPU(a2.dataId), ((e21, t3, n3, r3) => {
    let a3 = r3.texData.get(e21.dataId), i3 = r3.makeTensorInfo(n3, e21.dtype), s3 = r3.texData.get(i3.dataId);
    Object.assign(s3, a3), s3.refCount = 1, s3.shape = n3, s3.dtype = e21.dtype;
    let o3 = xf.computeFlatOffset(t3, va.computeStrides(e21.shape));
    a3.slice && (o3 += a3.slice.flatOffset), s3.slice = { flatOffset: o3, origDataId: a3.slice && a3.slice.origDataId || e21.dataId };
    let l3 = r3.dataRefCount.get(s3.slice.origDataId) || 1;
    return r3.dataRefCount.set(s3.slice.origDataId, l3 + 1), i3;
  })(a2, o2, l2, n2);
}
var gI = { kernelName: vr, backendName: "webgl", kernelFunc: bI };
var vI = { kernelName: lt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockShape: i2, crops: s2 } = r2;
  va.assert(4 >= a2.shape.length, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
  let o2 = i2.reduce((e21, t3) => e21 * t3), l2 = Uf.getReshaped(a2.shape, i2, o2), u2 = Uf.getPermuted(l2.length, i2.length), d2 = Uf.getReshapedPermuted(a2.shape, i2, o2), c2 = Uf.getSliceBeginCoords(s2, i2.length), h2 = Uf.getSliceSize(d2, s2, i2.length), p2 = [], f2 = fS({ inputs: { x: a2 }, backend: n2, attrs: { shape: l2 } }), m2 = NS({ inputs: { x: f2 }, backend: n2, attrs: { perm: u2 } }), A2 = fS({ inputs: { x: m2 }, backend: n2, attrs: { shape: d2 } }), x2 = bI({ inputs: { x: A2 }, backend: n2, attrs: { begin: c2, size: h2 } });
  return p2.push(f2), p2.push(m2), p2.push(A2), p2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), x2;
} };
var wI = { kernelName: ut, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, weights: i2 } = t2, { size: s2 } = r2, o2 = n2.readSync(a2.dataId), l2 = n2.readSync(i2.dataId), u2 = S$(o2, l2, i2.dtype, i2.shape, s2);
  return n2.makeTensorInfo([s2], i2.dtype, u2);
} };
var kI = { kernelName: dt, backendName: "webgl", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2 } = e20, { a: a2, b: i2 } = n2, s2 = _e().getBool("WEBGL_PACK_BINARY_OPERATIONS"), o2 = _e().getNumber("WEBGL_VERSION");
  if (r2.shouldExecuteOnCPU([a2, i2]) || 1 === o2) {
    let e21 = r2.texData.get(a2.dataId).values, t3 = r2.texData.get(i2.dataId).values, [n3, s3] = E$(a2.shape, i2.shape, e21, t3, a2.dtype), o3 = r2.makeTensorInfo(s3, a2.dtype);
    return r2.texData.get(o3.dataId).values = n3, o3;
  }
  return t2 = s2 ? new qR("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n", a2.shape, i2.shape, false) : new HR("\n  return float(int(a.r) & int(b.r));\n", a2.shape, i2.shape), r2.runWebGLProgram(t2, [a2, i2], a2.dtype);
} };
var NI = { kernelName: ht, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { s0: r2, s1: a2 } = t2, i2 = n2.readSync(r2.dataId), s2 = n2.readSync(a2.dataId), o2 = Uf.assertAndGetBroadcastShape(Array.from(i2), Array.from(s2));
  return n2.makeTensorInfo([o2.length], "int32", Int32Array.from(o2));
} };
var CI = oS({ opSnippet: "return float(a != b);", cpuKernelImpl: Y$, dtype: "bool" });
var $I = { kernelName: Bn, backendName: "webgl", kernelFunc: CI };
function RI(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2;
  return ZR({ inputs: { x: n2.texData.get(r2.dataId).complexTensorInfos.real }, backend: n2 });
}
var SI = { kernelName: ar, backendName: "webgl", kernelFunc: RI };
var II = { kernelName: pt, backendName: "webgl", kernelFunc: function e15(t2) {
  let { inputs: n2, backend: r2, attrs: a2 } = t2, { x: i2 } = n2, { dtype: s2 } = a2;
  if ("complex64" === s2) {
    if ("complex64" === i2.dtype) return ZR({ inputs: { x: i2 }, backend: r2 });
    let t3 = nd(i2.shape), n3 = e15({ inputs: { x: i2 }, backend: r2, attrs: { dtype: "float32" } }), a3 = YR({ inputs: { real: n3, imag: t3 }, backend: r2 });
    return t3.dispose(), r2.disposeIntermediateTensorInfo(n3), a3;
  }
  if ("complex64" === i2.dtype) {
    let t3 = RI({ inputs: { input: i2 }, backend: r2 }), n3 = e15({ inputs: { x: t3 }, backend: r2, attrs: { dtype: s2 } });
    return r2.disposeIntermediateTensorInfo(t3), n3;
  }
  if (!va.hasEncodingLoss(i2.dtype, s2)) {
    let e20 = ZR({ inputs: { x: i2 }, backend: r2 });
    return { dataId: e20.dataId, shape: e20.shape, dtype: s2 };
  }
  if (r2.shouldExecuteOnCPU([i2])) {
    let e20 = r2.texData.get(i2.dataId).values, [t3, n3, a3] = T$(e20, i2.shape, i2.dtype, s2);
    return r2.makeTensorInfo(t3, n3, a3);
  }
  if ("int32" === s2) return ((e20, t3) => {
    let n3 = new ER(e20.shape, "return float(int(x));"), r3 = t3.runWebGLProgram(n3, [e20], "int32");
    return { dataId: r3.dataId, shape: r3.shape, dtype: r3.dtype };
  })(i2, r2);
  if ("bool" === s2) {
    let e20 = r2.makeTensorInfo([], "bool", va.getTypedArrayFromDType("bool", 1)), t3 = CI({ inputs: { a: i2, b: e20 }, backend: r2 });
    return r2.disposeIntermediateTensorInfo(e20), t3;
  }
  throw Error(`Error in Cast: failed to cast ${i2.dtype} to ${s2}`);
} };
var EI = "return ceil(x);";
var TI = sS({ opSnippet: EI, packedOpSnippet: EI, cpuKernelImpl: M$ });
var MI = { kernelName: ft, backendName: "webgl", kernelFunc: TI };
var OI = class {
  constructor(e20) {
    this.variableNames = ["A"], this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = e20, this.userCode = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  }
};
var FI = class {
  constructor(e20) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "minVal", type: "float" }, { name: "maxVal", type: "float" }], this.outputShape = e20, this.userCode = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  }
};
var PI = { kernelName: mt, backendName: "webgl", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2 } = n2, { clipValueMin: s2, clipValueMax: o2 } = a2;
  return t2 = _e().getBool("WEBGL_PACK_CLIP") ? new FI(i2.shape) : new OI(i2.shape), r2.runWebGLProgram(t2, [i2], i2.dtype, [[s2], [o2]]);
} };
var zI = class {
  constructor(e20) {
    this.variableNames = ["real", "imag"], this.outputShape = e20, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
  }
};
function VI(e20, t2) {
  return { dataId: t2.dataId, dtype: t2.dtype, shape: e20.shape };
}
var _I = { kernelName: xt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2, a2 = n2.texData.get(r2.dataId), i2 = new zI(r2.shape), s2 = [VI(r2, a2.complexTensorInfos.real), VI(r2, a2.complexTensorInfos.imag)];
  return n2.runWebGLProgram(i2, s2, s2[0].dtype);
} };
var DI = class {
  constructor(e20) {
    this.outputShape = [], this.outputShape = Uf.computeOutShape(e20, 1), this.variableNames = e20.map((e21, t3) => "T" + t3);
    let t2 = Array(e20.length - 1);
    t2[0] = e20[0][1];
    for (let r2 = 1; t2.length > r2; r2++) t2[r2] = t2[r2 - 1] + e20[r2][1];
    let n2 = [`if (yC < ${t2[0]}) setOutput(getT0(yR, yC));`];
    for (let r2 = 1; t2.length > r2; r2++) n2.push(`else if (yC < ${t2[r2]}) setOutput(getT${r2}(yR, yC-${t2[r2 - 1]}));`);
    n2.push(`else setOutput(getT${t2.length}(yR, yC-${t2[t2.length - 1]}));`), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n2.join("\n        ")}
      }
    `;
  }
};
var WI = class {
  constructor(e20, t2) {
    this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = Uf.computeOutShape(e20, t2);
    let n2 = this.outputShape, r2 = n2.length, a2 = UC(r2), i2 = kR("coords", r2), s2 = ["x", "y", "z", "w", "u", "v"].slice(0, r2);
    this.variableNames = e20.map((e21, t3) => "T" + t3);
    let o2 = Array(e20.length - 1);
    o2[0] = e20[0][t2];
    for (let p2 = 1; o2.length > p2; p2++) o2[p2] = o2[p2 - 1] + e20[p2][t2];
    let l2 = s2[t2], u2 = s2.slice(-2), d2 = s2.join(), c2 = `if (${l2} < ${o2[0]}) {
        return getChannel(
            getT0(${d2}), vec2(${u2.join()}));
        }`;
    for (let p2 = 1; o2.length > p2; p2++) {
      let e21 = o2[p2 - 1];
      c2 += `
        if (${l2} < ${o2[p2]}  && ${l2} >= ${o2[p2 - 1]}) {
          return getChannel(
            getT${p2}(${LI(s2, l2, e21)}),
            vec2(${LI(u2, l2, e21)}));
        }`;
    }
    let h2 = o2[o2.length - 1];
    c2 += `
        return getChannel(
          getT${o2.length}(${LI(s2, l2, h2)}),
          vec2(${LI(u2, l2, h2)}));`, this.userCode = `
      float getValue(${s2.map((e21) => "int " + e21)}) {
        ${c2}
      }

      void main() {
        ${a2} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i2}), 0., 0., 0.);

        ${i2[r2 - 1]} = ${i2[r2 - 1]} + 1;
        if (${i2[r2 - 1]} < ${n2[r2 - 1]}) {
          result.g = getValue(${i2});
        }

        ${i2[r2 - 2]} = ${i2[r2 - 2]} + 1;
        if (${i2[r2 - 2]} < ${n2[r2 - 2]}) {
          result.a = getValue(${i2});
        }

        ${i2[r2 - 1]} = ${i2[r2 - 1]} - 1;
        if (${i2[r2 - 2]} < ${n2[r2 - 2]} &&
            ${i2[r2 - 1]} < ${n2[r2 - 1]}) {
          result.b = getValue(${i2});
        }
        setOutput(result);
      }
    `;
  }
};
function LI(e20, t2, n2) {
  let r2 = e20.indexOf(t2);
  return e20.map((e21, t3) => t3 === r2 ? `${e21} - ${n2}` : e21).join();
}
function BI(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2;
  return ZR({ inputs: { x: n2.texData.get(r2.dataId).complexTensorInfos.imag }, backend: n2 });
}
var UI = { kernelName: ln, backendName: "webgl", kernelFunc: BI };
function jI(e20, t2, n2) {
  let r2 = e20[0].dtype;
  if ("complex64" === r2) {
    let r3 = e20.map((e21) => RI({ inputs: { input: e21 }, backend: n2 })), a3 = e20.map((e21) => BI({ inputs: { input: e21 }, backend: n2 })), i3 = jI(r3, t2, n2), s3 = jI(a3, t2, n2), o3 = YR({ inputs: { real: i3, imag: s3 }, backend: n2 });
    return r3.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), a3.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), n2.disposeIntermediateTensorInfo(i3), n2.disposeIntermediateTensorInfo(s3), o3;
  }
  let a2 = n2.shouldExecuteOnCPU(e20);
  if ("string" === r2 && (a2 = true), a2) {
    let a3 = e20.map((e21) => {
      let r3 = [-1, va.sizeFromShape(e21.shape.slice(t2))];
      return fS({ inputs: { x: e21 }, backend: n2, attrs: { shape: r3 } });
    }), i3 = a3.map((e21) => ({ vals: n2.readSync(e21.dataId), shape: e21.shape })), s3 = Uf.computeOutShape(a3.map((e21) => e21.shape), 1), o3 = O$(i3, s3, r2, 1 === a3[0].shape[0]), l3 = Uf.computeOutShape(e20.map((e21) => e21.shape), t2), u3 = n2.makeTensorInfo(l3, r2, o3);
    return a3.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), u3;
  }
  let i2 = e20.filter((e21) => va.sizeFromShape(e21.shape) > 0), s2 = _e().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && i2[0].shape.length > 1;
  if (1 === i2.length) {
    let t3 = s2 ? new ER(e20[0].shape, PR) : new zR(e20[0].shape, PR);
    return n2.runWebGLProgram(t3, e20, r2);
  }
  let o2 = _e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
  if (i2.length > o2) {
    let e21 = [];
    for (let a3 = 0; i2.length > a3; a3 += o2) {
      let r4 = i2.slice(a3, a3 + o2);
      e21.push(jI(r4, t2, n2));
    }
    let r3 = jI(e21, t2, n2);
    for (let t3 of e21) n2.disposeIntermediateTensorInfo(t3);
    return r3;
  }
  if (s2) {
    let e21 = new WI(i2.map((e22) => e22.shape), t2);
    return n2.runWebGLProgram(e21, i2, r2);
  }
  let { tensors2D: l2, outShape: u2 } = ((e21, t3, n3) => {
    let r3 = Uf.computeOutShape(e21.map((e22) => e22.shape), t3);
    return { tensors2D: e21.map((e22) => fS({ inputs: { x: e22 }, attrs: { shape: [-1, va.sizeFromShape(e22.shape.slice(t3))] }, backend: n3 })), outShape: r3 };
  })(i2, t2, n2), d2 = new DI(l2.map((e21) => e21.shape)), c2 = n2.runWebGLProgram(d2, l2, r2);
  l2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21));
  let h2 = fS({ inputs: { x: c2 }, attrs: { shape: u2 }, backend: n2 });
  return n2.disposeIntermediateTensorInfo(c2), h2;
}
function GI(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { axis: a2 } = r2, i2 = va.parseAxisParam(a2, t2[0].shape)[0], s2 = t2.map((e21) => e21.shape);
  Uf.assertParamsConsistent(s2, i2);
  let o2 = Uf.computeOutShape(t2.map((e21) => e21.shape), i2);
  if (0 === va.sizeFromShape(o2)) return n2.makeTensorInfo(o2, t2[0].dtype, []);
  let l2 = t2.filter((e21) => va.sizeFromShape(e21.shape) > 0);
  return 1 === l2.length ? ZR({ inputs: { x: l2[0] }, backend: n2 }) : jI(l2, i2, n2);
}
var HI = { kernelName: yt, backendName: "webgl", kernelFunc: GI };
var XI = class {
  constructor(e20, t2 = false, n2 = null, r2 = false, a2 = false) {
    this.variableNames = ["x", "W"], this.outputShape = e20.outShape;
    let i2 = e20.padInfo.top, s2 = e20.padInfo.left, o2 = e20.strideHeight, l2 = e20.strideWidth, u2 = e20.dilationHeight, d2 = e20.dilationWidth, c2 = e20.filterHeight, h2 = e20.filterWidth, p2 = 4 * Math.floor(e20.inChannels / 4), f2 = e20.inChannels % 4, m2 = "channelsLast" === e20.dataFormat, A2 = m2 ? 1 : 2, x2 = m2 ? 2 : 3, y2 = m2 ? 3 : 1, b2 = "", g2 = "";
    n2 && (b2 = r2 ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n2}
        }` : a2 ? `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n2}
        }` : `
          float activation(float x) {
            ${n2}
          }
        `, g2 = "result = activation(result);");
    let v2 = t2 ? "result += getBiasAtOutCoords();" : "";
    t2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), a2 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${b2}

      const ivec2 strides = ivec2(${o2}, ${l2});
      const ivec2 pads = ivec2(${i2}, ${s2});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${y2}];

        ivec2 xRCCorner =
            ivec2(coords[${A2}], coords[${x2}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c2}; wR++) {
          int xR = xRCorner + wR * ${u2};

          if (xR < 0 || xR >= ${e20.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h2}; wC++) {
            int xC = xCCorner + wC * ${d2};

            if (xC < 0 || xC >= ${e20.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p2}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m2}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${1 === f2}) {

              if (${m2}) {
                dotProd +=
                    getX(batch, xR, xC, ${p2}) *
                    getW(wR, wC, ${p2}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p2}, xR, xC) *
                    getW(wR, wC, ${p2}, d2);
              }

            } else if (${2 === f2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p2}, d2),
                getW(wR, wC, ${p2} + 1, d2)
              );

              if (${m2}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p2}),
                  getX(batch, xR, xC, ${p2} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p2}, xR, xC),
                  getX(batch, ${p2} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${3 === f2}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p2}, d2),
                getW(wR, wC, ${p2} + 1, d2),
                getW(wR, wC, ${p2} + 2, d2)
              );

              if (${m2}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p2}),
                  getX(batch, xR, xC, ${p2} + 1),
                  getX(batch, xR, xC, ${p2} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p2}, xR, xC),
                  getX(batch, ${p2} + 1, xR, xC),
                  getX(batch, ${p2} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${v2}
        ${g2}
        setOutput(result);
      }
    `;
  }
};
var qI = class {
  constructor(e20) {
    this.variableNames = ["x", "W"], this.outputShape = e20.outShape;
    let t2 = e20.padInfo.front, n2 = e20.padInfo.top, r2 = e20.padInfo.left, a2 = e20.strideDepth, i2 = e20.strideHeight, s2 = e20.strideWidth, o2 = e20.dilationDepth, l2 = e20.dilationHeight, u2 = e20.dilationWidth, d2 = e20.filterDepth, c2 = e20.filterHeight, h2 = e20.filterWidth, p2 = 4 * Math.floor(e20.inChannels / 4), f2 = e20.inChannels % 4;
    this.userCode = `
      const ivec3 strides = ivec3(${a2}, ${i2}, ${s2});
      const ivec3 pads = ivec3(${t2}, ${n2}, ${r2});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d2}; wF++) {
          int xF = xFCorner + wF * ${o2};

          if (xF < 0 || xF >= ${e20.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c2}; wR++) {
            int xR = xRCorner + wR * ${l2};

            if (xR < 0 || xR >= ${e20.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h2}; wC++) {
              int xC = xCCorner + wC * ${u2};

              if (xC < 0 || xC >= ${e20.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p2}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${1 === f2}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p2}) *
                  getW(wF, wR, wC, ${p2}, d2);
              } else if (${2 === f2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p2}),
                  getX(batch, xF, xR, xC, ${p2} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p2}, d2),
                  getW(wF, wR, wC, ${p2} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${3 === f2}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p2}),
                  getX(batch, xF, xR, xC, ${p2} + 1),
                  getX(batch, xF, xR, xC, ${p2} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p2}, d2),
                  getW(wF, wR, wC, ${p2} + 1, d2),
                  getW(wF, wR, wC, ${p2} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var ZI = class {
  constructor(e20, t2 = false, n2 = null, r2 = false, a2 = false) {
    this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = e20.outShape, this.enableShapeUniforms = ZC(this.outputShape.length);
    let i2 = e20.padInfo.left, s2 = e20.strideWidth, o2 = e20.dilationWidth, l2 = e20.filterHeight, u2 = e20.filterWidth, d2 = u2, c2 = "\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";
    for (let m2 = 0; u2 > m2; m2++) c2 += `
           vec4 xTexelC${2 * m2};
           int xTexelC${2 * m2}Ready;
           vec4 xTexelC${2 * m2 + 1};
           int xTexelC${2 * m2 + 1}Ready;
           vec4 xC${m2};`;
    c2 += `
     for (int r = 0; r < ${l2}; r++) {
      for (int d1 = 0; d1 < ${e20.inChannels}; d1 += 2) {
       `;
    for (let m2 = 0; u2 > m2; m2++) c2 += `
           xTexelC${2 * m2} = vec4(0.0);
           xTexelC${2 * m2}Ready = 0;
           xTexelC${2 * m2 + 1} = vec4(0.0);
           xTexelC${2 * m2 + 1}Ready = 0;
           xC${m2} = vec4(0.0);`;
    c2 += "\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";
    for (let m2 = 0; (d2 + 1) / 2 > m2; m2++) {
      let t3 = 2 * m2;
      if (c2 += `
           xC = xCCorner + ${t3 * o2};
           `, 1 === s2) {
        if (u2 > t3 && (i2 % 2 == 1 ? (c2 += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t3}Ready == 0) {
                   xTexelC${t3} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${t3}.zw = vec2(0.0);
                   }
                   xTexelC${t3}Ready = 1;
                 }
               `, c2 += 1 === o2 && t3 > 0 ? `
                 xC${t3} = vec4(xTexelC${t3 - 2}.zw, xTexelC${t3}.xy);
                 ` : `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${t3} = vec4(previous.zw, xTexelC${t3}.xy);
                   } else {
                     xC${t3} = vec4(0.0, 0.0, xTexelC${t3}.xy);
                   }
                   `) : c2 += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${t3}Ready == 0) {
                   xTexelC${t3} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${t3}.zw = vec2(0.0);
                   }
                   xTexelC${t3}Ready = 1;
                 }

                 xC${t3} = xTexelC${t3};
                 `, u2 > t3 + 1)) {
          let e21 = i2 % 2 == 0 ? va.nearestLargerEven(o2) : o2;
          o2 % 2 == 0 && i2 % 2 == 1 || o2 % 2 != 0 && i2 % 2 != 1 ? (c2 += `
                   xCOffset = xC + imod(pads[1], 2) + ${e21};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t3 + 1}Ready == 0) {
                     xTexelC${t3 + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${t3 + 1}.zw = vec2(0.0);
                     }
                     xTexelC${t3 + 1}Ready = 1;
                   }
                   `, c2 += o2 > 1 ? `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${t3 + 1} = vec4(previous.zw, xTexelC${t3 + 1}.xy);
                     } else {
                      xC${t3 + 1} = vec4(0.0, 0.0, xTexelC${t3 + 1}.xy);
                     }
                     ` : `
                     xC${t3 + 1} = vec4(xTexelC${t3}.zw, xTexelC${t3 + 1}.xy);
                     `) : c2 += 1 === e21 ? `
                     xC${t3 + 1} = xTexelC${t3};
                     ` : `
                     xCOffset = xC + ${e21};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t3 + 1}Ready == 0) {
                       xTexelC${t3 + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${t3 + 1}.zw = vec2(0.0);
                       }
                       xTexelC${t3 + 1}Ready = 1;
                     }

                     xC${t3 + 1} = xTexelC${t3 + 1};
                     `;
        }
      } else u2 > t3 && (i2 % 2 == 1 ? (c2 += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t3}Ready == 0) {
                   xTexelC${t3} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${t3}.zw = vec2(0.0);
                   }
                   xTexelC${t3}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t3 + 1}Ready == 0) {
                   xTexelC${t3 + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${t3 + 1}.zw = vec2(0.0);
                   }
                   xTexelC${t3 + 1}Ready = 1;
                 }

                 xC${t3} = vec4(xTexelC${t3}.zw, xTexelC${t3 + 1}.zw);
               `, u2 > t3 + 1 && (c2 += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${t3 + 1} = vec4(xTexelC${t3 + 1}.xy, final.xy);
                 `)) : (c2 += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${t3}Ready == 0) {
                   xTexelC${t3} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${t3}.zw = vec2(0.0);
                   }
                   xTexelC${t3}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t3 + 1}Ready == 0) {
                   xTexelC${t3 + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${t3 + 1}.zw = vec2(0.);
                   }
                   xTexelC${t3 + 1}Ready = 1;
                 }

                 xC${t3} = vec4(
                   xTexelC${t3}.xy, xTexelC${t3 + 1}.xy);
               `, u2 > t3 + 1 && (c2 += `
                   xC${t3 + 1} = vec4(xTexelC${t3}.zw, xTexelC${t3 + 1}.zw);
                 `)));
      u2 > t3 && (c2 += `
             wTexel = getW(r, ${t3}, d1, d2);
             dotProd += xC${t3}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e20.inChannels}) {
               dotProd += xC${t3}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `, u2 > t3 + 1 && (c2 += `
               wTexel = getW(r, ${t3 + 1}, d1, d2);
               dotProd += xC${t3 + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e20.inChannels}) {
                 dotProd += xC${t3 + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `));
    }
    c2 += "\n     }\n   ", c2 += "\n     }\n   ", c2 += "\n     }\n   ";
    let h2 = "", p2 = "";
    n2 && (h2 = r2 ? `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n2}
         }` : a2 ? `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n2}
         }` : `vec4 activation(vec4 x) {
           ${n2}
         }`, p2 = "result = activation(result);");
    let f2 = t2 ? "result += getBiasAtOutCoords();" : "";
    t2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), a2 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
       ${h2}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${c2}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f2}
         ${p2}
         setOutput(result);
       }
     `;
  }
};
var KI = class {
  constructor(e20, t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "inputShape", type: "ivec4" }, { name: "pad", type: "ivec2" }, { name: "stride", type: "ivec2" }, { name: "dilation", type: "ivec2" }, { name: "inChannels", type: "int" }, { name: "itemsPerBlockRow", type: "int" }, { name: "outWidth", type: "int" }], this.outputShape = e20, this.enableShapeUniforms = ZC(this.outputShape.length);
    let { dataFormat: n2 } = t2, r2 = SC(), a2 = "channelsLast" === n2, i2 = a2 ? 1 : 2, s2 = a2 ? 2 : 3, o2 = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${e20[2]} && pos < ${e20[1]}) {`, l2 = "";
    for (let u2 = 0; 1 >= u2; u2++) for (let e21 = 0; 1 >= e21; e21++) l2 += `
          blockIndex = rc.z + ${e21};
          pos = rc.y + ${u2};

          ${o2}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i2}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${s2}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a2}) {
                  innerDims = vec2(d1, ch);
                  result[${2 * u2 + e21}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2 * u2 + e21}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
    this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l2}

        ${r2.output} = result;
      }
    `;
  }
};
function YI(e20, t2) {
  let n2 = e20.length;
  return 3 > n2 ? !t2 && 1 === n2 && e20[0] > 1 ? [e20[0], 1] : null : t2 ? [...e20.slice(0, -3), e20[n2 - 3] * e20[n2 - 2], e20[n2 - 1]] : [...e20.slice(0, -3), e20[n2 - 3], e20[n2 - 2] * e20[n2 - 1]];
}
function JI({ x: e20, filter: t2, convInfo: n2, backend: r2, bias: a2 = null, preluActivationWeights: i2 = null, leakyreluAlpha: s2 = 0, activation: o2 = null }) {
  let l2, u2 = e20.shape, d2 = r2.texData.get(e20.dataId), c2 = n2.inChannels, h2 = u2[0] * u2[1] * u2[2], p2 = n2.outChannels, f2 = "channelsLast" === n2.dataFormat, m2 = false, A2 = [];
  if (null != i2) {
    let e21 = YI(i2.shape, f2);
    null != e21 && (i2 = fS({ inputs: { x: i2 }, backend: r2, attrs: { shape: e21 } }), A2.push(i2));
  }
  if (null != a2) {
    let e21 = YI(a2.shape, f2);
    null != e21 && (a2 = fS({ inputs: { x: a2 }, backend: r2, attrs: { shape: e21 } }), A2.push(a2));
  }
  if ((1 !== h2 && 1 !== p2 || 1e3 >= c2) && d2.isPacked && f2 && null != d2.texture && u2[2] % 2 != 0 && va.arraysEqual(d2.shape.slice(-3), u2.slice(-3))) {
    let c3 = { dataId: e20.dataId, shape: [1, u2[0] * u2[1] * (u2[2] + 1), n2.inChannels], dtype: e20.dtype }, h3 = d2.shape;
    d2.shape = d2.shape.slice(), d2.shape[d2.shape.length - 2]++, va.assert(fC(d2.shape, c3.shape), () => `packed reshape ${d2.shape} to ${c3.shape} isn't free`);
    let p3 = fS({ inputs: { x: t2 }, backend: r2, attrs: { shape: [1, n2.inChannels, n2.outChannels] } });
    A2.push(p3);
    let f3 = $S({ a: c3, b: p3, backend: r2, transposeA: false, transposeB: m2, bias: a2, activation: o2, preluActivationWeights: i2, leakyreluAlpha: s2 }), x2 = r2.texData.get(f3.dataId);
    va.assert(x2.isPacked, () => "batchMatMul result is expected to be packed"), d2.shape = h3, x2.shape = n2.outShape, l2 = ZR({ inputs: { x: f3 }, backend: r2 }), l2.shape = n2.outShape, A2.push(f3);
  } else {
    let u3 = n2.outHeight * n2.outWidth, d3 = fS({ inputs: { x: e20 }, backend: r2, attrs: { shape: f2 ? [n2.batchSize, u3, n2.inChannels] : [n2.batchSize, n2.inChannels, u3] } }), c3 = fS({ inputs: { x: t2 }, backend: r2, attrs: { shape: [1, n2.inChannels, n2.outChannels] } }), h3 = $S({ a: f2 ? d3 : c3, b: f2 ? c3 : d3, transposeA: !f2, transposeB: m2, backend: r2, bias: a2, activation: o2, preluActivationWeights: i2, leakyreluAlpha: s2 });
    l2 = fS({ inputs: { x: h3 }, backend: r2, attrs: { shape: n2.outShape } }), A2.push(d3), A2.push(c3), A2.push(h3);
  }
  for (let x2 of A2) r2.disposeIntermediateTensorInfo(x2);
  return l2;
}
function QI({ x: e20, filter: t2, convInfo: n2, backend: r2, bias: a2 = null, preluActivationWeights: i2 = null, leakyreluAlpha: s2 = 0, activation: o2 = null }) {
  let { filterWidth: l2, filterHeight: u2, inChannels: d2, outWidth: c2, outHeight: h2, dataFormat: p2 } = n2, f2 = "channelsLast" === p2, m2 = l2 * u2 * d2, A2 = h2 * c2, x2 = [n2.batchSize, m2, A2], y2 = [];
  if (null != i2) {
    let e21 = YI(i2.shape, f2);
    null != e21 && (i2 = fS({ inputs: { x: i2 }, backend: r2, attrs: { shape: e21 } }), y2.push(i2));
  }
  if (null != a2) {
    let e21 = YI(a2.shape, f2);
    null != e21 && (a2 = fS({ inputs: { x: a2 }, backend: r2, attrs: { shape: e21 } }), y2.push(a2));
  }
  let b2 = fS({ inputs: { x: t2 }, backend: r2, attrs: { shape: [1, m2, va.sizeFromShape(t2.shape) / m2] } });
  y2.push(b2);
  let g2 = new KI(x2, n2), v2 = r2.runWebGLProgram(g2, [e20], "float32", [e20.shape, [n2.padInfo.top, n2.padInfo.left], [n2.strideHeight, n2.strideWidth], [n2.dilationHeight, n2.dilationWidth], [n2.inChannels], [n2.filterWidth * n2.inChannels], [n2.outWidth]]), w2 = fS({ inputs: { x: v2 }, backend: r2, attrs: { shape: x2 } });
  y2.push(v2), y2.push(w2);
  let k2 = null != a2, N2 = null != i2, C2 = "leakyrelu" === o2, $2 = o2 ? lS(o2, true) : null, R2 = new uS(f2 ? w2.shape : b2.shape, f2 ? b2.shape : w2.shape, f2 ? [n2.batchSize, A2, n2.outChannels] : [n2.batchSize, n2.outChannels, A2], true, false, k2, $2, N2, C2), S2 = f2 ? [w2, b2] : [b2, w2];
  if (a2 && S2.push(a2), N2 && S2.push(i2), C2) {
    let e21 = r2.makeTensorInfo([], "float32", va.createScalarValue(s2, "float32"));
    S2.push(e21), y2.push(e21);
  }
  let I2 = r2.runWebGLProgram(R2, S2, "float32"), E2 = fS({ inputs: { x: I2 }, backend: r2, attrs: { shape: n2.outShape } });
  y2.push(I2);
  for (let T2 of y2) r2.disposeIntermediateTensorInfo(T2);
  return E2;
}
var eE;
var tE = { kernelName: bt, backendName: "webgl", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2, filter: s2 } = n2, { strides: o2, pad: l2, dataFormat: u2, dilations: d2, dimRoundingMode: c2 } = a2, h2 = Uf.convertConv2DDataFormat(u2), p2 = Uf.computeConv2DInfo(i2.shape, s2.shape, o2, d2, l2, c2, false, h2);
  if (1 !== p2.filterHeight || 1 !== p2.filterWidth || 1 !== p2.dilationHeight || 1 !== p2.dilationWidth || 1 !== p2.strideHeight || 1 !== p2.strideWidth || "SAME" !== p2.padInfo.type && "VALID" !== p2.padInfo.type) if (2 >= p2.strideWidth && "channelsLast" === h2 && _e().getBool("WEBGL_EXP_CONV")) {
    let e21 = new ZI(p2);
    t2 = r2.runWebGLProgram(e21, [i2, s2], "float32", [[p2.padInfo.top, p2.padInfo.left], [p2.strideHeight, p2.strideWidth], [p2.dilationHeight, p2.dilationWidth], [p2.inHeight, p2.inWidth]]);
  } else if (_e().getBool("WEBGL_CONV_IM2COL")) t2 = QI({ x: i2, filter: s2, convInfo: p2, backend: r2 });
  else {
    let e21 = new XI(p2);
    t2 = r2.runWebGLProgram(e21, [i2, s2], "float32");
  }
  else t2 = JI({ x: i2, filter: s2, convInfo: p2, backend: r2 });
  let f2 = fS({ inputs: { x: t2 }, backend: r2, attrs: { shape: p2.outShape } });
  return r2.disposeIntermediateTensorInfo(t2), f2;
} };
var nE = class {
  constructor(e20) {
    this.variableNames = ["x", "dy"], this.outputShape = e20.filterShape, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e20.batchSize}; b++) {
          for (int yR = 0; yR < ${e20.outHeight}; yR++) {
            int xR = wR + yR * ${e20.strideHeight} - ${e20.padInfo.top};

            if (xR < 0 || xR >= ${e20.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e20.outWidth}; yC++) {
              int xC = wC + yC * ${e20.strideWidth} - ${e20.padInfo.left};

              if (xC < 0 || xC >= ${e20.inWidth}) {
                continue;
              }

              ${"channelsLast" === e20.dataFormat ? "float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);" : "float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var rE = class {
  constructor(e20) {
    this.variableNames = ["dy", "W"], this.outputShape = e20.inShape;
    let t2 = e20.filterHeight, n2 = e20.filterWidth, r2 = "channelsLast" === e20.dataFormat;
    this.userCode = `
      const ivec2 pads = ivec2(${t2 - 1 - e20.padInfo.top}, ${n2 - 1 - e20.padInfo.left});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${r2 ? 3 : 1}];

        ivec2 dyCorner = ivec2(coords[${r2 ? 1 : 2}], coords[${r2 ? 2 : 3}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t2}; wR++) {
          float dyR = float(dyRCorner + wR) / ${e20.strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${e20.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t2} - 1 - wR;

          for (int wC = 0; wC < ${n2}; wC++) {
            float dyC = float(dyCCorner + wC) / ${e20.strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${e20.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n2} - 1 - wC;

            for (int d2 = 0; d2 < ${e20.outChannels}; d2++) {

              if (${r2}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var aE = class {
  constructor(e20) {
    this.variableNames = ["x", "dy"], this.outputShape = e20.filterShape, this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e20.batchSize}; b++) {
          for (int yF = 0; yF < ${e20.outDepth}; yF++) {
            int xF = wF + yF * ${e20.strideDepth} - ${e20.padInfo.front};

            if (xF < 0 || xF >= ${e20.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e20.outHeight}; yR++) {
              int xR = wR + yR * ${e20.strideHeight} - ${e20.padInfo.top};

              if (xR < 0 || xR >= ${e20.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e20.outWidth}; yC++) {
                int xC = wC + yC * ${e20.strideWidth} - ${e20.padInfo.left};

                if (xC < 0 || xC >= ${e20.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var iE = class {
  constructor(e20) {
    this.variableNames = ["dy", "W"], this.outputShape = e20.inShape;
    let t2 = e20.filterDepth, n2 = e20.filterHeight, r2 = e20.filterWidth;
    this.userCode = `
      const ivec3 pads = ivec3(${t2 - 1 - e20.padInfo.front}, ${n2 - 1 - e20.padInfo.top}, ${r2 - 1 - e20.padInfo.left});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t2}; wF++) {
          float dyF = float(dyFCorner + wF) / ${e20.strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${e20.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t2} - 1 - wF;

          for (int wR = 0; wR < ${n2}; wR++) {
            float dyR = float(dyRCorner + wR) / ${e20.strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${e20.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n2} - 1 - wR;

            for (int wC = 0; wC < ${r2}; wC++) {
              float dyC = float(dyCCorner + wC) / ${e20.strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${e20.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r2} - 1 - wC;

              for (int d2 = 0; d2 < ${e20.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var sE = { kernelName: gt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, pad: o2, dataFormat: l2, dimRoundingMode: u2, filterShape: d2 } = r2, c2 = Uf.convertConv2DDataFormat(l2), h2 = Uf.computeConv2DInfo(a2.shape, d2, s2, 1, o2, u2, false, c2), p2 = new nE(h2);
  return n2.runWebGLProgram(p2, [a2, i2], "float32");
} };
var oE = class {
  constructor(e20) {
    this.variableNames = ["dy", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "strides", type: "vec2" }], this.outputShape = e20.inShape, this.enableShapeUniforms = ZC(this.outputShape.length);
    let t2 = e20.filterHeight, n2 = e20.filterWidth;
    this.userCode = `
      const ivec2 pads = ivec2(${t2 - 1 - e20.padInfo.top}, ${n2 - 1 - e20.padInfo.left});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t2}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e20.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t2} - 1 - wR;

          for (int wC = 0; wC < ${n2}; wC++) {
            int wCPerm = ${n2} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e20.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e20.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e20.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e20.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e20.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
  }
};
var lE = { kernelName: vt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = t2, { inputShape: s2, strides: o2, pad: l2, dataFormat: u2, dimRoundingMode: d2 } = r2, c2 = Uf.convertConv2DDataFormat(u2), h2 = Uf.computeConv2DInfo(s2, i2.shape, o2, 1, l2, d2, false, c2);
  if (_e().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && "channelsLast" === c2) {
    let e21 = [[h2.strideHeight, h2.strideWidth]], t3 = new oE(h2);
    return n2.runWebGLProgram(t3, [a2, i2], "float32", e21);
  }
  {
    let e21 = new rE(h2);
    return n2.runWebGLProgram(e21, [a2, i2], "float32");
  }
} };
var uE = { kernelName: wt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dilations: l2 } = r2, u2 = Uf.computeConv3DInfo(a2.shape, i2.shape, s2, l2, o2), d2 = new qI(u2);
  return n2.runWebGLProgram(d2, [a2, i2], "float32");
} };
var dE = { kernelName: kt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, pad: o2, filterShape: l2 } = r2, u2 = Uf.computeConv3DInfo(a2.shape, l2, s2, 1, o2), d2 = new aE(u2);
  return n2.runWebGLProgram(d2, [a2, i2], "float32");
} };
var cE = { kernelName: Nt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = t2, { pad: s2, strides: o2, inputShape: l2 } = r2, u2 = Uf.computeConv3DInfo(l2, i2.shape, o2, 1, s2), d2 = new iE(u2);
  return n2.runWebGLProgram(d2, [a2, i2], "float32");
} };
var hE = { kernelName: "Cos", backendName: "webgl", kernelFunc: sS({ opSnippet: iS + "\n  return cos(x);\n", packedOpSnippet: `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${XR}
  return result;
` }) };
var pE = sS({ opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n" });
var fE = { kernelName: $t, backendName: "webgl", kernelFunc: pE };
var mE = class {
  constructor(e20, t2, n2, r2, a2) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
    let [i2, s2, o2, l2] = e20, [u2] = t2, [d2, c2] = n2;
    this.outputShape = [u2, d2, c2, l2];
    let h2 = "bilinear" === r2 ? 1 : 0, [p2, f2] = [s2 - 1 + ".0", o2 - 1 + ".0"], [m2, A2, x2] = d2 > 1 ? ["" + (s2 - 1) / (d2 - 1), "(y2-y1) * height_ratio", `y1*${p2} + float(y)*(height_scale)`] : ["0.0", "0.0", "0.5 * (y1+y2) * " + p2], [y2, b2, g2] = c2 > 1 ? ["" + (o2 - 1) / (c2 - 1), "(x2-x1) * width_ratio", `x1*${f2} + float(x)*(width_scale)`] : ["0.0", "0.0", "0.5 * (x1+x2) * " + f2];
    this.userCode = `
      const float height_ratio = float(${m2});
      const float width_ratio = float(${y2});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i2}) {
          return;
        }

        float height_scale = ${A2};
        float width_scale = ${b2};

        float in_y = ${x2};
        if( in_y < 0.0 || in_y > ${p2} ) {
          setOutput(float(${a2}));
          return;
        }
        float in_x = ${g2};
        if( in_x < 0.0 || in_x > ${f2} ) {
          setOutput(float(${a2}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h2} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
  }
};
var AE = { kernelName: It, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { image: a2, boxes: i2, boxInd: s2 } = t2, { cropSize: o2, method: l2, extrapolationValue: u2 } = r2, d2 = new mE(a2.shape, i2.shape, o2, l2, u2);
  return n2.runWebGLProgram(d2, [a2, i2, s2], "float32");
} };
((e20) => {
  e20.Prod = "*", e20.Sum = "+";
})(eE || (eE = {}));
var xE = class {
  constructor(e20, t2, n2, r2) {
    this.op = e20, this.outputShape = t2, this.variableNames = ["x"], this.customUniforms = [{ name: "index", type: "float" }];
    let a2 = this.outputShape.length, i2 = n2 ? this.op === eE.Prod ? "1.0" : "0.0" : `getX(${yE(a2, "coords", this.op)})`, s2 = this.outputShape[this.outputShape.length - 1], o2 = "", l2 = "";
    n2 ? (o2 = r2 ? "end != " + (s2 - 1) : "end != 0", l2 = r2 ? "end + 1" : "end - 1") : (o2 = r2 ? "end + pow2 < " + s2 : "end >= pow2", l2 = r2 ? "end + pow2" : "end - pow2"), this.userCode = `
      void main() {
        ${UC(a2)} coords = getOutputCoords();
        int end = ${bE(a2, "coords", this.op)};
        float val = ${i2};
        int pow2 = int(pow(2.0, index));
        if (${o2}) {
          int idx = ${l2};
          ${bE(a2, "coords", this.op)} = idx;
          val ${this.op}= getX(${yE(a2, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
  }
};
function yE(e20, t2, n2) {
  if (1 === e20) return "" + t2;
  if (2 === e20) return `${t2}.x, ${t2}.y`;
  if (3 === e20) return `${t2}.x, ${t2}.y, ${t2}.z`;
  if (4 === e20) return `${t2}.x, ${t2}.y, ${t2}.z, ${t2}.w`;
  throw Error(`Cumulative ${n2} for rank ${e20} is not yet supported`);
}
function bE(e20, t2, n2) {
  if (1 === e20) return "" + t2;
  if (2 === e20) return t2 + ".y";
  if (3 === e20) return t2 + ".z";
  if (4 === e20) return t2 + ".w";
  throw Error(`Cumulative ${n2} for rank ${e20} is not yet supported`);
}
function gE(e20, t2, n2, r2, a2, i2) {
  let s2 = t2.shape.length, o2 = Uf.getAxesPermutation([r2], s2), l2 = t2;
  null != o2 && (l2 = NS({ inputs: { x: t2 }, backend: n2, attrs: { perm: o2 } }));
  let u2 = Uf.getInnerMostAxes(1, s2)[0];
  if (u2 !== s2 - 1) throw Error(`WebGL cumprod shader expects an inner-most axis=${t2.shape.length - 1} but got axis=${r2}`);
  let d2 = l2.shape[u2], c2 = ZR({ inputs: { x: l2 }, backend: n2 });
  for (let h2 = 0; h2 <= Math.ceil(Math.log2(d2)) - 1; h2++) {
    let t3 = new xE(e20, l2.shape, false, i2), r3 = c2;
    c2 = n2.runWebGLProgram(t3, [c2], c2.dtype, [[h2]]), n2.disposeIntermediateTensorInfo(r3);
  }
  if (a2) {
    let t3 = new xE(e20, l2.shape, a2, i2), r3 = c2;
    c2 = n2.runWebGLProgram(t3, [c2], c2.dtype), n2.disposeIntermediateTensorInfo(r3);
  }
  if (null != o2) {
    let e21 = NS({ inputs: { x: c2 }, backend: n2, attrs: { perm: Uf.getUndoAxesPermutation(o2) } });
    return n2.disposeIntermediateTensorInfo(c2), n2.disposeIntermediateTensorInfo(l2), e21;
  }
  return c2;
}
var vE = { kernelName: Rt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, exclusive: s2, reverse: o2 } = r2;
  return gE(eE.Prod, a2, n2, i2, s2, o2);
} };
var wE = { kernelName: St, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, exclusive: s2, reverse: o2 } = r2;
  return gE(eE.Sum, a2, n2, i2, s2, o2);
} };
var kE = { kernelName: Et, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, weights: i2 } = t2, { size: s2, binaryOutput: o2 } = r2;
  if (1 === a2.shape.length) {
    let e21 = n2.readSync(a2.dataId), t3 = n2.readSync(i2.dataId), r3 = S$(e21, t3, i2.dtype, i2.shape, s2);
    return n2.makeTensorInfo([s2], i2.dtype, r3);
  }
  if (2 === a2.shape.length) {
    let e21 = n2.bufferSync(a2), t3 = n2.bufferSync(i2), r3 = I$(e21, t3, s2, o2);
    return n2.makeTensorInfo(r3.shape, i2.dtype, r3.values);
  }
  throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${a2.shape.length}.`);
} };
var NE = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = e20, this.blockSize = t2, this.dataFormat = n2, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t2};
      int offset_h = imod(h, ${t2});
      int in_w = w / ${t2};
      int offset_w = imod(w, ${t2});
      int offset_d = (offset_h * ${t2} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
  }
  getHeightCoordString() {
    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
  }
  getWidthCoordString() {
    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
  }
  getDepthCoordString() {
    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
  }
  getOutputDepthSize() {
    return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
  }
  getInputSamplingString() {
    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }
};
var CE = { kernelName: Tt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockSize: i2, dataFormat: s2 } = r2, o2 = a2.shape[0], l2 = ("NHWC" === s2 ? a2.shape[1] : a2.shape[2]) * i2, u2 = ("NHWC" === s2 ? a2.shape[2] : a2.shape[3]) * i2, d2 = ("NHWC" === s2 ? a2.shape[3] : a2.shape[1]) / (i2 * i2), c2 = new NE("NHWC" === s2 ? [o2, l2, u2, d2] : [o2, d2, l2, u2], i2, s2);
  return n2.runWebGLProgram(c2, [a2], a2.dtype);
} };
var $E = class {
  constructor(e20, t2 = false, n2 = null, r2 = false, a2 = false) {
    this.variableNames = ["x", "W"], this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = e20.outShape, this.enableShapeUniforms = ZC(this.outputShape.length);
    let i2 = e20.filterHeight, s2 = e20.filterWidth, o2 = e20.outChannels / e20.inChannels, l2 = "", u2 = "";
    n2 && (l2 = r2 ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n2}
        }` : a2 ? `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n2}
        }` : `
          float activation(float x) {
            ${n2}
          }
        `, u2 = "result = activation(result);");
    let d2 = t2 ? "result += getBiasAtOutCoords();" : "";
    t2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), a2 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${l2}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o2};
        int q = d2 - d1 * ${o2};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i2}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${s2}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d2}
        ${u2}
        setOutput(result);
      }
    `;
  }
};
var RE = class {
  constructor(e20, t2 = false, n2 = null, r2 = false, a2 = false) {
    this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "pads", type: "ivec2" }, { name: "strides", type: "ivec2" }, { name: "dilations", type: "ivec2" }, { name: "inDims", type: "ivec2" }], this.outputShape = e20.outShape, this.enableShapeUniforms = ZC(this.outputShape.length);
    let i2 = e20.outChannels / e20.inChannels, s2 = e20.padInfo.left, o2 = e20.strideWidth, l2 = e20.dilationWidth, u2 = e20.filterHeight, d2 = e20.filterWidth, c2 = d2, h2 = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";
    for (let A2 = 0; d2 > A2; A2++) h2 += `
          vec4 xTexelC${2 * A2};
          int xTexelC${2 * A2}Ready;
          vec4 xTexelC${2 * A2 + 1};
          int xTexelC${2 * A2 + 1}Ready;
          vec4 xC${A2};`;
    h2 += `
    for (int r = 0; r < ${u2}; r++) {
      `;
    for (let A2 = 0; d2 > A2; A2++) h2 += `
          xTexelC${2 * A2} = vec4(0.0);
          xTexelC${2 * A2}Ready = 0;
          xTexelC${2 * A2 + 1} = vec4(0.0);
          xTexelC${2 * A2 + 1}Ready = 0;
          xC${A2} = vec4(0.0);`;
    h2 += "\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";
    for (let A2 = 0; (c2 + 1) / 2 > A2; A2++) {
      let e21 = 2 * A2;
      if (h2 += `
          xC = xCCorner + ${e21 * l2};
          `, 1 === o2) {
        if (d2 > e21 && (s2 % 2 == 1 ? (h2 += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e21}Ready == 0) {
                  xTexelC${e21} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${e21}.zw = vec2(0.0);
                  }
                  xTexelC${e21}Ready = 1;
                }
              `, h2 += 1 === l2 && e21 > 0 ? `
                xC${e21} = vec4(xTexelC${e21 - 2}.zw, xTexelC${e21}.xy);
                ` : `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${e21} = vec4(previous.zw, xTexelC${e21}.xy);
                  } else {
                    xC${e21} = vec4(0.0, 0.0, xTexelC${e21}.xy);
                  }
                  `) : h2 += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${e21}Ready == 0) {
                  xTexelC${e21} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${e21}.zw = vec2(0.0);
                  }
                  xTexelC${e21}Ready = 1;
                }

                xC${e21} = xTexelC${e21};
                `, d2 > e21 + 1)) {
          let t3 = s2 % 2 == 0 ? va.nearestLargerEven(l2) : l2;
          l2 % 2 == 0 && s2 % 2 == 1 || l2 % 2 != 0 && s2 % 2 != 1 ? (h2 += `
                  xCOffset = xC + imod(pads[1], 2) + ${t3};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e21 + 1}Ready == 0) {
                    xTexelC${e21 + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${e21 + 1}.zw = vec2(0.0);
                    }
                    xTexelC${e21 + 1}Ready = 1;
                  }
                  `, h2 += l2 > 1 ? `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${e21 + 1} = vec4(previous.zw, xTexelC${e21 + 1}.xy);
                    } else {
                     xC${e21 + 1} = vec4(0.0, 0.0, xTexelC${e21 + 1}.xy);
                    }
                    ` : `
                    xC${e21 + 1} = vec4(xTexelC${e21}.zw, xTexelC${e21 + 1}.xy);
                    `) : h2 += 1 === t3 ? `
                    xC${e21 + 1} = xTexelC${e21};
                    ` : `
                    xCOffset = xC + ${t3};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e21 + 1}Ready == 0) {
                      xTexelC${e21 + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${e21 + 1}.zw = vec2(0.0);
                      }
                      xTexelC${e21 + 1}Ready = 1;
                    }

                    xC${e21 + 1} = xTexelC${e21 + 1};
                    `;
        }
      } else d2 > e21 && (s2 % 2 == 1 ? (h2 += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e21}Ready == 0) {
                  xTexelC${e21} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${e21}.zw = vec2(0.0);
                  }
                  xTexelC${e21}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e21 + 1}Ready == 0) {
                  xTexelC${e21 + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${e21 + 1}.zw = vec2(0.0);
                  }
                  xTexelC${e21 + 1}Ready = 1;
                }

                xC${e21} = vec4(xTexelC${e21}.zw, xTexelC${e21 + 1}.zw);
              `, d2 > e21 + 1 && (h2 += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${e21 + 1} = vec4(xTexelC${e21 + 1}.xy, final.xy);
                `)) : (h2 += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${e21}Ready == 0) {
                  xTexelC${e21} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${e21}.zw = vec2(0.0);
                  }
                  xTexelC${e21}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e21 + 1}Ready == 0) {
                  xTexelC${e21 + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${e21 + 1}.zw = vec2(0.);
                  }
                  xTexelC${e21 + 1}Ready = 1;
                }

                xC${e21} = vec4(
                  xTexelC${e21}.xy, xTexelC${e21 + 1}.xy);
              `, d2 > e21 + 1 && (h2 += `
                  xC${e21 + 1} = vec4(xTexelC${e21}.zw, xTexelC${e21 + 1}.zw);
                `)));
      d2 > e21 && (h2 += `
            wTexel = getW(r, ${e21}, d1, q);
            dotProd += xC${e21} * vec4(wTexel.xz, wTexel.xz);
          `, d2 > e21 + 1 && (h2 += `
              wTexel = getW(r, ${e21 + 1}, d1, q);
              dotProd += xC${e21 + 1} * vec4(wTexel.xz, wTexel.xz);
            `));
    }
    h2 += "\n    }\n  ", h2 += "\n      }\n    ";
    let p2 = "", f2 = "";
    n2 && (p2 = r2 ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n2}
        }` : a2 ? `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n2}
        }` : `vec4 activation(vec4 x) {
          ${n2}
        }`, f2 = "result = activation(result);");
    let m2 = t2 ? "result += getBiasAtOutCoords();" : "";
    t2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), a2 && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${p2}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i2};
        int q = d2 - d1 * ${i2};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h2}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m2}
        ${f2}
        setOutput(result);
      }
    `;
  }
};
var SE = { kernelName: Mt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dilations: l2, dimRoundingMode: u2 } = r2, d2 = l2;
  null == d2 && (d2 = [1, 1]), va.assert(Uf.eitherStridesOrDilationsAreOne(s2, d2), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${s2} and dilations '${d2}'`);
  let c2, h2 = Uf.computeConv2DInfo(a2.shape, i2.shape, s2, d2, o2, u2, true);
  return c2 = _e().getBool("WEBGL_PACK_DEPTHWISECONV") && 2 >= h2.strideWidth && h2.outChannels / h2.inChannels === 1 ? new RE(h2) : new $E(h2), n2.runWebGLProgram(c2, [a2, i2], "float32", [[h2.padInfo.top, h2.padInfo.left], [h2.strideHeight, h2.strideWidth], [h2.dilationHeight, h2.dilationWidth], [h2.inHeight, h2.inWidth]]);
} };
var IE = class {
  constructor(e20) {
    this.variableNames = ["x", "dy"], this.outputShape = e20.filterShape, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${e20.outChannels / e20.inChannels} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e20.batchSize}; b++) {
          for (int yR = 0; yR < ${e20.outHeight}; yR++) {
            int xR = wR + yR * ${e20.strideHeight} - ${e20.padInfo.top};

            if (xR < 0 || xR >= ${e20.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e20.outWidth}; yC++) {
              int xC = wC + yC * ${e20.strideWidth} - ${e20.padInfo.left};

              if (xC < 0 || xC >= ${e20.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var EE = class {
  constructor(e20) {
    this.variableNames = ["dy", "W"], this.outputShape = e20.inShape;
    let t2 = e20.filterHeight, n2 = e20.filterWidth, r2 = e20.outChannels / e20.inChannels;
    this.userCode = `
      const ivec2 pads = ivec2(${t2 - 1 - e20.padInfo.top}, ${n2 - 1 - e20.padInfo.left});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t2}; wR++) {
          float dyR = float(dyRCorner + wR) / ${e20.strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${e20.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t2} - 1 - wR;

          for (int wC = 0; wC < ${n2}; wC++) {
            float dyC = float(dyCCorner + wC) / ${e20.strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${e20.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n2} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${r2}; dm++) {
              int d2 = d1 * ${r2} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var TE = { kernelName: Ot, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, dilations: o2, pad: l2, dimRoundingMode: u2, filterShape: d2 } = r2, c2 = Uf.computeConv2DInfo(a2.shape, d2, s2, o2, l2, u2, true), h2 = new IE(c2);
  return n2.runWebGLProgram(h2, [a2, i2], "float32");
} };
var ME = { kernelName: Ft, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = t2, { strides: s2, dilations: o2, pad: l2, dimRoundingMode: u2, inputShape: d2 } = r2, c2 = Uf.computeConv2DInfo(d2, i2.shape, s2, o2, l2, u2, true), h2 = new EE(c2);
  return n2.runWebGLProgram(h2, [a2, i2], "float32");
} };
var OE = class {
  constructor(e20) {
    this.variableNames = ["X"], this.outputShape = [e20, e20], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
  }
};
var FE = { kernelName: Pt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2, a2 = [...r2.shape, ...r2.shape], i2 = va.sizeFromShape(r2.shape), s2 = fS({ inputs: { x: r2 }, backend: n2, attrs: { shape: [i2] } }), o2 = new OE(i2), l2 = n2.runWebGLProgram(o2, [s2], s2.dtype), u2 = fS({ inputs: { x: l2 }, backend: n2, attrs: { shape: a2 } });
  return n2.disposeIntermediateTensorInfo(s2), n2.disposeIntermediateTensorInfo(l2), u2;
} };
var PE = class {
  constructor(e20) {
    this.variableNames = ["x", "W"], this.outputShape = e20.outShape;
    let { inHeight: t2, inWidth: n2, padInfo: r2, strideHeight: a2, strideWidth: i2, filterHeight: s2, filterWidth: o2, dilationHeight: l2, dilationWidth: u2 } = e20, { top: d2, left: c2 } = r2;
    this.userCode = `
      const ivec2 strides = ivec2(${a2}, ${i2});
      const ivec2 pads = ivec2(${d2}, ${c2});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${s2}; h++) {
          int hIn = hBeg + h * ${l2};

          if (hIn >= 0 && hIn < ${t2}) {
            for (int w = 0; w < ${o2}; w++) {
              int wIn = wBeg + w * ${u2};

              if (wIn >= 0 && wIn < ${n2}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
  }
};
var zE = { kernelName: zt, backendName: "webgl", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2, filter: s2 } = n2, { strides: o2, pad: l2, dilations: u2 } = a2, d2 = Uf.computeDilation2DInfo(i2.shape, s2.shape, o2, l2, "NHWC", u2), c2 = new PE(d2);
  t2 = r2.runWebGLProgram(c2, [i2, s2], "float32");
  let h2 = fS({ inputs: { x: t2 }, backend: r2, attrs: { shape: d2.outShape } });
  return r2.disposeIntermediateTensorInfo(t2), h2;
} };
var VE = { kernelName: Lt, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { equation: a2 } = r2, i2 = t2, { allDims: s2, summedDims: o2, idDims: l2 } = Uf.decodeEinsumEquation(a2, i2.length);
  Uf.checkEinsumDimSizes(s2.length, l2, i2);
  let { path: u2, steps: d2 } = Uf.getEinsumComputePath(o2, l2), c2 = d2.length, h2 = null, p2 = s2.length, f2 = [];
  for (let m2 = 0; c2 > m2; ++m2) {
    for (let e21 of d2[m2]) {
      let t3, { permutationIndices: r3, expandDims: a3 } = Uf.getEinsumPermutation(p2, l2[e21]);
      Uf.isIdentityPermutation(r3) ? t3 = i2[e21] : (t3 = NS({ inputs: { x: i2[e21] }, backend: n2, attrs: { perm: r3 } }), f2.push(t3));
      let s3 = t3.shape.slice();
      for (let e22 = 0; a3.length > e22; ++e22) s3.splice(a3[e22], 0, 1);
      va.arraysEqual(t3.shape, s3) || (t3 = fS({ inputs: { x: t3 }, backend: n2, attrs: { shape: s3 } }), f2.push(t3)), null === h2 ? h2 = t3 : (h2 = hS({ inputs: { a: t3, b: h2 }, backend: n2 }), f2.push(h2));
    }
    c2 - 1 > m2 && (u2[m2] >= 0 && (h2 = wS({ inputs: { x: h2 }, backend: n2, attrs: { axis: u2[m2] - (s2.length - p2), keepDims: false } }), f2.push(h2)), p2--);
  }
  for (let m2 of f2) m2 !== h2 && n2.disposeIntermediateTensorInfo(m2);
  return h2;
} };
var _E = { kernelName: "Elu", backendName: "webgl", kernelFunc: sS({ opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);", packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n" }) };
var DE = { kernelName: Ut, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { dy: r2, y: a2 } = t2, i2 = _e().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new qR("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", r2.shape, a2.shape) : new HR("return (b >= 0.0) ? a : a * (b + 1.0);", r2.shape, a2.shape);
  return n2.runWebGLProgram(i2, [r2, a2], r2.dtype);
} };
var WE = oS({ opSnippet: "return float(a == b);", packedOpSnippet: "\n  return vec4(equal(a, b));\n", dtype: "bool", cpuKernelImpl: F$ });
var LE = { kernelName: Gt, backendName: "webgl", kernelFunc: WE };
var BE = { kernelName: "Erf", backendName: "webgl", kernelFunc: sS({ opSnippet: `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Uf.ERF_P};
  float a1 = ${Uf.ERF_A1};
  float a2 = ${Uf.ERF_A2};
  float a3 = ${Uf.ERF_A3};
  float a4 = ${Uf.ERF_A4};
  float a5 = ${Uf.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
` }) };
var UE = sS({ opSnippet: iS + "\n  return exp(x);\n", packedOpSnippet: "\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", cpuKernelImpl: P$, dtype: "float32" });
var jE = { kernelName: "Exp", backendName: "webgl", kernelFunc: UE };
function GE(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { dim: a2 } = n2, { input: i2 } = t2, s2 = i2.shape.length, o2 = i2.shape.slice(), l2 = a2;
  return 0 > a2 && (va.assert(a2 >= -(s2 + 1), () => `Axis must be in the interval [${-(s2 + 1)}, ${s2}]`), l2 = s2 + a2 + 1), o2.splice(l2, 0, 1), fS({ inputs: { x: i2 }, backend: r2, attrs: { shape: o2 } });
}
var HE = { kernelName: Xt, backendName: "webgl", kernelFunc: GE };
var XE = "return exp(x) - 1.0;";
var qE = sS({ opSnippet: XE, packedOpSnippet: XE, cpuKernelImpl: z$ });
var ZE = { kernelName: qt, backendName: "webgl", kernelFunc: qE };
var KE = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["real", "imag"];
    let r2 = t2[1];
    this.outputShape = t2;
    let a2, i2 = n2 ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI, s2 = n2 ? r2 + ".0" : "1.0";
    if ("real" === e20) a2 = "return real * expR - imag * expI;";
    else {
      if ("imag" !== e20) throw Error(`FFT component must be either "real" or "imag", got ${e20}.`);
      a2 = "return real * expI + imag * expR;";
    }
    this.userCode = `
      const float exponentMultiplier = ${i2};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a2}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r2});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r2}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s2};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
  }
};
function YE(e20, t2, n2) {
  let r2 = n2.texData.get(e20.dataId), a2 = va.sizeFromShape(e20.shape), i2 = e20.shape[e20.shape.length - 1], s2 = fS({ inputs: { x: e20 }, backend: n2, attrs: { shape: [a2 / i2, i2] } }), o2 = s2.shape, l2 = new KE("real", o2, t2), u2 = new KE("imag", o2, t2), d2 = [{ dataId: r2.complexTensorInfos.real.dataId, dtype: r2.complexTensorInfos.real.dtype, shape: o2 }, { dataId: r2.complexTensorInfos.imag.dataId, dtype: r2.complexTensorInfos.imag.dtype, shape: o2 }], c2 = n2.runWebGLProgram(l2, d2, "float32"), h2 = n2.runWebGLProgram(u2, d2, "float32"), p2 = YR({ inputs: { real: c2, imag: h2 }, backend: n2 });
  n2.disposeIntermediateTensorInfo(c2), n2.disposeIntermediateTensorInfo(h2);
  let f2 = fS({ inputs: { x: p2 }, backend: n2, attrs: { shape: e20.shape } });
  return n2.disposeIntermediateTensorInfo(s2), n2.disposeIntermediateTensorInfo(p2), f2;
}
var JE = { kernelName: "FFT", backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2;
  return YE(r2, false, n2);
} };
var QE = class {
  constructor(e20, t2) {
    this.outputShape = [], this.customUniforms = [{ name: "value", type: "float" }], this.variableNames = ["x"], this.outputShape = e20, this.userCode = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  }
};
function eT(e20) {
  let { backend: t2, attrs: n2 } = e20, { shape: r2, value: a2 } = n2, { dtype: i2 } = n2;
  if (i2 = i2 || va.inferDtype(a2), "string" === i2) {
    let e21 = va.getArrayFromDType(i2, va.sizeFromShape(r2));
    return e21.fill(a2), t2.makeTensorInfo(r2, i2, e21);
  }
  {
    let e21 = new QE(r2, a2);
    return t2.runWebGLProgram(e21, [], i2, [[a2]]);
  }
}
var tT;
var nT = { kernelName: Kt, backendName: "webgl", kernelFunc: eT };
var rT = class {
  constructor(e20) {
    this.variableNames = ["Image"], this.outputShape = [];
    let t2 = e20[2];
    this.outputShape = e20, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t2} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t2}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
};
var aT = { kernelName: Yt, backendName: "webgl", kernelFunc({ inputs: e20, backend: t2 }) {
  let { image: n2 } = e20, r2 = t2, a2 = new rT(n2.shape);
  return r2.runWebGLProgram(a2, [n2], n2.dtype);
} };
var iT = "return floor(x);";
var sT = sS({ opSnippet: iT, packedOpSnippet: iT, cpuKernelImpl: V$ });
var oT = { kernelName: Jt, backendName: "webgl", kernelFunc: sT };
var lT = oS({ opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", dtype: "int32" });
var uT = { kernelName: Qt, backendName: "webgl", kernelFunc: lT };
var dT = class {
  constructor(e20) {
    this.variableNames = ["A"];
    let t2 = SC(), [n2, r2] = e20;
    this.outputShape = e20, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r2}.0, ${n2}.0);

        vec4 values = ${t2.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
  }
};
var cT = class {
  constructor(e20) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
    let t2 = SC(), [n2, r2] = e20;
    this.outputShape = e20, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r2}.0, ${n2}.0);
            vec4 values = ${t2.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t2.output} = result;
      }
    `;
  }
};
var hT = { kernelName: ra, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { pixels: a2 } = t2, { numChannels: i2 } = r2, s2 = "undefined" != typeof HTMLVideoElement && a2 instanceof HTMLVideoElement, o2 = "undefined" != typeof HTMLImageElement && a2 instanceof HTMLImageElement, [l2, u2] = s2 ? [a2.videoWidth, a2.videoHeight] : [a2.width, a2.height], d2 = [u2, l2], c2 = [u2, l2, i2];
  if (o2 || s2) {
    let e21 = _e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
    (null == tT || e21 !== pT) && (pT = e21, tT = document.createElement("canvas").getContext("2d", { willReadFrequently: pT })), tT.canvas.width = l2, tT.canvas.height = u2, tT.drawImage(a2, 0, 0, l2, u2), a2 = tT.canvas;
  }
  let h2 = n2.makeTensorInfo(d2, "int32");
  n2.texData.get(h2.dataId).usage = bN.PIXELS, n2.gpgpu.uploadPixelDataToTexture(n2.getTexture(h2.dataId), a2);
  let p2 = _e().getBool("WEBGL_PACK") ? new cT(c2) : new dT(c2), f2 = n2.runWebGLProgram(p2, [h2], "int32");
  return n2.disposeData(h2.dataId), f2;
} };
var pT = _e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
var fT = { kernelName: sa, backendName: "webgl", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2, filter: s2, bias: o2, preluActivationWeights: l2 } = n2, { strides: u2, pad: d2, dataFormat: c2, dilations: h2, dimRoundingMode: p2, activation: f2, leakyreluAlpha: m2 } = a2, A2 = Uf.convertConv2DDataFormat(c2), x2 = Uf.computeConv2DInfo(i2.shape, s2.shape, u2, h2, d2, p2, false, A2), y2 = [], b2 = null != o2, g2 = null != l2, v2 = "leakyrelu" === f2, w2 = () => {
    let e21 = [i2, s2], t3 = (e22, t4) => {
      if ("NCHW" === t4 && 1 === e22.shape.length && 1 !== e22.shape[0]) {
        let t5 = fS({ inputs: { x: e22 }, backend: r2, attrs: { shape: [e22.shape[0], 1, 1] } });
        return y2.push(t5), t5;
      }
      return e22;
    };
    if (b2 && e21.push(t3(o2, c2)), g2 && e21.push(t3(l2, c2)), v2) {
      let t4 = r2.makeTensorInfo([], "float32", va.createScalarValue(m2, "float32"));
      e21.push(t4), y2.push(t4);
    }
    return e21;
  };
  if (1 !== x2.filterHeight || 1 !== x2.filterWidth || 1 !== x2.dilationHeight || 1 !== x2.dilationWidth || 1 !== x2.strideHeight || 1 !== x2.strideWidth || "SAME" !== x2.padInfo.type && "VALID" !== x2.padInfo.type) if (2 >= x2.strideWidth && "channelsLast" === A2 && _e().getBool("WEBGL_EXP_CONV")) {
    let e21 = f2 ? lS(f2, true) : null, n3 = new ZI(x2, b2, e21, g2, v2), a3 = [[x2.padInfo.top, x2.padInfo.left], [x2.strideHeight, x2.strideWidth], [x2.dilationHeight, x2.dilationWidth], [x2.inHeight, x2.inWidth]], i3 = w2();
    t2 = r2.runWebGLProgram(n3, i3, "float32", a3);
  } else if (_e().getBool("WEBGL_CONV_IM2COL")) t2 = QI({ x: i2, filter: s2, convInfo: x2, backend: r2, bias: o2, activation: f2, preluActivationWeights: l2, leakyreluAlpha: m2 });
  else {
    let e21 = f2 ? lS(f2, false) : null, n3 = new XI(x2, b2, e21, g2, v2), a3 = w2();
    t2 = r2.runWebGLProgram(n3, a3, "float32");
  }
  else t2 = JI({ x: i2, filter: s2, convInfo: x2, backend: r2, bias: o2, activation: f2, preluActivationWeights: l2, leakyreluAlpha: m2 });
  let k2 = fS({ inputs: { x: t2 }, backend: r2, attrs: { shape: x2.outShape } });
  return y2.push(t2), y2.forEach((e21) => r2.disposeIntermediateTensorInfo(e21)), k2;
} };
var mT = { kernelName: oa, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2, bias: s2, preluActivationWeights: o2 } = t2, { strides: l2, pad: u2, dilations: d2, dimRoundingMode: c2, activation: h2, leakyreluAlpha: p2 } = r2, f2 = [], m2 = d2;
  null == m2 && (m2 = [1, 1]), va.assert(Uf.eitherStridesOrDilationsAreOne(l2, m2), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l2} and dilations '${m2}'`);
  let A2, x2 = Uf.computeConv2DInfo(a2.shape, i2.shape, l2, m2, u2, c2, true), y2 = _e().getBool("WEBGL_PACK_DEPTHWISECONV") && 2 >= x2.strideWidth && x2.outChannels / x2.inChannels === 1, b2 = h2 ? lS(h2, y2) : null, g2 = [a2, i2], v2 = null != s2, w2 = null != o2, k2 = "leakyrelu" === h2;
  if (v2 && g2.push(s2), w2 && g2.push(o2), k2) {
    let e21 = n2.makeTensorInfo([], "float32", va.createScalarValue(p2, "float32"));
    g2.push(e21), f2.push(e21);
  }
  A2 = y2 ? new RE(x2, v2, b2, w2, k2) : new $E(x2, v2, b2, w2, k2);
  let N2 = n2.runWebGLProgram(A2, g2, "float32", [[x2.padInfo.top, x2.padInfo.left], [x2.strideHeight, x2.strideWidth], [x2.dilationHeight, x2.dilationWidth], [x2.inHeight, x2.inWidth]]);
  return f2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), N2;
} };
var AT = class {
  constructor(e20, t2, n2, r2) {
    this.sliceDim = e20, this.strides = t2, this.paramsShape = r2, this.variableNames = ["x", "indices"], this.outputShape = n2;
    let a2 = UC(n2.length), i2 = "\n    int index;";
    for (let s2 = 0; this.sliceDim > s2; s2++) i2 += `
          index = round(getIndices(coords[0], ${s2}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[s2]};
          flattenIndex += index * ${this.strides[s2]};`;
    this.userCode = `
         void main() {
          ${a2} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i2}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
  }
};
var xT = { kernelName: nn, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { params: r2, indices: a2 } = t2, i2 = a2.shape, s2 = i2[i2.length - 1], o2 = va.sizeFromShape(r2.shape), [l2, u2, d2, c2] = Uf.prepareAndValidate(r2, a2), h2 = fS({ inputs: { x: a2 }, backend: n2, attrs: { shape: [u2, s2] } }), p2 = fS({ inputs: { x: r2 }, backend: n2, attrs: { shape: [va.sizeFromShape(r2.shape) / d2, d2] } });
  if (n2.shouldExecuteOnCPU([r2, a2]) || "string" === r2.dtype) {
    let e21 = n2.readSync(a2.dataId), t3 = n2.bufferSync(r2), i3 = _$(e21, t3, r2.dtype, u2, s2, d2, c2, r2.shape, o2);
    return n2.makeTensorInfo(l2, r2.dtype, i3.values);
  }
  let f2 = new AT(s2, c2, [u2, d2], r2.shape), m2 = n2.runWebGLProgram(f2, [p2, h2], p2.dtype), A2 = fS({ inputs: { x: m2 }, backend: n2, attrs: { shape: l2 } });
  return n2.disposeIntermediateTensorInfo(h2), n2.disposeIntermediateTensorInfo(p2), n2.disposeIntermediateTensorInfo(m2), A2;
} };
var yT = class {
  constructor(e20, t2) {
    this.variableNames = ["A", "indices"], this.outputShape = t2, this.rank = t2.length;
    let n2 = UC(this.rank), r2 = ((e21) => {
      let t3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], n3 = [];
      for (let r3 = 0; e21.length > r3; r3++) n3.push(2 === r3 ? "index" : "" + t3[r3]);
      return n3.join();
    })(e20);
    this.userCode = `
      void main() {
        ${n2} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e20[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r2}));
      }
    `;
  }
};
function bT(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, indices: i2 } = t2, { axis: s2, batchDims: o2 } = r2, l2 = va.parseAxisParam(s2, a2.shape)[0];
  if (_e().get("DEBUG")) {
    let e21 = n2.readSync(i2.dataId), t3 = a2.shape[l2];
    for (let n3 = 0; e21.length > n3; ++n3) {
      let r3 = e21[n3];
      va.assert(t3 - 1 >= r3 && r3 >= 0, () => `GatherV2: the index value ${r3} is not in [0, ${t3 - 1}]`);
    }
  }
  let u2 = Uf.segment_util.collectGatherOpShapeInfo(a2, i2, l2, o2), d2 = va.sizeFromShape(i2.shape), c2 = [], h2 = fS({ inputs: { x: a2 }, backend: n2, attrs: { shape: [u2.batchSize, u2.outerSize, u2.dimSize, u2.sliceSize] } }), p2 = fS({ inputs: { x: i2 }, backend: n2, attrs: { shape: [u2.batchSize, d2 / u2.batchSize] } });
  c2.push(h2), c2.push(p2);
  let f2 = [u2.batchSize, u2.outerSize, d2 / u2.batchSize, u2.sliceSize];
  if (n2.shouldExecuteOnCPU([a2, i2]) || "string" === a2.dtype) {
    let e21 = n2.bufferSync(p2), t3 = n2.bufferSync(h2), r3 = D$(t3, e21, f2);
    return c2.forEach((e22) => n2.disposeIntermediateTensorInfo(e22)), n2.makeTensorInfo(u2.outputShape, r3.dtype, r3.values);
  }
  let m2 = new yT(h2.shape, f2), A2 = n2.runWebGLProgram(m2, [h2, p2], h2.dtype);
  c2.push(A2);
  let x2 = fS({ inputs: { x: A2 }, backend: n2, attrs: { shape: u2.outputShape } });
  return c2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), x2;
}
var gT = { kernelName: tn, backendName: "webgl", kernelFunc: bT };
var vT = oS({ opSnippet: "return float(a > b);", packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n", cpuKernelImpl: W$, dtype: "bool" });
var wT = { kernelName: rn, backendName: "webgl", kernelFunc: vT };
var kT = oS({ opSnippet: "return float(a >= b);", packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n", dtype: "bool", cpuKernelImpl: L$ });
var NT = { kernelName: an, backendName: "webgl", kernelFunc: kT };
var CT = { kernelName: on, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2;
  return YE(r2, true, n2);
} };
var $T = sS({ opSnippet: "return float(!isnan(x) && !isinf(x));", dtype: "bool" });
var RT = { kernelName: un, backendName: "webgl", kernelFunc: $T };
var ST = sS({ opSnippet: "return float(isinf(x));", dtype: "bool" });
var IT = { kernelName: dn, backendName: "webgl", kernelFunc: ST };
var ET = sS({ opSnippet: "return float(isnan(x));", dtype: "bool" });
var TT = { kernelName: cn, backendName: "webgl", kernelFunc: ET };
var MT = oS({ opSnippet: "return float(a < b);", packedOpSnippet: "\n  return vec4(lessThan(a, b));\n", cpuKernelImpl: B$, dtype: "bool" });
var OT = { kernelName: pn, backendName: "webgl", kernelFunc: MT };
var FT = oS({ opSnippet: "return float(a <= b);", packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n", cpuKernelImpl: U$, dtype: "bool" });
var PT = { kernelName: fn, backendName: "webgl", kernelFunc: FT };
var zT = { kernelName: mn, backendName: "webgl", kernelFunc(e20) {
  let { backend: t2, attrs: n2 } = e20, { start: r2, stop: a2, num: i2 } = n2, s2 = j$(r2, a2, i2);
  return t2.makeTensorInfo([s2.length], "float32", s2);
} };
var VT = { kernelName: "Log", backendName: "webgl", kernelFunc: sS({ opSnippet: iS + "\n  return x < 0.0 ? 0./0. : log(x);\n", packedOpSnippet: "\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n", cpuKernelImpl: G$ }) };
var _T = sS({ opSnippet: iS + "\n  return log(1.0 + x);\n" });
var DT = { kernelName: xn, backendName: "webgl", kernelFunc: _T };
var WT = oS({ opSnippet: "return float(a >= 1.0 && b >= 1.0);", packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", dtype: "bool" });
var LT = { kernelName: yn, backendName: "webgl", kernelFunc: WT };
var BT = sS({ opSnippet: "return float(!(x >= 1.0));" });
var UT = { kernelName: bn, backendName: "webgl", kernelFunc: BT };
var jT = oS({ opSnippet: "return float(a >= 1.0 || b >= 1.0);", packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", dtype: "bool" });
var GT = { kernelName: gn, backendName: "webgl", kernelFunc: jT };
var HT = class {
  constructor(e20, t2, n2, r2, a2) {
    this.variableNames = ["x"], this.outputShape = [];
    let i2 = t2, s2 = e20[3] - 1;
    this.outputShape = e20;
    let o2, l2 = `float(${n2}) + float(${r2}) * sum`;
    o2 = 0.5 === a2 ? `inversesqrt(${l2})` : 1 === a2 ? `1.0/(${l2})` : `exp(log(${l2}) * float(-${a2}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i2}; j <= ${i2}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${s2}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o2};
        setOutput(val);
      }
    `;
  }
};
var XT = class {
  constructor(e20, t2, n2, r2, a2) {
    this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
    let i2 = t2, s2 = e20[3] - 1;
    this.outputShape = e20;
    let o2, l2 = `float(${n2}) + float(${r2}) * sum`;
    o2 = 0.5 === a2 ? `inversesqrt(${l2})` : 1 === a2 ? `1.0/(${l2})` : `exp(log(${l2}) * float(-${a2}));`, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i2};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i2}; j <= ${i2}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${s2}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o2};
        setOutput(result);
      }
    `;
  }
};
var qT = { kernelName: "LRN", backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { depthRadius: i2, bias: s2, alpha: o2, beta: l2 } = r2, u2 = _e().getBool("WEBGL_PACK_NORMALIZATION") ? new XT(a2.shape, i2, s2, o2, l2) : new HT(a2.shape, i2, s2, o2, l2);
  return n2.runWebGLProgram(u2, [a2], a2.dtype);
} };
var ZT = class {
  constructor(e20, t2, n2, r2, a2) {
    this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e20, this.depth = e20[3], this.depthRadius = t2, this.bias = n2, this.alpha = r2, this.beta = a2, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t2})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t2} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r2}) * norm + float(${n2});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r2})
                * float(${a2})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a2});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
  }
};
var KT = { kernelName: Cn, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, y: i2, dy: s2 } = t2, { depthRadius: o2, bias: l2, alpha: u2, beta: d2 } = r2, c2 = new ZT(a2.shape, o2, l2, u2, d2);
  return n2.runWebGLProgram(c2, [a2, i2, s2], a2.dtype);
} };
function YT(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { reductionIndices: i2, keepDims: s2 } = r2, o2 = a2.shape.length, l2 = va.parseAxisParam(i2, a2.shape), u2 = l2, d2 = Uf.getAxesPermutation(u2, o2), c2 = null != d2, h2 = n2.shouldExecuteOnCPU([a2]), p2 = a2;
  if (c2) {
    if (h2) {
      let e21 = n2.texData.get(p2.dataId).values, t3 = Array(o2);
      for (let n3 = 0; t3.length > n3; n3++) t3[n3] = a2.shape[d2[n3]];
      let r3 = gR(e21, a2.shape, a2.dtype, d2, t3);
      p2 = n2.makeTensorInfo(t3, a2.dtype), n2.texData.get(p2.dataId).values = r3;
    } else p2 = vS(a2, d2, n2);
    u2 = Uf.getInnerMostAxes(u2.length, o2);
  }
  Uf.assertAxesAreInnerMostDims("max", u2, o2);
  let f2, [m2, A2] = Uf.computeOutAndReduceShapes(p2.shape, u2), x2 = m2;
  if (s2 && (x2 = Uf.expandShapeToKeepDim(m2, l2)), h2) {
    let e21 = n2.texData.get(p2.dataId).values, t3 = H$(e21, va.sizeFromShape(A2), x2, a2.dtype);
    f2 = n2.makeTensorInfo(x2, a2.dtype), n2.texData.get(f2.dataId).values = t3;
  } else f2 = ((e21, t3, n3, r3) => {
    let a3 = va.sizeFromShape(t3), i3 = fS({ inputs: { x: e21 }, attrs: { shape: [va.sizeFromShape(e21.shape) / a3, a3] }, backend: r3 }), s3 = yS(i3, e21.dtype, "max", r3), o3 = fS({ inputs: { x: s3 }, attrs: { shape: n3 }, backend: r3 });
    return r3.disposeIntermediateTensorInfo(i3), r3.disposeIntermediateTensorInfo(s3), o3;
  })(p2, A2, x2, n2);
  return c2 && n2.disposeIntermediateTensorInfo(p2), f2;
}
var JT = { kernelName: "Max", backendName: "webgl", kernelFunc: YT };
var QT = oS({ opSnippet: GR + "\n  return max(a, b);\n", packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  " + XR + "\n  return result;\n", cpuKernelImpl: X$ });
var eM = { kernelName: Sn, backendName: "webgl", kernelFunc: QT };
var tM = { kernelName: In, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2;
  $C(a2, "maxPool");
  let { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2 } = r2;
  va.assert(Uf.eitherStridesOrDilationsAreOne(s2, 1), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s2} and dilations '1'`);
  let u2 = Uf.computePool2DInfo(a2.shape, i2, s2, 1, o2, l2);
  if (1 === u2.filterWidth && 1 === u2.filterHeight && va.arraysEqual(u2.inShape, u2.outShape)) return ZR({ inputs: { x: a2 }, backend: n2 });
  let d2 = new aI(u2, "max", false);
  return n2.runWebGLProgram(d2, [a2], a2.dtype);
} };
var nM = { kernelName: Tn, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dataFormat: l2, dimRoundingMode: u2 } = r2, d2 = Uf.computePool3DInfo(a2.shape, i2, s2, [1, 1, 1], o2, u2, l2), c2 = new iI(d2, "max", false);
  return n2.runWebGLProgram(c2, [a2], a2.dtype);
} };
var rM = class {
  constructor(e20) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e20.inShape;
    let t2 = e20.effectiveFilterHeight, n2 = e20.effectiveFilterWidth;
    this.userCode = `
      const ivec2 pads = ivec2(${t2 - 1 - e20.padInfo.top}, ${n2 - 1 - e20.padInfo.left});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t2};
          wR += ${e20.dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${e20.strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${e20.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${n2}; wC++) {
            float dyC = float(dyCCorner + wC) / ${e20.strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${e20.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${t2 * n2 - 1} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${n2} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var aM = class {
  constructor(e20) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = e20.inShape;
    let t2 = e20.effectiveFilterDepth, n2 = e20.effectiveFilterHeight, r2 = e20.effectiveFilterWidth;
    this.userCode = `
      const ivec3 pads = ivec3(${t2 - 1 - e20.padInfo.front}, ${n2 - 1 - e20.padInfo.top}, ${r2 - 1 - e20.padInfo.left});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${t2};
           wD += ${e20.dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${e20.strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${e20.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${n2};
              wR += ${e20.dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${e20.strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${e20.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${r2};
                wC += ${e20.dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${e20.strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${e20.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${t2 * n2 * r2 - 1} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${n2} * ${r2} +
                  wR * ${r2} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
};
var iM = { kernelName: Mn, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, s2 = i2, { filterSize: o2, strides: l2, pad: u2, dimRoundingMode: d2 } = r2, c2 = Uf.computePool3DInfo(s2.shape, o2, l2, [1, 1, 1], u2, d2), h2 = new iI(c2, "max", true), p2 = n2.runWebGLProgram(h2, [s2], s2.dtype), f2 = new aM(c2), m2 = n2.runWebGLProgram(f2, [a2, p2], s2.dtype);
  return n2.disposeIntermediateTensorInfo(p2), m2;
} };
var sM = { kernelName: En, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2, output: s2 } = t2, o2 = i2;
  $C([i2, s2], "maxPoolGrad");
  let { filterSize: l2, strides: u2, pad: d2, dimRoundingMode: c2 } = r2, h2 = Uf.computePool2DInfo(o2.shape, l2, u2, 1, d2, c2), p2 = new aI(h2, "max", true), f2 = n2.runWebGLProgram(p2, [o2], o2.dtype), m2 = new rM(h2), A2 = n2.runWebGLProgram(m2, [a2, f2], o2.dtype);
  return n2.disposeIntermediateTensorInfo(f2), A2;
} };
var oM = { kernelName: On, backendName: "webgl", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { x: r2 } = e20, { filterSize: a2, strides: i2, pad: s2, includeBatchInIndex: o2 } = t2, l2 = n2;
  va.assert(4 === r2.shape.length, () => `Error in maxPool: input must be rank 4 but got rank ${r2.shape.length}.`);
  let u2 = [1, 1];
  va.assert(Uf.eitherStridesOrDilationsAreOne(i2, u2), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i2} and dilations '${u2}'`);
  let d2 = Uf.computePool2DInfo(r2.shape, a2, i2, u2, s2), [c2, h2] = ((e21, t3, n3, r3) => {
    let a3 = new aI(n3, "max", false), i3 = r3.runWebGLProgram(a3, [e21], "float32");
    return a3 = new aI(n3, "max", true, true, t3), [i3, r3.runWebGLProgram(a3, [e21], "float32")];
  })(r2, o2, d2, l2);
  return [c2, h2];
} };
var lM = { kernelName: Fn, backendName: "webgl", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { x: r2 } = e20, { keepDims: a2, axis: i2 } = t2, s2 = n2, o2 = r2.shape.length, l2 = va.parseAxisParam(i2, r2.shape), u2 = l2, d2 = Uf.getAxesPermutation(u2, o2), c2 = null != d2, h2 = s2.shouldExecuteOnCPU([r2]), p2 = [], f2 = r2;
  if (c2) {
    if (h2) {
      let e21 = s2.texData.get(f2.dataId).values, t3 = Array(o2);
      for (let a3 = 0; t3.length > a3; a3++) t3[a3] = r2.shape[d2[a3]];
      let n3 = gR(e21, r2.shape, r2.dtype, d2, t3);
      f2 = s2.makeTensorInfo(t3, r2.dtype), s2.texData.get(f2.dataId).values = n3;
    } else f2 = vS(r2, d2, s2);
    p2.push(f2), u2 = Uf.getInnerMostAxes(u2.length, o2);
  }
  Uf.assertAxesAreInnerMostDims("sum", u2, o2);
  let [m2, A2] = Uf.computeOutAndReduceShapes(f2.shape, u2), x2 = m2;
  a2 && (x2 = Uf.expandShapeToKeepDim(m2, l2));
  let y2 = ((e21, t3, n3, r3) => {
    let a3 = va.sizeFromShape(t3), i3 = fS({ inputs: { x: e21 }, attrs: { shape: [va.sizeFromShape(e21.shape) / a3, a3] }, backend: r3 }), s3 = yS(i3, "float32", "mean", r3), o3 = fS({ inputs: { x: s3 }, attrs: { shape: n3 }, backend: r3 });
    return r3.disposeIntermediateTensorInfo(i3), r3.disposeIntermediateTensorInfo(s3), o3;
  })(f2, A2, x2, s2);
  for (let b2 of p2) s2.disposeIntermediateTensorInfo(b2);
  return y2;
} };
var uM = { kernelName: "Min", backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2, o2 = a2.shape.length, l2 = va.parseAxisParam(i2, a2.shape), u2 = l2, d2 = Uf.getAxesPermutation(u2, o2), c2 = a2;
  null != d2 && (c2 = NS({ inputs: { x: a2 }, backend: n2, attrs: { perm: d2 } }), u2 = Uf.getInnerMostAxes(u2.length, a2.shape.length)), Uf.assertAxesAreInnerMostDims("min", u2, o2);
  let h2, [p2, f2] = Uf.computeOutAndReduceShapes(c2.shape, u2), m2 = fS({ inputs: { x: c2 }, backend: n2, attrs: { shape: [-1, va.sizeFromShape(f2)] } }), A2 = yS(m2, m2.dtype, "min", n2);
  return h2 = fS(s2 ? { inputs: { x: A2 }, backend: n2, attrs: { shape: Uf.expandShapeToKeepDim(p2, l2) } } : { inputs: { x: A2 }, backend: n2, attrs: { shape: p2 } }), n2.disposeIntermediateTensorInfo(m2), n2.disposeIntermediateTensorInfo(A2), null != d2 && n2.disposeIntermediateTensorInfo(c2), h2;
} };
var dM = oS({ opSnippet: GR + "\n  return min(a, b);\n", packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  " + XR + "\n  return result;\n", cpuKernelImpl: q$ });
var cM = { kernelName: zn, backendName: "webgl", kernelFunc: dM };
var hM = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["x"], this.outputShape = t2.map((t3, n3) => t3[0] + e20[n3] + t3[1]);
    let r2 = e20.length, a2 = UC(r2), i2 = t2.map((e21) => e21[0]).join(","), s2 = t2.map((t3, n3) => t3[0] + e20[n3]).join(","), o2 = "reflect" === n2 ? 0 : 1;
    this.userCode = 1 !== r2 ? `
      ${a2} start = ${a2}(${i2});
      ${a2} end = ${a2}(${s2});

      void main() {
        ${a2} outC = getOutputCoords();
        for (int i = 0; i < ${r2}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${o2};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${o2};
          }
        }
        ${a2} coords = outC - start;
        setOutput(getX(${["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r2)}));
      }
    ` : `
        int start = ${i2};
        int end = ${s2};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${o2};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${o2};
          }
          setOutput(getX(outC - start));
        }
      `;
  }
};
var pM = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2.map((t3, n3) => t3[0] + e20[n3] + t3[1]);
    let r2 = e20.length, a2 = UC(r2), i2 = t2.map((e21) => e21[0]).join(","), s2 = t2.map((t3, n3) => t3[0] + e20[n3]).join(","), o2 = kR("rc", r2), l2 = kR("source", r2), u2 = `${o2[r2 - 1]} < ${this.outputShape[r2 - 1]}`, d2 = 1 === r2 ? "source" : `vec2(${l2.slice(-2).join()})`, c2 = "reflect" === n2 ? 0 : 1, h2 = "";
    if (1 === r2) {
      let e21 = `
        ${a2} source = rc;
        if (source < start) {
          source = start * 2 - source - ${c2};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${c2};
        }
        source -= start;
      `;
      h2 = `
        ${a2} rc = outputLoc;
        ${e21}
        result[0] = getChannel(getX(${l2.join()}), ${d2});
        ${o2[r2 - 1]} += 1;
        if(${u2}) {
          ${e21}
          result[1] = getChannel(getX(${l2.join()}), ${d2});
        }
      `;
    } else {
      let e21 = `
        ${a2} source = rc;
        ${a2} lt = ${a2}(lessThan(source, start));
        ${a2} gte = ${a2}(greaterThanEqual(source, end));
        ${a2} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${c2}) +
                gte * ((end - 1) * 2 - source + ${c2});
        source -= start;
      `;
      h2 = `
        ${a2} rc = outputLoc;
        ${e21}
        result[0] = getChannel(getX(${l2.join()}), ${d2});
        ${o2[r2 - 1]} += 1;
        if(${u2}) {
          ${e21}
          result[1] = getChannel(getX(${l2.join()}), ${d2});
        }
        rc = outputLoc;
        ${o2[r2 - 2]} += 1;
        if(${o2[r2 - 2]} < ${this.outputShape[r2 - 2]}) {
          ${e21}
          result[2] = getChannel(getX(${l2.join()}), ${d2});
          ${o2[r2 - 1]} += 1;
          if(${u2}) {
            ${e21}
            result[3] = getChannel(getX(${l2.join()}), ${d2});
          }
        }
      `;
    }
    this.userCode = `
      const ${a2} start = ${a2}(${i2});
      const ${a2} end = ${a2}(${s2});

      void main() {
        ${a2} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h2}
        setOutput(result);
      }
    `;
  }
};
var fM = { kernelName: Vn, backendName: "webgl", kernelFunc({ inputs: e20, backend: t2, attrs: n2 }) {
  let { x: r2 } = e20, { paddings: a2, mode: i2 } = n2, s2 = _e().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new pM(r2.shape, a2, i2) : new hM(r2.shape, a2, i2);
  return t2.runWebGLProgram(s2, [r2], r2.dtype);
} };
var mM = { kernelName: "Mod", backendName: "webgl", kernelFunc: oS({ opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);", packedOpSnippet: "\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  " + XR + "\n  return result;\n" }) };
var AM = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["probs"], this.customUniforms = [{ name: "seed", type: "float" }], this.outputShape = [e20, n2], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t2 - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t2 - 1}));
      }
    `;
  }
};
var xM = oS({ opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", checkOutOfBounds: true });
var yM = { kernelName: Wt, backendName: "webgl", kernelFunc: xM };
var bM = "return a - b;";
var gM = oS({ opSnippet: bM, packedOpSnippet: bM, supportsComplex: true, cpuKernelImpl: xR });
var vM = { kernelName: "Sub", backendName: "webgl", kernelFunc: gM };
function wM(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { logits: a2 } = t2, { dim: i2 } = r2, s2 = va.parseAxisParam([i2], a2.shape), o2 = YT({ inputs: { x: a2 }, backend: n2, attrs: { reductionIndices: s2, keepDims: false } }), l2 = Uf.expandShapeToKeepDim(o2.shape, s2), u2 = fS({ inputs: { x: o2 }, backend: n2, attrs: { shape: l2 } }), d2 = gM({ inputs: { a: a2, b: u2 }, backend: n2 }), c2 = UE({ inputs: { x: d2 }, backend: n2 }), h2 = wS({ inputs: { x: c2 }, backend: n2, attrs: { axis: s2, keepDims: false } }), p2 = fS({ inputs: { x: h2 }, backend: n2, attrs: { shape: l2 } }), f2 = xM({ inputs: { a: c2, b: p2 }, backend: n2 });
  return n2.disposeIntermediateTensorInfo(o2), n2.disposeIntermediateTensorInfo(u2), n2.disposeIntermediateTensorInfo(d2), n2.disposeIntermediateTensorInfo(c2), n2.disposeIntermediateTensorInfo(h2), n2.disposeIntermediateTensorInfo(p2), f2;
}
var kM = { kernelName: Tr, backendName: "webgl", kernelFunc: wM };
var NM = { kernelName: Dn, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { logits: a2 } = t2, { numSamples: i2, seed: s2, normalized: o2 } = r2, l2 = o2 ? a2 : wM({ inputs: { logits: a2 }, backend: n2, attrs: { dim: a2.shape.length - 1 } }), u2 = new AM(l2.shape[0], l2.shape[1], i2), d2 = n2.runWebGLProgram(u2, [l2], "int32", [[s2]]);
  return o2 || n2.disposeIntermediateTensorInfo(l2), d2;
} };
var CM = TR + "\n  return -x;\n";
var $M = { kernelName: "Neg", backendName: "webgl", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2 } = e20, { x: a2 } = n2;
  if (r2.shouldExecuteOnCPU([a2])) {
    let e21 = r2.texData.get(a2.dataId), [t3, n3] = K$(e21.values, a2.shape, a2.dtype);
    return r2.makeTensorInfo(n3, a2.dtype, t3);
  }
  return t2 = _e().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new zR(a2.shape, "\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n") : new ER(a2.shape, CM), r2.runWebGLProgram(t2, [a2], a2.dtype);
} };
var RM = Ym.nonMaxSuppressionV3Impl;
var SM = { kernelName: Un, backendName: "webgl", kernelFunc(e20) {
  Uf.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { boxes: a2, scores: i2 } = t2, { maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2 } = r2, u2 = n2.readSync(a2.dataId), d2 = n2.readSync(i2.dataId), { selectedIndices: c2 } = RM(u2, d2, s2, o2, l2);
  return n2.makeTensorInfo([c2.length], "int32", new Int32Array(c2));
} };
var IM = Ym.nonMaxSuppressionV4Impl;
var EM = { kernelName: jn, backendName: "webgl", kernelFunc(e20) {
  Uf.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { boxes: a2, scores: i2 } = t2, { maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2, padToMaxOutputSize: u2 } = r2, d2 = n2.readSync(a2.dataId), c2 = n2.readSync(i2.dataId), { selectedIndices: h2, validOutputs: p2 } = IM(d2, c2, s2, o2, l2, u2);
  return [n2.makeTensorInfo([h2.length], "int32", new Int32Array(h2)), n2.makeTensorInfo([], "int32", new Int32Array([p2]))];
} };
var TM = Ym.nonMaxSuppressionV5Impl;
var MM = { kernelName: Gn, backendName: "webgl", kernelFunc(e20) {
  Uf.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { boxes: a2, scores: i2 } = t2, { maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2, softNmsSigma: u2 } = r2, d2 = n2.readSync(a2.dataId), c2 = n2.readSync(i2.dataId), h2 = s2, p2 = o2, f2 = l2, m2 = u2, { selectedIndices: A2, selectedScores: x2 } = TM(d2, c2, h2, p2, f2, m2);
  return [n2.makeTensorInfo([A2.length], "int32", new Int32Array(A2)), n2.makeTensorInfo([x2.length], "float32", new Float32Array(x2))];
} };
var OM = class {
  constructor(e20, t2, n2, r2) {
    this.variableNames = ["indices"], this.outputShape = [e20, t2], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r2}), float(${n2}),
                      float(index == coords.y)));
      }
    `;
  }
};
var FM = { kernelName: Xn, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { indices: a2 } = t2, { dtype: i2, depth: s2, onValue: o2, offValue: l2 } = r2, u2 = va.sizeFromShape(a2.shape), d2 = new OM(u2, s2, o2, l2), c2 = fS({ inputs: { x: a2 }, backend: n2, attrs: { shape: [u2] } }), h2 = n2.runWebGLProgram(d2, [c2], i2);
  n2.disposeIntermediateTensorInfo(c2);
  let p2 = fS({ inputs: { x: h2 }, backend: n2, attrs: { shape: [...a2.shape, s2] } });
  return n2.disposeIntermediateTensorInfo(h2), p2;
} };
function PM(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2;
  if ("complex64" === r2.dtype) {
    let e21 = RI({ inputs: { input: r2 }, backend: n2 }), t3 = PM({ inputs: { x: e21 }, backend: n2 }), a2 = BI({ inputs: { input: r2 }, backend: n2 }), i2 = PM({ inputs: { x: a2 }, backend: n2 }), s2 = YR({ inputs: { real: t3, imag: i2 }, backend: n2 });
    return n2.disposeIntermediateTensorInfo(e21), n2.disposeIntermediateTensorInfo(t3), n2.disposeIntermediateTensorInfo(a2), n2.disposeIntermediateTensorInfo(i2), s2;
  }
  return eT({ attrs: { shape: r2.shape, dtype: r2.dtype, value: "string" === r2.dtype ? "" : 0 }, backend: n2 });
}
var zM = { kernelName: ta, backendName: "webgl", kernelFunc: PM };
var VM = { kernelName: Hn, backendName: "webgl", kernelFunc: function e16(t2) {
  let { inputs: n2, backend: r2 } = t2, { x: a2 } = n2;
  if ("string" === a2.dtype) throw Error("onesLike is not supported under string dtype");
  if ("complex64" === a2.dtype) {
    let t3 = RI({ inputs: { input: a2 }, backend: r2 }), n3 = e16({ inputs: { x: t3 }, backend: r2 }), i2 = BI({ inputs: { input: a2 }, backend: r2 }), s2 = PM({ inputs: { x: i2 }, backend: r2 }), o2 = YR({ inputs: { real: n3, imag: s2 }, backend: r2 });
    return r2.disposeIntermediateTensorInfo(t3), r2.disposeIntermediateTensorInfo(n3), r2.disposeIntermediateTensorInfo(i2), r2.disposeIntermediateTensorInfo(s2), o2;
  }
  return eT({ attrs: { shape: a2.shape, dtype: a2.dtype, value: 1 }, backend: r2 });
} };
var _M = { kernelName: qn, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { axis: a2 } = r2;
  if (1 === t2.length) return GE({ inputs: { input: t2[0] }, backend: n2, attrs: { dim: a2 } });
  let i2 = t2[0].shape, s2 = t2[0].dtype;
  t2.forEach((e21) => {
    va.assertShapesMatch(i2, e21.shape, "All tensors passed to stack must have matching shapes"), va.assert(s2 === e21.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  let o2 = [], l2 = GI({ inputs: t2.map((e21) => {
    let t3 = GE({ inputs: { input: e21 }, backend: n2, attrs: { dim: a2 } });
    return o2.push(t3), t3;
  }), backend: n2, attrs: { axis: a2 } });
  return o2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), l2;
} };
var DM = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["x"], this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = t2.map((t3, n3) => t3[0] + e20[n3] + t3[1]);
    let r2 = e20.length, a2 = UC(r2), i2 = t2.map((e21) => e21[0]).join(","), s2 = t2.map((t3, n3) => t3[0] + e20[n3]).join(",");
    this.userCode = 1 !== r2 ? `
      ${a2} start = ${a2}(${i2});
      ${a2} end = ${a2}(${s2});

      void main() {
        ${a2} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a2} coords = outC - start;
          setOutput(getX(${["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r2)}));
        }
      }
    ` : `
        int start = ${i2};
        int end = ${s2};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
  }
};
var WM = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.customUniforms = [{ name: "value", type: "float" }], this.outputShape = t2.map((t3, n3) => t3[0] + e20[n3] + t3[1]);
    let r2 = e20.length, a2 = UC(r2), i2 = t2.map((e21) => e21[0]).join(","), s2 = t2.map((t3, n3) => t3[0] + e20[n3]).join(","), o2 = kR("rc", r2), l2 = kR("source", r2), u2 = `${o2[r2 - 1]} < ${this.outputShape[r2 - 1]}`, d2 = 1 === r2 ? "source" : `vec2(${l2.slice(-2).join()})`, c2 = [a2 + " rc = outputLoc;", `${o2[r2 - 1]} += 1;
       if(${u2}) {
      `, 1 === r2 ? "" : `}
       rc = outputLoc;
       ${o2[r2 - 2]} += 1;
       if(${o2[r2 - 2]} < ${this.outputShape[r2 - 2]}) {`, 1 === r2 ? "" : `  ${o2[r2 - 1]} += 1;
         if(${u2}) {`], h2 = 1 === r2 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", p2 = "";
    for (let f2 = 0, m2 = 1 === r2 ? 2 : 4; m2 > f2; f2++) p2 += `
        ${c2[f2]}
        if (${h2}) {
          result[${f2}] = float(value);
        } else {
          ${a2} source = rc - start;
          result[${f2}] = getChannel(getX(${l2.join()}), ${d2});
        }
      `;
    p2 += 1 === r2 ? "} " : "}}", this.userCode = `
      const ${a2} start = ${a2}(${i2});
      const ${a2} end = ${a2}(${s2});

      void main() {
        ${a2} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p2}
        setOutput(result);
      }
    `;
  }
};
var LM = (e20) => {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { paddings: i2, constantValue: s2 } = r2;
  if (0 === va.sizeFromShape(a2.shape)) return eT({ backend: n2, attrs: { shape: i2.map((e21, t3) => e21[0] + a2.shape[t3] + e21[1]), value: s2, dtype: a2.dtype } });
  let o2 = _e().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new WM(a2.shape, i2, s2) : new DM(a2.shape, i2, s2);
  return n2.runWebGLProgram(o2, [a2], a2.dtype, [[s2]]);
};
var BM = { kernelName: Zn, backendName: "webgl", kernelFunc: LM };
var UM = { kernelName: "Pow", backendName: "webgl", kernelFunc: oS({ opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  " + XR + "\n  return result;\n" }) };
var jM = { kernelName: Qn, backendName: "webgl", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2 } = n2, { axis: s2, keepDims: o2 } = a2, l2 = i2.shape.length, u2 = [], d2 = va.parseAxisParam(s2, i2.shape), c2 = d2, h2 = Uf.getAxesPermutation(c2, l2), p2 = i2;
  if (null != h2 && (p2 = NS({ inputs: { x: i2 }, backend: r2, attrs: { perm: h2 } }), c2 = Uf.getInnerMostAxes(c2.length, l2), u2.push(p2)), Uf.assertAxesAreInnerMostDims("prod", c2, l2), r2.shouldExecuteOnCPU([p2])) {
    let e21 = r2.texData.get(p2.dataId).values, { outVals: n3, outShape: a3, outDtype: i3 } = J$(p2.shape, p2.dtype, e21, c2);
    t2 = r2.makeTensorInfo(a3, i3, n3);
  } else {
    let [e21, n3] = Uf.computeOutAndReduceShapes(p2.shape, c2), a3 = va.sizeFromShape(n3), s3 = fS({ inputs: { x: p2 }, backend: r2, attrs: { shape: [-1, a3] } }), o3 = yS(s3, fi(i2.dtype), "prod", r2);
    t2 = fS({ inputs: { x: o3 }, backend: r2, attrs: { shape: e21 } }), u2.push(s3), u2.push(o3);
  }
  if (o2) {
    u2.push(t2);
    let e21 = Uf.expandShapeToKeepDim(t2.shape, d2);
    t2 = fS({ inputs: { x: t2 }, backend: r2, attrs: { shape: e21 } });
  }
  return u2.forEach((e21) => r2.disposeIntermediateTensorInfo(e21)), t2;
} };
var GM = { kernelName: er, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { paramsNestedSplits: a2, paramsDenseValues: i2, indices: s2 } = t2, { outputRaggedRank: o2 } = r2, l2 = a2.map((e21) => n2.readSync(e21.dataId)), u2 = a2.map((e21) => e21.shape), d2 = n2.readSync(i2.dataId), c2 = n2.readSync(s2.dataId), [h2, p2, f2] = Q$(l2, u2, d2, i2.shape, i2.dtype, c2, s2.shape, o2), m2 = h2.map((e21) => n2.makeTensorInfo([e21.length], "int32", e21)), A2 = n2.makeTensorInfo(f2, i2.dtype, p2);
  return m2.concat([A2]);
} };
var HM = { kernelName: tr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { starts: r2, limits: a2, deltas: i2 } = t2, s2 = n2.readSync(r2.dataId), o2 = n2.readSync(a2.dataId), l2 = n2.readSync(i2.dataId), [u2, d2] = eR(s2, r2.shape, r2.dtype, o2, a2.shape, l2, i2.shape);
  return [n2.makeTensorInfo([u2.length], "int32", u2), n2.makeTensorInfo([d2.length], r2.dtype, d2)];
} };
var XM = { kernelName: nr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { shape: a2, values: i2, defaultValue: s2, rowPartitionTensors: o2 } = t2, { rowPartitionTypes: l2 } = r2, u2 = n2.readSync(a2.dataId), d2 = n2.readSync(i2.dataId), c2 = n2.readSync(s2.dataId), h2 = o2.map((e21) => n2.readSync(e21.dataId)), p2 = o2.map((e21) => e21.shape), [f2, m2] = tR(u2, a2.shape, d2, i2.shape, i2.dtype, c2, s2.shape, h2, p2, l2);
  return n2.makeTensorInfo(f2, i2.dtype, m2);
} };
var qM = (e20) => {
  let { backend: t2, attrs: n2 } = e20, { start: r2, stop: a2, step: i2, dtype: s2 } = n2, o2 = nR(r2, a2, i2, s2);
  return t2.makeTensorInfo([o2.length], s2, o2);
};
var ZM = { kernelName: rr, backendName: "webgl", kernelFunc: qM };
var KM = sS({ opSnippet: "return 1.0 / x;" });
var YM = { kernelName: ir, backendName: "webgl", kernelFunc: KM };
var JM = sS({ opSnippet: TR + "\n  return (x < 0.0) ? 0.0 : x;\n", packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" });
var QM = { kernelName: sr, backendName: "webgl", kernelFunc: JM };
var eO = sS({ opSnippet: TR + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n", packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" });
var tO = { kernelName: hr, backendName: "webgl", kernelFunc: eO };
var nO = class {
  constructor(e20, t2, n2, r2, a2) {
    this.variableNames = ["A"], this.outputShape = [];
    let [i2, s2, o2, l2] = e20;
    this.outputShape = [i2, t2, n2, l2];
    let u2, d2 = [r2 && t2 > 1 ? s2 - 1 : s2, r2 && n2 > 1 ? o2 - 1 : o2], c2 = [r2 && t2 > 1 ? t2 - 1 : t2, r2 && n2 > 1 ? n2 - 1 : n2];
    u2 = a2 ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d2[0] / c2[0]},
          ${d2[1] / c2[1]});
      const vec2 inputShapeRC = vec2(${s2}.0, ${o2}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${u2};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
  }
};
var rO = class {
  constructor(e20, t2, n2, r2, a2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
    let [i2, s2, o2, l2] = e20;
    this.outputShape = [i2, t2, n2, l2];
    let u2, d2 = [r2 && t2 > 1 ? s2 - 1 : s2, r2 && n2 > 1 ? o2 - 1 : o2], c2 = [r2 && t2 > 1 ? t2 - 1 : t2, r2 && n2 > 1 ? n2 - 1 : n2];
    u2 = a2 ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d2[0] / c2[0]},
          ${d2[1] / c2[1]},
          ${d2[1] / c2[1]});
      const vec3 inputShapeRC = vec3(${s2}.0, ${o2}.0,
                                     ${o2}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${u2};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l2 - 1};
        bool hasNextRow = coords.z < ${n2 - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
  }
};
var aO = { kernelName: dr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2 } = t2, { alignCorners: i2, halfPixelCenters: s2, size: o2 } = r2, [l2, u2] = o2, d2 = _e().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new rO(a2.shape, l2, u2, i2, s2) : new nO(a2.shape, l2, u2, i2, s2);
  return n2.runWebGLProgram(d2, [a2], "float32");
} };
var iO = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t2;
    let [, r2, a2] = t2, [, i2, s2] = e20, o2 = [n2 && i2 > 1 ? r2 - 1 : r2, n2 && s2 > 1 ? a2 - 1 : a2], l2 = [n2 && i2 > 1 ? i2 - 1 : i2, n2 && s2 > 1 ? s2 - 1 : s2], u2 = o2[0] / l2[0], d2 = o2[1] / l2[1], c2 = 1 / u2, h2 = 1 / d2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u2});
        const float widthScale = float(${d2});

        const float invHeightScale = float(${c2});
        const float invWidthScale = float(${h2});

        const int winHeight = int(${2 * Math.ceil(c2) + 2});
        const int winWidth = int(${2 * Math.ceil(h2) + 2});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i2}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${s2}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r2 - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a2 - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
};
var sO = { kernelName: cr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2, dy: i2 } = t2, { alignCorners: s2 } = r2, o2 = new iO(i2.shape, a2.shape, s2);
  return n2.runWebGLProgram(o2, [i2], i2.dtype);
} };
var oO = class {
  constructor(e20, t2, n2, r2, a2) {
    this.variableNames = ["A"], this.outputShape = [];
    let [i2, s2, o2, l2] = e20;
    this.outputShape = [i2, t2, n2, l2];
    let u2, d2 = [r2 && t2 > 1 ? s2 - 1 : s2, r2 && n2 > 1 ? o2 - 1 : o2], c2 = [r2 && t2 > 1 ? t2 - 1 : t2, r2 && n2 > 1 ? n2 - 1 : n2];
    u2 = a2 ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d2[0] / c2[0]},
          ${d2[1] / c2[1]});
      const vec2 inputShapeRC = vec2(${s2}.0, ${o2}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${u2};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r2 ? "0.5" : "0.0"})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
  }
};
var lO = class {
  constructor(e20, t2, n2, r2, a2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
    let [i2, s2, o2, l2] = e20;
    this.outputShape = [i2, t2, n2, l2];
    let u2, d2 = [r2 && t2 > 1 ? s2 - 1 : s2, r2 && n2 > 1 ? o2 - 1 : o2], c2 = [r2 && t2 > 1 ? t2 - 1 : t2, r2 && n2 > 1 ? n2 - 1 : n2];
    u2 = a2 ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d2[0] / c2[0]},
          ${d2[1] / c2[1]},
          ${d2[1] / c2[1]});
      const vec3 inputShapeRC = vec3(${s2}.0, ${o2}.0,
                                     ${o2}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${u2};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r2 ? "0.5" : "0.0"})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l2 - 1};
        bool hasNextRow = coords.z < ${n2 - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
  }
};
var uO = { kernelName: lr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2 } = t2, { alignCorners: i2, halfPixelCenters: s2, size: o2 } = r2, [l2, u2] = o2, d2 = _e().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new lO(a2.shape, l2, u2, i2, s2) : new oO(a2.shape, l2, u2, i2, s2);
  return n2.runWebGLProgram(d2, [a2], a2.dtype);
} };
var dO = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t2;
    let [, r2, a2] = t2, [, i2, s2] = e20, o2 = [n2 && i2 > 1 ? r2 - 1 : r2, n2 && s2 > 1 ? a2 - 1 : a2], l2 = [n2 && i2 > 1 ? i2 - 1 : i2, n2 && s2 > 1 ? s2 - 1 : s2], u2 = o2[0] / l2[0], d2 = o2[1] / l2[1], c2 = 1 / u2, h2 = 1 / d2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u2});
        const float widthScale = float(${d2});

        const float invHeightScale = float(${c2});
        const float invWidthScale = float(${h2});

        const int winHeight = int(${2 * Math.ceil(c2) + 2});
        const int winWidth = int(${2 * Math.ceil(h2) + 2});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i2}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${s2}) {
              continue;
            }

            float sourceFracRow =
              float(${o2[0]}) *
                (float(dyR) / float(${l2[0]}));

            float sourceFracCol =
                float(${o2[1]}) *
                  (float(dyC) / float(${l2[1]}));

            int sourceNearestRow = int(min(
                float(int(${r2}) - 1),
                ${n2} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a2}) - 1),
                ${n2} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
};
var cO = { kernelName: ur, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2, dy: i2 } = t2, { alignCorners: s2 } = r2, o2 = new dO(i2.shape, a2.shape, s2);
  return n2.runWebGLProgram(o2, [i2], i2.dtype);
} };
var hO = class {
  constructor(e20, t2) {
    this.variableNames = ["x"];
    let n2 = e20.length;
    if (n2 > 4) throw Error(`WebGL backend: Reverse of rank-${n2} tensor is not yet supported`);
    if (this.outputShape = e20, 1 === n2) return void (this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e20[0]} - coord - 1));
        }
      `);
    let r2 = e20.map((n3, r3) => ((n4) => -1 !== t2.indexOf(n4) && 1 !== e20[n4] ? `${e20[n4]} - coords[${n4}] - 1` : `coords[${n4}]`)(r3)).join(","), a2 = UC(n2);
    this.userCode = `
      void main() {
        ${a2} coords = getOutputCoords();
        setOutput(getX(${r2}));
      }
    `;
  }
};
var pO = class {
  constructor(e20, t2) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
    let n2 = e20.length;
    if (n2 > 4) throw Error(`WebGL backend: Reverse of rank-${n2} tensor is not yet supported`);
    this.outputShape = e20;
    let r2 = kR("rc", n2), a2 = `${r2[n2 - 1]} + 1 < ${this.outputShape[n2 - 1]}`, i2 = `${r2[n2 - 2]} + 1 < ${this.outputShape[n2 - 2]}`, s2 = UC(n2);
    var o2;
    function l2(n3) {
      let r3 = e20.map((r4, a3) => ((n4, r5) => -1 !== t2.indexOf(n4) && 1 !== e20[n4] ? `${e20[n4]} - ${r5[n4]} - 1` : "" + r5[n4])(a3, n3));
      return `getChannel(getX(${r3.join(",")}), vec2(${r3.slice(-2).join(",")}))`;
    }
    this.userCode = 1 === n2 ? `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e20[0]} - rc - 1),
            ${e20[0]} - rc - 1);
          if(${a2}){
              result.g = getChannel(getX(${e20[0]} - (rc  + 1) - 1),
                ${e20[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : `
        void main() {
          ${s2} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o2 = r2.slice(), l2(o2)};
          if(${a2}){
            result.g = ${((e21) => (e21[n2 - 1] = "(" + e21[n2 - 1] + " + 1)", l2(e21)))(r2.slice())};
          }
          if(${i2}) {
            result.b = ${((e21) => (e21[n2 - 2] = "(" + e21[n2 - 2] + " + 1)", l2(e21)))(r2.slice())};
            if(${a2}) {
              result.a = ${((e21) => (e21[n2 - 1] = "(" + e21[n2 - 1] + " + 1)", e21[n2 - 2] = "(" + e21[n2 - 2] + " + 1)", l2(e21)))(r2.slice())};
            }
          }
          setOutput(result);
        }
    `;
  }
};
var fO = { kernelName: pr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { dims: i2 } = r2, s2 = a2.shape.length, o2 = va.parseAxisParam(i2, a2.shape);
  if (0 === s2) return ZR({ inputs: { x: a2 }, backend: n2 });
  let l2 = _e().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new pO(a2.shape, o2) : new hO(a2.shape, o2);
  return n2.runWebGLProgram(l2, [a2], a2.dtype);
} };
var mO = class {
  constructor(e20, t2) {
    this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{ name: "params", type: "vec4" }];
    let n2 = e20[1], r2 = e20[2];
    this.outputShape = e20;
    let a2 = "";
    a2 = "number" == typeof t2 ? `float outputValue = ${t2.toFixed(2)};` : `
        vec3 fill = vec3(${t2.join(",")});
        float outputValue = fill[coords[3]];`, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a2}
          if(coordX >= 0 && coordX < ${r2} && coordY >= 0 && coordY < ${n2}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
};
var AO = { kernelName: aa, backendName: "webgl", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { image: r2 } = e20, { radians: a2, fillValue: i2, center: s2 } = t2, o2 = n2, l2 = new mO(r2.shape, i2), [u2, d2] = Uf.getImageCenter(s2, r2.shape[1], r2.shape[2]);
  return o2.runWebGLProgram(l2, [r2], r2.dtype, [[u2, d2, Math.sin(a2), Math.cos(a2)]]);
} };
var xO = sS({ opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n" });
var yO = { kernelName: fr, backendName: "webgl", kernelFunc: xO };
var bO = sS({ opSnippet: "return inversesqrt(x);", cpuKernelImpl: rR });
var gO = { kernelName: mr, backendName: "webgl", kernelFunc: bO };
var vO = class {
  constructor(e20, t2, n2, r2, a2, i2, s2 = true, o2 = false) {
    this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = i2;
    let l2 = UC(a2.length), u2 = UC(i2.length), d2 = "";
    1 === n2 ? d2 = "i" : 2 === n2 && (d2 = "i, j");
    let c2 = "";
    1 === r2 ? c2 = "i" : 2 === r2 && (c2 = "i, coords[1]");
    let h2 = "";
    o2 && (h2 = "coords[0], coords[1]"), this.userCode = `
        ${l2} strides = ${l2}(${a2});

        void main() {
          ${u2} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e20}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t2}; j++) {
              int index = round(getIndices(${d2}));
              flattenedIndex += index * ${t2 > 1 ? "strides[j]" : "strides"};
            }
            if (flattenedIndex == coords[0]) {
              sum += getUpdates(${c2});
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(${h2}), sum, float(found)));
        }
      `;
  }
};
var wO = class {
  constructor(e20, t2, n2, r2, a2, i2, s2 = true, o2 = false) {
    this.variableNames = ["updates", "indices", "defaultValue"], this.packedInputs = true, this.packedOutput = true, this.outputShape = i2;
    let l2 = UC(a2.length), u2 = UC(i2.length), d2 = "";
    1 === n2 ? d2 = "i" : 2 === n2 && (d2 = "i, j");
    let c2 = "";
    1 === r2 ? c2 = "i" : 2 === r2 && (c2 = "i, coords[1]");
    let h2 = "";
    o2 && (h2 = "coords[0], coords[1]"), this.userCode = `
        ${l2} strides = ${l2}(${a2});

        void main() {
          ${u2} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e20}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t2}; j+=2) {
              ivec4 index = round(getIndices(${d2}));
              flattenedIndex += index.xz * ${t2 > 1 ? "strides[j]" : "strides"};
              if (j + 1 < ${t2}) {
                flattenedIndex += index.yw * ${t2 > 1 ? "strides[j + 1]" : "strides"};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = getUpdates(${c2});
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(getDefaultValue(${h2}), sum, found));
        }
      `;
  }
};
var kO = { kernelName: Ar, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { indices: a2, updates: i2 } = t2, { shape: s2 } = r2, { sliceRank: o2, numUpdates: l2, sliceSize: u2, strides: d2, outputSize: c2 } = Uf.calculateShapes(i2, a2, s2), h2 = [c2 / u2, u2];
  if (0 === c2) return n2.makeTensorInfo(s2, a2.dtype);
  let p2, f2 = fS({ inputs: { x: a2 }, backend: n2, attrs: { shape: [l2, o2] } }), m2 = fS({ inputs: { x: i2 }, backend: n2, attrs: { shape: [l2, u2] } }), A2 = n2.makeTensorInfo([], "float32", new Float32Array([0]));
  p2 = _e().getBool("WEBGL_PACK") ? new wO(l2, o2, f2.shape.length, m2.shape.length, d2, h2) : new vO(l2, o2, f2.shape.length, m2.shape.length, d2, h2);
  let x2 = n2.runWebGLProgram(p2, [m2, f2, A2], m2.dtype), y2 = fS({ inputs: { x: x2 }, backend: n2, attrs: { shape: s2 } });
  return n2.disposeIntermediateTensorInfo(f2), n2.disposeIntermediateTensorInfo(m2), n2.disposeIntermediateTensorInfo(x2), n2.disposeIntermediateTensorInfo(A2), y2;
} };
var NO = class {
  constructor(e20, t2, n2, r2) {
    this.variableNames = ["sortedSequence", "values"], this.customUniforms = [{ name: "numInputs", type: "int" }], this.outputShape = [e20, n2];
    let a2 = `for (int i = 0; i < ${Math.ceil(Math.log2(t2 + 1))}; ++i) { if (left >= right) break;`, i2 = 2 === _e().getNumber("WEBGL_VERSION") ? "while (left < right) {" : a2;
    this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i2}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${"left" === r2 ? "<" : "<="} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
  }
};
var CO = { kernelName: yr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { sortedSequence: a2, values: i2 } = t2, { side: s2 } = r2, o2 = new NO(a2.shape[0], a2.shape[1], i2.shape[1], s2);
  return n2.runWebGLProgram(o2, [a2, i2], "int32", [[a2.shape[1]]]);
} };
var $O = class {
  constructor(e20, t2, n2) {
    let r2, a2;
    if (this.variableNames = ["c", "a", "b"], this.outputShape = t2, n2 > 4) throw Error(`Where for rank ${n2} is not yet supported`);
    if (1 === n2) a2 = "resRC", r2 = "resRC";
    else {
      let n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i3 = [], s2 = [];
      for (let r3 = 0; t2.length > r3; r3++) s2.push("" + n3[r3]), e20 > r3 && i3.push("" + n3[r3]);
      r2 = i3.join(), a2 = s2.join();
    }
    let i2 = UC(n2);
    this.userCode = `
      void main() {
        ${i2} resRC = getOutputCoords();
        float cVal = getC(${r2});
        if (cVal >= 1.0) {
          setOutput(getA(${a2}));
        } else {
          setOutput(getB(${a2}));
        }
      }
    `;
  }
};
var RO = { kernelName: br, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { condition: r2, t: a2, e: i2 } = t2, s2 = new $O(r2.shape.length, a2.shape, a2.shape.length);
  return n2.runWebGLProgram(s2, [r2, a2, i2], pi(a2.dtype, i2.dtype));
} };
var SO = sS({ opSnippet: `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Uf.SELU_SCALEALPHA};
  float scale = ${Uf.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
` });
var IO = { kernelName: gr, backendName: "webgl", kernelFunc: SO };
var EO = sS({ opSnippet: iS + "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n", packedOpSnippet: "\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n", cpuKernelImpl: iR });
var TO = { kernelName: Cr, backendName: "webgl", kernelFunc: EO };
var MO = sS({ opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n" });
var OO = { kernelName: Nr, backendName: "webgl", kernelFunc: MO };
var FO = { kernelName: "Sin", backendName: "webgl", kernelFunc: sS({ opSnippet: iS + "\n  return sin(x);\n", packedOpSnippet: `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${XR}
  return result;
` }) };
var PO = sS({ opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n" });
var zO = { kernelName: kr, backendName: "webgl", kernelFunc: PO };
var VO = sS({ opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n" });
var _O = { kernelName: $r, backendName: "webgl", kernelFunc: VO };
var DO = { kernelName: Ir, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockShape: i2, paddings: s2 } = r2;
  va.assert(4 >= a2.shape.length, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
  let o2 = i2.reduce((e21, t3) => e21 * t3), l2 = [[0, 0]];
  l2.push(...s2);
  for (let x2 = 1 + i2.length; a2.shape.length > x2; ++x2) l2.push([0, 0]);
  let u2 = [], d2 = LM({ inputs: { x: a2 }, backend: n2, attrs: { paddings: l2, constantValue: 0 } }), c2 = Uf.getReshaped(d2.shape, i2, o2, false), h2 = Uf.getPermuted(c2.length, i2.length, false), p2 = Uf.getReshapedPermuted(d2.shape, i2, o2, false), f2 = fS({ inputs: { x: d2 }, backend: n2, attrs: { shape: c2 } }), m2 = NS({ inputs: { x: f2 }, backend: n2, attrs: { perm: h2 } }), A2 = fS({ inputs: { x: m2 }, backend: n2, attrs: { shape: p2 } });
  return u2.push(d2), u2.push(f2), u2.push(m2), u2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), A2;
} };
var WO = { kernelName: Mr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { indices: r2, values: a2, denseShape: i2, defaultValue: s2 } = t2;
  if (1 !== i2.shape.length) throw Error("Dense shape must be a vector, saw:\n         " + i2.shape);
  if (2 !== r2.shape.length) throw Error("Indices must be a matrix, saw:\n         " + r2.shape);
  if (1 !== a2.shape.length) throw Error("Values must be a vector, saw:\n         " + a2.shape);
  if (0 !== s2.shape.length) throw Error("Default value must be a scalar, saw:\n        " + s2.shape);
  let o2 = n2.readSync(r2.dataId), l2 = n2.readSync(a2.dataId), u2 = n2.readSync(i2.dataId), d2 = n2.readSync(s2.dataId)[0], [c2, h2, p2, f2, m2] = lR(o2, r2.shape, r2.dtype, l2, a2.dtype, u2, d2);
  return [n2.makeTensorInfo(h2, r2.dtype, c2), n2.makeTensorInfo([h2[0]], a2.dtype, p2), n2.makeTensorInfo([f2.length], "bool", new Uint8Array(f2.map((e21) => +e21))), n2.makeTensorInfo([m2.length], r2.dtype, new Int32Array(m2))];
} };
var LO = { kernelName: Or, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { inputIndices: r2, inputShape: a2, newShape: i2 } = t2;
  if (2 !== r2.shape.length) throw Error("Input indices should be a matrix but received shape " + r2.shape);
  if (1 !== a2.shape.length) throw Error("Input shape should be a vector but received shape " + a2.shape);
  if (1 !== i2.shape.length) throw Error("Target shape should be a vector but received shape " + i2.shape);
  let s2 = Array.from(n2.readSync(a2.dataId)), o2 = n2.readSync(r2.dataId), l2 = Array.from(n2.readSync(i2.dataId)), [u2, d2, c2] = uR(o2, r2.shape, r2.dtype, s2, l2);
  return [n2.makeTensorInfo(d2, r2.dtype, u2), n2.makeTensorInfo([c2.length], i2.dtype, new Int32Array(c2))];
} };
var BO = { kernelName: Fr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { data: r2, indices: a2, segmentIds: i2 } = t2;
  if (1 > r2.shape.length) throw Error("Data should be at least 1 dimensional but received scalar");
  if (1 !== a2.shape.length) throw Error("Indices should be a vector but received shape\n              " + a2.shape);
  if (1 !== i2.shape.length) throw Error("Segment ids should be a vector but received shape\n              " + i2.shape);
  let s2 = n2.readSync(r2.dataId), o2 = n2.readSync(a2.dataId), l2 = n2.readSync(i2.dataId), [u2, d2] = dR(s2, r2.shape, r2.dtype, o2, l2, true);
  return n2.makeTensorInfo(d2, r2.dtype, u2);
} };
var UO = { kernelName: Pr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { data: r2, indices: a2, segmentIds: i2 } = t2;
  if (1 > r2.shape.length) throw Error("Data should be at least 1 dimensional but received scalar");
  if (1 !== a2.shape.length) throw Error("Indices should be a vector but received shape\n             " + a2.shape);
  if (1 !== i2.shape.length) throw Error("Segment ids should be a vector but received shape\n             " + i2.shape);
  let s2 = n2.readSync(r2.dataId), o2 = n2.readSync(a2.dataId), l2 = n2.readSync(i2.dataId), [u2, d2] = dR(s2, r2.shape, r2.dtype, o2, l2);
  return n2.makeTensorInfo(d2, r2.dtype, u2);
} };
var jO = { kernelName: zr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { sparseIndices: a2, sparseValues: i2, defaultValue: s2 } = t2, { outputShape: o2 } = r2, { sliceRank: l2, numUpdates: u2, sliceSize: d2, strides: c2, outputSize: h2 } = Uf.calculateShapes(i2, a2, o2), p2 = false;
  if ("string" === i2.dtype) {
    let e21 = n2.bufferSync(a2), t3 = n2.bufferSync(i2), r3 = va.decodeString(n2.readSync(s2.dataId)[0]), f3 = aR(e21, t3, o2, h2, d2, u2, l2, c2, r3, p2);
    return n2.makeTensorInfo(o2, f3.dtype, f3.values);
  }
  let f2 = new vO(u2, l2, a2.shape.length, i2.shape.length, c2, [h2, 1], p2), m2 = n2.runWebGLProgram(f2, [i2, a2, s2], i2.dtype), A2 = fS({ inputs: { x: m2 }, backend: n2, attrs: { shape: o2 } });
  return n2.disposeIntermediateTensorInfo(m2), A2;
} };
var GO = { kernelName: Er, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { numOrSizeSplits: i2, axis: s2 } = r2, o2 = va.parseAxisParam(s2, a2.shape)[0], l2 = Uf.prepareSplitSize(a2, i2, o2), u2 = Array(a2.shape.length).fill(0), d2 = a2.shape.slice();
  return l2.map((e21) => {
    let t3 = [...d2];
    t3[o2] = e21;
    let r3 = bI({ inputs: { x: a2 }, backend: n2, attrs: { begin: u2, size: t3 } });
    return u2[o2] += e21, r3;
  });
} };
var HO = "return sqrt(x);";
var XO = sS({ opSnippet: HO, packedOpSnippet: HO, cpuKernelImpl: cR });
var qO = { kernelName: Rr, backendName: "webgl", kernelFunc: XO };
var ZO = sS({ opSnippet: "return x * x;" });
var KO = { kernelName: _r, backendName: "webgl", kernelFunc: ZO };
var YO = "return (a - b) * (a - b);";
var JO = oS({ opSnippet: YO, packedOpSnippet: YO });
var QO = { kernelName: Vr, backendName: "webgl", kernelFunc: JO };
var eF = { kernelName: Dr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2;
  if ("string" !== a2.dtype) throw Error("Input must be of datatype string");
  let i2 = n2.readSync(a2.dataId), s2 = Uf.fromUint8ToStringArray(i2), o2 = hR(s2, "string", r2);
  return n2.makeTensorInfo(a2.shape, "string", o2);
} };
var tF = { kernelName: na, backendName: "webgl", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { x: r2 } = e20, a2 = new ER(r2.shape, TR + `
    return x > 0.0 ? 1.0 : float(${t2.alpha});
  `);
  return n2.runWebGLProgram(a2, [r2], r2.dtype);
} };
var nF = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["x"], this.outputShape = n2;
    let r2 = n2.length, a2 = UC(n2.length), i2 = UC(n2.length), s2 = "";
    if (1 === r2) s2 = "coords * strides + begin";
    else {
      let e21 = 0;
      s2 = n2.map((t3, r3) => (e21++, 1 === n2.length ? `coords * strides[${r3}] + begin[${r3}]` : `coords[${e21 - 1}] * strides[${r3}] + begin[${r3}]`)).join(",");
    }
    this.userCode = `
      ${a2} begin = ${a2}(${e20});
      ${a2} strides = ${a2}(${t2});

      void main() {
        ${i2} coords = getOutputCoords();
        setOutput(getX(${s2}));
      }
    `;
  }
};
var rF = { kernelName: Wr, backendName: "webgl", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2 } = n2, { begin: s2, end: o2, strides: l2, beginMask: u2, endMask: d2, ellipsisMask: c2, newAxisMask: h2, shrinkAxisMask: p2 } = a2, { finalShapeSparse: f2, finalShape: m2, isIdentity: A2, sliceDim0: x2, isSimpleSlice: y2, begin: b2, end: g2, strides: v2 } = xf.sliceInfo(i2.shape, s2, o2, l2, u2, d2, c2, h2, p2);
  if (A2) t2 = fS({ inputs: { x: i2 }, backend: r2, attrs: { shape: m2 } });
  else if (x2 || y2) {
    va.assert(i2.shape.length >= 1, () => "Input must have rank at least 1, got: " + i2.shape.length);
    let e21 = xf.computeOutShape(b2, g2, v2), n3 = bI({ inputs: { x: i2 }, backend: r2, attrs: { begin: b2, size: e21 } });
    t2 = fS({ inputs: { x: n3 }, backend: r2, attrs: { shape: m2 } }), r2.disposeIntermediateTensorInfo(n3);
  } else if (r2.shouldExecuteOnCPU([i2])) {
    let e21 = r2.readSync(i2.dataId), n3 = uo(i2.shape, i2.dtype, e21), a3 = pR(f2, n3, v2, b2);
    t2 = r2.makeTensorInfo(m2, i2.dtype, a3.values);
  } else {
    let e21 = new nF(b2, v2, f2);
    t2 = r2.runWebGLProgram(e21, [i2], i2.dtype);
  }
  let w2 = fS({ inputs: { x: t2 }, backend: r2, attrs: { shape: m2 } });
  return r2.disposeIntermediateTensorInfo(t2), w2;
} };
var aF = { kernelName: Lr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { separator: a2, nGramWidths: i2, leftPad: s2, rightPad: o2, padWidth: l2, preserveShortSequences: u2 } = r2, { data: d2, dataSplits: c2 } = t2, h2 = n2.readSync(d2.dataId), p2 = n2.readSync(c2.dataId), [f2, m2] = fR(h2, p2, a2, i2, s2, o2, l2, u2);
  return [n2.makeTensorInfo([f2.length], "string", f2), n2.makeTensorInfo(c2.shape, "int32", m2)];
} };
var iF = { kernelName: Br, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { skipEmpty: a2 } = r2, { input: i2, delimiter: s2 } = t2;
  if ("string" !== i2.dtype) throw Error("Input must be of datatype string");
  if (1 !== i2.shape.length) throw Error("Input must be a vector, got shape: " + i2.shape);
  if (0 !== s2.shape.length) throw Error("Delimiter must be a scalar, got shape: " + s2.shape);
  let o2 = n2.readSync(i2.dataId), l2 = n2.readSync(s2.dataId)[0], [u2, d2, c2] = mR(o2, l2, a2), h2 = d2.length;
  return [n2.makeTensorInfo([h2, 2], "int32", u2), n2.makeTensorInfo([h2], "string", d2), n2.makeTensorInfo([2], "int32", new Int32Array(c2))];
} };
var sF = { kernelName: Ur, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { numBuckets: a2 } = r2, { input: i2 } = t2;
  if ("string" !== i2.dtype) throw Error("Input must be of datatype string");
  if (0 >= a2) throw Error("Number of buckets must be at least 1");
  let s2 = n2.readSync(i2.dataId), o2 = AR(s2, a2);
  return n2.makeTensorInfo(i2.shape, "int32", o2);
} };
var oF = { kernelName: "Tan", backendName: "webgl", kernelFunc: sS({ opSnippet: "return tan(x);" }) };
var lF = sS({ opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n" });
var uF = { kernelName: Hr, backendName: "webgl", kernelFunc: lF };
var dF = { kernelName: xr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { tensor: r2, indices: a2, updates: i2 } = t2, { sliceRank: s2, numUpdates: o2, sliceSize: l2, strides: u2, outputSize: d2 } = Uf.calculateShapes(i2, a2, r2.shape), c2 = [d2 / l2, l2];
  if (0 === d2) return n2.makeTensorInfo(r2.shape, a2.dtype);
  let h2 = fS({ inputs: { x: a2 }, backend: n2, attrs: { shape: [o2, s2] } }), p2 = fS({ inputs: { x: i2 }, backend: n2, attrs: { shape: [o2, l2] } }), f2 = fS({ inputs: { x: r2 }, backend: n2, attrs: { shape: c2 } }), m2 = new vO(o2, s2, h2.shape.length, p2.shape.length, u2, c2, false, true), A2 = n2.runWebGLProgram(m2, [p2, h2, f2], f2.dtype), x2 = fS({ inputs: { x: A2 }, backend: n2, attrs: { shape: r2.shape } });
  return n2.disposeIntermediateTensorInfo(h2), n2.disposeIntermediateTensorInfo(p2), n2.disposeIntermediateTensorInfo(f2), n2.disposeIntermediateTensorInfo(A2), x2;
} };
var cF = class {
  constructor(e20, t2) {
    this.variableNames = ["A"];
    let n2 = Array(e20.length);
    for (let i2 = 0; n2.length > i2; i2++) n2[i2] = e20[i2] * t2[i2];
    this.outputShape = n2, this.rank = n2.length;
    let r2 = UC(this.rank), a2 = ((e21) => {
      let t3 = e21.length;
      if (t3 > 5) throw Error(`Tile for rank ${t3} is not yet supported`);
      if (1 === t3) return `imod(resRC, ${e21[0]})`;
      let n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r3 = [];
      for (let a3 = 0; e21.length > a3; a3++) r3.push(`imod(${n3[a3]}, ${e21[a3]})`);
      return r3.join();
    })(e20);
    this.userCode = `
      void main() {
        ${r2} resRC = getOutputCoords();
        setOutput(getA(${a2}));
      }
    `;
  }
};
function hF(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { reps: i2 } = r2;
  if ("string" === a2.dtype || a2.shape.length > 5) {
    let e21 = n2.readSync(a2.dataId), t3 = "string" === a2.dtype ? e21.map((e22) => va.decodeString(e22)) : e21, r3 = uo(a2.shape, a2.dtype, t3), s3 = yR(r3, i2);
    return n2.makeTensorInfo(s3.shape, s3.dtype, s3.values);
  }
  let s2 = new cF(a2.shape, i2);
  return n2.runWebGLProgram(s2, [a2], a2.dtype);
}
var pF = { kernelName: Xr, backendName: "webgl", kernelFunc: hF };
var fF = class {
  constructor(e20) {
    this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "negativeInf", type: "float" }, { name: "dir", type: "int" }, { name: "inc", type: "int" }], this.outputShape = e20, this.userCode = "\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     ";
  }
};
var mF = class {
  constructor(e20) {
    this.variableNames = ["x", "indices"], this.customUniforms = [{ name: "n", type: "int" }, { name: "firstPass", type: "int" }, { name: "k", type: "int" }], this.outputShape = e20, this.userCode = "\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     ";
  }
};
function AF(e20, t2) {
  null !== t2 && e20.disposeIntermediateTensorInfo(t2);
}
function xF(e20) {
  let t2 = 1;
  for (; e20 > t2; ) t2 *= 2;
  return t2;
}
var yF;
var bF;
var gF;
var vF = { kernelName: qr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { k: i2, sorted: s2 } = r2, o2 = _e().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), l2 = _e().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), u2 = a2.shape, d2 = u2[u2.length - 1];
  if (n2.shouldExecuteOnCPU([a2]) || o2 > d2 || i2 > l2) {
    let e21 = n2.readSync(a2.dataId), [t3, r3] = bR(e21, u2, a2.dtype, i2, s2);
    return [n2.makeTensorInfo(t3.shape, t3.dtype, t3.values), n2.makeTensorInfo(r3.shape, r3.dtype, r3.values)];
  }
  if (0 === i2) return u2[u2.length - 1] = 0, [n2.makeTensorInfo(u2, a2.dtype, []), n2.makeTensorInfo(u2, "int32", [])];
  if (1 === d2) return [a2, eT({ attrs: { shape: u2, dtype: "int32", value: 0 }, backend: n2 })];
  let c2 = n2.texData.get(a2.dataId), h2 = null !== c2 && c2.isPacked, p2 = h2 ? n2.unpackTensor(a2) : a2, f2 = va.sizeFromShape(u2) / d2, m2 = fS({ inputs: { x: p2 }, attrs: { shape: [f2, d2] }, backend: n2 });
  h2 && AF(n2, p2);
  let A2 = xF(i2), x2 = xF(d2), y2 = null, b2 = () => null === y2 ? [m2, m2] : [m2, y2], g2 = (e21, t3, r3) => {
    let a3 = b2(), i3 = new fF(r3), s3 = y2;
    y2 = n2.runWebGLProgram(i3, a3, "int32", [[d2], [null === y2 ? 1 : 0], [-Infinity], [e21], [t3]]), AF(n2, s3);
  };
  for (let C2 = 1; A2 > C2; C2 *= 2) {
    let e21 = 2 * C2;
    for (let t3 = C2; t3 >= 1; t3 /= 2) g2(e21, t3, [f2, x2]);
  }
  for (let C2 = x2; C2 > A2; C2 /= 2) {
    let e21 = b2(), t3 = new mF([f2, C2 / 2]), r3 = y2;
    y2 = n2.runWebGLProgram(t3, e21, "int32", [[d2], [null === y2 ? 1 : 0], [A2]]), AF(n2, r3);
    let a3 = A2 / 2, i3 = 2 * a3;
    for (let n3 = a3; n3 >= 1; n3 /= 2) g2(i3, n3, y2.shape);
  }
  let v2 = y2;
  y2 = bI({ inputs: { x: y2 }, backend: n2, attrs: { begin: 0, size: [f2, i2] } }), AF(n2, v2);
  let w2 = bT({ inputs: { x: m2, indices: y2 }, backend: n2, attrs: { axis: 1, batchDims: 1 } });
  AF(n2, m2);
  let k2 = u2.slice(0, -1);
  k2.push(i2), v2 = y2, y2 = fS({ inputs: { x: y2 }, attrs: { shape: k2 }, backend: n2 }), AF(n2, v2);
  let N2 = w2;
  return w2 = fS({ inputs: { x: w2 }, attrs: { shape: k2 }, backend: n2 }), AF(n2, N2), [w2, y2];
} };
var wF = class {
  constructor(e20, t2, n2, r2, a2, i2) {
    this.variableNames = ["Image", "Transforms"], this.outputShape = i2;
    let s2, o2 = "nearest" === n2 ? 1 : 2;
    switch (r2) {
      case "constant":
      default:
        s2 = 1;
        break;
      case "reflect":
        s2 = 2;
        break;
      case "wrap":
        s2 = 3;
        break;
      case "nearest":
        s2 = 4;
    }
    this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${s2} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${s2} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${s2} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e20} && 0 <= coordX && coordX < ${t2}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a2});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a2});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t2}));
                float mapY = mapCoord(inY, float(${e20}));

                if (${o2} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
  }
};
var kF = { kernelName: Zr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { image: a2, transforms: i2 } = t2, { interpolation: s2, fillMode: o2, fillValue: l2, outputShape: u2 } = r2, [d2, c2, h2, p2] = a2.shape, [f2, m2] = null != u2 ? u2 : [c2, h2], A2 = new wF(c2, h2, s2, o2, l2, [d2, f2, m2, p2]);
  return n2.runWebGLProgram(A2, [a2, i2], "float32");
} };
var NF = { kernelName: Yr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { axis: a2 } = n2, { x: i2 } = t2;
  $C(i2, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
  let s2 = r2.readSync(i2.dataId), { outputValues: o2, outputShape: l2, indices: u2 } = vR(s2, a2, i2.shape, i2.dtype);
  return [r2.makeTensorInfo(l2, i2.dtype, o2), r2.makeTensorInfo([u2.length], "int32", u2)];
} };
var CF = { kernelName: Jr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { value: a2 } = t2, { axis: i2 } = r2;
  0 > i2 && (i2 += a2.shape.length);
  let s2 = a2, o2 = s2.shape.length, l2 = a2.shape[i2], u2 = Array(o2 - 1), d2 = 0;
  for (let m2 = 0; o2 > m2; m2++) m2 !== i2 && (u2[d2++] = s2.shape[m2]);
  let c2 = [], h2 = Array(o2).fill(0), p2 = s2.shape.slice();
  p2[i2] = 1;
  let f2 = Array(l2);
  for (let m2 = 0; f2.length > m2; m2++) {
    h2[i2] = m2;
    let e21 = bI({ inputs: { x: s2 }, backend: n2, attrs: { begin: h2, size: p2 } }), t3 = fS({ inputs: { x: e21 }, backend: n2, attrs: { shape: u2 } });
    f2[m2] = t3, c2.push(e21);
  }
  return c2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), f2;
} };
var $F = class {
  constructor(e20, t2) {
    this.variableNames = ["x", "segmentIds"];
    let n2 = e20.windowSize, r2 = e20.inSize, a2 = e20.numSegments;
    this.outputShape = [e20.batchSize, a2 * Math.ceil(r2 / n2)];
    let i2 = 4 * Math.floor(n2 / 4), s2 = n2 % 4, o2 = "\n        sumValue += dot(values, segFilter);\n    ", l2 = "";
    r2 % n2 > 0 && (l2 = `
        if (inIdx < 0 || inIdx >= ${r2}) {
          return initializationValue;
        }
      `);
    let u2 = "";
    r2 % n2 > 0 && (u2 = `
        if (inIdx < 0 || inIdx >= ${r2}) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${l2}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${u2}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a2})) * float(${n2}));
        int currentSeg = int(mod(float(outIdx), float(${a2})));

        float sumValue = 0.0;

        for (int i = 0; i < ${i2}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${o2}
        }

        int inIdx = inOffset + ${i2};
        if (${1 === s2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${o2}
        } else if (${2 === s2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${o2}
        } else if (${3 === s2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${o2}
        }
        setOutput(sumValue);
      }
    `;
  }
};
var RF = { kernelName: Qr, backendName: "webgl", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, segmentIds: i2 } = t2, { numSegments: s2 } = r2, o2 = a2.shape.length, l2 = [], u2 = 0, d2 = Uf.getAxesPermutation([u2], o2), c2 = a2;
  null != d2 && (c2 = NS({ inputs: { x: a2 }, backend: n2, attrs: { perm: d2 } }), l2.push(c2), u2 = Uf.getInnerMostAxes(1, o2)[0]);
  let h2 = Uf.segment_util.computeOutShape(c2.shape, u2, s2), p2 = va.sizeFromShape([c2.shape[u2]]), f2 = fS({ inputs: { x: c2 }, backend: n2, attrs: { shape: [-1, p2] } });
  l2.push(f2);
  let m2 = fi(a2.dtype), A2 = (e21, t3, r3, a3, i3) => {
    let s3 = e21.shape[0], o3 = e21.shape[1], u3 = Uf.segment_util.segOpComputeOptimalWindowSize(o3, i3), d3 = new $F({ windowSize: u3, inSize: o3, batchSize: s3, numSegments: i3 }, t3), c3 = n2.compileAndRun(d3, [e21, r3], a3);
    if (l2.push(c3), c3.shape[1] === i3) return c3;
    let h3 = qM({ backend: n2, attrs: { start: 0, stop: i3, step: 1, dtype: "float32" } }), p3 = hF({ inputs: { x: h3 }, backend: n2, attrs: { reps: [o3 / u3] } });
    return l2.push(h3), l2.push(p3), A2(c3, t3, p3, a3, i3);
  }, x2 = fS({ inputs: { x: A2(f2, "unsortedSegmentSum", i2, m2, s2) }, backend: n2, attrs: { shape: h2 } }), y2 = x2;
  if (null != d2) {
    l2.push(x2);
    let e21 = Uf.getUndoAxesPermutation(d2);
    y2 = NS({ inputs: { x: y2 }, backend: n2, attrs: { perm: e21 } });
  }
  return l2.forEach((e21) => n2.disposeIntermediateTensorInfo(e21)), y2;
} };
var SF = [RS, IS, TS, OS, PS, _S, DS, WS, HS, XS, ZS, YS, QS, tI, rI, sI, oI, dI, cI, hI, mI, vI, wI, kI, NI, II, MI, PI, JR, _I, HI, tE, sE, lE, uE, dE, cE, hE, fE, AE, vE, wE, kE, CE, SE, TE, ME, FE, zE, VE, _E, DE, LE, BE, jE, HE, ZE, JE, nT, aT, oT, uT, hT, fT, mT, xT, gT, wT, NT, KR, CT, UI, RT, IT, TT, tS, OT, PT, zT, VT, DT, LT, UT, GT, qT, KT, JT, eM, tM, nM, iM, sM, oM, lM, uM, cM, fM, mM, NM, pS, $M, SM, EM, MM, $I, FM, VM, _M, BM, UM, aS, jM, GM, HM, XM, ZM, SI, yM, YM, QM, tO, mS, aO, sO, uO, cO, fO, AO, yO, gO, kO, CO, RO, IO, TO, OO, FO, zO, gI, kM, _O, DO, WO, LO, BO, UO, jO, GO, qO, KO, QO, eF, tF, rF, aF, iF, sF, vM, kS, oF, uF, dF, pF, vF, kF, CS, NF, CF, RF, zM];
for (let a0 of SF) ma(a0);
((e20) => {
  e20[e20.float32 = 0] = "float32", e20[e20.int32 = 1] = "int32", e20[e20.bool = 2] = "bool", e20[e20.string = 3] = "string", e20[e20.complex64 = 4] = "complex64";
})(yF || (yF = {})), ((e20) => {
  e20[e20.linear = 0] = "linear", e20[e20.relu = 1] = "relu", e20[e20.relu6 = 2] = "relu6", e20[e20.prelu = 3] = "prelu", e20[e20.leakyrelu = 4] = "leakyrelu", e20[e20.sigmoid = 5] = "sigmoid", e20[e20.elu = 6] = "elu";
})(bF || (bF = {}));
var IF = { kernelName: ia, backendName: "wasm", setupFunc(e20) {
  gF = e20.wasm.cwrap(ia, null, ["number", "array", "number", "number", "array", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { a: a2, b: i2, bias: s2, preluActivationWeights: o2 } = t2;
  if ("float32" !== a2.dtype || "float32" !== i2.dtype) throw Error("_FusedMatMul for non non-float32 tensors not yet supported.");
  let { transposeA: l2, transposeB: u2, activation: d2, leakyreluAlpha: c2 } = r2, h2 = n2.dataIdMap.get(a2.dataId).id, p2 = n2.dataIdMap.get(i2.dataId).id, f2 = 0;
  if (null != s2) {
    let e21 = n2.dataIdMap.get(s2.dataId);
    if (1 !== e21.shape.length) throw Error(`_FusedMatMul only supports rank-1 bias but got rank ${e21.shape.length}.`);
    f2 = e21.id;
  }
  let m2 = null == o2 ? 0 : n2.dataIdMap.get(o2.dataId).id, A2 = bF[d2];
  if (null == A2) throw Error(d2 + " activation not yet supported for FusedConv2D in the wasm backend.");
  let x2 = l2 ? a2.shape[2] : a2.shape[1], y2 = u2 ? i2.shape[1] : i2.shape[2], b2 = Fl.assertAndGetBroadcastShape(a2.shape.slice(0, -2), i2.shape.slice(0, -2)), g2 = n2.makeOutput([...b2, x2, y2], a2.dtype), v2 = n2.dataIdMap.get(g2.dataId).id, w2 = new Uint8Array(new Int32Array(a2.shape).buffer), k2 = new Uint8Array(new Int32Array(i2.shape).buffer);
  return gF(h2, w2, a2.shape.length, p2, k2, i2.shape.length, l2, u2, A2, f2, m2, c2 || 0, v2), g2;
} };
function EF(e20, t2) {
  let n2;
  return { kernelName: e20, backendName: "wasm", setupFunc(t3) {
    n2 = t3.wasm.cwrap(e20, null, ["number", "number", "number"]);
  }, kernelFunc(e21) {
    let { backend: r2, inputs: { x: a2 } } = e21, i2 = r2.dataIdMap.get(a2.dataId).id, s2 = r2.makeOutput(a2.shape, t2 || a2.dtype), o2 = r2.dataIdMap.get(s2.dataId).id;
    return 0 === va.sizeFromShape(s2.shape) || n2(i2, yF[a2.dtype], o2), s2;
  } };
}
var TF = EF("Abs");
var MF = EF(je);
var OF = EF(Ge);
function FF(e20, t2, n2) {
  let r2;
  return { kernelName: e20, backendName: "wasm", setupFunc(t3) {
    r2 = t3.wasm.cwrap(e20, null, ["number", "array", "number", "number", "array", "number", "number", "number"]);
  }, kernelFunc(e21) {
    let { backend: t3, inputs: a2 } = e21, { a: i2, b: s2 } = a2, o2 = t3.dataIdMap.get(i2.dataId).id, l2 = t3.dataIdMap.get(s2.dataId).id, u2 = null != n2 ? n2 : i2.dtype, d2 = Uf.assertAndGetBroadcastShape(i2.shape, s2.shape), c2 = t3.makeOutput(d2, u2);
    if (0 === va.sizeFromShape(d2)) return c2;
    let h2 = new Uint8Array(new Int32Array(i2.shape).buffer), p2 = new Uint8Array(new Int32Array(s2.shape).buffer), f2 = t3.dataIdMap.get(c2.dataId).id;
    return r2(o2, h2, i2.shape.length, l2, p2, s2.shape.length, yF[i2.dtype], f2), c2;
  } };
}
var PF;
var zF = FF("Add");
var VF = { kernelName: Xe, backendName: "wasm", setupFunc(e20) {
  PF = e20.wasm.cwrap(Xe, null, ["array", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, r2 = n2.makeOutput(t2[0].shape, t2[0].dtype);
  if (0 === va.sizeFromShape(r2.shape)) return r2;
  let a2 = t2.map((e21) => n2.dataIdMap.get(e21.dataId).id), i2 = new Uint8Array(new Int32Array(a2).buffer), s2 = n2.dataIdMap.get(r2.dataId).id;
  return PF(i2, a2.length, yF[r2.dtype], s2), r2;
} };
function _F(e20) {
  let { inputs: { x: t2 }, backend: n2 } = e20;
  if ("string" === t2.dtype) return Ui(n2.readSync(t2.dataId), t2.shape, t2.dtype);
  let r2 = n2.makeOutput(t2.shape, t2.dtype), a2 = n2.typedArrayFromHeap(t2);
  return n2.typedArrayFromHeap(r2).set(a2), r2;
}
var DF;
var WF = { kernelName: sn, backendName: "wasm", kernelFunc: _F };
function LF(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, [a2, i2] = ((e21, t3) => {
    let n3 = [], r3 = [];
    for (let a3 = 0; e21.length > a3; ++a3) 1 !== e21[a3] && n3.push(e21[a3]), 1 !== e21[t3[a3]] && r3.push(t3[a3]);
    for (let a3 = 0; r3.length > a3; ++a3) {
      let e22 = -1;
      for (let t4 = 0; r3.length > t4; ++t4) r3[t4] >= a3 && (-1 === e22 || r3[e22] > r3[t4]) && (e22 = t4);
      r3[e22] = a3;
    }
    return [n3, r3];
  })(t2.x.shape, r2.perm), s2 = true;
  for (let f2 = 0; i2.length > f2; f2++) i2[f2] !== f2 && (s2 = false);
  let o2 = ((e21, t3) => {
    let n3 = Array(e21.length);
    for (let r3 = 0; n3.length > r3; r3++) n3[r3] = e21[t3[r3]];
    return n3;
  })(t2.x.shape, r2.perm), l2 = { dataId: t2.x.dataId, shape: a2, dtype: t2.x.dtype };
  if (s2) {
    let e21 = _F({ inputs: t2, backend: n2 });
    return e21.shape = o2, e21;
  }
  let u2 = n2.makeOutput(o2, l2.dtype), d2 = n2.dataIdMap.get(l2.dataId).id, c2 = n2.dataIdMap.get(u2.dataId).id, h2 = new Uint8Array(new Int32Array(i2).buffer), p2 = new Uint8Array(new Int32Array(l2.shape).buffer);
  return DF(d2, p2, l2.shape.length, yF[l2.dtype], c2, h2, i2.length), u2;
}
var BF;
var UF = { kernelName: Kr, backendName: "wasm", kernelFunc: LF, setupFunc(e20) {
  DF = e20.wasm.cwrap(Kr, null, ["number", "array", "number", "number", "number", "array", "number"]);
} };
function jF(e20, t2, n2) {
  let r2 = e20.shape, a2 = e20.shape.length, i2 = va.parseAxisParam(t2, r2), s2 = i2, o2 = Uf.getAxesPermutation(s2, a2), l2 = null, u2 = false;
  if (null != o2) {
    let t3 = Array(a2);
    for (let e21 = 0; t3.length > e21; e21++) t3[e21] = r2[o2[e21]];
    s2 = Uf.getInnerMostAxes(s2.length, a2), l2 = LF({ inputs: { x: e20 }, attrs: { perm: o2 }, backend: n2 });
    let i3 = n2.dataIdMap.get(e20.dataId).id;
    n2.dataIdMap.get(l2.dataId).id !== i3 && (u2 = true);
  }
  return { transposed: l2, originalAxes: i2, axes: s2, inputWasTransposed: u2 };
}
var GF;
var HF = { kernelName: "All", backendName: "wasm", setupFunc(e20) {
  BF = e20.wasm.cwrap("All", null, ["number, number, number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { axis: a2, keepDims: i2 } = r2, { x: s2 } = n2, o2 = t2.dataIdMap.get(s2.dataId).id, l2 = s2, { transposed: u2, axes: d2, originalAxes: c2, inputWasTransposed: h2 } = jF(s2, a2, t2);
  h2 && (l2 = u2, o2 = t2.dataIdMap.get(u2.dataId).id), Uf.assertAxesAreInnerMostDims("all", d2, l2.shape.length);
  let [p2, f2] = Uf.computeOutAndReduceShapes(l2.shape, d2), m2 = va.sizeFromShape(f2), A2 = t2.makeOutput(p2, s2.dtype);
  if (0 !== va.sizeFromShape(l2.shape)) {
    let e21 = t2.dataIdMap.get(A2.dataId).id;
    BF(o2, m2, e21);
  }
  if (h2 && t2.disposeData(u2.dataId), i2) {
    let e21 = Uf.expandShapeToKeepDim(A2.shape, c2);
    A2.shape = e21;
  }
  return A2;
} };
var XF = { kernelName: "Any", backendName: "wasm", setupFunc(e20) {
  GF = e20.wasm.cwrap("Any", null, ["number, number, number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { axis: a2, keepDims: i2 } = r2, { x: s2 } = n2, o2 = t2.dataIdMap.get(s2.dataId).id, l2 = s2, { transposed: u2, axes: d2, originalAxes: c2, inputWasTransposed: h2 } = jF(s2, a2, t2);
  h2 && (l2 = u2, o2 = t2.dataIdMap.get(u2.dataId).id), Uf.assertAxesAreInnerMostDims("any", d2, l2.shape.length);
  let [p2, f2] = Uf.computeOutAndReduceShapes(l2.shape, d2), m2 = va.sizeFromShape(f2), A2 = t2.makeOutput(p2, s2.dtype);
  if (0 !== va.sizeFromShape(l2.shape)) {
    let e21 = t2.dataIdMap.get(A2.dataId).id;
    GF(o2, m2, e21);
  }
  if (h2 && t2.disposeData(u2.dataId), i2) {
    let e21 = Uf.expandShapeToKeepDim(A2.shape, c2);
    A2.shape = e21;
  }
  return A2;
} };
function qF(e20) {
  let t2;
  return { kernelName: e20, backendName: "wasm", setupFunc(n2) {
    t2 = n2.wasm.cwrap(e20, null, ["number", "number", "number", "number", "number"]);
  }, kernelFunc(e21) {
    let { backend: n2, inputs: r2, attrs: a2 } = e21, { axis: i2 } = a2, { x: s2 } = r2, o2 = n2.dataIdMap.get(s2.dataId).id, l2 = o2, u2 = s2, { transposed: d2, axes: c2, inputWasTransposed: h2 } = jF(s2, i2, n2);
    if (h2) {
      let e22 = n2.dataIdMap.get(d2.dataId).id;
      e22 !== o2 && (u2 = d2, l2 = e22);
    }
    let p2 = u2.shape.slice(0, -1), f2 = n2.makeOutput(p2, "int32"), m2 = n2.dataIdMap.get(f2.dataId).id, A2 = va.sizeFromShape(f2.shape);
    return t2(l2, yF[u2.dtype], A2, u2.shape[c2[0]], m2), h2 && n2.disposeData(d2.dataId), f2;
  } };
}
var ZF;
var KF;
var YF;
var JF;
var QF = qF(Ke);
var eP = qF(Ye);
var tP = EF(Je);
var nP = EF(Qe);
var rP = EF(et);
var aP = FF(nt);
var iP = EF(tt);
var sP = { kernelName: rt, backendName: "wasm", setupFunc(e20) {
  ZF = e20.wasm.cwrap(rt, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, a2 = t2.x, i2 = r2.dataIdMap.get(a2.dataId).id, { filterSize: s2, strides: o2, pad: l2, dimRoundingMode: u2 } = n2, d2 = Uf.computePool2DInfo(a2.shape, s2, o2, 1, l2, u2), c2 = d2.filterHeight, h2 = d2.filterWidth, p2 = d2.padInfo.top, f2 = d2.padInfo.right, m2 = d2.padInfo.bottom, A2 = d2.padInfo.left, x2 = d2.strideHeight, y2 = d2.strideWidth, b2 = d2.inChannels;
  if ("channelsLast" !== d2.dataFormat) throw Error(`wasm backend does not support dataFormat:'${d2.dataFormat}'. Please use 'channelsLast'.`);
  if (1 !== d2.dilationWidth || 1 !== d2.dilationHeight) throw Error(`was backend only supports average pooling with dilation = [1, 1], got [${d2.dilationHeight}, ${d2.dilationWidth}].`);
  let g2 = r2.makeOutput(d2.outShape, "float32"), v2 = r2.dataIdMap.get(g2.dataId).id;
  return ZF(i2, a2.shape[0], a2.shape[1], a2.shape[2], c2, h2, p2, f2, m2, A2, x2, y2, b2, v2), g2;
} };
var oP = { kernelName: it, backendName: "wasm", setupFunc(e20) {
  KF = e20.wasm.cwrap("AvgPool3D", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2, dataFormat: u2 } = r2, d2 = Uf.computePool3DInfo(a2.shape, i2, s2, 1, o2, l2, u2), c2 = n2.makeOutput(d2.outShape, a2.dtype);
  return KF(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(c2.dataId).id, d2.batchSize, d2.inChannels, d2.inDepth, d2.inHeight, d2.inWidth, d2.outDepth, d2.outHeight, d2.outWidth, d2.strideDepth, d2.strideHeight, d2.strideWidth, d2.dilationDepth, d2.dilationHeight, d2.dilationWidth, d2.effectiveFilterDepth, d2.effectiveFilterHeight, d2.effectiveFilterWidth, d2.padInfo.front, d2.padInfo.top, d2.padInfo.left), c2;
} };
var lP = { kernelName: st, backendName: "wasm", setupFunc(e20) {
  YF = e20.wasm.cwrap("AvgPool3DGrad", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, { filterSize: s2, strides: o2, pad: l2, dimRoundingMode: u2 } = r2, d2 = Uf.computePool3DInfo(i2.shape, s2, o2, 1, l2, u2), c2 = n2.makeOutput(i2.shape, i2.dtype);
  return YF(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(c2.dataId).id, d2.batchSize, d2.inChannels, d2.inDepth, d2.inHeight, d2.inWidth, d2.outDepth, d2.outHeight, d2.outWidth, d2.strideDepth, d2.strideHeight, d2.strideWidth, d2.dilationDepth, d2.dilationHeight, d2.dilationWidth, d2.effectiveFilterDepth, d2.effectiveFilterHeight, d2.effectiveFilterWidth, d2.padInfo.front, d2.padInfo.top, d2.padInfo.left, d2.filterDepth, d2.filterHeight, d2.filterWidth), c2;
} };
var uP = { kernelName: at, backendName: "wasm", setupFunc(e20) {
  JF = e20.wasm.cwrap("AvgPoolGrad", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, { filterSize: s2, strides: o2, pad: l2 } = r2, u2 = Uf.computePool2DInfo(i2.shape, s2, o2, 1, l2), d2 = n2.makeOutput(i2.shape, i2.dtype);
  return JF(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(d2.dataId).id, u2.batchSize, u2.inChannels, u2.inHeight, u2.inWidth, u2.outHeight, u2.outWidth, u2.strideHeight, u2.strideWidth, u2.dilationHeight, u2.dilationWidth, u2.effectiveFilterHeight, u2.effectiveFilterWidth, u2.padInfo.top, u2.padInfo.left, u2.filterHeight, u2.filterWidth), d2;
} };
function dP(e20) {
  let { inputs: t2, attrs: n2 } = e20, { x: r2 } = t2, { shape: a2 } = n2, i2 = va.sizeFromShape(r2.shape), s2 = va.inferFromImplicitShape(a2, i2);
  return va.assert(i2 === va.sizeFromShape(s2), () => `new shape: ${s2}, old shape: ${r2.shape}. New shape and old shape must have the same number of elements.`), e20.backend.incRef(r2.dataId), { dataId: r2.dataId, shape: s2, dtype: r2.dtype };
}
var cP;
var hP = { kernelName: or, backendName: "wasm", kernelFunc: dP };
var pP = { kernelName: ot, backendName: "wasm", setupFunc(e20) {
  cP = e20.wasm.cwrap(ot, null, ["number", "array", "number", "number", "array", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { a: a2, b: i2 } = t2, { transposeA: s2, transposeB: o2 } = r2;
  if ("float32" !== a2.dtype || "float32" !== i2.dtype) throw Error("BatchMatMul for non non-float32 tensors not yet supported.");
  let l2 = a2.shape.length, u2 = i2.shape.length, d2 = s2 ? a2.shape[l2 - 2] : a2.shape[l2 - 1], c2 = o2 ? i2.shape[u2 - 1] : i2.shape[u2 - 2], h2 = s2 ? a2.shape[l2 - 1] : a2.shape[l2 - 2], p2 = o2 ? i2.shape[u2 - 2] : i2.shape[u2 - 1], f2 = a2.shape.slice(0, -2), m2 = i2.shape.slice(0, -2), A2 = va.sizeFromShape(f2), x2 = va.sizeFromShape(m2), y2 = Fl.assertAndGetBroadcastShape(a2.shape.slice(0, -2), i2.shape.slice(0, -2)).concat([h2, p2]);
  va.assert(d2 === c2, () => `Error in matMul: inner shapes (${d2}) and (${c2}) of Tensors with shapes ${a2.shape} and ${i2.shape} and transposeA=${s2} and transposeB=${o2} must match.`);
  let b2 = o2 ? [x2, p2, c2] : [x2, c2, p2], g2 = dP({ inputs: { x: a2 }, backend: n2, attrs: { shape: s2 ? [A2, d2, h2] : [A2, h2, d2] } }), v2 = dP({ inputs: { x: i2 }, backend: n2, attrs: { shape: b2 } }), w2 = n2.dataIdMap.get(g2.dataId).id, k2 = n2.dataIdMap.get(v2.dataId).id, N2 = s2 ? g2.shape[2] : g2.shape[1], C2 = o2 ? v2.shape[1] : v2.shape[2], $2 = n2.makeOutput([Math.max(A2, x2), N2, C2], g2.dtype), R2 = n2.dataIdMap.get($2.dataId).id, S2 = new Uint8Array(new Int32Array(g2.shape).buffer), I2 = new Uint8Array(new Int32Array(v2.shape).buffer);
  return cP(w2, S2, g2.shape.length, k2, I2, v2.shape.length, s2, o2, R2), n2.disposeData(g2.dataId), n2.disposeData(v2.dataId), $2.shape = y2, $2;
} };
function fP(e20) {
  let { inputs: { x: t2 }, attrs: { begin: n2, size: r2 }, backend: a2 } = e20, [i2, s2] = xf.parseSliceParams(t2, n2, r2), o2 = xf.isSliceContinous(t2.shape, i2, s2), l2 = a2.readSync(t2.dataId), u2 = a2.makeOutput(s2, t2.dtype), d2 = va.computeStrides(t2.shape), c2 = a2.dataIdMap.get(u2.dataId);
  if (o2) {
    let e21 = xf.computeFlatOffset(i2, d2);
    return "string" === t2.dtype ? c2.stringBytes = l2.slice(e21, e21 + va.sizeFromShape(s2)) : a2.typedArrayFromHeap(u2).set(l2.subarray(e21, e21 + va.sizeFromShape(s2))), u2;
  }
  if ("string" === t2.dtype) {
    let e21 = Pb(l2, i2, s2, t2.shape, t2.dtype);
    return c2.stringBytes = e21, u2;
  }
  let h2 = a2.typedArrayFromHeap(u2), p2 = t2.shape.length;
  if (2 === p2) ((e21, t3, n3, r3, a3) => {
    let i3 = 0, s3 = r3[0], o3 = r3[1], l3 = s3 + a3[0];
    for (let u3 = s3; l3 > u3; u3++) {
      let r4 = u3 * t3 + o3;
      n3.set(e21.subarray(r4, r4 + a3[1]), i3), i3 += a3[1];
    }
  })(l2, d2[0], h2, i2, s2);
  else if (3 === p2) ((e21, t3, n3, r3, a3, i3) => {
    let s3 = 0, o3 = a3[0], l3 = a3[1], u3 = a3[2], d3 = o3 + i3[0], c3 = l3 + i3[1];
    for (let h3 = o3; d3 > h3; h3++) for (let a4 = l3; c3 > a4; a4++) {
      let o4 = h3 * t3 + a4 * n3 + u3;
      r3.set(e21.subarray(o4, o4 + i3[2]), s3), s3 += i3[2];
    }
  })(l2, d2[0], d2[1], h2, i2, s2);
  else if (4 === p2) ((e21, t3, n3, r3, a3, i3, s3) => {
    let o3 = 0, l3 = i3[0], u3 = i3[1], d3 = i3[2], c3 = l3 + s3[0], h3 = u3 + s3[1], p3 = d3 + s3[2], f2 = i3[3];
    for (let m2 = l3; c3 > m2; m2++) for (let i4 = u3; h3 > i4; i4++) for (let l4 = d3; p3 > l4; l4++) {
      let u4 = m2 * t3 + i4 * n3 + l4 * r3 + f2;
      a3.set(e21.subarray(u4, u4 + s3[3]), o3), o3 += s3[3];
    }
  })(l2, d2[0], d2[1], d2[2], h2, i2, s2);
  else {
    let e21 = Pb(l2, i2, s2, t2.shape, t2.dtype);
    h2.set(e21);
  }
  return u2;
}
var mP;
var AP = { kernelName: vr, backendName: "wasm", kernelFunc: fP };
var xP = { kernelName: lt, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockShape: i2, crops: s2 } = r2, o2 = i2.reduce((e21, t3) => e21 * t3), l2 = Uf.getReshaped(a2.shape, i2, o2), u2 = Uf.getPermuted(l2.length, i2.length), d2 = Uf.getReshapedPermuted(a2.shape, i2, o2), c2 = Uf.getSliceBeginCoords(s2, i2.length), h2 = Uf.getSliceSize(d2, s2, i2.length), p2 = dP({ inputs: { x: a2 }, backend: n2, attrs: { shape: l2 } }), f2 = LF({ inputs: { x: p2 }, backend: n2, attrs: { perm: u2 } }), m2 = dP({ inputs: { x: f2 }, backend: n2, attrs: { shape: d2 } }), A2 = fP({ inputs: { x: m2 }, backend: n2, attrs: { begin: c2, size: h2 } });
  return n2.disposeData(p2.dataId), n2.disposeData(f2.dataId), n2.disposeData(m2.dataId), A2;
} };
var yP = { kernelName: ut, backendName: "wasm", setupFunc(e20) {
  mP = e20.wasm.cwrap(ut, null, ["number", "number", "boolean", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { x: a2, weights: i2 } = n2, { size: s2 } = r2, o2 = 0 !== i2.shape.reduce((e21, t3) => e21 * t3, 1), l2 = t2.makeOutput(1 === a2.shape.length ? [s2] : [a2.shape[0], s2], i2.dtype);
  function u2(e21) {
    return t2.dataIdMap.get(e21.dataId).id;
  }
  return mP(u2(a2), s2, o2, u2(i2), yF[i2.dtype], u2(l2)), l2;
} };
var bP = FF(dt);
var gP = { kernelName: ht, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { s0: r2, s1: a2 } = t2, i2 = n2.typedArrayFromHeap(r2), s2 = n2.typedArrayFromHeap(a2), o2 = Uf.assertAndGetBroadcastShape(Array.from(i2), Array.from(s2));
  return n2.makeOutput([o2.length], "int32", void 0, new Int32Array(o2));
} };
function vP(e20) {
  let { inputs: { x: t2 }, attrs: { dtype: n2 }, backend: r2 } = e20, a2 = r2.makeOutput(t2.shape, n2), i2 = r2.typedArrayFromHeap(t2);
  return r2.typedArrayFromHeap(a2).set(i2), a2;
}
var wP;
var kP = { kernelName: pt, backendName: "wasm", kernelFunc: vP };
var NP = EF(ft);
var CP = { kernelName: mt, backendName: "wasm", setupFunc(e20) {
  wP = e20.wasm.cwrap(mt, null, ["number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { clipValueMin: i2, clipValueMax: s2 } = r2, o2 = n2.dataIdMap.get(a2.dataId).id, l2 = n2.makeOutput(a2.shape, a2.dtype), u2 = n2.dataIdMap.get(l2.dataId).id;
  return wP(o2, i2, s2, u2), l2;
} };
function $P(e20) {
  let { inputs: t2, backend: n2 } = e20, r2 = va.parseAxisParam(e20.attrs.axis, t2[0].shape)[0], a2 = t2.map((e21) => e21.shape);
  Uf.assertParamsConsistent(a2, r2);
  let i2 = Uf.computeOutShape(t2.map((e21) => e21.shape), r2), s2 = t2.filter((e21) => va.sizeFromShape(e21.shape) > 0);
  if (1 === s2.length) return _F({ inputs: { x: s2[0] }, backend: n2 });
  let o2 = n2.makeOutput(i2, t2[0].dtype);
  if (0 === va.sizeFromShape(i2)) return o2;
  if ("string" === s2[0].dtype) {
    let e21 = s2.map((e22) => {
      let t3 = [-1, va.sizeFromShape(e22.shape.slice(r2))];
      return dP({ inputs: { x: e22 }, backend: n2, attrs: { shape: t3 } });
    }), a3 = e21.map((e22) => ({ vals: n2.readSync(e22.dataId), shape: e22.shape }));
    i2 = Uf.computeOutShape(e21.map((e22) => e22.shape), 1);
    let l3 = yy(a3, i2, t2[0].dtype, 1 === e21[0].shape[0]), u3 = Uf.computeOutShape(s2.map((e22) => e22.shape), r2);
    return o2.shape = u3, n2.dataIdMap.get(o2.dataId).stringBytes = Uf.fromStringArrayToUint8(l3), e21.forEach((e22) => n2.disposeData(e22.dataId)), o2;
  }
  let l2 = va.sizeFromShape(s2[0].shape.slice(0, r2)), u2 = 0, d2 = s2.map((e21) => {
    let t3 = va.sizeFromShape(e21.shape.slice(r2));
    return u2 += t3, t3;
  }), c2 = s2.map((e21) => n2.typedArrayFromHeap(e21)), h2 = n2.typedArrayFromHeap(o2);
  for (let p2 = 0; l2 > p2; p2++) {
    let e21 = p2 * u2;
    for (let t3 = 0; c2.length > t3; t3++) {
      let n3 = d2[t3], r3 = p2 * n3, a3 = c2[t3].subarray(r3, r3 + n3);
      h2.set(a3, e21), e21 += n3;
    }
  }
  return o2;
}
var RP;
var SP;
var IP;
var EP;
var TP;
var MP;
var OP;
var FP = { kernelName: yt, backendName: "wasm", kernelFunc: $P };
var PP = { kernelName: bt, backendName: "wasm", setupFunc(e20) {
  RP = e20.wasm.cwrap(bt, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { x: a2, filter: i2 } = t2, s2 = r2.dataIdMap.get(a2.dataId).id, o2 = r2.dataIdMap.get(i2.dataId).id, { strides: l2, dilations: u2, pad: d2, dimRoundingMode: c2, dataFormat: h2 } = n2, p2 = Uf.convertConv2DDataFormat(h2), f2 = Uf.computeConv2DInfo(a2.shape, i2.shape, l2, u2, d2, c2, false, p2), m2 = f2.filterHeight, A2 = f2.filterWidth, x2 = f2.padInfo.top, y2 = f2.padInfo.right, b2 = f2.padInfo.bottom, g2 = f2.padInfo.left, v2 = f2.dilationHeight, w2 = f2.dilationWidth, k2 = f2.strideHeight, N2 = f2.strideWidth, C2 = f2.inChannels, $2 = f2.outChannels, R2 = "SAME" === f2.padInfo.type ? 1 : 0;
  if ("channelsLast" !== f2.dataFormat) throw Error(`wasm backend Conv2D does not support dataFormat:'${f2.dataFormat}'. Please use 'channelsLast'.`);
  let S2 = r2.makeOutput(f2.outShape, "float32"), I2 = r2.dataIdMap.get(S2.dataId).id;
  return RP(s2, a2.shape[0], a2.shape[1], a2.shape[2], o2, m2, A2, x2, y2, b2, g2, R2, v2, w2, k2, N2, C2, $2, I2), S2;
} };
var zP = { kernelName: vt, backendName: "wasm", setupFunc(e20) {
  SP = e20.wasm.cwrap(vt, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = n2, { strides: s2, pad: o2, dataFormat: l2, dimRoundingMode: u2, inputShape: d2 } = r2, c2 = Uf.convertConv2DDataFormat(l2), h2 = Uf.computeConv2DInfo(d2, i2.shape, s2, 1, o2, u2, false, c2), { batchSize: p2, filterHeight: f2, filterWidth: m2, inChannels: A2, inHeight: x2, inWidth: y2, outChannels: b2, outHeight: g2, outWidth: v2, strideHeight: w2, strideWidth: k2 } = h2, N2 = f2 - 1 - h2.padInfo.top, C2 = m2 - 1 - h2.padInfo.left, $2 = "channelsLast" === h2.dataFormat, R2 = va.computeStrides(h2.inShape), S2 = va.computeStrides(a2.shape), [I2, E2, T2] = va.computeStrides(i2.shape), M2 = R2[0], O2 = $2 ? R2[1] : R2[2], F2 = $2 ? R2[2] : 1, P2 = $2 ? 1 : R2[1], z2 = S2[0], V2 = $2 ? S2[1] : S2[2], _2 = $2 ? S2[2] : 1, D2 = $2 ? 1 : S2[1], W2 = t2.makeOutput(h2.inShape, "float32"), L2 = t2.dataIdMap.get(W2.dataId).id, B2 = t2.dataIdMap.get(a2.dataId).id, U2 = t2.dataIdMap.get(i2.dataId).id;
  return SP(B2, U2, p2, f2, m2, x2, y2, A2, g2, v2, b2, w2, k2, N2, C2, I2, E2, T2, M2, O2, F2, P2, z2, V2, _2, D2, L2), W2;
} };
var VP = { kernelName: wt, backendName: "wasm", setupFunc(e20) {
  IP = e20.wasm.cwrap(wt, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dilations: l2 } = r2;
  if ("float32" !== a2.dtype) throw Error("Tensor x must have dtype float32, got " + a2.dtype);
  if ("float32" !== i2.dtype) throw Error("Tensor filter must have dtype float32, got " + i2.dtype);
  let u2 = Uf.computeConv3DInfo(a2.shape, i2.shape, s2, l2, o2), d2 = n2.makeOutput(u2.outShape, a2.dtype);
  return IP(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(i2.dataId).id, n2.dataIdMap.get(d2.dataId).id, u2.batchSize, u2.inDepth, u2.inHeight, u2.inWidth, u2.inChannels, u2.outDepth, u2.outHeight, u2.outWidth, u2.outChannels, u2.strideDepth, u2.strideHeight, u2.strideWidth, u2.dilationDepth, u2.dilationHeight, u2.dilationWidth, u2.filterDepth, u2.filterHeight, u2.filterWidth, u2.padInfo.front, u2.padInfo.top, u2.padInfo.left), d2;
} };
var _P = { kernelName: kt, backendName: "wasm", setupFunc(e20) {
  EP = e20.wasm.cwrap(kt, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, pad: o2, filterShape: l2 } = r2;
  if ("float32" !== a2.dtype) throw Error("Tensor dy must have dtype float32, got " + a2.dtype);
  if ("float32" !== i2.dtype) throw Error("Tensor filter must have dtype float32, got " + i2.dtype);
  let u2 = Uf.computeConv3DInfo(a2.shape, l2, s2, 1, o2), d2 = n2.makeOutput(u2.filterShape, i2.dtype);
  return EP(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(i2.dataId).id, n2.dataIdMap.get(d2.dataId).id, u2.batchSize, u2.inDepth, u2.inHeight, u2.inWidth, u2.inChannels, u2.outDepth, u2.outHeight, u2.outWidth, u2.outChannels, u2.strideDepth, u2.strideHeight, u2.strideWidth, u2.dilationDepth, u2.dilationHeight, u2.dilationWidth, u2.filterDepth, u2.filterHeight, u2.filterWidth, u2.padInfo.front, u2.padInfo.top, u2.padInfo.left), d2;
} };
var DP = { kernelName: Nt, backendName: "wasm", setupFunc(e20) {
  TP = e20.wasm.cwrap(Nt, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = t2, { pad: s2, strides: o2, inputShape: l2 } = r2;
  if ("float32" !== a2.dtype) throw Error("Tensor dy must have dtype float32, got " + a2.dtype);
  if ("float32" !== i2.dtype) throw Error("Tensor filter must have dtype float32, got " + i2.dtype);
  let u2 = Uf.computeConv3DInfo(l2, i2.shape, o2, 1, s2), d2 = n2.makeOutput(u2.inShape, a2.dtype);
  return TP(n2.dataIdMap.get(i2.dataId).id, n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(d2.dataId).id, u2.batchSize, u2.inDepth, u2.inHeight, u2.inWidth, u2.inChannels, u2.outDepth, u2.outHeight, u2.outWidth, u2.outChannels, u2.strideDepth, u2.strideHeight, u2.strideWidth, u2.dilationDepth, u2.dilationHeight, u2.dilationWidth, u2.filterDepth, u2.filterHeight, u2.filterWidth, u2.padInfo.front, u2.padInfo.top, u2.padInfo.left), d2;
} };
var WP = EF("Cos");
var LP = EF($t);
((e20) => {
  e20[e20.bilinear = 0] = "bilinear", e20[e20.nearest = 1] = "nearest";
})(MP || (MP = {}));
var BP;
var UP;
var jP;
var GP;
var HP;
var XP;
var qP;
var ZP;
var KP;
var YP;
var JP = { kernelName: It, backendName: "wasm", setupFunc(e20) {
  OP = e20.wasm.cwrap(It, null, ["number", "number", "number", "number", "array", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let t2, { backend: n2, inputs: r2, attrs: a2 } = e20, { method: i2, extrapolationValue: s2, cropSize: o2 } = a2, { image: l2, boxes: u2, boxInd: d2 } = r2, c2 = u2.shape[0], [h2, p2] = o2, f2 = [c2, h2, p2, l2.shape[3]], m2 = n2.dataIdMap.get(l2.dataId);
  "float32" !== l2.dtype && (t2 = vP({ backend: n2, inputs: { x: l2 }, attrs: { dtype: "float32" } }), m2 = n2.dataIdMap.get(t2.dataId));
  let A2 = m2.id, x2 = n2.dataIdMap.get(u2.dataId).id, y2 = n2.dataIdMap.get(d2.dataId).id, b2 = n2.makeOutput(f2, "float32"), g2 = n2.dataIdMap.get(b2.dataId).id, v2 = new Uint8Array(new Int32Array(l2.shape).buffer);
  return OP(A2, x2, y2, c2, v2, h2, p2, MP[i2], s2, g2), null != t2 && n2.disposeData(t2.dataId), b2;
} };
var QP = { kernelName: Rt, backendName: "wasm", setupFunc(e20) {
  BP = e20.wasm.cwrap(Rt, null, ["number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, exclusive: s2, reverse: o2 } = r2, l2 = a2.shape.length;
  va.assert("float32" === a2.dtype || "int32" === a2.dtype, () => `cumprod does not support ${a2.dtype} tensors in the WASM backend`);
  let u2 = Uf.getAxesPermutation([i2], l2), d2 = a2;
  null !== u2 && (d2 = LF({ inputs: { x: a2 }, attrs: { perm: u2 }, backend: n2 }));
  let c2 = Uf.getInnerMostAxes(1, l2)[0];
  Uf.assertAxesAreInnerMostDims("cumprod", [c2], l2);
  let h2 = n2.makeOutput(d2.shape, d2.dtype), p2 = d2.shape[c2], f2 = n2.dataIdMap.get(d2.dataId).id, m2 = n2.dataIdMap.get(h2.dataId).id;
  BP(f2, s2 ? 1 : 0, o2 ? 1 : 0, p2, m2, yF[a2.dtype]);
  let A2 = h2;
  return null !== u2 && (A2 = LF({ inputs: { x: h2 }, attrs: { perm: Uf.getUndoAxesPermutation(u2) }, backend: n2 }), n2.disposeData(d2.dataId), n2.disposeData(h2.dataId)), A2;
} };
var ez = { kernelName: St, backendName: "wasm", setupFunc(e20) {
  UP = e20.wasm.cwrap(St, null, ["number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, exclusive: s2, reverse: o2 } = r2, l2 = a2.shape.length;
  va.assert("float32" === a2.dtype || "int32" === a2.dtype, () => `cumsum does not support ${a2.dtype} tensors in the WASM backend`);
  let u2 = Uf.getAxesPermutation([i2], l2), d2 = a2;
  null !== u2 && (d2 = LF({ inputs: { x: a2 }, attrs: { perm: u2 }, backend: n2 }));
  let c2 = Uf.getInnerMostAxes(1, l2)[0];
  Uf.assertAxesAreInnerMostDims("cumsum", [c2], l2);
  let h2 = n2.makeOutput(d2.shape, d2.dtype), p2 = d2.shape[c2], f2 = n2.dataIdMap.get(d2.dataId).id, m2 = n2.dataIdMap.get(h2.dataId).id;
  UP(f2, s2 ? 1 : 0, o2 ? 1 : 0, p2, m2, yF[a2.dtype]);
  let A2 = h2;
  return null !== u2 && (A2 = LF({ inputs: { x: h2 }, attrs: { perm: Uf.getUndoAxesPermutation(u2) }, backend: n2 }), n2.disposeData(d2.dataId), n2.disposeData(h2.dataId)), A2;
} };
var tz = { kernelName: Et, backendName: "wasm", setupFunc(e20) {
  jP = e20.wasm.cwrap("DenseBincount", null, ["number", "array", "number", "number", "boolean", "number", "number", "boolean", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { x: a2, weights: i2 } = n2, { size: s2, binaryOutput: o2 } = r2, l2 = 0 !== i2.shape.reduce((e21, t3) => e21 * t3, 1), u2 = t2.makeOutput(1 === a2.shape.length ? [s2] : [a2.shape[0], s2], i2.dtype);
  function d2(e21) {
    return t2.dataIdMap.get(e21.dataId).id;
  }
  return jP(d2(a2), new Uint8Array(new Int32Array(a2.shape).buffer), a2.shape.length, s2, l2, d2(i2), yF[i2.dtype], o2, d2(u2)), u2;
} };
var nz = { kernelName: Tt, backendName: "wasm", setupFunc(e20) {
  GP = e20.wasm.cwrap(Tt, null, ["number", "number", "number", "array", "number", "array", "array", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { x: a2 } = n2, { blockSize: i2, dataFormat: s2 } = r2, o2 = a2.shape[0], l2 = ("NHWC" === s2 ? a2.shape[1] : a2.shape[2]) * i2, u2 = ("NHWC" === s2 ? a2.shape[2] : a2.shape[3]) * i2, d2 = ("NHWC" === s2 ? a2.shape[3] : a2.shape[1]) / (i2 * i2), c2 = "NHWC" === s2 ? [o2, l2, u2, d2] : [o2, d2, l2, u2], h2 = t2.makeOutput(c2, "float32"), p2 = t2.dataIdMap.get(a2.dataId).id, f2 = new Uint8Array(new Int32Array(va.computeStrides(a2.shape)).buffer), m2 = new Uint8Array(new Int32Array(c2).buffer), A2 = new Uint8Array(new Int32Array(va.computeStrides(c2)).buffer), x2 = t2.dataIdMap.get(h2.dataId).id;
  return GP(p2, i2, "NHWC" === s2 ? 1 : 0, f2, a2.shape.length - 1, m2, A2, c2.length, x2), h2;
} };
var rz = { kernelName: Mt, backendName: "wasm", setupFunc(e20) {
  HP = e20.wasm.cwrap(Mt, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { x: a2, filter: i2 } = t2, s2 = r2.dataIdMap.get(a2.dataId).id, o2 = r2.dataIdMap.get(i2.dataId).id, { strides: l2, dilations: u2, pad: d2, dimRoundingMode: c2 } = n2, h2 = Uf.computeConv2DInfo(a2.shape, i2.shape, l2, u2 ?? [1, 1], d2, c2, true), p2 = h2.filterHeight, f2 = h2.filterWidth, m2 = h2.padInfo.top, A2 = h2.padInfo.right, x2 = h2.padInfo.bottom, y2 = h2.padInfo.left, b2 = h2.dilationHeight, g2 = h2.dilationWidth, v2 = h2.strideHeight, w2 = h2.strideWidth, k2 = h2.inChannels, N2 = h2.outChannels, C2 = "SAME" === h2.padInfo.type ? 1 : 0;
  if ("channelsLast" !== h2.dataFormat) throw Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h2.dataFormat}'. Please use 'channelsLast'.`);
  let $2 = r2.makeOutput(h2.outShape, "float32"), R2 = r2.dataIdMap.get($2.dataId).id;
  return HP(s2, a2.shape[0], a2.shape[1], a2.shape[2], o2, p2, f2, m2, A2, x2, y2, C2, b2, g2, v2, w2, k2, N2, R2), $2;
} };
var az = { kernelName: Pt, backendName: "wasm", setupFunc(e20) {
  XP = e20.wasm.cwrap("Diag", null, ["number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2, a2 = va.sizeFromShape(r2.shape), i2 = n2.makeOutput([...r2.shape, ...r2.shape], r2.dtype);
  return XP(n2.dataIdMap.get(r2.dataId).id, yF[r2.dtype], a2, n2.dataIdMap.get(i2.dataId).id), i2;
} };
var iz = { kernelName: zt, backendName: "wasm", setupFunc(e20) {
  qP = e20.wasm.cwrap(zt, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dilations: l2 } = r2;
  if (a2.dtype !== i2.dtype) throw Error(`Dilation2D error: x must have the same dtype as filter. Got ${a2.dtype} and ${i2.dtype}`);
  let u2 = Uf.computeDilation2DInfo(a2.shape, i2.shape, s2, o2, "NHWC", l2), d2 = n2.makeOutput(u2.outShape, a2.dtype);
  return qP(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(i2.dataId).id, n2.dataIdMap.get(d2.dataId).id, yF[a2.dtype], u2.batchSize, u2.inChannels, u2.inHeight, u2.inWidth, u2.outHeight, u2.outWidth, u2.strideHeight, u2.strideWidth, u2.dilationHeight, u2.dilationWidth, u2.filterHeight, u2.filterWidth, u2.padInfo.top, u2.padInfo.left), d2;
} };
var sz = { kernelName: _t, backendName: "wasm", setupFunc(e20) {
  ZP = e20.wasm.cwrap(_t, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2, dy: s2 } = t2, { strides: o2, pad: l2, dilations: u2 } = r2;
  if (a2.dtype !== i2.dtype || a2.dtype !== s2.dtype) throw Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a2.dtype}, ${i2.dtype}, and ${s2.dtype}`);
  let d2 = Uf.computeDilation2DInfo(a2.shape, i2.shape, o2, l2, "NHWC", u2), c2 = n2.makeOutput(i2.shape, i2.dtype);
  return ZP(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(i2.dataId).id, n2.dataIdMap.get(s2.dataId).id, n2.dataIdMap.get(c2.dataId).id, yF[a2.dtype], d2.batchSize, d2.inChannels, d2.inHeight, d2.inWidth, d2.outHeight, d2.outWidth, d2.strideHeight, d2.strideWidth, d2.dilationHeight, d2.dilationWidth, d2.filterHeight, d2.filterWidth, d2.padInfo.top, d2.padInfo.left), c2;
} };
var oz = { kernelName: Vt, backendName: "wasm", setupFunc(e20) {
  KP = e20.wasm.cwrap(Vt, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2, dy: s2 } = t2, { strides: o2, pad: l2, dilations: u2 } = r2;
  if (a2.dtype !== i2.dtype || a2.dtype !== s2.dtype) throw Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a2.dtype}, ${i2.dtype}, and ${s2.dtype}`);
  let d2 = Uf.computeDilation2DInfo(a2.shape, i2.shape, o2, l2, "NHWC", u2), c2 = n2.makeOutput(a2.shape, a2.dtype);
  return KP(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(i2.dataId).id, n2.dataIdMap.get(s2.dataId).id, n2.dataIdMap.get(c2.dataId).id, yF[a2.dtype], d2.batchSize, d2.inChannels, d2.inHeight, d2.inWidth, d2.outHeight, d2.outWidth, d2.strideHeight, d2.strideWidth, d2.dilationHeight, d2.dilationWidth, d2.filterHeight, d2.filterWidth, d2.padInfo.top, d2.padInfo.left), c2;
} };
var lz = EF("Elu");
var uz = { kernelName: Ut, backendName: "wasm", setupFunc(e20) {
  YP = e20.wasm.cwrap(Ut, null, ["number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { dy: r2, y: a2 } = t2, i2 = n2.makeOutput(a2.shape, "float32"), s2 = (e21) => n2.dataIdMap.get(e21.dataId).id;
  return YP(s2(a2), s2(r2), s2(i2)), i2;
} };
var dz = FF(Gt, 0, "bool");
var cz = EF("Erf");
var hz = EF("Exp", "float32");
function pz(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { input: a2 } = t2, { dim: i2 } = n2, s2 = a2.shape.length, o2 = a2.shape.slice(), l2 = i2;
  return 0 > i2 && (va.assert(i2 >= -(s2 + 1), () => `Axis must be in the interval [${-(s2 + 1)}, ${s2}]`), l2 = s2 + i2 + 1), o2.splice(l2, 0, 1), dP({ inputs: { x: a2 }, backend: r2, attrs: { shape: o2 } });
}
var fz = { kernelName: Xt, backendName: "wasm", kernelFunc: pz };
var mz = EF(qt, "float32");
function Az(e20) {
  let { attrs: { shape: t2, value: n2 }, backend: r2 } = e20, { attrs: { dtype: a2 } } = e20;
  a2 = a2 || va.inferDtype(n2);
  let i2 = r2.makeOutput(t2, a2);
  return r2.typedArrayFromHeap(i2).fill(n2), i2;
}
var xz;
var yz;
var bz;
var gz;
var vz;
var wz;
var kz;
var Nz;
var Cz;
var $z;
var Rz;
var Sz;
var Iz;
var Ez;
var Tz;
var Mz;
var Oz;
var Fz;
var Pz;
var zz;
var Vz = { kernelName: Kt, backendName: "wasm", kernelFunc: Az };
var _z = { kernelName: Yt, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { image: r2 } = t2, a2 = n2.makeOutput(r2.shape, r2.dtype), i2 = n2.dataIdMap.get(r2.dataId).id, s2 = n2.dataIdMap.get(a2.dataId).id, [o2, l2, u2, d2] = r2.shape;
  return xz(i2, o2, l2, u2, d2, s2), a2;
}, setupFunc(e20) {
  xz = e20.wasm.cwrap(Yt, null, ["number", "number", "number", "number", "number", "number"]);
} };
var Dz = EF(Jt);
var Wz = FF(Qt);
var Lz = { kernelName: en, backendName: "wasm", setupFunc(e20) {
  yz = e20.wasm.cwrap(en, null, ["number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { varianceEpsilon: a2 } = r2, { x: i2, mean: s2, variance: o2, offset: l2, scale: u2 } = n2, d2 = t2.dataIdMap.get(i2.dataId).id, c2 = t2.dataIdMap.get(s2.dataId).id, h2 = t2.dataIdMap.get(o2.dataId).id, p2 = null != l2 ? t2.dataIdMap.get(l2.dataId).id : 0, f2 = null != u2 ? t2.dataIdMap.get(u2.dataId).id : 0, m2 = t2.makeOutput(i2.shape, i2.dtype);
  if (0 === va.sizeFromShape(i2.shape)) return m2;
  let A2 = t2.dataIdMap.get(m2.dataId).id;
  return yz(d2, c2, h2, p2, f2, a2, A2), m2;
} };
var Bz = { kernelName: sa, backendName: "wasm", setupFunc(e20) {
  bz = e20.wasm.cwrap(sa, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { x: a2, filter: i2, bias: s2, preluActivationWeights: o2 } = t2, { strides: l2, pad: u2, dilations: d2, dataFormat: c2, dimRoundingMode: h2, activation: p2, leakyreluAlpha: f2 } = n2, m2 = Uf.computeConv2DInfo(a2.shape, i2.shape, l2, d2, u2, h2), A2 = bF[p2];
  if (null == A2) throw Error(p2 + " activation not yet supported for FusedConv2D in the wasm backend.");
  let x2 = r2.dataIdMap.get(a2.dataId).id, y2 = r2.dataIdMap.get(i2.dataId).id, b2 = m2.outChannels, g2 = 0;
  if (null != s2) {
    let e21 = r2.dataIdMap.get(s2.dataId);
    if (1 !== e21.shape.length) throw Error(`FusedConv2D only supports rank-1 bias but got rank ${e21.shape.length}.`);
    if (e21.shape[0] !== b2) throw Error(`FusedConv2D bias shape (${e21.shape}) does not match the number of output channels (${b2})`);
    g2 = e21.id;
  }
  let v2 = m2.filterHeight, w2 = m2.filterWidth, k2 = m2.padInfo.top, N2 = m2.padInfo.right, C2 = m2.padInfo.bottom, $2 = m2.padInfo.left, R2 = m2.dilationHeight, S2 = m2.dilationWidth, I2 = m2.strideHeight, E2 = m2.strideWidth, T2 = m2.inChannels, M2 = "SAME" === m2.padInfo.type ? 1 : 0, O2 = m2.batchSize, F2 = m2.inHeight, P2 = m2.inWidth;
  if ("NHWC" !== c2) throw Error(`wasm backend FusedConv2D does not support dataFormat:'${c2}'. Please use 'NHWC'.`);
  let z2 = r2.makeOutput(m2.outShape, "float32"), V2 = r2.dataIdMap.get(z2.dataId).id, _2 = null == o2 ? 0 : r2.dataIdMap.get(o2.dataId).id;
  return bz(x2, O2, F2, P2, y2, v2, w2, g2, k2, N2, C2, $2, M2, R2, S2, I2, E2, T2, b2, A2, _2, f2 || 0, V2), z2;
} };
var Uz = { kernelName: oa, backendName: "wasm", setupFunc(e20) {
  gz = e20.wasm.cwrap(oa, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { x: a2, filter: i2, bias: s2, preluActivationWeights: o2 } = t2, { strides: l2, pad: u2, dilations: d2, dataFormat: c2, dimRoundingMode: h2, activation: p2, leakyreluAlpha: f2 } = n2, m2 = Uf.computeConv2DInfo(a2.shape, i2.shape, l2, d2, u2, h2, true), A2 = bF[p2];
  if (null == A2) throw Error(p2 + " activation not yet supported for FusedDepthwiseConv2D in the wasm backend.");
  let x2 = r2.dataIdMap.get(a2.dataId).id, y2 = r2.dataIdMap.get(i2.dataId).id, b2 = m2.outChannels, g2 = 0;
  if (null != s2) {
    let e21 = r2.dataIdMap.get(s2.dataId);
    if (1 !== e21.shape.length) throw Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e21.shape.length}.`);
    if (e21.shape[0] !== b2) throw Error(`FusedDepthwiseConv2D bias shape (${e21.shape}) does not match the number of output channels (${b2})`);
    g2 = e21.id;
  }
  let v2 = m2.filterHeight, w2 = m2.filterWidth, k2 = m2.padInfo.top, N2 = m2.padInfo.right, C2 = m2.padInfo.bottom, $2 = m2.padInfo.left, R2 = m2.dilationHeight, S2 = m2.dilationWidth, I2 = m2.strideHeight, E2 = m2.strideWidth, T2 = m2.inChannels, M2 = "SAME" === m2.padInfo.type ? 1 : 0, O2 = m2.batchSize, F2 = m2.inHeight, P2 = m2.inWidth;
  if ("NHWC" !== c2) throw Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${c2}'. Please use 'NHWC'.`);
  let z2 = r2.makeOutput(m2.outShape, "float32"), V2 = r2.dataIdMap.get(z2.dataId).id, _2 = null == o2 ? 0 : r2.dataIdMap.get(o2.dataId).id;
  return gz(x2, O2, F2, P2, y2, v2, w2, g2, k2, N2, C2, $2, M2, R2, S2, I2, E2, T2, b2, A2, _2, f2 || 0, V2), z2;
} };
var jz = { kernelName: nn, backendName: "wasm", setupFunc(e20) {
  vz = e20.wasm.cwrap(nn, null, ["number", "number", "number", "number", "number", "number", "array", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2 } = e20, { params: r2, indices: a2 } = n2, [i2, s2, o2, l2] = mf.prepareAndValidate(r2, a2), u2 = t2.makeOutput(i2, r2.dtype);
  if (0 === s2) return u2;
  let d2 = a2.shape, c2 = d2[d2.length - 1], h2 = t2.dataIdMap.get(r2.dataId).id, p2 = t2.dataIdMap.get(a2.dataId).id, f2 = new Uint8Array(new Int32Array(l2).buffer), m2 = t2.dataIdMap.get(u2.dataId).id;
  return vz(h2, yF[r2.dtype], p2, s2, c2, o2, f2, m2), u2;
} };
var Gz = { kernelName: tn, backendName: "wasm", setupFunc(e20) {
  wz = e20.wasm.cwrap("Gather", null, ["number", "number", "array", "number", "number", "number", "array", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { x: a2, indices: i2 } = n2, { axis: s2, batchDims: o2 } = r2, l2 = va.parseAxisParam(s2, a2.shape)[0], u2 = t2.readSync(i2.dataId), d2 = a2.shape[l2];
  for (let k2 = 0; u2.length > k2; ++k2) {
    let e21 = u2[k2];
    va.assert(d2 - 1 >= e21 && e21 >= 0, () => `GatherV2: the index value ${e21} is not in [0, ${d2 - 1}]`);
  }
  let c2 = Uf.segment_util.collectGatherOpShapeInfo(a2, i2, l2, o2), h2 = dP({ inputs: { x: a2 }, attrs: { shape: [c2.batchSize, c2.outerSize, c2.dimSize, c2.sliceSize] }, backend: t2 }), p2 = va.sizeFromShape(i2.shape), f2 = dP({ inputs: { x: i2 }, attrs: { shape: [c2.batchSize, p2 / c2.batchSize] }, backend: t2 }), m2 = [c2.batchSize, c2.outerSize, p2 / c2.batchSize, c2.sliceSize], A2 = t2.makeOutput(m2, a2.dtype);
  if (0 === va.sizeFromShape(a2.shape)) return A2;
  let x2 = h2.shape.length - 1, y2 = t2.dataIdMap.get(h2.dataId).id, b2 = t2.dataIdMap.get(f2.dataId).id, g2 = t2.dataIdMap.get(A2.dataId).id, v2 = new Uint8Array(new Int32Array(va.computeStrides(h2.shape)).buffer), w2 = new Uint8Array(new Int32Array(va.computeStrides(m2)).buffer);
  return wz(y2, yF[a2.dtype], v2, x2, b2, c2.batchSize, w2, g2), t2.disposeData(h2.dataId), t2.disposeData(f2.dataId), A2.shape = c2.outputShape, A2;
} };
var Hz = FF(rn, 0, "bool");
var Xz = FF(an, 0, "bool");
var qz = EF(un, "bool");
var Zz = EF(dn, "bool");
var Kz = EF(cn, "bool");
var Yz = { kernelName: hn, backendName: "wasm", setupFunc(e20) {
  kz = e20.wasm.cwrap(hn, null, ["number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: { x: t2 }, attrs: { alpha: n2 }, backend: r2 } = e20, a2 = r2.dataIdMap.get(t2.dataId).id, i2 = r2.makeOutput(t2.shape, "float32");
  if (0 !== va.sizeFromShape(t2.shape)) {
    let e21 = r2.dataIdMap.get(i2.dataId).id;
    kz(a2, yF[t2.dtype], n2, e21);
  }
  return i2;
} };
var Jz = FF(pn, 0, "bool");
var Qz = FF(fn, 0, "bool");
var eV = { kernelName: mn, backendName: "wasm", setupFunc(e20) {
  Nz = e20.wasm.cwrap(mn, null, ["number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { attrs: t2, backend: n2 } = e20, { start: r2, stop: a2, num: i2 } = t2, s2 = Math.floor(i2), o2 = n2.makeOutput([s2], "float32");
  return Nz(n2.dataIdMap.get(o2.dataId).id, r2, a2, s2), o2;
} };
var tV = EF("Log");
var nV = EF(xn);
var rV = FF(yn, 0, "bool");
var aV = EF(bn);
var iV = FF(gn, 0, "bool");
var sV = FF(vn, 0, "bool");
var oV = { kernelName: "LRN", backendName: "wasm", setupFunc(e20) {
  Cz = e20.wasm.cwrap("LRN", null, ["number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { depthRadius: i2, bias: s2, alpha: o2, beta: l2 } = r2;
  if ("float32" !== a2.dtype) throw Error("LRN error: x must have dtype float32");
  let u2 = n2.makeOutput(a2.shape, a2.dtype);
  return Cz(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(u2.dataId).id, a2.shape[3], i2, s2, o2, l2), u2;
} };
var lV = { kernelName: Cn, backendName: "wasm", setupFunc(e20) {
  $z = e20.wasm.cwrap(Cn, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, y: i2, dy: s2 } = t2, { depthRadius: o2, bias: l2, alpha: u2, beta: d2 } = r2;
  if ("float32" !== a2.dtype || "float32" !== i2.dtype || "float32" !== s2.dtype) throw Error("LRNGrad error: x, y, and dy must have dtype float32");
  let c2 = n2.makeOutput(a2.shape, a2.dtype);
  return $z(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(i2.dataId).id, n2.dataIdMap.get(s2.dataId).id, n2.dataIdMap.get(c2.dataId).id, s2.shape[3], o2, l2, u2, d2), c2;
} };
var uV = { kernelName: "Max", backendName: "wasm", setupFunc(e20) {
  Rz = e20.wasm.cwrap("Max", null, ["number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { reductionIndices: a2, keepDims: i2 } = r2, { x: s2 } = n2, o2 = t2.dataIdMap.get(s2.dataId).id, l2 = s2, { transposed: u2, axes: d2, originalAxes: c2, inputWasTransposed: h2 } = jF(s2, a2, t2);
  h2 && (l2 = u2, o2 = t2.dataIdMap.get(u2.dataId).id), Uf.assertAxesAreInnerMostDims("max", d2, l2.shape.length);
  let [p2, f2] = Uf.computeOutAndReduceShapes(l2.shape, d2), m2 = va.sizeFromShape(f2), A2 = t2.makeOutput(p2, s2.dtype);
  if (0 !== va.sizeFromShape(l2.shape)) {
    let e21 = t2.dataIdMap.get(A2.dataId).id;
    Rz(o2, yF[s2.dtype], m2, e21);
  }
  if (h2 && t2.disposeData(u2.dataId), i2) {
    let e21 = Uf.expandShapeToKeepDim(A2.shape, c2);
    A2.shape = e21;
  }
  return A2;
} };
var dV = FF(Sn);
var cV = { kernelName: In, backendName: "wasm", setupFunc(e20) {
  Sz = e20.wasm.cwrap(In, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, a2 = t2.x, i2 = r2.dataIdMap.get(a2.dataId).id;
  va.assert("float32" === a2.dtype, () => `Error in MaxPool: only float32 input is supported. Got ${a2.dtype}.`);
  let { filterSize: s2, strides: o2, pad: l2, dimRoundingMode: u2 } = n2, d2 = Uf.computePool2DInfo(a2.shape, s2, o2, 1, l2, u2), c2 = d2.filterHeight, h2 = d2.filterWidth, p2 = d2.padInfo.top, f2 = d2.padInfo.right, m2 = d2.padInfo.bottom, A2 = d2.padInfo.left, x2 = d2.dilationHeight, y2 = d2.dilationWidth, b2 = d2.strideHeight, g2 = d2.strideWidth, v2 = d2.inChannels, w2 = d2.outChannels;
  if ("channelsLast" !== d2.dataFormat) throw Error(`wasm backend does not support dataFormat:'${d2.dataFormat}'. Please use 'channelsLast'.`);
  let k2 = r2.makeOutput(d2.outShape, "float32"), N2 = r2.dataIdMap.get(k2.dataId).id;
  return Sz(i2, a2.shape[0], a2.shape[1], a2.shape[2], c2, h2, p2, f2, m2, A2, x2, y2, b2, g2, v2, w2, N2), k2;
} };
var hV = { kernelName: Tn, backendName: "wasm", setupFunc(e20) {
  Iz = e20.wasm.cwrap("MaxPool3D", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2, dataFormat: u2 } = r2, d2 = Uf.computePool3DInfo(a2.shape, i2, s2, 1, o2, l2, u2), c2 = n2.makeOutput(d2.outShape, a2.dtype);
  return Iz(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(c2.dataId).id, d2.batchSize, d2.inChannels, d2.inDepth, d2.inHeight, d2.inWidth, d2.outDepth, d2.outHeight, d2.outWidth, d2.strideDepth, d2.strideHeight, d2.strideWidth, d2.dilationDepth, d2.dilationHeight, d2.dilationWidth, d2.effectiveFilterDepth, d2.effectiveFilterHeight, d2.effectiveFilterWidth, d2.padInfo.front, d2.padInfo.top, d2.padInfo.left), c2;
} };
var pV = { kernelName: Mn, backendName: "wasm", setupFunc(e20) {
  Ez = e20.wasm.cwrap("MaxPool3DGrad", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, { filterSize: s2, strides: o2, pad: l2, dimRoundingMode: u2 } = r2, d2 = Uf.computePool3DInfo(i2.shape, s2, o2, 1, l2, u2), c2 = n2.makeOutput(i2.shape, i2.dtype);
  return Ez(n2.dataIdMap.get(i2.dataId).id, n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(c2.dataId).id, d2.batchSize, d2.inChannels, d2.inDepth, d2.inHeight, d2.inWidth, d2.outDepth, d2.outHeight, d2.outWidth, d2.strideDepth, d2.strideHeight, d2.strideWidth, d2.dilationDepth, d2.dilationHeight, d2.dilationWidth, d2.effectiveFilterDepth, d2.effectiveFilterHeight, d2.effectiveFilterWidth, d2.padInfo.front, d2.padInfo.top, d2.padInfo.left), c2;
} };
var fV = { kernelName: En, backendName: "wasm", setupFunc(e20) {
  Tz = e20.wasm.cwrap("MaxPoolGrad", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, { filterSize: s2, strides: o2, pad: l2, dimRoundingMode: u2 } = r2, d2 = Uf.computePool2DInfo(i2.shape, s2, o2, 1, l2, u2), c2 = n2.makeOutput(i2.shape, i2.dtype);
  return Tz(n2.dataIdMap.get(i2.dataId).id, n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(c2.dataId).id, d2.batchSize, d2.inChannels, d2.inHeight, d2.inWidth, d2.outHeight, d2.outWidth, d2.strideHeight, d2.strideWidth, d2.dilationHeight, d2.dilationWidth, d2.effectiveFilterHeight, d2.effectiveFilterWidth, d2.padInfo.top, d2.padInfo.left), c2;
} };
var mV = { kernelName: On, backendName: "wasm", setupFunc(e20) {
  Mz = e20.wasm.cwrap("MaxPoolWithArgmax", null, ["number", "number", "number", "number", "boolean", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, includeBatchInIndex: l2 } = r2;
  va.assert(4 === a2.shape.length, () => `Error in maxPool: input must be rank 4 but got rank ${a2.shape.length}.`);
  let u2 = [1, 1];
  va.assert(Uf.eitherStridesOrDilationsAreOne(s2, u2), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s2} and dilations '${u2}'`);
  let d2 = Uf.computePool2DInfo(a2.shape, i2, s2, [1, 1], o2), c2 = n2.makeOutput(d2.outShape, a2.dtype), h2 = n2.makeOutput(d2.outShape, "int32");
  return Mz(n2.dataIdMap.get(a2.dataId).id, n2.dataIdMap.get(c2.dataId).id, n2.dataIdMap.get(h2.dataId).id, yF[a2.dtype], l2, d2.batchSize, d2.inChannels, d2.inHeight, d2.inWidth, d2.outHeight, d2.outWidth, d2.strideHeight, d2.strideWidth, d2.dilationHeight, d2.dilationWidth, d2.effectiveFilterHeight, d2.effectiveFilterWidth, d2.padInfo.top, d2.padInfo.left), [c2, h2];
} };
var AV = { kernelName: Fn, backendName: "wasm", setupFunc(e20) {
  Oz = e20.wasm.cwrap(Fn, null, ["number, number, number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { axis: a2, keepDims: i2 } = r2, { x: s2 } = n2, o2 = t2.dataIdMap.get(s2.dataId).id, l2 = o2, u2 = s2, { transposed: d2, axes: c2, originalAxes: h2, inputWasTransposed: p2 } = jF(s2, a2, t2), f2 = c2;
  if (p2) {
    let e21 = t2.dataIdMap.get(d2.dataId).id;
    e21 !== o2 && (u2 = d2, l2 = e21, f2 = Uf.getInnerMostAxes(f2.length, u2.shape.length));
  }
  Uf.assertAxesAreInnerMostDims("mean", f2, u2.shape.length);
  let [m2, A2] = Uf.computeOutAndReduceShapes(u2.shape, f2), x2 = va.sizeFromShape(A2), y2 = u2;
  "float32" !== u2.dtype && (y2 = vP({ backend: t2, inputs: { x: u2 }, attrs: { dtype: "float32" } }), l2 = t2.dataIdMap.get(y2.dataId).id);
  let b2 = t2.makeOutput(m2, "float32");
  if (0 !== va.sizeFromShape(u2.shape)) {
    let e21 = t2.dataIdMap.get(b2.dataId).id;
    Oz(l2, x2, e21);
  }
  if (p2 && t2.disposeData(d2.dataId), i2) {
    let e21 = Uf.expandShapeToKeepDim(b2.shape, h2);
    b2.shape = e21;
  }
  return "float32" !== u2.dtype && t2.disposeData(y2.dataId), b2;
} };
var xV = { kernelName: "Min", backendName: "wasm", setupFunc(e20) {
  Fz = e20.wasm.cwrap("Min", null, ["number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { axis: a2, keepDims: i2 } = r2, { x: s2 } = n2, o2 = t2.dataIdMap.get(s2.dataId).id, l2 = o2, u2 = s2, { transposed: d2, axes: c2, originalAxes: h2, inputWasTransposed: p2 } = jF(s2, a2, t2);
  if (p2) {
    let e21 = t2.dataIdMap.get(d2.dataId).id;
    e21 !== o2 && (u2 = d2, l2 = e21);
  }
  Uf.assertAxesAreInnerMostDims("min", c2, u2.shape.length);
  let [f2, m2] = Uf.computeOutAndReduceShapes(u2.shape, c2), A2 = va.sizeFromShape(m2), x2 = t2.makeOutput(f2, u2.dtype);
  if (0 !== va.sizeFromShape(u2.shape)) {
    let e21 = t2.dataIdMap.get(x2.dataId).id;
    Fz(l2, yF[s2.dtype], A2, e21);
  }
  if (p2 && t2.disposeData(d2.dataId), i2) {
    let e21 = Uf.expandShapeToKeepDim(x2.shape, h2);
    x2.shape = e21;
  }
  return x2;
} };
var yV = FF(zn);
((e20) => {
  e20[e20.reflect = 0] = "reflect", e20[e20.symmetric = 1] = "symmetric";
})(Pz || (Pz = {}));
var bV;
var gV = { kernelName: Vn, backendName: "wasm", kernelFunc(e20) {
  let { inputs: { x: t2 }, backend: n2, attrs: { paddings: r2, mode: a2 } } = e20, i2 = r2.map((e21, n3) => e21[0] + t2.shape[n3] + e21[1]), s2 = n2.dataIdMap.get(t2.dataId).id, o2 = n2.makeOutput(i2, t2.dtype), l2 = n2.dataIdMap.get(o2.dataId).id, u2 = new Uint8Array(new Int32Array(t2.shape).buffer), d2 = r2.map((e21) => e21[0]), c2 = r2.map((e21) => e21[1]), h2 = new Uint8Array(new Int32Array(d2).buffer), p2 = new Uint8Array(new Int32Array(c2).buffer);
  return zz(s2, u2, t2.shape.length, yF[t2.dtype], h2, p2, Pz[a2], l2), o2;
}, setupFunc(e20) {
  zz = e20.wasm.cwrap(Vn, null, ["number", "array", "number", "number", "array", "array", "number", "number"]);
} };
function vV(e20) {
  let { backend: t2, inputs: { logits: n2 }, attrs: { dim: r2 } } = e20, a2 = t2.dataIdMap.get(n2.dataId).id, i2 = t2.makeOutput(n2.shape, n2.dtype), s2 = t2.dataIdMap.get(i2.dataId).id, o2 = n2.shape[r2], l2 = va.sizeFromShape(n2.shape) / o2;
  return 0 === va.sizeFromShape(i2.shape) || bV(a2, s2, o2, l2), i2;
}
var wV;
var kV;
var NV = { kernelName: Tr, backendName: "wasm", setupFunc(e20) {
  bV = e20.wasm.cwrap(Tr, null, ["number", "number", "number", "number"]);
}, kernelFunc: vV };
var CV = { kernelName: Dn, backendName: "wasm", setupFunc(e20) {
  wV = e20.wasm.cwrap(Dn, null, ["number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { logits: a2 } = t2, { numSamples: i2, seed: s2, normalized: o2 } = r2;
  if ("float32" !== a2.dtype) throw Error("Tensor logits must have dtype float32, got " + a2.dtype);
  let l2 = o2 ? a2 : vV({ inputs: { logits: a2 }, backend: n2, attrs: { dim: a2.shape.length - 1 } }), [u2, d2] = l2.shape, c2 = n2.makeOutput([u2, i2], "int32");
  return wV(n2.dataIdMap.get(l2.dataId).id, u2, d2, i2, s2, n2.dataIdMap.get(c2.dataId).id), o2 || n2.disposeData(l2.dataId), c2;
} };
var $V = FF("Mod");
var RV = FF(Wn);
var SV = EF("Neg");
function IV(e20, t2) {
  let n2 = new Int32Array(e20.wasm.HEAPU8.buffer, t2, 4), r2 = n2[0], a2 = n2[1], i2 = n2[2], s2 = n2[3];
  return e20.wasm.On(t2), { pSelectedIndices: r2, selectedSize: a2, pSelectedScores: i2, pValidOutputs: s2 };
}
var EV;
var TV;
var MV;
var OV;
var FV;
var PV;
var zV;
var VV;
var _V;
var DV;
var WV;
var LV;
var BV;
var UV;
var jV;
var GV;
var HV;
var XV;
var qV;
var ZV = { kernelName: Un, backendName: "wasm", setupFunc(e20) {
  kV = e20.wasm.cwrap(Un, "number", ["number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { iouThreshold: a2, maxOutputSize: i2, scoreThreshold: s2 } = r2, { boxes: o2, scores: l2 } = n2, u2 = t2.dataIdMap.get(o2.dataId).id, d2 = t2.dataIdMap.get(l2.dataId).id, c2 = kV(u2, d2, i2, a2, s2), { pSelectedIndices: h2, selectedSize: p2, pSelectedScores: f2, pValidOutputs: m2 } = IV(t2, c2);
  return t2.wasm.On(f2), t2.wasm.On(m2), t2.makeOutput([p2], "int32", h2);
} };
var KV = { kernelName: jn, backendName: "wasm", setupFunc(e20) {
  EV = e20.wasm.cwrap(jn, "number", ["number", "number", "number", "number", "number", "bool"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { iouThreshold: a2, maxOutputSize: i2, scoreThreshold: s2, padToMaxOutputSize: o2 } = r2, { boxes: l2, scores: u2 } = n2, d2 = t2.dataIdMap.get(l2.dataId).id, c2 = t2.dataIdMap.get(u2.dataId).id, h2 = EV(d2, c2, i2, a2, s2, o2), { pSelectedIndices: p2, selectedSize: f2, pSelectedScores: m2, pValidOutputs: A2 } = IV(t2, h2);
  return t2.wasm.On(m2), [t2.makeOutput([f2], "int32", p2), t2.makeOutput([], "int32", A2)];
} };
var YV = { kernelName: Gn, backendName: "wasm", setupFunc(e20) {
  TV = e20.wasm.cwrap(Gn, "number", ["number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { iouThreshold: a2, maxOutputSize: i2, scoreThreshold: s2, softNmsSigma: o2 } = r2, { boxes: l2, scores: u2 } = n2, d2 = t2.dataIdMap.get(l2.dataId).id, c2 = t2.dataIdMap.get(u2.dataId).id, h2 = TV(d2, c2, i2, a2, s2, o2), { pSelectedIndices: p2, selectedSize: f2, pSelectedScores: m2, pValidOutputs: A2 } = IV(t2, h2);
  return t2.wasm.On(A2), [t2.makeOutput([f2], "int32", p2), t2.makeOutput([f2], "float32", m2)];
} };
var JV = FF(Bn, 0, "bool");
var QV = { kernelName: Xn, backendName: "wasm", setupFunc(e20) {
  MV = e20.wasm.cwrap(Xn, null, ["number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { indices: a2 } = t2, { dtype: i2, depth: s2, onValue: o2, offValue: l2 } = r2, u2 = n2.makeOutput([...a2.shape, s2], i2), d2 = n2.dataIdMap.get(u2.dataId).id, c2 = n2.dataIdMap.get(a2.dataId).id;
  return MV(c2, s2, o2, l2, d2), u2;
} };
var e_ = { kernelName: Hn, backendName: "wasm", kernelFunc(e20) {
  let { inputs: { x: t2 }, backend: n2 } = e20, r2 = n2.makeOutput(t2.shape, t2.dtype);
  return n2.typedArrayFromHeap(r2).fill(1), r2;
} };
var t_ = { kernelName: qn, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { axis: a2 } = r2;
  if (1 === t2.length) return pz({ inputs: { input: t2[0] }, backend: n2, attrs: { dim: a2 } });
  let i2 = t2[0].shape, s2 = t2[0].dtype;
  t2.forEach((e21) => {
    va.assertShapesMatch(i2, e21.shape, "All tensors passed to stack must have matching shapes"), va.assert(s2 === e21.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  let o2 = [], l2 = $P({ inputs: t2.map((e21) => {
    let t3 = pz({ inputs: { input: e21 }, backend: n2, attrs: { dim: a2 } });
    return o2.push(t3), t3;
  }), backend: n2, attrs: { axis: a2 } });
  return o2.forEach((e21) => n2.disposeData(e21.dataId)), l2;
} };
var n_ = { kernelName: Zn, backendName: "wasm", kernelFunc(e20) {
  let { inputs: { x: t2 }, backend: n2, attrs: { paddings: r2, constantValue: a2 } } = e20, i2 = r2.map((e21, n3) => e21[0] + t2.shape[n3] + e21[1]);
  if (0 === va.sizeFromShape(t2.shape)) return Az({ backend: n2, attrs: { shape: i2, value: a2, dtype: t2.dtype } });
  let s2 = n2.dataIdMap.get(t2.dataId).id, o2 = n2.makeOutput(i2, t2.dtype), l2 = n2.dataIdMap.get(o2.dataId).id, u2 = new Uint8Array(new Int32Array(t2.shape).buffer), d2 = r2.map((e21) => e21[0]), c2 = r2.map((e21) => e21[1]), h2 = new Uint8Array(new Int32Array(d2).buffer), p2 = new Uint8Array(new Int32Array(c2).buffer);
  return OV(s2, u2, t2.shape.length, yF[t2.dtype], h2, p2, a2, l2), o2;
}, setupFunc(e20) {
  OV = e20.wasm.cwrap(Zn, null, ["number", "array", "number", "number", "array", "array", "number", "number"]);
} };
var r_ = FF("Pow");
var a_ = { kernelName: Jn, backendName: "wasm", setupFunc(e20) {
  FV = e20.wasm.cwrap(Jn, null, ["number", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2, alpha: a2 } = t2, i2 = n2.dataIdMap.get(r2.dataId).id, s2 = n2.dataIdMap.get(a2.dataId).id, o2 = i2, l2 = r2, u2 = l2;
  "float32" !== l2.dtype && (u2 = vP({ backend: n2, inputs: { x: r2 }, attrs: { dtype: "float32" } }), o2 = n2.dataIdMap.get(u2.dataId).id);
  let d2 = n2.makeOutput(r2.shape, "float32"), c2 = n2.dataIdMap.get(d2.dataId).id;
  return FV(o2, s2, c2), "float32" !== l2.dtype && n2.disposeData(u2.dataId), d2;
} };
var i_ = { kernelName: Qn, backendName: "wasm", setupFunc(e20) {
  PV = e20.wasm.cwrap(Qn, null, ["number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { axis: a2, keepDims: i2 } = r2, { x: s2 } = n2, o2 = t2.dataIdMap.get(s2.dataId).id, l2 = o2, u2 = s2, { transposed: d2, axes: c2, originalAxes: h2, inputWasTransposed: p2 } = jF(s2, a2, t2), f2 = c2;
  if (p2) {
    let e21 = t2.dataIdMap.get(d2.dataId).id;
    e21 !== o2 && (u2 = d2, l2 = e21, f2 = Uf.getInnerMostAxes(f2.length, u2.shape.length));
  }
  Uf.assertAxesAreInnerMostDims("prod", f2, u2.shape.length);
  let [m2, A2] = Uf.computeOutAndReduceShapes(u2.shape, f2), x2 = va.sizeFromShape(A2), y2 = t2.makeOutput(m2, u2.dtype);
  if (0 !== va.sizeFromShape(u2.shape)) {
    let e21 = t2.dataIdMap.get(y2.dataId).id;
    PV(l2, x2, yF[y2.dtype], e21);
  }
  if (p2 && t2.disposeData(d2.dataId), i2) {
    let e21 = Uf.expandShapeToKeepDim(y2.shape, h2);
    y2.shape = e21;
  }
  return y2;
} };
var s_ = { kernelName: rr, backendName: "wasm", kernelFunc(e20) {
  let { backend: t2, attrs: n2 } = e20, { start: r2, stop: a2, step: i2, dtype: s2 } = n2, o2 = Rb(r2, a2, i2, s2), l2 = t2.makeOutput([o2.length], s2);
  return t2.typedArrayFromHeap(l2).set(o2), l2;
} };
var o_ = FF(Wt);
var l_ = EF(ir);
var u_ = EF(sr);
var d_ = EF(hr);
var c_ = { kernelName: dr, backendName: "wasm", setupFunc(e20) {
  zV = e20.wasm.cwrap(dr, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let t2, { backend: n2, inputs: r2, attrs: a2 } = e20, { images: i2 } = r2, { alignCorners: s2, halfPixelCenters: o2, size: l2 } = a2, [u2, d2] = l2, [c2, h2, p2, f2] = i2.shape, m2 = [c2, u2, d2, f2], A2 = n2.dataIdMap.get(i2.dataId);
  "float32" !== A2.dtype && (t2 = vP({ backend: n2, inputs: { x: i2 }, attrs: { dtype: "float32" } }), A2 = n2.dataIdMap.get(t2.dataId));
  let x2 = A2.id, y2 = n2.makeOutput(m2, "float32");
  if (0 === va.sizeFromShape(i2.shape)) return y2;
  let b2 = n2.dataIdMap.get(y2.dataId).id;
  return zV(x2, c2, h2, p2, f2, u2, d2, s2 ? 1 : 0, o2 ? 1 : 0, b2), null != t2 && n2.disposeData(t2.dataId), y2;
} };
var h_ = { kernelName: cr, backendName: "wasm", setupFunc(e20) {
  VV = e20.wasm.cwrap(cr, null, ["number", "number", "number", "array", "array", "boolean"]);
}, kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { images: i2, dy: s2 } = n2, { alignCorners: o2 } = a2, l2 = r2.makeOutput(i2.shape, "float32"), u2 = r2.dataIdMap.get(i2.dataId);
  return "float32" !== u2.dtype && (t2 = vP({ backend: r2, inputs: { x: i2 }, attrs: { dtype: "float32" } }), u2 = r2.dataIdMap.get(t2.dataId)), VV(r2.dataIdMap.get(i2.dataId).id, r2.dataIdMap.get(s2.dataId).id, r2.dataIdMap.get(l2.dataId).id, new Uint8Array(new Int32Array(i2.shape).buffer), new Uint8Array(new Int32Array(s2.shape).buffer), o2), null != t2 && r2.disposeData(t2.dataId), l2;
} };
var p_ = { kernelName: lr, backendName: "wasm", setupFunc(e20) {
  _V = e20.wasm.cwrap(lr, null, ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { images: a2 } = n2, { alignCorners: i2, halfPixelCenters: s2, size: o2 } = r2, [l2, u2] = o2, [d2, c2, h2, p2] = a2.shape, f2 = t2.makeOutput([d2, l2, u2, p2], "float32");
  if (0 === va.sizeFromShape(a2.shape)) return f2;
  let m2, A2 = t2.dataIdMap.get(a2.dataId);
  "float32" !== A2.dtype && (m2 = vP({ backend: t2, inputs: { x: a2 }, attrs: { dtype: "float32" } }), A2 = t2.dataIdMap.get(m2.dataId));
  let x2 = A2.id, y2 = t2.dataIdMap.get(f2.dataId).id;
  return _V(x2, d2, c2, h2, p2, l2, u2, i2 ? 1 : 0, s2 ? 1 : 0, y2), null != m2 && t2.disposeData(m2.dataId), f2;
} };
var f_ = { kernelName: ur, backendName: "wasm", setupFunc(e20) {
  DV = e20.wasm.cwrap(ur, null, ["number", "number", "number", "array", "array", "boolean"]);
}, kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { images: i2, dy: s2 } = n2, { alignCorners: o2 } = a2, l2 = r2.makeOutput(i2.shape, "float32"), u2 = r2.dataIdMap.get(i2.dataId);
  return "float32" !== u2.dtype && (t2 = vP({ backend: r2, inputs: { x: i2 }, attrs: { dtype: "float32" } }), u2 = r2.dataIdMap.get(t2.dataId)), DV(r2.dataIdMap.get(i2.dataId).id, r2.dataIdMap.get(s2.dataId).id, r2.dataIdMap.get(l2.dataId).id, new Uint8Array(new Int32Array(i2.shape).buffer), new Uint8Array(new Int32Array(s2.shape).buffer), o2), null != t2 && r2.disposeData(t2.dataId), l2;
} };
var m_ = { kernelName: pr, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { dims: i2 } = r2, s2 = va.parseAxisParam(i2, a2.shape);
  if (0 === a2.shape.length) return _F({ inputs: { x: a2 }, backend: n2 });
  let o2 = n2.makeOutput(a2.shape, a2.dtype), l2 = n2.dataIdMap.get(a2.dataId).id, u2 = n2.dataIdMap.get(o2.dataId).id, d2 = new Uint8Array(new Int32Array(s2).buffer), c2 = new Uint8Array(new Int32Array(a2.shape).buffer);
  WV(l2, d2, s2.length, c2, a2.shape.length, u2);
  let h2 = dP({ inputs: { x: o2 }, attrs: { shape: a2.shape }, backend: n2 });
  return n2.disposeData(o2.dataId), h2;
}, setupFunc(e20) {
  WV = e20.wasm.cwrap(pr, null, ["number", "array", "number", "array", "number", "number"]);
} };
var A_ = { kernelName: aa, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { image: a2 } = t2, { radians: i2, fillValue: s2, center: o2 } = r2, l2 = n2.makeOutput(a2.shape, a2.dtype), u2 = n2.dataIdMap.get(a2.dataId).id, d2 = n2.dataIdMap.get(l2.dataId).id, [c2, h2, p2, f2] = a2.shape, [m2, A2] = Uf.getImageCenter(o2, h2, p2), x2 = "number" == typeof s2 ? [s2, s2, s2, 0 === s2 ? 0 : 255] : [...s2, 255], y2 = new Uint8Array(new Int32Array(x2).buffer);
  return LV(u2, c2, h2, p2, f2, i2, m2, A2, y2, x2.length, d2), l2;
}, setupFunc(e20) {
  LV = e20.wasm.cwrap(aa, null, ["number", "number", "number", "number", "number", "number", "number", "number", "array", "number", "number"]);
} };
var x_ = EF(fr);
var y_ = EF(mr);
var b_ = { kernelName: Ar, backendName: "wasm", setupFunc(e20) {
  BV = e20.wasm.cwrap(Ar, null, ["number", "number", "number", "number", "number", "number", "array", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { indices: a2, updates: i2 } = n2, { shape: s2 } = r2, o2 = t2.makeOutput(s2, i2.dtype);
  if (0 === va.sizeFromShape(s2)) return o2;
  let { sliceRank: l2, numUpdates: u2, sliceSize: d2, strides: c2, outputSize: h2 } = _c.calculateShapes(i2, a2, s2), p2 = t2.dataIdMap.get(a2.dataId).id, f2 = t2.dataIdMap.get(i2.dataId).id, m2 = new Uint8Array(new Int32Array(c2).buffer), A2 = t2.dataIdMap.get(o2.dataId).id;
  return BV(p2, f2, yF[i2.dtype], l2, u2, d2, m2, h2, A2), o2;
} };
var g_ = { kernelName: yr, backendName: "wasm", setupFunc(e20) {
  UV = e20.wasm.cwrap(yr, null, ["number", "number", "number", "number", "number", "number", "bool", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { sortedSequence: a2, values: i2 } = t2, { side: s2 } = r2;
  if (a2.dtype !== i2.dtype) throw Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a2.dtype} and ${i2.dtype}`);
  let o2 = n2.makeOutput(i2.shape, "int32");
  function l2(e21) {
    return n2.dataIdMap.get(e21.dataId).id;
  }
  return UV(l2(a2), l2(i2), a2.shape[0], a2.shape[1], i2.shape[1], yF[a2.dtype], "left" === s2, l2(o2)), o2;
} };
var v_ = { kernelName: br, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { condition: r2, t: a2, e: i2 } = t2, s2 = n2.dataIdMap.get(r2.dataId).id, o2 = n2.dataIdMap.get(a2.dataId).id, l2 = n2.dataIdMap.get(i2.dataId).id, u2 = n2.makeOutput(a2.shape, a2.dtype), d2 = n2.dataIdMap.get(u2.dataId).id, c2 = r2.shape.length, h2 = 0 === c2 || c2 > 1 || 1 === a2.shape.length ? 1 : va.sizeFromShape(a2.shape.slice(1));
  return jV(s2, o2, l2, h2, d2), u2;
}, setupFunc(e20) {
  jV = e20.wasm.cwrap("SelectV2", null, ["number", "number", "number", "number", "number"]);
} };
var w_ = EF(gr);
var k_ = { kernelName: "Sigmoid", backendName: "wasm", setupFunc(e20) {
  GV = e20.wasm.cwrap(Cr, null, ["number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: { x: n2 } } = e20, r2 = t2.dataIdMap.get(n2.dataId).id, a2 = t2.makeOutput(n2.shape, n2.dtype), i2 = t2.dataIdMap.get(a2.dataId).id;
  return 0 === va.sizeFromShape(a2.shape) || GV(r2, i2), a2;
} };
var N_ = EF(Nr);
var C_ = EF("Sin");
var $_ = EF(kr);
var R_ = EF($r);
var S_ = { kernelName: Ir, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockShape: i2, paddings: s2 } = r2, o2 = va.sizeFromShape(i2), l2 = [[0, 0]];
  l2.push(...s2);
  for (let A2 = 1 + i2.length; a2.shape.length > A2; ++A2) l2.push([0, 0]);
  let u2 = n_.kernelFunc({ inputs: { x: a2 }, backend: n2, attrs: { paddings: l2, constantValue: 0 } }), d2 = Uf.getReshaped(u2.shape, i2, o2, false), c2 = Uf.getPermuted(d2.length, i2.length, false), h2 = Uf.getReshapedPermuted(u2.shape, i2, o2, false), p2 = dP({ inputs: { x: u2 }, backend: n2, attrs: { shape: d2 } }), f2 = LF({ inputs: { x: p2 }, backend: n2, attrs: { perm: c2 } }), m2 = dP({ inputs: { x: f2 }, backend: n2, attrs: { shape: h2 } });
  return n2.disposeData(u2.dataId), n2.disposeData(p2.dataId), n2.disposeData(f2.dataId), m2;
} };
var I_ = { kernelName: Mr, backendName: "wasm", setupFunc(e20) {
  HV = e20.wasm.cwrap("SparseFillEmptyRows", "number", ["number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let t2, { backend: n2, inputs: r2 } = e20, { indices: a2, values: i2, denseShape: s2, defaultValue: o2 } = r2, l2 = a2.shape[0], u2 = a2.shape[1], d2 = n2.readSync(s2.dataId)[0], c2 = [l2 + d2, u2], h2 = n2.dataIdMap.get(a2.dataId).id, p2 = n2.dataIdMap.get(i2.dataId).id, f2 = n2.dataIdMap.get(o2.dataId).id, m2 = n2.makeOutput(c2, a2.dtype), A2 = n2.dataIdMap.get(m2.dataId).id, x2 = n2.makeOutput(c2.slice(0, 1), i2.dtype), y2 = n2.dataIdMap.get(x2.dataId).id, b2 = n2.makeOutput([d2], "bool"), g2 = n2.dataIdMap.get(b2.dataId).id, v2 = n2.makeOutput([l2], a2.dtype), w2 = n2.dataIdMap.get(v2.dataId).id, k2 = n2.makeOutput([4], "int32"), N2 = n2.dataIdMap.get(k2.dataId).id, C2 = HV(h2, p2, yF[i2.dtype], l2, d2, u2, f2, A2, y2, g2, w2, N2), $2 = n2.readSync(k2.dataId);
  switch ($2[0]) {
    case 1:
      t2 = Uf.getSparseFillEmptyRowsIndicesDenseShapeMismatch($2[1]);
      break;
    case 2:
      t2 = Uf.getSparseFillEmptyRowsNegativeIndexErrorMessage($2[1], $2[2]);
      break;
    case 3:
      t2 = Uf.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage($2[1], $2[2], $2[3]);
      break;
    default:
      t2 = "";
  }
  if (n2.disposeData(k2.dataId), t2) throw n2.disposeData(m2.dataId), n2.disposeData(x2.dataId), n2.disposeData(b2.dataId), n2.disposeData(v2.dataId), Error(t2);
  let R2 = m2, S2 = x2;
  return C2 !== c2[0] && (R2 = fP({ inputs: { x: m2 }, attrs: { begin: 0, size: [C2, u2] }, backend: n2 }), S2 = fP({ inputs: { x: x2 }, attrs: { begin: 0, size: C2 }, backend: n2 }), n2.disposeData(m2.dataId), n2.disposeData(x2.dataId)), [R2, S2, b2, v2];
} };
var E_ = { kernelName: Or, backendName: "wasm", setupFunc(e20) {
  XV = e20.wasm.cwrap(Or, null, ["number", "number", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2 } = e20, { inputIndices: r2, inputShape: a2, newShape: i2 } = n2;
  if (2 !== r2.shape.length) throw Error("Input indices should be a matrix but received shape\n        " + r2.shape);
  if (1 !== a2.shape.length) throw Error("Input shape should be a vector but received shape\n        " + a2.shape);
  if (1 !== i2.shape.length) throw Error("Target shape should be a vector but received shape " + i2.shape);
  let s2 = t2.dataIdMap.get(r2.dataId).id, o2 = t2.dataIdMap.get(a2.dataId).id, l2 = t2.dataIdMap.get(i2.dataId).id, u2 = r2.shape[0], d2 = va.sizeFromShape(i2.shape), c2 = t2.makeOutput([u2, d2], r2.dtype), h2 = t2.dataIdMap.get(c2.dataId).id, p2 = t2.makeOutput([d2], i2.dtype), f2 = t2.dataIdMap.get(p2.dataId).id, m2 = t2.makeOutput([3], "int32"), A2 = t2.dataIdMap.get(m2.dataId).id;
  XV(s2, o2, l2, u2, h2, f2, A2);
  let x2, y2 = t2.readSync(m2.dataId);
  switch (y2[0]) {
    case 0:
      x2 = Uf.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y2[1], y2[2]);
      break;
    case 1:
      x2 = Uf.getSparseReshapeNegativeOutputDimErrorMessage(y2[1], y2[2]);
      break;
    case 2:
      x2 = Uf.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();
      break;
    case 3: {
      let e21 = Array.from(t2.readSync(a2.dataId)), n3 = Array.from(t2.readSync(p2.dataId));
      x2 = Uf.getSparseReshapeInputOutputMultipleErrorMessage(e21, n3);
      break;
    }
    case 4: {
      let e21 = Array.from(t2.readSync(a2.dataId)), n3 = Array.from(t2.readSync(p2.dataId));
      x2 = Uf.getSparseReshapeInputOutputMismatchErrorMessage(e21, n3);
      break;
    }
    default:
      x2 = "";
  }
  if (t2.disposeData(m2.dataId), x2) throw t2.disposeData(c2.dataId), t2.disposeData(p2.dataId), Error(x2);
  return [c2, p2];
} };
function T_(e20) {
  qV = e20.wasm.cwrap("SparseSegmentReduction", null, ["number", "number", "number", "number", "number", "number", "number", "number", "number"]);
}
function M_(e20, t2) {
  let { backend: n2, inputs: r2 } = e20, { data: a2, indices: i2, segmentIds: s2 } = r2, o2 = i2.shape[0], l2 = n2.readSync(s2.dataId, o2 - 1, o2)[0], u2 = o2 > 0 ? l2 + 1 : 0;
  if (0 > u2) throw Error(Uf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
  let d2 = a2.shape.slice();
  d2[0] = u2;
  let c2 = n2.dataIdMap.get(a2.dataId).id, h2 = n2.dataIdMap.get(i2.dataId).id, p2 = n2.dataIdMap.get(s2.dataId).id, f2 = n2.makeOutput(d2, a2.dtype), m2 = n2.dataIdMap.get(f2.dataId).id, A2 = n2.makeOutput([4], "int32"), x2 = n2.dataIdMap.get(A2.dataId).id;
  qV(c2, yF[a2.dtype], a2.shape[0], h2, p2, m2, x2, t2, 0);
  let y2, b2 = n2.readSync(A2.dataId);
  switch (b2[0]) {
    case 0:
      y2 = Uf.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();
      break;
    case 1:
      y2 = Uf.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();
      break;
    case 2:
      y2 = Uf.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b2[1], b2[2]);
      break;
    case 3:
      y2 = Uf.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b2[1], b2[2], b2[3]);
      break;
    default:
      y2 = "";
  }
  if (n2.disposeData(A2.dataId), y2) throw n2.disposeData(f2.dataId), Error(y2);
  return f2;
}
var O_;
var F_;
var P_;
var z_;
var V_;
var __;
var D_;
var W_;
var L_ = { kernelName: Fr, backendName: "wasm", setupFunc: T_, kernelFunc(e20) {
  return M_(e20, true);
} };
var B_ = { kernelName: Pr, backendName: "wasm", setupFunc: T_, kernelFunc(e20) {
  return M_(e20, false);
} };
var U_ = { kernelName: zr, backendName: "wasm", setupFunc(e20) {
  O_ = e20.wasm.cwrap(zr, null, ["number", "number", "number", "number", "number", "number", "number", "number", "array", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { sparseIndices: a2, sparseValues: i2, defaultValue: s2 } = n2, { outputShape: o2 } = r2, l2 = t2.makeOutput(o2, s2.dtype);
  if (0 === va.sizeFromShape(o2)) return l2;
  let { sliceRank: u2, numUpdates: d2, sliceSize: c2, strides: h2, outputSize: p2 } = Uf.calculateShapes(i2, a2, o2), f2 = t2.dataIdMap.get(a2.dataId).id, m2 = t2.dataIdMap.get(i2.dataId).id, A2 = t2.dataIdMap.get(s2.dataId).id, x2 = new Uint8Array(new Int32Array(h2).buffer), y2 = t2.dataIdMap.get(l2.dataId).id;
  return O_(f2, m2, i2.shape.length, A2, yF[s2.dtype], u2, d2, c2, x2, p2, y2), l2;
} };
var j_ = { kernelName: Er, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { x: a2 } = t2, { numOrSizeSplits: i2, axis: s2 } = n2, o2 = va.parseAxisParam(s2, a2.shape)[0], l2 = Uf.prepareSplitSize(a2, i2, o2), u2 = Array(a2.shape.length).fill(0), d2 = a2.shape.slice();
  return l2.map((e21) => {
    let t3 = [...d2];
    t3[o2] = e21;
    let n3 = fP({ inputs: { x: a2 }, attrs: { begin: u2, size: t3 }, backend: r2 });
    return u2[o2] += e21, n3;
  });
} };
var G_ = EF(Rr);
var H_ = EF(_r);
var X_ = FF(Vr);
var q_ = { kernelName: na, backendName: "wasm", setupFunc(e20) {
  F_ = e20.wasm.cwrap(na, null, ["number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { alpha: a2 } = r2, { x: i2 } = n2, s2 = t2.dataIdMap.get(i2.dataId).id, o2 = t2.makeOutput(i2.shape, i2.dtype), l2 = t2.dataIdMap.get(o2.dataId).id;
  return F_(s2, a2, yF[i2.dtype], l2), o2;
} };
var Z_ = { kernelName: Wr, backendName: "wasm", setupFunc(e20) {
  P_ = e20.wasm.cwrap(Wr, null, ["number", "array", "number", "array", "array", "array", "array", "array", "number", "number"]);
}, kernelFunc(e20) {
  let t2, { backend: n2, inputs: r2, attrs: a2 } = e20, { x: i2 } = r2, { begin: s2, end: o2, strides: l2, beginMask: u2, endMask: d2, ellipsisMask: c2, newAxisMask: h2, shrinkAxisMask: p2 } = a2, { finalShapeSparse: f2, finalShape: m2, isIdentity: A2, sliceDim0: x2, isSimpleSlice: y2, begin: b2, end: g2, strides: v2 } = xf.sliceInfo(i2.shape, s2, o2, l2, u2, d2, c2, h2, p2);
  if (A2) t2 = dP({ inputs: { x: i2 }, backend: n2, attrs: { shape: m2 } });
  else if (x2 || y2) {
    va.assert(i2.shape.length >= 1, () => "Input must have rank at least 1, got: " + i2.shape.length);
    let e21 = xf.computeOutShape(b2, g2, v2), r3 = fP({ inputs: { x: i2 }, backend: n2, attrs: { begin: b2, size: e21 } });
    t2 = dP({ inputs: { x: r3 }, backend: n2, attrs: { shape: m2 } }), n2.disposeData(r3.dataId);
  } else {
    let e21 = n2.makeOutput(f2, "float32"), r3 = n2.dataIdMap.get(i2.dataId).id, a3 = new Uint8Array(new Int32Array(va.computeStrides(i2.shape)).buffer), s3 = new Uint8Array(new Int32Array(b2).buffer), o3 = new Uint8Array(new Int32Array(g2).buffer), l3 = new Uint8Array(new Int32Array(v2).buffer), u3 = new Uint8Array(new Int32Array(f2).buffer), d3 = new Uint8Array(new Int32Array(va.computeStrides(f2)).buffer), c3 = n2.dataIdMap.get(e21.dataId).id;
    P_(r3, a3, i2.shape.length, s3, o3, l3, u3, d3, f2.length, c3), t2 = dP({ inputs: { x: e21 }, backend: n2, attrs: { shape: m2 } }), n2.disposeData(e21.dataId);
  }
  return t2;
} };
var K_ = { kernelName: Lr, backendName: "wasm", kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { data: a2, dataSplits: i2 } = n2, { separator: s2, nGramWidths: o2, leftPad: l2, rightPad: u2, padWidth: d2, preserveShortSequences: c2 } = r2, h2 = t2.readSync(a2.dataId), p2 = t2.readSync(i2.dataId), [f2, m2] = Jb(h2, p2, s2, o2, l2, u2, d2, c2), A2 = t2.makeOutput([f2.length], "string");
  t2.dataIdMap.get(A2.dataId).stringBytes = f2;
  let x2 = t2.makeOutput(i2.shape, "int32");
  return t2.typedArrayFromHeap(x2).set(m2), [A2, x2];
} };
var Y_ = { kernelName: Br, backendName: "wasm", kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { input: a2, delimiter: i2 } = n2, { skipEmpty: s2 } = r2, o2 = t2.readSync(a2.dataId), l2 = t2.readSync(i2.dataId), [u2, d2, c2] = eg(o2, l2[0], s2), h2 = d2.length, p2 = t2.makeOutput([h2, 2], "int32");
  t2.typedArrayFromHeap(p2).set(u2);
  let f2 = t2.makeOutput([h2], "string");
  t2.dataIdMap.get(f2.dataId).stringBytes = d2;
  let m2 = t2.makeOutput([2], "int32");
  return t2.typedArrayFromHeap(m2).set(c2), [p2, f2, m2];
} };
var J_ = { kernelName: Ur, backendName: "wasm", kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { input: a2 } = n2, { numBuckets: i2 } = r2, s2 = tg(t2.readSync(a2.dataId), i2), o2 = t2.makeOutput(a2.shape, "int32");
  return t2.typedArrayFromHeap(o2).set(s2), o2;
} };
var Q_ = FF("Sub");
var eD = { kernelName: "Sum", backendName: "wasm", setupFunc(e20) {
  z_ = e20.wasm.cwrap("Sum", null, ["number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2, attrs: r2 } = e20, { axis: a2, keepDims: i2 } = r2, { x: s2 } = n2, o2 = t2.dataIdMap.get(s2.dataId).id, l2 = o2, u2 = s2, { transposed: d2, axes: c2, originalAxes: h2, inputWasTransposed: p2 } = jF(s2, a2, t2), f2 = c2;
  if (p2) {
    let e21 = t2.dataIdMap.get(d2.dataId).id;
    e21 !== o2 && (u2 = d2, l2 = e21, f2 = Uf.getInnerMostAxes(f2.length, u2.shape.length));
  }
  Uf.assertAxesAreInnerMostDims("sum", f2, u2.shape.length);
  let [m2, A2] = Uf.computeOutAndReduceShapes(u2.shape, f2), x2 = va.sizeFromShape(A2), y2 = t2.makeOutput(m2, u2.dtype);
  if (0 !== va.sizeFromShape(u2.shape)) {
    let e21 = t2.dataIdMap.get(y2.dataId).id;
    z_(l2, x2, yF[y2.dtype], e21);
  }
  if (p2 && t2.disposeData(d2.dataId), i2) {
    let e21 = Uf.expandShapeToKeepDim(y2.shape, h2);
    y2.shape = e21;
  }
  return y2;
} };
var tD = EF("Tan");
var nD = EF(Hr);
var rD = { kernelName: xr, backendName: "wasm", setupFunc(e20) {
  V_ = e20.wasm.cwrap(xr, null, ["number", "number", "number", "number", "number", "number", "array", "number", "number", "number"]);
}, kernelFunc(e20) {
  let { backend: t2, inputs: n2 } = e20, { tensor: r2, indices: a2, updates: i2 } = n2, s2 = t2.makeOutput(r2.shape, r2.dtype);
  if (0 === va.sizeFromShape(r2.shape)) return s2;
  let { sliceRank: o2, numUpdates: l2, sliceSize: u2, strides: d2, outputSize: c2 } = _c.calculateShapes(i2, a2, r2.shape), h2 = t2.dataIdMap.get(a2.dataId).id, p2 = t2.dataIdMap.get(i2.dataId).id, f2 = t2.dataIdMap.get(r2.dataId).id, m2 = new Uint8Array(new Int32Array(d2).buffer), A2 = t2.dataIdMap.get(s2.dataId).id;
  return V_(h2, p2, yF[i2.dtype], o2, l2, u2, m2, c2, A2, f2), s2;
} };
var aD = { kernelName: Xr, backendName: "wasm", setupFunc(e20) {
  __ = e20.wasm.cwrap(Xr, null, ["number", "array", "number", "array", "number", "number"]);
}, kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, i2 = n2.dataIdMap.get(a2.dataId).id, { reps: s2 } = r2, o2 = Array(a2.shape.length);
  for (let h2 = 0; o2.length > h2; h2++) o2[h2] = a2.shape[h2] * s2[h2];
  let l2 = new Uint8Array(new Int32Array(a2.shape).buffer), u2 = new Uint8Array(new Int32Array(o2).buffer), d2 = n2.makeOutput(o2, a2.dtype), c2 = n2.dataIdMap.get(d2.dataId).id;
  return __(i2, l2, a2.shape.length, u2, o2.length, yF[d2.dtype], c2), d2;
} };
var iD = { kernelName: qr, backendName: "wasm", setupFunc(e20) {
  D_ = e20.wasm.cwrap(qr, null, ["number", "array", "number", "number", "number", "bool", "number", "number"]);
}, kernelFunc({ inputs: e20, backend: t2, attrs: n2 }) {
  let { x: r2 } = e20, { k: a2, sorted: i2 } = n2, s2 = t2.dataIdMap.get(r2.dataId).id, o2 = new Uint8Array(new Int32Array(r2.shape).buffer), l2 = r2.shape.slice();
  l2[l2.length - 1] = a2;
  let u2 = t2.makeOutput(l2, r2.dtype), d2 = t2.dataIdMap.get(u2.dataId).id, c2 = t2.makeOutput(l2, "int32"), h2 = t2.dataIdMap.get(c2.dataId).id;
  return D_(s2, o2, r2.shape.length, yF[r2.dtype], a2, i2, d2, h2), [u2, c2];
} };
var sD = { kernelName: Zr, backendName: "wasm", setupFunc(e20) {
  W_ = e20.wasm.cwrap(Zr, null, ["number", "number", "bool", "number", "number", "number", "number", "number", "number", "array", "number", "array", "number", "number", "number", "number", "number"]);
}, kernelFunc(e20) {
  let t2, { backend: n2, inputs: r2, attrs: a2 } = e20, { image: i2, transforms: s2 } = r2, { interpolation: o2, fillMode: l2, fillValue: u2, outputShape: d2 } = a2, [c2, h2, p2, f2] = i2.shape, [m2, A2] = null != d2 ? d2 : [h2, p2], x2 = [c2, m2, A2, f2], y2 = new Uint8Array(new Int32Array(va.computeStrides(i2.shape)).buffer), b2 = new Uint8Array(new Int32Array(va.computeStrides(x2)).buffer), g2 = n2.makeOutput(x2, i2.dtype), v2 = n2.dataIdMap.get(g2.dataId).id, w2 = n2.dataIdMap.get(i2.dataId).id, k2 = n2.dataIdMap.get(s2.dataId).id, N2 = "nearest" === o2 ? 1 : 2;
  switch (l2) {
    case "constant":
    default:
      t2 = 1;
      break;
    case "reflect":
      t2 = 2;
      break;
    case "wrap":
      t2 = 3;
      break;
    case "nearest":
      t2 = 4;
  }
  return W_(w2, k2, s2.shape[0] > 1, c2, m2, A2, f2, p2, h2, y2, i2.shape.length - 1, b2, x2.length - 1, N2, t2, u2, v2), g2;
} };
var oD = { kernelName: Yr, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { axis: a2 } = n2, { x: i2 } = t2, { outputValues: s2, outputShape: o2, indices: l2 } = dg(r2.readSync(i2.dataId), a2, i2.shape, i2.dtype);
  return [r2.makeOutput(o2, i2.dtype, void 0, s2), r2.makeOutput([l2.length], "int32", void 0, l2)];
} };
var lD = { kernelName: Jr, backendName: "wasm", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { value: a2 } = t2, { axis: i2 } = r2;
  0 > i2 && (i2 += a2.shape.length);
  let s2 = a2.shape[i2], o2 = a2.shape.length, l2 = Array(o2 - 1), u2 = 0;
  for (let p2 = 0; o2 > p2; p2++) p2 !== i2 && (l2[u2++] = a2.shape[p2]);
  let d2 = Array(s2), c2 = Array(o2).fill(0), h2 = a2.shape.slice();
  h2[i2] = 1;
  for (let p2 = 0; d2.length > p2; p2++) c2[i2] = p2, d2[p2] = fP({ inputs: { x: a2 }, attrs: { begin: c2, size: h2 }, backend: n2 });
  return d2.map(({ dataId: e21, dtype: t3 }) => ({ dataId: e21, dtype: t3, shape: l2 }));
} };
var uD = { kernelName: ta, backendName: "wasm", kernelFunc(e20) {
  let { inputs: { x: t2 }, backend: n2 } = e20, r2 = n2.makeOutput(t2.shape, t2.dtype);
  return n2.typedArrayFromHeap(r2).fill(0), r2;
} };
var dD = [IF, TF, MF, OF, zF, VF, HF, XF, QF, eP, tP, nP, rP, aP, iP, sP, uP, oP, lP, pP, xP, yP, bP, gP, kP, NP, CP, FP, PP, zP, VP, _P, DP, WP, LP, JP, QP, ez, tz, nz, rz, az, iz, sz, oz, lz, uz, dz, cz, hz, fz, mz, Vz, _z, Dz, Wz, Lz, Bz, Uz, jz, Gz, Hz, Xz, WF, qz, Zz, Kz, Yz, Jz, Qz, eV, nV, tV, rV, aV, iV, sV, oV, lV, uV, dV, cV, hV, pV, fV, mV, AV, xV, yV, gV, CV, $V, RV, SV, ZV, KV, YV, JV, QV, e_, t_, n_, r_, a_, i_, s_, o_, l_, u_, d_, hP, c_, h_, p_, f_, m_, A_, x_, y_, b_, g_, v_, w_, k_, N_, C_, $_, AP, NV, R_, S_, I_, E_, L_, B_, U_, j_, G_, H_, X_, q_, Z_, K_, Y_, J_, Q_, eD, tD, nD, rD, aD, iD, sD, UF, oD, lD, uD];
for (let a0 of dD) ma(a0);
var cD = _e();
cD.registerFlag("WASM_HAS_SIMD_SUPPORT", () => __async(null, null, function* () {
  try {
    return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]));
  } catch (si2) {
    return false;
  }
})), cD.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT", () => __async(null, null, function* () {
  if (cD.get("IS_NODE")) return false;
  try {
    return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));
  } catch (si2) {
    return false;
  }
}));
var hD = x(P());
var pD = x(z());
var fD = x(V());
var mD = hD.default || hD;
var AD = fD.default || fD;
var xD = class extends D {
  constructor(e20) {
    super(), this.wasm = e20, this.dataIdNextNumber = 1, this.wasm.tfjs.initWithThreadsCount(RD), SD = this.wasm.tfjs.getThreadsCount(), this.dataIdMap = new _(this, Yi());
  }
  write(e20, t2, n2) {
    let r2 = { id: this.dataIdNextNumber++ };
    return this.move(r2, e20, t2, n2, 1), r2;
  }
  numDataIds() {
    return this.dataIdMap.numDataIds();
  }
  time(e20) {
    return __async(this, null, function* () {
      let t2 = va.now();
      return e20(), { kernelMs: va.now() - t2 };
    });
  }
  move(e20, t2, n2, r2, a2) {
    let i2 = this.dataIdNextNumber++;
    if ("string" === r2) return void this.dataIdMap.set(e20, { id: i2, stringBytes: t2, shape: n2, dtype: r2, memoryOffset: null, refCount: a2 });
    let s2 = va.sizeFromShape(n2), o2 = s2 * va.bytesPerElement(r2), l2 = this.wasm.Mn(o2) >>> 0;
    this.dataIdMap.set(e20, { id: i2, memoryOffset: l2, shape: n2, dtype: r2, refCount: a2 }), this.wasm.tfjs.registerTensor(i2, s2, l2), null != t2 && this.wasm.HEAPU8.set(new Uint8Array(t2.buffer, t2.byteOffset, o2), l2);
  }
  read(e20) {
    return __async(this, null, function* () {
      return this.readSync(e20);
    });
  }
  readSync(e20, t2, n2) {
    let { memoryOffset: r2, dtype: a2, shape: i2, stringBytes: s2 } = this.dataIdMap.get(e20);
    if ("string" === a2) return null != t2 && 0 !== t2 || null != n2 && s2.length > n2 ? s2.slice(t2, n2) : s2;
    t2 = t2 || 0, n2 = n2 || va.sizeFromShape(i2);
    let o2 = va.bytesPerElement(a2);
    return ((e21, t3) => {
      switch (t3) {
        case "float32":
          return new Float32Array(e21);
        case "int32":
          return new Int32Array(e21);
        case "bool":
          return new Uint8Array(e21);
        default:
          throw Error("Unknown dtype " + t3);
      }
    })(this.wasm.HEAPU8.slice(r2 + t2 * o2, r2 + n2 * o2).buffer, a2);
  }
  disposeData(e20, t2 = false) {
    if (this.dataIdMap.has(e20)) {
      let n2 = this.dataIdMap.get(e20);
      if (n2.refCount--, !t2 && n2.refCount > 0) return false;
      this.wasm.On(n2.memoryOffset), this.wasm.tfjs.disposeData(n2.id), this.dataIdMap.delete(e20);
    }
    return true;
  }
  refCount(e20) {
    return this.dataIdMap.has(e20) ? this.dataIdMap.get(e20).refCount : 0;
  }
  incRef(e20) {
    let t2 = this.dataIdMap.get(e20);
    null != t2 && t2.refCount++;
  }
  floatPrecision() {
    return 32;
  }
  getMemoryOffset(e20) {
    return this.dataIdMap.get(e20).memoryOffset;
  }
  dispose() {
    this.wasm.tfjs.dispose(), "PThread" in this.wasm && this.wasm.PThread.terminateAllThreads(), this.wasm = null;
  }
  memory() {
    return { unreliable: false };
  }
  makeOutput(e20, t2, n2, r2) {
    let a2;
    if (null == n2) a2 = this.write(null != r2 ? r2 : null, e20, t2);
    else {
      let r3 = this.dataIdNextNumber++;
      a2 = { id: r3 }, this.dataIdMap.set(a2, { id: r3, memoryOffset: n2, shape: e20, dtype: t2, refCount: 1 });
      let i2 = va.sizeFromShape(e20);
      this.wasm.tfjs.registerTensor(r3, i2, n2);
    }
    return { dataId: a2, shape: e20, dtype: t2 };
  }
  typedArrayFromHeap({ shape: e20, dtype: t2, dataId: n2 }) {
    let r2 = this.wasm.HEAPU8.buffer, { memoryOffset: a2 } = this.dataIdMap.get(n2), i2 = va.sizeFromShape(e20);
    switch (t2) {
      case "float32":
        return new Float32Array(r2, a2, i2);
      case "int32":
        return new Int32Array(r2, a2, i2);
      case "bool":
        return new Uint8Array(r2, a2, i2);
      default:
        throw Error("Unknown dtype " + t2);
    }
  }
};
function yD(e20, t2, n2) {
  if (null != gD) return gD;
  let r2 = "tfjs-backend-wasm.wasm";
  return e20 && t2 ? r2 = "tfjs-backend-wasm-threaded-simd.wasm" : e20 && (r2 = "tfjs-backend-wasm-simd.wasm"), null != wD && null != wD[r2] ? wD[r2] : n2 + r2;
}
var bD = ["tfjs-backend-wasm.wasm", "tfjs-backend-wasm-simd.wasm", "tfjs-backend-wasm-threaded-simd.wasm"];
var gD = null;
var vD = null;
var wD = {};
var kD = false;
var ND = false;
function CD(e20, t2 = false) {
  if (Zi("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."), kD) throw Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");
  gD = e20, ND = t2;
}
function $D(e20, t2 = false) {
  if (kD) throw Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");
  if ("string" == typeof e20) vD = e20;
  else {
    wD = e20;
    let t3 = bD.filter((e21) => null == wD[e21]);
    if (t3.length > 0) throw Error(`There were no entries found for the following binaries: ${t3.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`);
  }
  ND = t2;
}
var RD = -1;
var SD = -1;
function ID(e20) {
  RD = e20;
}
function ED() {
  if (-1 === SD) throw Error("WASM backend not initialized.");
  return SD;
}
var TD = "4.22.0";
ds("wasm", () => __async(null, null, function* () {
  let { wasm: e20 } = yield (() => __async(null, null, function* () {
    let [e21, t2] = yield Promise.all([_e().getAsync("WASM_HAS_SIMD_SUPPORT"), _e().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);
    return new Promise((n2, r2) => {
      let a2 = { locateFile(n3, r3) {
        if (n3.endsWith(".worker.js")) {
          let e22 = pD.wasmWorkerContents.replace(/\n/g, "\\n"), t3 = new Blob([e22], { type: "application/javascript" });
          return URL.createObjectURL(t3);
        }
        return n3.endsWith(".wasm") ? yD(e21, t2, null != vD ? vD : r3) : r3 + n3;
      } };
      ND && (a2.instantiateWasm = /* @__PURE__ */ ((e22) => (t3, n3) => (va.fetch(e22, { credentials: "same-origin" }).then((r3) => {
        r3.ok || t3.env.a(`failed to load wasm binary file at '${e22}'`), r3.arrayBuffer().then((e23) => {
          WebAssembly.instantiate(e23, t3).then((e24) => {
            n3(e24.instance, e24.module);
          });
        });
      }), {}))(yD(e21, t2, null != vD ? vD : "")));
      let i2, s2 = false;
      a2.onAbort = () => {
        s2 || kD || (kD = true, r2({ message: "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers" }));
      }, t2 && e21 && null == gD ? (a2.mainScriptUrlOrBlob = new Blob(["var WasmBackendModuleThreadedSimd = " + mD], { type: "text/javascript" }), i2 = mD(a2)) : i2 = AD(a2), i2.then((e22) => {
        s2 = true, kD = false, e22.tfjs = { init: e22.cwrap("init", null, []), initWithThreadsCount: e22.cwrap("init_with_threads_count", null, ["number"]), getThreadsCount: e22.cwrap("get_threads_count", "number", []), registerTensor: e22.cwrap("register_tensor", null, ["number", "number", "number"]), disposeData: e22.cwrap("dispose_data", null, ["number"]), dispose: e22.cwrap("dispose", null, []) }, n2({ wasm: e22 });
      }).catch(r2);
    });
  }))();
  return new xD(e20);
}), 2);
var MD = _e();
MD.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE", () => 15), MD.registerFlag("WEBGPU_CPU_FORWARD", () => true), MD.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE", () => -1), MD.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE", () => true), MD.registerFlag("WEBGPU_USE_LOW_POWER_GPU", () => false), MD.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e3), MD.registerFlag("WEBGPU_USE_PROFILE_TOOL", () => false), MD.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE", () => true), MD.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG", () => false), MD.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL", () => -1), MD.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER", () => false), MD.registerFlag("WEBGPU_PRINT_SHADER", () => ""), MD.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY", () => false);
var OD = class {
  constructor(e20) {
    e20 && (this.vendor = e20.vendor, this.architecture = e20.architecture, this.intelGPUGeneration = this.getIntelGPUGeneration());
  }
  getIntelGPUGeneration() {
    if (this.isIntel()) {
      if (this.architecture.startsWith("gen")) return +this.architecture.match(/\d+/);
      if (this.architecture.startsWith("xe")) return 12;
    }
    return 0;
  }
  isIntel() {
    return "intel" === this.vendor;
  }
};
var FD = class {
  constructor(e20) {
    this.device = e20, this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
  }
  acquireBuffer(e20, t2, n2 = false, r2 = true) {
    let a2, i2 = PD(e20, t2);
    return r2 ? (this.freeBuffers.has(i2) || this.freeBuffers.set(i2, []), this.freeBuffers.get(i2).length > 0 ? (a2 = this.freeBuffers.get(i2).pop(), this.numFreeBuffers--) : (a2 = this.device.createBuffer({ size: e20, usage: t2, mappedAtCreation: n2 }), this.numBytesAllocated += e20)) : (a2 = this.device.createBuffer({ size: e20, usage: t2, mappedAtCreation: n2 }), this.numBytesAllocated += e20), this.usedBuffers.has(i2) || this.usedBuffers.set(i2, []), this.usedBuffers.get(i2).push(a2), this.numUsedBuffers++, this.numBytesUsed += e20, a2;
  }
  releaseBuffer(e20, t2 = true) {
    if (0 === this.freeBuffers.size) return;
    let n2 = e20.size, r2 = PD(n2, e20.usage), a2 = this.usedBuffers.get(r2), i2 = a2.indexOf(e20);
    if (0 > i2) throw Error("Cannot find the buffer in buffer manager");
    a2[i2] = a2[a2.length - 1], a2.pop(), this.numUsedBuffers--, this.numBytesUsed -= n2, t2 ? (this.freeBuffers.get(r2).push(e20), this.numFreeBuffers++) : (e20.destroy(), this.numBytesAllocated -= n2);
  }
  getNumUsedBuffers() {
    return this.numUsedBuffers;
  }
  getNumFreeBuffers() {
    return this.numFreeBuffers;
  }
  dispose() {
    this.freeBuffers.forEach((e20, t2) => {
      e20.forEach((e21) => {
        e21.destroy();
      });
    }), this.usedBuffers.forEach((e20, t2) => {
      e20.forEach((e21) => {
        e21.destroy();
      });
    }), this.freeBuffers = /* @__PURE__ */ new Map(), this.usedBuffers = /* @__PURE__ */ new Map(), this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
  }
};
function PD(e20, t2) {
  return `${e20}_${t2}`;
}
var zD = class {
  constructor(e20) {
    this.device = e20, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = /* @__PURE__ */ new Map(), this.usedTextures = /* @__PURE__ */ new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
  }
  acquireTexture(e20, t2, n2, r2) {
    let a2 = e20 * t2 * _D(n2), i2 = VD(e20, t2, n2, r2);
    if (this.freeTextures.has(i2) || this.freeTextures.set(i2, []), this.usedTextures.has(i2) || this.usedTextures.set(i2, []), this.numBytesUsed += a2, this.numUsedTextures++, this.freeTextures.get(i2).length > 0) {
      this.numFreeTextures--;
      let e21 = this.freeTextures.get(i2).shift();
      return this.usedTextures.get(i2).push(e21), e21;
    }
    this.numBytesAllocated += a2;
    let s2 = this.device.createTexture({ size: [e20, t2], format: n2, usage: r2 });
    return this.usedTextures.get(i2).push(s2), s2;
  }
  releaseTexture(e20) {
    if (0 === this.freeTextures.size) return;
    let t2 = e20.width, n2 = e20.height, r2 = e20.format, a2 = VD(t2, n2, r2, e20.usage);
    this.freeTextures.has(a2) || this.freeTextures.set(a2, []), this.freeTextures.get(a2).push(e20), this.numFreeTextures++, this.numUsedTextures--;
    let i2 = this.usedTextures.get(a2), s2 = i2.indexOf(e20);
    if (0 > s2) throw Error("Cannot release a texture that was never provided by this texture manager");
    i2.splice(s2, 1);
    let o2 = _D(r2);
    this.numBytesUsed -= t2 * n2 * o2;
  }
  getNumUsedTextures() {
    return this.numUsedTextures;
  }
  getNumFreeTextures() {
    return this.numFreeTextures;
  }
  dispose() {
    this.freeTextures.forEach((e20, t2) => {
      e20.forEach((e21) => {
        e21.destroy();
      });
    }), this.usedTextures.forEach((e20, t2) => {
      e20.forEach((e21) => {
        e21.destroy();
      });
    }), this.freeTextures = /* @__PURE__ */ new Map(), this.usedTextures = /* @__PURE__ */ new Map(), this.numUsedTextures = 0, this.numFreeTextures = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
  }
};
function VD(e20, t2, n2, r2) {
  return `${e20}_${t2}_${n2}_${r2}`;
}
function _D(e20) {
  if ("rgba8unorm" === e20) return 16;
  throw Error(e20 + " is not supported!");
}
function DD(e20, t2) {
  if (Math.max(...e20) > 5) throw Error("Cannot symbolically compute strides for rank > 6 tensor.");
  let n2 = e20.length, r2 = e20.map((e21) => `${t2}.${"xyzwuv"[e21]}`), a2 = Array(n2 - 1);
  a2[n2 - 2] = r2[n2 - 1];
  for (let i2 = n2 - 3; i2 >= 0; --i2) a2[i2] = `(${a2[i2 + 1]} * ${r2[i2 + 1]})`;
  return a2;
}
var WD;
var LD = (e20, t2, n2) => "int32" === n2 ? `atomicAdd(${e20}, bitcast<i32>(${t2}));` : `
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${t2});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${e20}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;
((e20) => {
  e20[e20.FROM_PIXELS = 0] = "FROM_PIXELS", e20[e20.DRAW = 1] = "DRAW";
})(WD || (WD = {}));
var BD = (e20, t2 = "f32") => {
  switch (e20) {
    case 1:
      return "" + t2;
    case 2:
      return `vec2<${t2}>`;
    case 3:
      return `vec3<${t2}>`;
    case 4:
      return `vec4<${t2}>`;
    default:
      throw Error(`${e20}-component ${t2} is not supported.`);
  }
};
function UD(e20) {
  if (1 >= e20) return "i32";
  if (2 === e20) return "vec2<i32>";
  if (3 === e20) return "vec3<i32>";
  if (4 === e20) return "vec4<i32>";
  if (5 === e20) return "vec5";
  if (6 === e20) return "vec6";
  throw Error(`GPU for rank ${e20} is not yet supported`);
}
function jD(e20) {
  if (0 === e20) return "x";
  if (1 === e20) return "y";
  if (2 === e20) return "z";
  if (3 === e20) return "w";
  if (4 === e20) return "u";
  if (5 === e20) return "v";
  throw Error(`Index ${e20} is not yet supported`);
}
function GD(...e20) {
  let t2;
  switch (e20.length) {
    case 0:
      t2 = "\n        fn main()\n      ";
      break;
    case 1:
      t2 = `
        fn main(${e20[0]} : i32)
      `;
      break;
    default:
      throw Error("Unreachable");
  }
  return t2;
}
function HD(e20, t2) {
  let n2;
  return n2 = `
     ${((e21) => `
  @compute @workgroup_size(${e21.workgroupSize[0]}, ${e21.workgroupSize[1]}, ${e21.workgroupSize[2]})
`)(t2)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${e20 ? "main(getGlobalIndex());" : "main();"};
      }
    `, n2;
}
var XD = "\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n";
function qD(e20, t2 = "") {
  let n2 = e20.length, r2 = "" !== t2 ? `get${t2.charAt(0).toUpperCase() + t2.slice(1)}CoordsFromIndex` : "getCoordsFromIndex", a2 = "" !== t2 ? t2.charAt(0).toLowerCase() + t2.slice(1) + "ShapeStrides" : "outShapeStrides";
  if (1 >= n2) return `fn ${r2}(index : i32) -> i32 { return index; }`;
  let i2, s2 = va.computeStrides(e20), o2 = UD(n2), l2 = [];
  for (let u2 = 0; n2 > u2; u2++) l2.push("d" + u2);
  return 1 === s2.length ? `    fn ${r2}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${a2}; let d1 = index - d0 * uniforms.${a2};
      return vec2<i32>(d0, d1);
    }` : (i2 = "var index2 = index;" + s2.map((e21, t3) => `let ${l2[t3]} = index2 / uniforms.${a2}.${jD(t3)}; ${t3 === s2.length - 1 ? `let ${l2[t3 + 1]} = index2 - ${l2[t3]} * uniforms.${a2}.${jD(t3)}` : `index2 = index2 - ${l2[t3]} * uniforms.${a2}.${jD(t3)}`};`).join(""), `
    fn ${r2}(index : i32) -> ${o2} {
      ${i2}
      return ${o2}(${l2.join(",")});
    }
  `);
}
function ZD(e20) {
  let t2 = "";
  switch (e20) {
    case 0:
    case 1:
      t2 += "\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";
      break;
    case 2:
      t2 += "\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";
      break;
    case 3:
      t2 += "\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";
      break;
    case 4:
      t2 += "\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";
      break;
    case 5:
      t2 += "\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";
      break;
    case 6:
      t2 += "\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";
      break;
    default:
      va.assert(false, () => `Unsupported ${e20}D shape`);
  }
  return t2;
}
function KD(e20) {
  return 1 === e20.dispatch[1] && 1 === e20.dispatch[2];
}
function YD(e20, t2 = 1) {
  if ("float32" === e20) return BD(t2, "f32");
  if ("int32" === e20 || "bool" === e20) return BD(t2, "i32");
  throw Error(`type ${e20} is not supported.`);
}
function JD(e20) {
  return !(e20.dispatchLayout.hasOwnProperty("y") && 0 !== e20.dispatchLayout.y.length || e20.dispatchLayout.hasOwnProperty("z") && 0 !== e20.dispatchLayout.z.length);
}
var QD = {};
A(QD, { GPUBytesPerElement() {
  return lW;
}, MatMulProgramType() {
  return eW;
}, assertNotComplex() {
  return dW;
}, computeDispatch() {
  return rW;
}, computeWorkPerThreadForConv2d() {
  return sW;
}, computeWorkgroupInfoForMatMul() {
  return aW;
}, computeWorkgroupSizeForConv2d() {
  return iW;
}, flatDispatchLayout() {
  return oW;
}, isWebGPUSupported() {
  return uW;
}, tilesFitEvenlyIntoShape() {
  return nW;
} });
var eW;
var tW = (e20) => {
  let t2 = 1;
  for (let n2 = 0; e20.length > n2; n2++) t2 *= e20[n2];
  return t2;
};
function nW(e20, t2) {
  if (e20.length !== t2.length) throw Error(`Cannot compute whether rank ${e20.length} tiles fit evenly into rank ${t2.length} shape - ranks must match.`);
  return t2.every((t3, n2) => t3 % e20[n2] === 0);
}
function rW(e20, t2, n2 = [1, 1, 1], r2 = [1, 1, 1]) {
  let [a2, i2, s2] = [Math.ceil(tW(e20.x.map((e21) => t2[e21])) / (n2[0] * r2[0])), e20.y ? Math.ceil(tW(e20.y.map((e21) => t2[e21])) / (n2[1] * r2[1])) : 1, e20.z ? Math.ceil(tW(e20.z.map((e21) => t2[e21])) / (n2[2] * r2[2])) : 1];
  return [a2, i2, s2];
}
function aW(e20, t2, n2, r2 = false) {
  let a2 = [8, 8, 1], i2 = [4, 4, 1];
  return r2 || (8 >= e20 && (i2[1] = 1), 16 >= t2 && 16 >= n2 && (a2[0] = 4)), { workgroupSize: a2, elementsPerThread: i2 };
}
function iW(e20, t2, n2 = false) {
  if (n2) return [8, 8, 1];
  let r2 = tW(e20.x.map((e21) => t2[e21])), a2 = tW(e20.y.map((e21) => t2[e21]));
  return r2 > 4 ? a2 > 4 ? [16, 16, 1] : [16, 4, 1] : [4, 16, 1];
}
function sW(e20, t2, n2 = false) {
  if (n2) return [4, 4, 1];
  let r2 = tW(e20.x.map((e21) => t2[e21])), a2 = tW(e20.y.map((e21) => t2[e21]));
  return r2 > 4 ? a2 > 4 ? [2, 2, 1] : [2, 1, 1] : [1, 2, 1];
}
function oW(e20) {
  return { x: e20.map((e21, t2) => t2) };
}
function lW(e20) {
  if ("float32" === e20 || "int32" === e20 || "bool" === e20 || "string" === e20) return 4;
  if ("complex64" === e20) return 8;
  throw Error("Unknown dtype " + e20);
}
function uW() {
  return !("undefined" == typeof globalThis || !globalThis.navigator || !globalThis.navigator.gpu);
}
function dW(e20, t2) {
  Array.isArray(e20) || (e20 = [e20]), e20.forEach((e21) => {
    null != e21 && va.assert("complex64" !== e21.dtype, () => t2 + " does not support complex64 tensors in the WebGPU backend.");
  });
}
((e20) => {
  e20[e20.MatMulReduceProgram = 0] = "MatMulReduceProgram", e20[e20.MatMulSplitKProgram = 1] = "MatMulSplitKProgram", e20[e20.MatMulSmallOutputSizeProgram = 2] = "MatMulSmallOutputSizeProgram", e20[e20.MatMulPackedProgram = 3] = "MatMulPackedProgram", e20[e20.MatMulMax = 4] = "MatMulMax";
})(eW || (eW = {}));
var cW;
var hW;
var pW = _e().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");
var fW = class e17 extends D {
  nextDataId() {
    return e17.nextDataId++;
  }
  constructor(e20, t2) {
    if (super(), this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.dispatchCountInPass = 0, this.disposed = false, this.downloadWaitMs = 0, this.tensorDataPendingDisposal = [], this.queryResolveBuffer = null, this.querySet = null, this.querySetCount = 2, this.stagingPendingDisposal = [], this.uniformPendingDisposal = [], this.uploadWaitMs = 0, this.hasReadSyncWarned = false, this.hasTimestampQueryWarned = false, !uW()) throw Error("WebGPU is not supported on this device");
    this.pipelineCache = {}, this.device = e20, this.queue = e20.queue, this.commandEncoder = null, this.computePassEncoder = null, this.adapterInfo = new OD(t2), this.supportTimestampQuery = this.device.features.has("timestamp-query"), this.thresholdToIncreaseWorkgroups = 12 > this.adapterInfo.intelGPUGeneration ? 8 : 16, this.bufferManager = new FD(this.device), this.textureManager = new zD(this.device), this.tensorMap = new _(this, Yi()), _e().getBool("WEBGPU_USE_PROFILE_TOOL") && (this.dummyCanvas = document.createElement("canvas"), this.dummyCanvas.width = 1, this.dummyCanvas.height = 1, this.dummyContext = this.dummyCanvas.getContext("webgpu"), this.dummyContext.configure({ device: e20, format: "bgra8unorm" }), document.body.appendChild(this.dummyCanvas));
  }
  floatPrecision() {
    return 32;
  }
  disposeData(e20, t2 = false) {
    if (!this.tensorMap.has(e20)) return true;
    let n2 = this.tensorMap.get(e20);
    return t2 ? n2.refCount = 0 : n2.refCount--, 0 >= n2.refCount && (null != n2.complexTensorInfos && (this.disposeData(n2.complexTensorInfos.real.dataId), this.disposeData(n2.complexTensorInfos.imag.dataId)), this.commandQueueOwnedIds.has(e20) ? (this.tensorDataPendingDisposal.push(e20), true) : (this.releaseResource(e20), this.tensorMap.delete(e20), true));
  }
  memory() {
    return { numBytesInGPU: this.bufferManager.numBytesUsed, numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated, unreliable: false };
  }
  releaseResource(e20) {
    let t2 = this.tensorMap.get(e20);
    if (t2 && t2.resource) {
      if (t2.external) return void (t2.resource = null);
      t2.resource instanceof GPUBuffer ? this.bufferManager.releaseBuffer(t2.resource) : t2.resource instanceof GPUTexture && this.textureManager.releaseTexture(t2.resource), t2.resource = null;
    }
  }
  refCount(e20) {
    return this.tensorMap.has(e20) ? this.tensorMap.get(e20).refCount : 0;
  }
  incRef(e20) {
    this.tensorMap.get(e20).refCount++;
  }
  decRef(e20) {
    this.tensorMap.has(e20) && this.tensorMap.get(e20).refCount--;
  }
  write(e20, t2, n2) {
    if ("complex64" === n2 && null != e20) throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    let r2 = { id: this.nextDataId() };
    return this.tensorMap.set(r2, { dtype: n2, shape: t2, values: e20, refCount: 1 }), r2;
  }
  move(e20, t2, n2, r2, a2) {
    if ("complex64" === r2) throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.tensorMap.set(e20, { dtype: r2, shape: n2, values: t2, refCount: a2 });
  }
  submitQueue() {
    this.queue.submit([this.commandEncoder.finish()]), this.commandEncoder = null, this.dispatchCountInPass = 0, this.commandQueueOwnedIds = /* @__PURE__ */ new WeakSet(), this.tensorDataPendingDisposal.forEach((e20) => {
      this.releaseResource(e20), this.tensorMap.delete(e20);
    }), this.uniformPendingDisposal.forEach((e20) => this.bufferManager.releaseBuffer(e20)), this.stagingPendingDisposal.forEach((e20) => this.bufferManager.releaseBuffer(e20, false)), this.tensorDataPendingDisposal = [], this.uniformPendingDisposal = [], this.stagingPendingDisposal = [];
  }
  ensureCommandEncoderReady() {
    this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder());
  }
  endComputePassEncoder() {
    this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);
  }
  checkCompileCompletionAsync() {
    return __async(this, null, function* () {
      let e20;
      try {
        e20 = yield Promise.all(Object.values(this.pipelineCache));
      } catch (t2) {
        throw Error(t2.message);
      }
      Object.keys(this.pipelineCache).map((t2, n2) => {
        this.pipelineCache[t2] = e20[n2];
      });
    });
  }
  getBufferData(e20) {
    return __async(this, null, function* () {
      if (_e().getBool("WEBGPU_ENGINE_COMPILE_ONLY")) return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"), null;
      let t2 = e20.size, n2 = this.bufferManager.acquireBuffer(t2, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
      this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(e20, 0, n2, 0, t2), this.submitQueue(), yield n2.mapAsync(GPUMapMode.READ);
      let r2 = n2.getMappedRange().slice(0);
      return n2.unmap(), null != n2 && this.bufferManager.releaseBuffer(n2), _e().getBool("WEBGPU_USE_PROFILE_TOOL") && (va.assert(void 0 !== this.dummyContext, () => "Fail to get context for profiling tool"), this.dummyContext.getCurrentTexture()), r2;
    });
  }
  convertAndCacheOnCPU(e20, t2) {
    let n2 = this.tensorMap.get(e20);
    return n2.values = t2, n2.values;
  }
  readSync(e20) {
    let t2 = this.tensorMap.get(e20), { values: n2, complexTensorInfos: r2 } = t2;
    if (null != n2 || "string" === t2.dtype) return n2;
    if ("complex64" === t2.dtype) {
      let t3 = this.readSync(r2.real.dataId), n3 = this.readSync(r2.imag.dataId), a3 = va.convertBackendValuesAndArrayBuffer(Uf.mergeRealAndImagArrays(t3, n3).buffer, "float32");
      return this.convertAndCacheOnCPU(e20, a3), a3;
    }
    this.hasReadSyncWarned || (this.hasReadSyncWarned = true, console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));
    let a2 = ["opaque", "premultiplied"], i2 = t2.resource, s2 = i2.size;
    va.assert(s2 % 4 == 0, () => "Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");
    let o2 = s2 / 4, l2 = new ArrayBuffer(s2), u2 = 256, d2 = 256, c2 = a2.map((e21) => new OffscreenCanvas(u2, d2)), h2 = new OffscreenCanvas(u2, d2);
    this.endComputePassEncoder(), c2.map((e21, t3) => {
      let n3 = e21.getContext("webgpu");
      return n3.configure({ device: this.device, format: "bgra8unorm", usage: GPUTextureUsage.COPY_DST, alphaMode: a2[t3] }), n3.getCurrentTexture();
    }).map((e21, t3) => {
      let n3 = (n4, r4, s4) => {
        this.ensureCommandEncoderReady(), this.commandEncoder.copyBufferToTexture({ buffer: i2, bytesPerRow: 1024, offset: s4 }, { texture: e21 }, { width: n4, height: r4 }), this.submitQueue();
        let o3 = h2.getContext("2d", { willReadFrequently: true });
        o3.clearRect(0, 0, n4, r4), o3.drawImage(c2[t3], 0, 0);
        let u3 = o3.getImageData(0, 0, n4, r4).data, d3 = a2[t3], p4 = new Uint8ClampedArray(l2, s4, n4 * r4 * 4);
        for (let e22 = 0; p4.length > e22; e22 += 4) if ("premultiplied" === d3) p4[e22 + 3] = u3[e22 + 3];
        else {
          let t4 = u3[e22];
          p4[e22] = u3[e22 + 2], p4[e22 + 1] = u3[e22 + 1], p4[e22 + 2] = t4;
        }
      }, r3 = Math.floor(o2 / (u2 * d2)), s3 = u2, p3 = d2, f2 = 0;
      for (let a3 = 0; r3 > a3; a3++) n3(s3, p3, f2), f2 += u2 * d2 * 4;
      let m2 = o2 % (u2 * d2);
      p3 = Math.floor(m2 / u2), p3 > 0 && (n3(s3, p3, f2), f2 += 4 * p3 * u2), s3 = m2 % u2, s3 > 0 && n3(s3, 1, f2);
    });
    let p2 = va.convertBackendValuesAndArrayBuffer(l2, t2.dtype);
    return this.convertAndCacheOnCPU(e20, p2), p2;
  }
  read(e20) {
    return __async(this, null, function* () {
      if (!this.tensorMap.has(e20)) throw Error(`Tensor ${e20} was not registered!`);
      let t2, n2 = this.tensorMap.get(e20), { values: r2 } = n2;
      if (null != r2) return r2;
      if ("complex64" === n2.dtype) {
        let e21 = yield Promise.all([this.read(n2.complexTensorInfos.real.dataId), this.read(n2.complexTensorInfos.imag.dataId)]);
        t2 = Uf.mergeRealAndImagArrays(e21[0], e21[1]);
      } else {
        let e21 = yield this.getBufferData(n2.resource);
        t2 = va.convertBackendValuesAndArrayBuffer(e21, n2.dtype);
      }
      return this.convertAndCacheOnCPU(e20, t2), t2;
    });
  }
  copyBuffer(e20) {
    let t2 = e20.size, n2 = this.bufferManager.acquireBuffer(t2, e20.usage);
    return this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(e20, 0, n2, 0, t2), this.submitQueue(), n2;
  }
  createTensorFromGPUData(e20, t2, n2) {
    let r2 = e20.buffer;
    if ("complex64" === n2) throw Error("Cannot write to a complex64 dtype. ");
    let a2 = { id: this.nextDataId() };
    this.tensorMap.set(a2, { dtype: n2, shape: t2, values: null, refCount: 1, external: e20.zeroCopy });
    let i2 = this.tensorMap.get(a2), s2 = lW(i2.dtype) * va.sizeFromShape(i2.shape);
    if (s2 > e20.buffer.size) throw Error(`GPUBuffer size(${e20.buffer.size}) is smaller than tensor size(${s2})!`);
    if ((e20.buffer.usage & (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) !== (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) throw Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");
    return true !== e20.zeroCopy && (r2 = this.copyBuffer(r2)), i2.resource = r2, Yi().makeTensorFromDataId(a2, t2, n2, this);
  }
  readToGPU(e20) {
    let t2 = this.tensorMap.get(e20), { values: n2, dtype: r2, shape: a2, resource: i2 } = t2;
    if ("complex64" === r2) throw Error("Does not support reading buffer for complex64 dtype.");
    if (null == i2) throw Error(null != n2 ? "Data is not on GPU but on CPU." : "There is no data on GPU or CPU.");
    let s2 = i2.size, o2 = this.bufferManager.acquireBuffer(s2, i2.usage);
    this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(i2, 0, o2, 0, s2), this.submitQueue();
    let l2 = this.makeTensorInfo(a2, r2), u2 = Yi().makeTensorFromTensorInfo(l2);
    return this.tensorMap.get(l2.dataId).resource = o2, { tensorRef: u2, buffer: o2 };
  }
  bufferSync(e20) {
    let t2 = this.readSync(e20.dataId);
    if ("string" === e20.dtype) try {
      let n2 = t2.map((e21) => va.decodeString(e21));
      return uo(e20.shape, e20.dtype, n2);
    } catch (n2) {
      throw Error("Failed to decode encoded string bytes into utf-8");
    }
    return uo(e20.shape, e20.dtype, t2);
  }
  time(e20) {
    return __async(this, null, function* () {
      !this.supportTimestampQuery && !this.hasTimestampQueryWarned && (console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."), this.hasTimestampQueryWarned = true);
      let t2 = this.activeTimers, n2 = [], r2 = false;
      null == this.programTimersStack ? (this.programTimersStack = n2, r2 = true) : this.activeTimers.push(n2), this.activeTimers = n2, e20();
      let a2 = va.flatten(this.activeTimers.map((e21) => e21.query)).filter((e21) => null != e21), i2 = va.flatten(this.activeTimers.map((e21) => e21.name)).filter((e21) => null != e21);
      this.activeTimers = t2, r2 && (this.programTimersStack = null);
      let s2 = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null }, o2 = yield Promise.all(a2);
      return s2.kernelMs = va.sum(o2), s2.getExtraProfileInfo = () => o2.map((e21, t3) => ({ name: i2[t3], ms: e21 })).map((e21) => `${e21.name}: ${e21.ms}`).join(", "), this.uploadWaitMs = 0, this.downloadWaitMs = 0, s2;
    });
  }
  makeTensorInfo(e20, t2, n2) {
    return "string" === t2 && null != n2 && n2.length > 0 && va.isString(n2[0]) && (n2 = n2.map((e21) => va.encodeString(e21))), { dataId: this.write(n2, e20, t2), shape: e20, dtype: t2 };
  }
  tensorToBinding(e20) {
    if (!e20) return null;
    let t2 = this.tensorMap.get(e20.dataId).resource;
    return t2 instanceof GPUBuffer ? { buffer: t2 } : t2 instanceof GPUTexture ? t2.createView() : t2;
  }
  uploadToGPU(e20) {
    let t2 = this.tensorMap.get(e20);
    if (null != t2.resource) return;
    let n2, r2 = lW(t2.dtype) * va.sizeFromShape(t2.shape), a2 = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
    if (t2.values) {
      if (n2 = this.bufferManager.acquireBuffer(r2, a2, true), "unmapped" === n2.mapState) {
        let e21 = this.bufferManager.acquireBuffer(r2, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, true, false), a3 = e21.getMappedRange();
        "int32" === t2.dtype || "bool" === t2.dtype ? new Int32Array(a3).set(t2.values) : new Float32Array(a3).set(t2.values), e21.unmap(), this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(e21, 0, n2, 0, r2), this.stagingPendingDisposal.push(e21);
      } else {
        let e21 = n2.getMappedRange();
        "int32" === t2.dtype || "bool" === t2.dtype ? new Int32Array(e21).set(t2.values) : new Float32Array(e21).set(t2.values), n2.unmap();
      }
      t2.values = null;
    } else n2 = this.bufferManager.acquireBuffer(r2, a2);
    t2.resource = n2;
  }
  makeUniforms(e20) {
    let t2 = 0, n2 = 0, r2 = [], a2 = 1;
    e20.forEach((e21) => {
      let i3;
      switch (0 === e21.data.length && (e21.data = [1]), e21.data.length) {
        case 1:
          i3 = 4;
          break;
        case 2:
          i3 = 8;
          break;
        case 3:
        case 4:
        case 5:
        case 6:
          i3 = 16;
          break;
        default:
          va.assert(false, () => `Unsupported ${e21.data.length}D shape`);
      }
      (5 === n2 || 6 === n2) && (i3 = 16), i3 > a2 && (a2 = i3), t2 = Math.ceil(t2 / i3) * i3, n2 = e21.data.length, r2.push(t2), t2 += 4 * e21.data.length;
    }), t2 = Math.ceil(t2 / a2) * a2;
    let i2 = new ArrayBuffer(t2);
    e20.forEach((e21, t3) => {
      let n3 = r2[t3];
      "int32" === e21.type ? new Int32Array(i2, n3, e21.data.length).set(e21.data) : "uint32" === e21.type ? new Uint32Array(i2, n3, e21.data.length).set(e21.data) : new Float32Array(i2, n3, e21.data.length).set(e21.data);
    });
    let s2 = this.bufferManager.acquireBuffer(t2, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
    return this.queue.writeBuffer(s2, 0, i2, 0, t2), this.uniformPendingDisposal.push(s2), { offset: 0, size: t2, buffer: s2 };
  }
  runWebGPUProgram(e20, t2, n2, r2, a2) {
    if (a2 || (a2 = this.makeTensorInfo(e20.outputShape, n2)), 0 === va.sizeFromShape(a2.shape)) return this.tensorMap.get(a2.dataId).values = va.getTypedArrayFromDType(a2.dtype, 0), a2;
    this.uploadToGPU(a2.dataId), e20.dispatch = ((e21, t3) => {
      let n3 = this.device.limits.maxComputeWorkgroupsPerDimension, r3 = t3.dispatchLayout, a3 = t3.dispatch;
      if (a3.every((e22) => n3 >= e22)) return a3;
      va.assert(a3[0] > n3 && void 0 === r3.y && void 0 === r3.z, () => "Dispatch size exceeds WebGPU limits in Y or Z dimension.");
      let i3 = Math.ceil(Math.sqrt(a3[0]));
      return i3 > n3 ? (i3 = Math.ceil(Math.cbrt(a3[0])), va.assert(n3 >= i3, () => "Total dispatch size exceeds WebGPU maximum."), [i3, i3, i3]) : [i3, i3, 1];
    })(0, e20);
    let i2 = t2.map((t3, n3) => {
      if ("complex64" === t3.dtype) throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      return this.uploadToGPU(t3.dataId), { dtype: this.tensorMap.get(t3.dataId).dtype, shape: t3.shape, name: e20.variableNames[n3] };
    });
    e20.shaderKey = ((e21, t3, n3) => {
      let r3 = e21.shaderKey;
      if (null != e21.pixelsOpType) return r3;
      let a3 = [], i3 = [];
      t3.forEach((e22) => {
        a3.push(e22.shape), i3.push(e22.dtype);
      }), a3.push(n3.shape), i3.push(n3.dtype);
      let s3 = t3.map((e22) => Uf.getBroadcastDims(e22.shape, n3.shape)), o2 = t3.map((e22) => va.arraysEqual(e22.shape, n3.shape)).join("_"), l2 = s3.map((e22) => e22.join("_")).join(";"), u2 = KD(e21) ? "flatDispatch" : "";
      return r3 += "_" + (e21.workgroupSize ? e21.workgroupSize.join(",") : "") + a3.map((e22) => e22.length).join(",") + i3.join(",") + e21.variableNames.join(",") + l2 + o2 + u2, r3;
    })(e20, i2, a2);
    let s2 = _e().getBool("WEBGPU_ENGINE_COMPILE_ONLY");
    return e20.shaderKey in this.pipelineCache || (this.pipelineCache[e20.shaderKey] = ((e21, t3, n3, r3, a3) => {
      let i3 = ((e22, t4, n4) => {
        let r4 = [], a4 = n4.workgroupSize[0] * n4.workgroupSize[1] * n4.workgroupSize[2];
        if (n4.outputComponent = n4.outputComponent ? n4.outputComponent : 1, r4.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${KD(n4) ? "  return i32(globalId.x);" : `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${a4}u +
                localIndex);
        `}
      }
    `), null != n4.pixelsOpType) {
          let a5 = n4.pixelsOpType === WD.FROM_PIXELS ? `@group(0) @binding(0) var<storage, read_write> result: array<${YD(t4.dtype, n4.outputComponent)}>;` : `@group(0) @binding(1) var<storage, read> inBuf : array<${YD(e22[0].dtype, n4.outputComponent)}>;`;
          r4.push(`
        struct Uniform {
          outShapeStrides : ${3 === t4.shape.length ? "vec2<i32>" : "i32"},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${a5}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);
          let i5 = JD(n4);
          return [XD, r4.join("\n"), qD(t4.shape), n4.getUserCode(), HD(i5, n4)].join("\n");
        }
        let i4, s4, o3 = "struct Uniforms { NAN : f32, INFINITY : f32, ";
        n4.variableNames.forEach((t5, n5) => {
          let r5 = UD(e22[n5].shape.length);
          o3 += `${t5.charAt(0).toLowerCase() + t5.slice(1)}Shape : ${r5}, `, i4 = e22[n5].shape.length - 1, s4 = UD(i4), o3 += `${t5.charAt(0).toLowerCase() + t5.slice(1)}ShapeStrides: ${s4}, `;
        });
        let l2 = UD(t4.shape.length);
        o3 += `outShape : ${l2}, `, i4 = t4.shape.length - 1, s4 = UD(i4), o3 += `
         outShapeStrides: ${s4}, `, n4.size && (o3 += "size : i32, "), n4.uniforms && (o3 += n4.uniforms), o3 += "};", o3 = ((e23) => (e23 = e23.replace(/(\w+)\s*:\s*vec(5|6)/g, (e24) => "@align(16) " + e24), e23 = e23.replace(/vec(5|6)\s*,\s*(\w+)/g, (e24, t5, n5) => `vec${t5}, @align(16) ${n5}`), e23))(o3), r4.push(o3), r4.push(n4.atomic ? "\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    " : `
      @group(0) @binding(0) var<storage, read_write> result: array<${YD(t4.dtype, n4.outputComponent)}>;
    `), n4.variableNames.forEach((t5, a5) => {
          r4.push(`
      @group(0) @binding(${1 + a5}) var<storage, read> ${t5}: array<${YD(e22[a5].dtype, n4.variableComponents ? n4.variableComponents[a5] : n4.outputComponent)}>;
        `);
        }), "" !== o3 && r4.push(`
      @group(0) @binding(${1 + n4.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);
        let u2 = ((e23, t5) => {
          let { x: n5, y: r5 = [], z: a5 = [] } = t5, i5 = e23.length, s5 = n5.length + r5.length + a5.length;
          if (s5 !== i5) return "";
          if (n5.length === i5) return `fn getOutputCoords() -> ${UD(i5)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;
          let o4 = "", l3 = [n5, r5, a5];
          for (let h3 = 0; l3.length > h3; h3++) {
            let e24 = l3[h3];
            if (0 !== e24.length) if (1 === e24.length) o4 += `let d${e24[0]} = i32(globalId[${h3}]);`;
            else {
              let t6 = DD(e24, "uniforms.outShape");
              o4 += `var index${h3} = i32(globalId[${h3}]);`;
              for (let n6 = 0; t6.length > n6; n6++) o4 += `let d${e24[n6]} = index${h3} / ${t6[n6]};`, o4 += n6 === t6.length - 1 ? `let d${e24[n6 + 1]} = index${h3} - d${e24[n6]} * ${t6[n6]};` : `index${h3} = index${h3} - d${e24[n6]} * ${t6[n6]};`;
            }
          }
          let u3 = [];
          for (let h3 = 0; s5 > h3; h3++) u3.push("d" + h3);
          let d3 = UD(s5), c3 = `fn getOutputCoords() -> ${d3} {
  ${o4}
`;
          return c3 += 0 === u3.length ? `return ${d3}(0); }` : `return ${d3}(${u3.join(",")}); }`, c3;
        })(t4.shape, n4.dispatchLayout), d2 = [XD, r4.join("\n") + "\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n", qD(t4.shape), u2, ZD(t4.shape.length)];
        n4.atomic || d2.push(((e23, t5, n5) => {
          let r5 = e23.length, a5 = YD(t5, n5), i5 = `fn setOutputAtIndex(flatIndex : i32, value : ${BD(n5)}) {
      result[flatIndex] = ${a5}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${BD(n5, "i32")}) {
      result[flatIndex] = ${a5}(value);
    }
    `;
          if (r5 >= 2) {
            let e24 = ["d0", "d1", "d2", "d3", "d4", "d5"].slice(0, r5), t6 = UD(r5);
            i5 += `
      fn setOutputAtCoords(${e24.map((e25) => e25 + " : i32").join(", ")}, value : ${BD(n5)}) {
        let flatIndex = getOutputIndexFromCoords(${t6}(${e24.join(", ")}));
        setOutputAtIndex(flatIndex${1 === n5 ? "" : " / " + n5}, value);
      }
      fn setOutputAtCoordsI32(${e24.map((e25) => e25 + " : i32").join(", ")}, value : ${BD(n5, "i32")}) {
        let flatIndex = getOutputIndexFromCoords(${t6}(${e24.join(", ")}));
        setOutputAtIndexI32(flatIndex${1 === n5 ? "" : " / " + n5}, value);
      }
    `;
          }
          return i5;
        })(t4.shape, t4.dtype, n4.outputComponent)), n4.variableNames.forEach((t5, n5) => {
          d2.push("" + qD(e22[n5].shape, t5));
        });
        let c2 = e22.map((e23, r5) => ((e24, t5, n5, r6) => {
          let a5 = ((e25, t6) => {
            let n6 = e25.name, r7 = e25.shape.length, a6 = UD(r7), i5 = "get" + n6.charAt(0).toUpperCase() + n6.slice(1), s5 = ["d0", "d1", "d2", "d3", "d4", "d5"].slice(0, r7), o4 = s5.map((e26) => e26 + " : i32").join(", ");
            if (1 > r7) return `
      fn ${i5}() -> ${BD(t6)} {
        return ${BD(t6)}(${n6}[0]);
      }
    `;
            let l3 = `uniforms.${n6.charAt(0).toLowerCase() + n6.slice(1)}Shape`, u3 = r7 + "D";
            return 0 === r7 && (u3 = "1D"), `
    fn ${i5}(${o4}) -> ${BD(t6)} {
      return ${BD(t6)}(${n6}[getIndexFromCoords${u3}(${a6}(${s5.join(",")}),
        ${l3})${1 === t6 ? "" : " / " + t6}]);
    }
   `;
          })(e24, n5);
          return t5.length >= e24.shape.length && (a5 += ((e25, t6, n6, r7) => {
            let a6 = e25.name, i5 = a6.charAt(0).toUpperCase() + a6.slice(1), s5 = "get" + i5 + "ByOutput", o4 = e25.shape.length, l3 = t6.length, u3 = UD(l3);
            if (va.arraysEqual(e25.shape, t6) && r7) return `
    fn ${s5}Index(globalIndex : i32) -> ${BD(n6)} {
      return ${BD(n6)}(${a6}[globalIndex]);
    }

    fn ${s5}Coords(coords : ${u3}) -> ${BD(n6)} {
      return ${BD(n6)}(${a6}[${l3 > 1 ? "getOutputIndexFromCoords(coords)" : "coords"}${1 === n6 ? "" : " / " + n6}]);
    }
    `;
            let d3 = Uf.getBroadcastDims(e25.shape, t6), c3 = l3 - o4, h3 = "";
            if (0 === o4) return `
    fn ${s5}Index(globalIndex : i32) -> ${BD(n6)}{
      return get${i5}();
    }

    fn ${s5}Coords(coords : ${u3}) -> ${BD(n6)}{
      return get${i5}();
    }
  `;
            h3 = 2 > l3 && d3.length >= 1 ? "coords = 0;" : d3.map((e26) => `coords.${jD(e26 + c3)} = 0;`).join("\n");
            let p2 = "";
            p2 = 2 > l3 && o4 > 0 ? "coords" : l3 > 1 ? `${UD(o4)}(${e25.shape.map((e26, t7) => "coords." + jD(t7 + c3)).join(", ")})` : "coords";
            let f2 = `uniforms.${a6.charAt(0).toLowerCase() + a6.slice(1)}Shape`, m2 = o4 + "D";
            return `
  fn ${s5}Index(globalIndex : i32) -> ${BD(n6)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${h3}
    return ${BD(n6)}(${a6}[getIndexFromCoords${m2}(${p2}, ${f2})${1 === n6 ? "" : " / " + n6}]);
  }

  fn ${s5}Coords(coordsIn : ${u3}) -> ${BD(n6)} {
    var coords = coordsIn;
    ${h3}
    return ${BD(n6)}(${a6}[getIndexFromCoords${m2}(${p2}, ${f2})${1 === n6 ? "" : " / " + n6}]);
  }
`;
          })(e24, t5, n5, r6)), a5;
        })(e23, t4.shape, n4.variableComponents ? n4.variableComponents[r5] : n4.outputComponent, n4.dispatchLayout.x.length === t4.shape.length)).join("\n");
        d2.push(c2), d2.push(n4.getUserCode());
        let h2 = JD(n4);
        return d2.push(HD(h2, n4)), d2.join("\n");
      })(n3, { dtype: r3.dtype, shape: r3.shape }, t3), s3 = e21.createShaderModule({ code: i3, label: t3.constructor.name }), o2 = _e().get("WEBGPU_PRINT_SHADER");
      if ("" !== o2) {
        o2 = o2.toLowerCase();
        let e22 = o2.split(",");
        ("all" === o2 || e22.some((e23) => t3.shaderKey.toLowerCase().includes(e23))) && (console.group(t3.shaderKey), console.debug(i3), console.groupEnd());
      }
      return a3 ? e21.createComputePipelineAsync({ compute: { module: s3, entryPoint: "_start" }, label: t3.constructor.name, layout: "auto" }) : e21.createComputePipeline({ compute: { module: s3, entryPoint: "_start" }, label: t3.constructor.name, layout: "auto" });
    })(this.device, e20, i2, a2, s2)), e20.pipeline = this.pipelineCache[e20.shaderKey], s2 || this.recordAndSubmit(e20, a2, t2, r2), a2;
  }
  recordAndSubmit(e20, t2, n2, r2) {
    if (e20.pipeline instanceof Promise) throw Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");
    let a2 = [], i2 = [], s2 = "int32";
    if (null == e20.pixelsOpType) {
      a2.push({ type: "float32", data: [NaN] }, { type: "float32", data: [1 / 0] }), i2 = n2.concat(t2).map((e22) => e22.shape);
      let e21 = "int32";
      i2.map((t3) => {
        a2.push({ type: e21, data: t3 });
        let n3 = va.computeStrides(t3);
        a2.push({ type: e21, data: n3 });
      });
    } else {
      let e21 = va.computeStrides(t2.shape);
      a2.push({ type: s2, data: e21 });
    }
    if (e20.size) {
      let t3 = va.sizeFromShape(e20.outputShape);
      a2.push({ type: s2, data: [e20.outputComponent ? t3 / e20.outputComponent : t3] });
    }
    r2 && (a2 = [...a2, ...r2]);
    let o2 = [this.tensorToBinding(t2), ...n2.map((e21) => this.tensorToBinding(e21)), this.makeUniforms(a2)];
    n2.forEach((e21) => {
      this.commandQueueOwnedIds.add(e21.dataId);
    }), this.commandQueueOwnedIds.add(t2.dataId);
    let l2 = this.device.createBindGroup({ layout: e20.pipeline.getBindGroupLayout(0), entries: o2.map((e21, t3) => ({ binding: t3, resource: e21 })) }), u2 = null != this.activeTimers;
    this.ensureCommandEncoderReady();
    let d2 = {};
    u2 && this.supportTimestampQuery ? (this.endComputePassEncoder(), null == this.querySet && (this.querySet = this.device.createQuerySet({ type: "timestamp", count: this.querySetCount })), d2.timestampWrites = { querySet: this.querySet, beginningOfPassWriteIndex: 0, endOfPassWriteIndex: 1 }, this.computePassEncoder = this.commandEncoder.beginComputePass(d2)) : this.computePassEncoder || (this.computePassEncoder = this.commandEncoder.beginComputePass(d2)), this.computePassEncoder.setPipeline(e20.pipeline), this.computePassEncoder.setBindGroup(0, l2), this.computePassEncoder.dispatchWorkgroups(e20.dispatch[0], e20.dispatch[1], e20.dispatch[2]), this.dispatchCountInPass++, (u2 || _e().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE") <= this.dispatchCountInPass || e20.pixelsOpType === WD.DRAW) && (this.endComputePassEncoder(), u2 ? this.activeTimers.push({ name: e20.constructor.name, query: this.getQueryTime() }) : this.submitQueue());
  }
  getQueryTime() {
    return __async(this, null, function* () {
      if (!this.supportTimestampQuery) return 0;
      null == this.queryResolveBuffer && (this.queryResolveBuffer = this.bufferManager.acquireBuffer(8 * this.querySetCount, GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.QUERY_RESOLVE)), this.commandEncoder.resolveQuerySet(this.querySet, 0, this.querySetCount, this.queryResolveBuffer, 0);
      let e20 = this.bufferManager.acquireBuffer(8 * this.querySetCount, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, e20, 0, 8 * this.querySetCount), this.submitQueue(), yield e20.mapAsync(GPUMapMode.READ);
      let t2 = new BigUint64Array(e20.getMappedRange()), n2 = +(t2[1] - t2[0]) / 1e6;
      return e20.unmap(), this.bufferManager.releaseBuffer(e20), n2;
    });
  }
  shouldExecuteOnCPU(e20, t2 = pW) {
    return _e().getBool("WEBGPU_CPU_FORWARD") && e20.every((e21) => null == this.tensorMap.get(e21.dataId).resource && va.sizeFromShape(e21.shape) < t2);
  }
  numDataIds() {
    return this.tensorMap.numDataIds() - this.tensorDataPendingDisposal.length;
  }
  dispose() {
    this.disposed || (null != this.querySet && this.querySet.destroy(), this.bufferManager.dispose(), this.textureManager.dispose(), this.disposed = true);
  }
};
function mW(e20, t2) {
  let n2;
  do {
    switch (e20) {
      case cW.ATAN2:
        n2 = "let resultTemp = atan2(a, b);";
        break;
      case cW.MAX:
        n2 = "let resultTemp = max(a, b);";
        break;
      case cW.MIN:
        n2 = "let resultTemp = min(a, b);";
        break;
      case cW.MOD:
        n2 = t2 ? "\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n" : "\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n";
        break;
      case cW.NOT_EQUAL:
        n2 = t2 ? "\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n" : "\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n";
        break;
      case cW.POW:
        n2 = t2 ? "\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n" : "\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n";
        break;
      default:
        continue;
    }
    let r2, a2, i2;
    return t2 ? (r2 = "isnanVec4", a2 = "vec4<f32>", i2 = "vec4<bool>") : (r2 = "isnan", a2 = "f32", i2 = "bool"), `
      let aIsNaN = ${r2}(a);
      let aPostLegalization = select(a, ${a2}(42), aIsNaN);
      let bIsNaN = ${r2}(b);
      let bPostLegalization = select(b, ${a2}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${n2}
        return select(
            resultTemp, ${a2}(valueForNaN),
            ${i2}(isNaN) | aIsNaN | bIsNaN);
      }
    `;
  } while (0);
  switch (e20) {
    case cW.ADD:
      n2 = "let resultTemp = a + b;";
      break;
    case cW.COMPLEX_MULTIPLY_IMAG:
      n2 = "let resultTemp = areal * bimag + aimag * breal;";
      break;
    case cW.COMPLEX_MULTIPLY_REAL:
      n2 = "let resultTemp = areal * breal - aimag * bimag;";
      break;
    case cW.DIV:
      n2 = "let resultTemp = a / b;";
      break;
    case cW.ELU_DER:
      n2 = "let resultTemp = select(a * (b + 1.0), a, b >= b - b);";
      break;
    case cW.EQUAL:
      n2 = "\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n";
      break;
    case cW.FLOOR_DIV:
      n2 = "\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n";
      break;
    case cW.GREATER:
      n2 = "\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n";
      break;
    case cW.GREATER_EQUAL:
      n2 = "\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n";
      break;
    case cW.LESS:
      n2 = "\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n";
      break;
    case cW.LESS_EQUAL:
      n2 = "\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n";
      break;
    case cW.LOGICAL_AND:
      return t2 ? "return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));" : "return f32(a >= 1.0 && b >= 1.0);";
    case cW.LOGICAL_OR:
      return t2 ? "return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));" : "return f32(a >= 1.0 || b >= 1.0);";
    case cW.MUL:
      n2 = "let resultTemp = a * b;";
      break;
    case cW.PRELU:
      return t2 ? "\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n" : "if (a < 0.0) { return b * a; }  return a;";
    case cW.SQUARED_DIFFERENCE:
      n2 = "let resultTemp = (a - b) * (a - b);";
      break;
    case cW.SUB:
      n2 = "let resultTemp = a - b;";
  }
  return `
    ${n2}
    return resultTemp;
  `;
}
fW.nextDataId = 0, uW() && ds("webgpu", () => __async(null, null, function* () {
  let e20 = { powerPreference: _e().get("WEBGPU_USE_LOW_POWER_GPU") ? "low-power" : "high-performance" }, t2 = yield navigator.gpu.requestAdapter(e20), n2 = {}, r2 = [];
  t2.features.has("timestamp-query") && r2.push("timestamp-query"), t2.features.has("bgra8unorm-storage") && r2.push(["bgra8unorm-storage"]), n2.requiredFeatures = r2;
  let a2 = t2.limits;
  n2.requiredLimits = { maxComputeWorkgroupStorageSize: a2.maxComputeWorkgroupStorageSize, maxComputeWorkgroupsPerDimension: a2.maxComputeWorkgroupsPerDimension, maxStorageBufferBindingSize: a2.maxStorageBufferBindingSize, maxBufferSize: a2.maxBufferSize, maxComputeWorkgroupSizeX: a2.maxComputeWorkgroupSizeX, maxComputeInvocationsPerWorkgroup: a2.maxComputeInvocationsPerWorkgroup };
  let i2 = yield t2.requestDevice(n2), s2 = "info" in t2 ? t2.info : "requestAdapterInfo" in t2 ? yield t2.requestAdapterInfo() : void 0;
  return new fW(i2, s2);
}), 3), ((e20) => {
  e20[e20.ADD = 0] = "ADD", e20[e20.ATAN2 = 1] = "ATAN2", e20[e20.COMPLEX_MULTIPLY_IMAG = 2] = "COMPLEX_MULTIPLY_IMAG", e20[e20.COMPLEX_MULTIPLY_REAL = 3] = "COMPLEX_MULTIPLY_REAL", e20[e20.DIV = 4] = "DIV", e20[e20.ELU_DER = 5] = "ELU_DER", e20[e20.EQUAL = 6] = "EQUAL", e20[e20.FLOOR_DIV = 7] = "FLOOR_DIV", e20[e20.GREATER = 8] = "GREATER", e20[e20.GREATER_EQUAL = 9] = "GREATER_EQUAL", e20[e20.LESS = 10] = "LESS", e20[e20.LESS_EQUAL = 11] = "LESS_EQUAL", e20[e20.LOGICAL_AND = 12] = "LOGICAL_AND", e20[e20.LOGICAL_OR = 13] = "LOGICAL_OR", e20[e20.MAX = 14] = "MAX", e20[e20.MIN = 15] = "MIN", e20[e20.MOD = 16] = "MOD", e20[e20.MUL = 17] = "MUL", e20[e20.NOT_EQUAL = 18] = "NOT_EQUAL", e20[e20.POW = 19] = "POW", e20[e20.PRELU = 20] = "PRELU", e20[e20.SQUARED_DIFFERENCE = 21] = "SQUARED_DIFFERENCE", e20[e20.SUB = 22] = "SUB";
})(cW || (cW = {})), ((e20) => {
  e20[e20.ABS = 0] = "ABS", e20[e20.ACOS = 1] = "ACOS", e20[e20.ACOSH = 2] = "ACOSH", e20[e20.ASIN = 3] = "ASIN", e20[e20.ASINH = 4] = "ASINH", e20[e20.ATAN = 5] = "ATAN", e20[e20.ATANH = 6] = "ATANH", e20[e20.CEIL = 7] = "CEIL", e20[e20.COS = 8] = "COS", e20[e20.COSH = 9] = "COSH", e20[e20.ELU = 10] = "ELU", e20[e20.ERF = 11] = "ERF", e20[e20.EXP = 12] = "EXP", e20[e20.EXPM1 = 13] = "EXPM1", e20[e20.FLOOR = 14] = "FLOOR", e20[e20.IS_FINITE = 15] = "IS_FINITE", e20[e20.IS_INF = 16] = "IS_INF", e20[e20.IS_NAN = 17] = "IS_NAN", e20[e20.LINEAR = 18] = "LINEAR", e20[e20.LOG = 19] = "LOG", e20[e20.LOG1P = 20] = "LOG1P", e20[e20.LOGICAL_NOT = 21] = "LOGICAL_NOT", e20[e20.NEG = 22] = "NEG", e20[e20.RELU = 23] = "RELU", e20[e20.RELU6 = 24] = "RELU6", e20[e20.LEAKYRELU = 25] = "LEAKYRELU", e20[e20.RECIPROCAL = 26] = "RECIPROCAL", e20[e20.ROUND = 27] = "ROUND", e20[e20.RSQRT = 28] = "RSQRT", e20[e20.SELU = 29] = "SELU", e20[e20.SIGMOID = 30] = "SIGMOID", e20[e20.SIGN = 31] = "SIGN", e20[e20.SIN = 32] = "SIN", e20[e20.SINH = 33] = "SINH", e20[e20.SOFTPLUS = 34] = "SOFTPLUS", e20[e20.SQRT = 35] = "SQRT", e20[e20.SQUARE = 36] = "SQUARE", e20[e20.STEP = 37] = "STEP", e20[e20.TAN = 38] = "TAN", e20[e20.TANH = 39] = "TANH", e20[e20.TO_INT = 40] = "TO_INT";
})(hW || (hW = {}));
var AW = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${Uf.ERF_P};
  let a1 = ${Uf.ERF_A1};
  let a2 = ${Uf.ERF_A2};
  let a3 = ${Uf.ERF_A3};
  let a4 = ${Uf.ERF_A4};
  let a5 = ${Uf.ERF_A5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`;
var xW = `
  if (a >= 0.0) {
    return ${Uf.SELU_SCALE} * a;
  } else {
    return ${Uf.SELU_SCALEALPHA} * (exp(a) - 1.0);
  }
`;
function yW(e20, t2) {
  switch (e20) {
    case hW.ABS:
      return "return abs(a);";
    case hW.ACOS:
      return "\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";
    case hW.ACOSH:
      return "\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";
    case hW.ASIN:
      return "\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";
    case hW.ASINH:
      return "return asinh(a);";
    case hW.ATAN:
      return "\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";
    case hW.ATANH:
      return "\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";
    case hW.COS:
      return "return cos(a);";
    case hW.COSH:
      return "\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
    case hW.CEIL:
      return "return ceil(a);";
    case hW.ELU:
      return t2 ? "\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n" : "if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";
    case hW.ERF:
      return AW;
    case hW.EXP:
      return "return exp(a);";
    case hW.EXPM1:
      return "return exp(a) - 1.0;";
    case hW.FLOOR:
      return "return floor(a);";
    case hW.IS_FINITE:
      return "return f32(!isnan(a) && !isinf(a));";
    case hW.IS_INF:
      return "return f32(isinf(a));";
    case hW.IS_NAN:
      return "return f32(isnan(a));";
    case hW.LINEAR:
      return "return a;";
    case hW.LOG:
      return "if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";
    case hW.LOG1P:
      return "\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";
    case hW.LOGICAL_NOT:
      return "return f32(!(a >= 1.0));";
    case hW.NEG:
      return "return -a;";
    case hW.LEAKYRELU:
      return t2 ? "\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n" : "if (a < 0.0) { return uniforms.alpha * a; } return a;";
    case hW.RECIPROCAL:
      return "return 1.0 / a;";
    case hW.RELU:
      return t2 ? "\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n" : "return select(a, 0.0, a < 0.0);";
    case hW.RELU6:
      return t2 ? "return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));" : "return clamp(a, 0.0, 6.0);";
    case hW.ROUND:
      return "return round(a);";
    case hW.RSQRT:
      return "return inverseSqrt(a);";
    case hW.SELU:
      return xW;
    case hW.SIGMOID:
      return "return 1.0 / (1.0 + exp(-1.0 * a));";
    case hW.SIGN:
      return "return sign(a);";
    case hW.SIN:
      return "return sin(a);";
    case hW.SINH:
      return "\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
    case hW.SOFTPLUS:
      return "\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";
    case hW.SQRT:
      return "return sqrt(a);";
    case hW.SQUARE:
      return "return a * a;";
    case hW.STEP:
      return "\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";
    case hW.TAN:
      return "return tan(a);";
    case hW.TANH:
      return "\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";
    case hW.TO_INT:
      return "return f32(i32((a)));";
    default:
      throw Error(`BinaryType ${e20} is not implemented!`);
  }
}
function bW(e20, t2 = false, n2 = false, r2 = 3) {
  if (null === e20) return "";
  let a2 = "";
  if ("linear" === e20) a2 = yW(hW.LINEAR);
  else if ("relu" === e20) a2 = yW(hW.RELU, n2);
  else if ("elu" === e20) a2 = yW(hW.ELU, n2);
  else if ("relu6" === e20) a2 = yW(hW.RELU6, n2);
  else if ("prelu" === e20) a2 = mW(cW.PRELU, n2);
  else if ("sigmoid" === e20) a2 = yW(hW.SIGMOID, n2);
  else {
    if ("leakyrelu" !== e20) throw Error(`Activation ${e20} has not been implemented for the WebGPU backend.`);
    a2 = yW(hW.LEAKYRELU, n2);
  }
  let i2 = BD(n2 ? 4 : 1), s2 = "";
  return s2 = t2 ? `
      fn activation(a : ${i2}, coords : vec${r2}<i32>) -> ${i2} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${a2}
      }` : `
      fn activation(a : ${i2}, coords : vec${r2}<i32>) -> ${i2} {
        ${a2}
      }`, s2;
}
function gW(e20, t2) {
  return `
      ${e20 ? "value = value + getBiasByOutputCoords(coords);" : ""}
      ${t2 ? "value = activation(value, coords);" : ""}
      `;
}
function vW(e20, t2, n2 = false, r2 = false, a2 = false, i2 = 1) {
  va.assert(e20 && 1 === i2 || !e20, () => `transposeA ${e20} is not compatible with component size ${i2}`);
  let s2 = `
      ${e20 ? "value = getA(batch, col, row);" : "value = getA(batch, row, col);"}

    `, o2 = t2 ? "value = getB(batch, col, row);" : "value = getB(batch, row, col);";
  return `
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${BD(i2)} {
    var value = ${BD(i2)}(0.0);
    ${n2 && a2 ? s2 : `
    ${e20 ? "if(row < uniforms.dimAOuter && col < uniforms.dimInner)" : "if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${s2}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${BD(i2)} {
    var value = ${BD(i2)}(0.0);
    ${o2}
    return value;
  }
  `;
}
function wW(e20, t2, n2, r2, a2 = false, i2 = false, s2 = false, o2 = 1) {
  return `
  ${vW(n2, r2, a2, i2, s2, o2)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${BD(o2)}) {
    ${a2 && i2 ? "" : "if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${gW(e20, t2)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `;
}
function kW(e20, t2, n2 = false, r2 = 32, a2 = false, i2 = 32, s2 = false) {
  let o2 = t2[1] * e20[1], l2 = t2[0] * e20[0], u2 = n2 ? o2 : r2, d2 = n2 ? r2 : o2, c2 = u2 / t2[0], h2 = r2 / t2[1], p2 = e20[1], f2 = e20[0];
  return va.assert((n2 && 4 === c2 && 4 === e20[1] || !n2 && (3 === c2 || 4 === c2)) && u2 % t2[0] === 0 && r2 % t2[1] === 0 && 4 === e20[0], () => `If transposeA ${n2} is true, innerElementSize ${c2} and workPerThread[1] ${e20[1]} must be 4.
          Otherwise, innerElementSize ${c2} must be 3 or 4.
      tileAWidth ${u2} must be divisible by workgroupSize[0]${t2[0]}. tileInner ${r2} must be divisible by workgroupSize[1] ${t2[1]}. colPerThread ${e20[0]} must be 4.`), `
  var<workgroup> mm_Asub : array<array<vec${c2}<f32>, ${u2 / c2}>, ${d2}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l2 / e20[0]}>, ${r2}>;

  ${GD()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${p2};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${p2};
    let globalCol = i32(globalId.x) * ${f2};
    let batch = ${a2 ? "0" : "i32(globalId.z)"};
    let batchA = ${a2 || !s2 ? "batch" : "batch % uniforms.aShape[0]"};
    let batchB = ${a2 || !s2 ? "batch" : "batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${o2};

    let numTiles = ${a2 ? "" + Math.ceil(i2 / r2) : `(uniforms.dimInner - 1) / ${r2} + 1`};
    var kStart = ${a2 ? "i32(globalId.z) * " + i2 : "0"};

    var acc: array<vec4<f32>, ${p2}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${h2};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${p2}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${((e21, t3) => e21 ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${t3});
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${t3});
        `)(n2, c2)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${h2}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r2};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${((e21, t3, n3, r3) => {
    if (e21) return `
      for (var k = 0; k < ${r3}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${n3}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;
    {
      let e22 = "", a3 = "";
      for (let n4 = 0; t3 > n4; n4++) e22 += `let BCached${n4} = mm_Bsub[k * ${t3} + ${n4}][tileCol];`, a3 += `acc[i] = fma(BCached${n4}, vec4<f32>(ACached[${n4}]), acc[i]);`;
      return `
      for (var k = 0; k < ${r3 / t3}; k++) {
        ${e22}
        for (var i = 0; i < ${n3}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${a3}
        }
      }`;
    }
  })(n2, c2, p2, r2)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${p2}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`;
}
var NW = (e20) => e20 ? "\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        " : "\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";
function CW(e20, t2, n2 = false, r2 = 32, a2 = false, i2 = 32, s2 = false, o2 = false) {
  let l2 = e20[1] * t2[1], u2 = e20[0] * t2[0], d2 = n2 ? l2 : r2, c2 = n2 ? r2 : l2;
  va.assert(c2 % t2[1] === 0 && d2 % t2[0] === 0 && r2 % t2[1] === 0, () => `tileAHight ${c2} must be divisible by workgroupSize[1]${t2[1]}, tileAWidth ${d2} must be divisible by workgroupSize[0]${t2[0]}, tileInner ${r2} must be divisible by workgroupSize[1]${t2[1]}`);
  let h2 = c2 / t2[1], p2 = d2 / t2[0], f2 = r2 / t2[1], m2 = e20[1], A2 = e20[0], x2 = s2 ? `
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l2};
      let globalColStart = i32(workgroupId.x) * ${u2};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${c2}; inputRow = inputRow + ${t2[1]}) {
          for (var inputCol = localCol; inputCol < ${d2}; inputCol = inputCol + ${t2[0]}) {
            ${NW(n2)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r2}; inputRow = inputRow + ${t2[1]}) {
              for (var inputCol = localCol; inputCol < ${u2}; inputCol = inputCol + ${t2[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r2};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${A2}>;
        for (var k = 0; k < ${r2}; k++) {
          for (var inner = 0; inner < ${A2}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${t2[0]}];
          }
          for (var innerRow = 0; innerRow < ${m2}; innerRow++) {
            let ACached = ${n2 ? `mm_Asub[k][localRow + innerRow * ${t2[1]}];` : `mm_Asub[localRow + innerRow * ${t2[1]}][k];`}
            for (var innerCol = 0; innerCol < ${A2}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${m2}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${t2[1]};
        for (var innerCol = 0; innerCol < ${A2}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${t2[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      ` : `
  let tileRow = i32(localId.y) * ${m2};
  let tileCol = i32(localId.x) * ${A2};

  let globalRow = i32(globalId.y) * ${m2};
  let globalCol = i32(globalId.x) * ${A2};
  let globalRowStart = i32(workgroupId.y) * ${l2};

  let tileRowA = i32(localId.y) * ${h2};
  let tileColA = i32(localId.x) * ${p2};
  let tileRowB = i32(localId.y) * ${f2};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${h2}; innerRow++) {
      for (var innerCol = 0; innerCol < ${p2}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${NW(n2)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${f2}; innerRow++) {
      for (var innerCol = 0; innerCol < ${A2}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r2};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${A2}>;
    for (var k = 0; k < ${r2}; k++) {
      for (var inner = 0; inner < ${A2}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${m2}; innerRow++) {
        ${/* @__PURE__ */ ((e21) => e21 ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];")(n2)}
        for (var innerCol = 0; innerCol < ${A2}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${m2}; innerRow++) {
    for (var innerCol = 0; innerCol < ${A2}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;
  return `
    var<workgroup> mm_Asub : array<array<f32, ${d2}>, ${c2}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u2}>, ${r2}>;

    ${GD()} {
      let batch = ${a2 ? "0" : "i32(globalId.z)"};
      let batchA = ${a2 || !o2 ? "batch" : "batch % uniforms.aShape[0]"};
      let batchB = ${a2 || !o2 ? "batch" : "batch % uniforms.bShape[0]"};
      let numTiles = ${a2 ? "" + Math.ceil(i2 / r2) : `(uniforms.dimInner - 1) / ${r2} + 1`};
      var kStart = ${a2 ? "i32(globalId.z) * " + i2 : "0"};

      var acc : array<array<f32, ${A2}>, ${m2}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${m2}; innerRow++) {
        for (var innerCol = 0; innerCol < ${A2}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${x2}
    }
  `;
}
var $W = class {
  constructor(e20, t2, n2 = false, r2 = false, a2 = null, i2 = null, s2 = null, o2 = false) {
    this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = t2, this.dispatchLayout = { x: [2], y: [1], z: [0] };
    let l2 = n2 ? e20[1] : e20[2];
    if (this.isVec4 = (l2 % 4 == 0 && !n2 || t2[1] % 4 == 0 && n2) && t2[2] % 4 == 0 && !r2, this.outputComponent = this.isVec4 ? 4 : 1, this.isVectorA = 1 === t2[1] && !n2, !this.isVec4 && this.isVectorA) this.elementsPerThread = [1, 1, 1], this.workgroupSize = [32, 1, 1];
    else {
      let e21 = aW(t2[1], l2, t2[2], n2);
      this.workgroupSize = e21.workgroupSize, this.elementsPerThread = e21.elementsPerThread;
    }
    this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);
    let u2 = null != a2, d2 = null != s2;
    u2 && this.variableNames.push("bias"), d2 && this.variableNames.push("preluActivationWeights"), this.sequentialAccessByThreads = o2, this.transposeA = n2, this.transposeB = r2, this.addBias = u2, this.activation = i2, this.hasPreluActivationWeights = d2, [this.fitAOuter, this.fitBOuter, this.fitInner] = this.getShapeFit(t2[1], t2[2], l2), this.shaderKey = `matMulPacked_${this.elementsPerThread}_${n2}_${r2}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`;
  }
  getShapeFit(e20, t2, n2) {
    let r2 = this.workgroupSize[1] * this.elementsPerThread[1], a2 = this.workgroupSize[0] * this.elementsPerThread[0];
    return this.tileInner = !this.isVec4 && this.isVectorA ? 4 * this.workgroupSize[0] : a2, [e20 % r2 === 0, t2 % a2 === 0, n2 % this.tileInner === 0];
  }
  getUserCode() {
    return `
      ${bW(this.activation, this.hasPreluActivationWeights, this.isVec4)}
      ${wW(this.addBias, this.activation, false, this.transposeB, this.fitAOuter, this.fitBOuter, this.fitInner, this.isVec4 ? 4 : 1)}
      ${this.isVec4 ? kW(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, true) : this.isVectorA ? ((e20, t2 = false) => {
      va.assert(1 === e20[1] && 1 === e20[2], () => `A linear work group size is required. But got ${e20}.`);
      let n2 = 4 * e20[0];
      return `
    var<workgroup> mm_Asub : array<vec4<f32>, ${e20[0]}>;

    ${GD()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n2} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n2} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${/* @__PURE__ */ ((e21) => e21 ? "\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  " : "\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t2)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n2 / 4}; k++) {
          let rowB = t * ${n2} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `;
    })(this.workgroupSize, this.transposeA) : CW(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, this.sequentialAccessByThreads, true)}
    `;
  }
};
var RW = class {
  constructor(e20, t2 = false, n2 = false, r2 = null, a2 = null, i2 = null) {
    this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [256, 1, 1], this.outputShape = e20, this.dispatchLayout = { x: [], y: [1, 2], z: [0] }, this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize);
    let s2 = null != r2, o2 = null != i2;
    s2 && this.variableNames.push("bias"), o2 && this.variableNames.push("preluActivationWeights"), this.transposeA = t2, this.transposeB = n2, this.addBias = s2, this.activation = a2, this.hasPreluActivationWeights = o2, this.shaderKey = `matMulReduce_${this.activation}_${t2}_${n2}`;
  }
  getUserCode() {
    return `
      ${bW(this.activation, this.hasPreluActivationWeights)}
      ${wW(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${((e20) => `
    var<workgroup> sumValues : array<f32, ${e20}>;
    ${GD()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${e20}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${e20 / 2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `)(this.workgroupSize[0])}
    `;
  }
};
var SW = class {
  constructor(e20, t2, n2, r2 = false, a2 = false, i2 = null, s2 = null, o2 = null) {
    this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [16, 8, 1], this.outputShape = n2, this.dispatchLayout = { x: [2], y: [1], z: [0] }, this.dispatch = [Math.ceil(n2[2] / this.workgroupSize[0]), Math.ceil(n2[1] / this.workgroupSize[1]), n2[0]];
    let l2 = null != i2;
    l2 && this.variableNames.push("bias");
    let u2 = null != o2;
    u2 && this.variableNames.push("preluActivationWeights"), this.transposeA = r2, this.transposeB = a2, this.addBias = l2, this.activation = s2, this.hasPreluActivationWeights = u2, this.shaderKey = `matMulSmallOutputSize_${this.activation}_${r2}_${a2}`;
  }
  getUserCode() {
    return `
      ${bW(this.activation, this.hasPreluActivationWeights)}
      ${wW(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${((e20) => {
      let t2 = e20[1], n2 = e20[0], r2 = t2 > n2 ? t2 : n2;
      return `
  var<workgroup> mm_Asub : array<array<f32, ${r2}>, ${t2}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n2}>, ${r2}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${GD()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r2} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r2};
    globalRowB = globalRowB + ${r2};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r2};
      globalRowB = globalRowB + ${r2};

      for (var k = 0; k < ${r2}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `;
    })(this.workgroupSize)}
    `;
  }
};
var IW = class {
  constructor(e20, t2, n2 = false, r2 = false) {
    this.variableNames = ["A", "B"], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.workgroupSize = [8, 8, 1], this.atomic = true, this.splitedDimInner = 128, va.assert(1 === e20[0], () => "MatMulSplitKProgram only supports batch = 1."), this.outputShape = e20, this.dispatchLayout = { x: [2], y: [1], z: [0, 3] };
    let a2 = (n2 && this.outputShape[1] % 4 == 0 || !n2 && t2 % 4 == 0) && this.outputShape[2] % 4 == 0;
    this.elementsPerThread = [4, 4, this.splitedDimInner], this.outputComponent = a2 ? 4 : 1, a2 || (16 > this.outputShape[1] && (this.elementsPerThread[1] = 1), 16 > this.outputShape[2] && (this.elementsPerThread[0] = 1)), this.dispatch = rW(this.dispatchLayout, [this.outputShape[0], this.outputShape[1], this.outputShape[2], t2], this.workgroupSize, this.elementsPerThread), this.transposeA = n2, this.transposeB = r2, this.shaderKey = `matMulSplitK_${n2}_${r2}_${this.elementsPerThread}_${this.outputComponent}`;
  }
  getUserCode() {
    let e20 = this.outputComponent;
    return `
      ${vW(false, this.transposeB, false, false, false, e20)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${BD(e20)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e20}; i = i + 1) {
            ${LD("&result[flatIndex + i]", e20 > 1 ? "value[i]" : "value", "float32")}
          }
        }
      }
      ${4 === e20 ? kW(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner) : CW(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner)}
    `;
  }
};
var EW = class {
  constructor(e20, t2 = null, n2 = null, r2 = null) {
    this.uniforms = "", this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.addBias = null != t2, this.hasPreluActivationWeights = null != r2, this.activation = n2, this.addBias && this.variableNames.push("bias"), this.hasPreluActivationWeights && this.variableNames.push("preluActivationWeights"), this.shaderKey = "biasActivation_" + n2;
  }
  getUserCode() {
    return `
    ${bW(this.activation, this.hasPreluActivationWeights)}
    ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${gW(this.addBias, this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `;
  }
};
var TW = class {
  constructor(e20) {
    this.variableNames = [], this.outputShape = [], this.uniforms = "value : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "fill";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `;
  }
};
function MW(e20) {
  let { backend: t2, attrs: n2 } = e20, { shape: r2, value: a2 } = n2, { dtype: i2 } = n2;
  if (i2 = i2 || va.inferDtype(a2), "string" === i2) {
    let e21 = va.getArrayFromDType(i2, va.sizeFromShape(r2));
    return e21.fill(a2), t2.makeTensorInfo(r2, i2, e21);
  }
  {
    let e21 = new TW(r2);
    return t2.runWebGPUProgram(e21, [], i2, [{ type: "float32", data: [a2] }]);
  }
}
var OW = { kernelName: Kt, backendName: "webgpu", kernelFunc: MW };
function FW(e20) {
  let { inputs: t2, attrs: n2 } = e20, { x: r2 } = t2, { shape: a2 } = n2, i2 = va.sizeFromShape(r2.shape), s2 = va.inferFromImplicitShape(a2, i2), o2 = va.sizeFromShape(s2);
  return va.assert(i2 === o2, () => `The new shape (${s2}) has ${o2} elements and the old shape (${r2.shape}) has ${i2} elements. The new shape and old shape must have the same number of elements.`), e20.backend.incRef(r2.dataId), { dataId: r2.dataId, shape: s2, dtype: r2.dtype };
}
var PW = { kernelName: or, backendName: "webgpu", kernelFunc: FW };
function zW({ a: e20, b: t2, transposeA: n2, transposeB: r2, backend: a2, bias: i2 = null, preluActivationWeights: s2 = null, leakyreluAlpha: o2 = 0, activation: l2 = null }) {
  let u2 = e20.shape.length, d2 = t2.shape.length, c2 = n2 ? e20.shape[u2 - 2] : e20.shape[u2 - 1], h2 = r2 ? t2.shape[d2 - 1] : t2.shape[d2 - 2], p2 = n2 ? e20.shape[u2 - 1] : e20.shape[u2 - 2], f2 = r2 ? t2.shape[d2 - 2] : t2.shape[d2 - 1], m2 = e20.shape.slice(0, -2), A2 = t2.shape.slice(0, -2), x2 = va.sizeFromShape(m2), y2 = va.sizeFromShape(A2), b2 = Fl.assertAndGetBroadcastShape(e20.shape.slice(0, -2), t2.shape.slice(0, -2)).concat([p2, f2]);
  va.assert(c2 === h2, () => `Error in matMul: inner shapes (${c2}) and (${h2}) of Tensors with shapes ${e20.shape} and ${t2.shape} and transposeA=${n2} and transposeB=${r2} must match.`);
  let g2, v2, w2 = n2 ? [x2, c2, p2] : [x2, p2, c2], k2 = r2 ? [y2, f2, h2] : [y2, h2, f2], N2 = FW({ inputs: { x: e20 }, backend: a2, attrs: { shape: w2 } }), C2 = FW({ inputs: { x: t2 }, backend: a2, attrs: { shape: k2 } }), $2 = [N2, C2], R2 = Math.max(x2, y2), S2 = [N2, C2], I2 = [{ type: "int32", data: [p2] }, { type: "int32", data: [f2] }, { type: "int32", data: [c2] }], E2 = [R2, p2, f2], T2 = _e().get("WEBGPU_MATMUL_PROGRAM_TYPE");
  if (0 > T2) {
    let e21 = _e().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), t3 = e21 > 0 ? e21 : a2.thresholdToIncreaseWorkgroups, n3 = R2 * Math.ceil(p2 / 32) * Math.ceil(f2 / 32);
    T2 = n3 > t3 && (p2 > 8 || n3 > 2 * t3) ? eW.MatMulPackedProgram : R2 * p2 * f2 > 128 ? 1 !== R2 || 2e3 > h2 ? eW.MatMulSmallOutputSizeProgram : eW.MatMulSplitKProgram : eW.MatMulReduceProgram;
  }
  switch (T2) {
    case eW.MatMulReduceProgram:
      g2 = new RW(E2, n2, r2, i2, l2, s2);
      break;
    case eW.MatMulSplitKProgram:
      if (v2 = MW({ backend: a2, attrs: { shape: E2, value: 0, dtype: e20.dtype } }), g2 = new IW(E2, h2, n2, r2), i2 || l2) {
        v2 = a2.runWebGPUProgram(g2, S2, e20.dtype, I2, v2);
        let t4 = new EW(v2.shape, i2, l2, s2), n3 = null, r3 = [v2];
        i2 && r3.push(i2), s2 && r3.push(s2), "leakyrelu" === l2 && (n3 = [{ type: "float32", data: [o2] }], t4.uniforms += " alpha : f32,");
        let u3 = a2.runWebGPUProgram(t4, r3, v2.dtype, n3);
        $2.push(v2);
        let d3 = FW({ inputs: { x: u3 }, backend: a2, attrs: { shape: b2 } });
        $2.push(u3);
        for (let e21 of $2) a2.disposeData(e21.dataId);
        return d3;
      }
      break;
    case eW.MatMulSmallOutputSizeProgram:
      g2 = new SW(w2, k2, E2, n2, r2, i2, l2, s2);
      break;
    case eW.MatMulPackedProgram:
      let t3 = a2.adapterInfo.isIntel();
      g2 = new $W(w2, E2, n2, r2, i2, l2, s2, t3);
      break;
    default:
      throw Error(`Unsupported MatMulProgramType ${T2}.`);
  }
  i2 && S2.push(i2), s2 && S2.push(s2), "leakyrelu" === l2 && (I2.push({ type: "float32", data: [o2] }), g2.uniforms += " alpha : f32,"), v2 = a2.runWebGPUProgram(g2, S2, e20.dtype, I2, v2);
  let M2 = FW({ inputs: { x: v2 }, backend: a2, attrs: { shape: b2 } });
  $2.push(v2);
  for (let O2 of $2) a2.disposeData(O2.dataId);
  return M2;
}
var VW = { kernelName: ia, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { a: a2, b: i2, bias: s2, preluActivationWeights: o2 } = t2, { transposeA: l2, transposeB: u2, activation: d2, leakyreluAlpha: c2 } = r2;
  return zW({ a: a2, b: i2, transposeA: l2, transposeB: u2, backend: n2, bias: s2, preluActivationWeights: o2, leakyreluAlpha: c2, activation: d2 });
} };
var _W = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.workgroupSize = [128, 1, 1], this.size = true, this.outputShape = Uf.assertAndGetBroadcastShape(t2, n2), this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "binaryOpComplex_" + e20, this.op = e20;
  }
  getUserCode() {
    return `
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${mW(this.op, false)}
      }

      ${GD("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `;
  }
};
var DW = class {
  constructor(e20, t2, n2) {
    if (this.size = true, this.variableNames = ["A", "B"], this.outputShape = Uf.assertAndGetBroadcastShape(t2, n2), this.dispatchLayout = oW(this.outputShape), this.op = e20, this.useSharedMemoryWithA = 1 >= t2.length && n2.length > 1 && 128 > t2[0], this.useSharedMemoryWithB = 1 >= n2.length && t2.length > 1 && 128 > n2[0], this.useSharedMemoryWithA || this.useSharedMemoryWithB) this.outputComponent = 1, this.variableComponents = [1, 1], this.lastDimensionSize = this.useSharedMemoryWithB ? n2[0] : t2[0], this.shaderKey = `binary_${e20}_${this.lastDimensionSize}`, this.type = "shared", this.workgroupSize = [256, 1, 1];
    else {
      let r2 = t2.length > 0 && t2[t2.length - 1] % 4 == 0, a2 = n2.length > 0 && n2[n2.length - 1] % 4 == 0;
      r2 && a2 ? (this.outputComponent = 4, this.variableComponents = [4, 4]) : r2 && (va.isScalarShape(n2) || 1 === n2[n2.length - 1]) || a2 && (va.isScalarShape(t2) || 1 === t2[t2.length - 1]) ? (this.outputComponent = 4, this.variableComponents = r2 ? [4, 1] : [1, 4]) : (this.outputComponent = 1, this.variableComponents = [1, 1]), this.type = "nonshared", this.shaderKey = `binary_${e20}_${this.variableComponents}`, this.workgroupSize = [128, 1, 1];
    }
    this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.outputComponent, 1, 1]);
  }
  getUserCode() {
    let e20, t2 = 4 === this.outputComponent ? "vec4<f32>" : "f32", n2 = `
    fn binaryOperation(a : ${t2}, b : ${t2}) -> ${t2} {
      ${mW(this.op, 4 === this.outputComponent)}
    };
    `;
    if ("shared" === this.type) {
      let t3 = this.lastDimensionSize > 1 ? `coords[${this.outputShape.length - 1}]` : "0", r2 = this.useSharedMemoryWithB ? `let a = getAByOutputIndex(index);
          let b = sharedBuf[${t3}];` : `let a = sharedBuf[${t3}];
          let b = getBByOutputIndex(index);`;
      e20 = `
        ${n2}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${GD("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB ? "B" : "A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${r2}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `;
    } else e20 = `
       ${n2}
       ${GD("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t2}(getAByOutputCoords(coords));
           let b = ${t2}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;
    return e20;
  }
};
function WW(e20) {
  let { inputs: t2 } = e20, { x: n2 } = t2;
  return e20.backend.incRef(n2.dataId), { dataId: n2.dataId, shape: n2.shape, dtype: n2.dtype };
}
var LW = { kernelName: sn, backendName: "webgpu", kernelFunc: WW };
function BW(e20) {
  let { inputs: t2, backend: n2 } = e20, { real: r2, imag: a2 } = t2, i2 = n2.makeTensorInfo(r2.shape, "complex64"), s2 = n2.tensorMap.get(i2.dataId), o2 = WW({ inputs: { x: r2 }, backend: n2 }), l2 = WW({ inputs: { x: a2 }, backend: n2 });
  return s2.complexTensorInfos = { real: o2, imag: l2 }, i2;
}
var UW = { kernelName: At, backendName: "webgpu", kernelFunc: BW };
var jW = class {
  constructor(e20, t2, n2 = "") {
    this.variableNames = ["A"], this.size = true, this.workgroupSize = [128, 1, 1], this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.op = t2, "" !== n2 && (this.uniforms = n2), this.shaderKey = "unary_" + t2;
  }
  getUserCode() {
    return `
      fn unaryOperation(a : f32) -> f32 {
        ${yW(this.op, false)}
      }
      ${GD("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `;
  }
};
function GW({ opType: e20, cpuKernelImpl: t2, dtype: n2 }) {
  return ({ inputs: r2, backend: a2 }) => {
    let { x: i2 } = r2, s2 = a2, o2 = n2 || i2.dtype;
    if (s2.shouldExecuteOnCPU([i2]) && null != t2) {
      let e21 = s2.tensorMap.get(i2.dataId), n3 = t2(e21.values, o2);
      return s2.makeTensorInfo(i2.shape, o2, n3);
    }
    let l2 = new jW(i2.shape, e20);
    return s2.runWebGPUProgram(l2, [i2], o2);
  };
}
function HW({ opType: e20, cpuKernelImpl: t2, supportsComplex: n2 = false, dtype: r2 }) {
  return ({ inputs: a2, backend: i2 }) => {
    let { a: s2, b: o2 } = a2, l2 = i2;
    if (n2 && "complex64" === s2.dtype) {
      let t3, n3, r3 = l2.tensorMap.get(s2.dataId), a3 = l2.tensorMap.get(o2.dataId);
      if (e20 !== cW.MUL) [t3, n3] = [[r3.complexTensorInfos.real, a3.complexTensorInfos.real], [r3.complexTensorInfos.imag, a3.complexTensorInfos.imag]].map((t4) => {
        let [n4, r4] = t4, a4 = { dataId: n4.dataId, dtype: n4.dtype, shape: s2.shape }, i4 = { dataId: r4.dataId, dtype: r4.dtype, shape: o2.shape }, u3 = new DW(e20, s2.shape, o2.shape);
        return l2.runWebGPUProgram(u3, [a4, i4], pi(n4.dtype, r4.dtype));
      });
      else {
        let e21 = new _W(cW.COMPLEX_MULTIPLY_REAL, s2.shape, o2.shape), i4 = new _W(cW.COMPLEX_MULTIPLY_IMAG, s2.shape, o2.shape), u3 = [{ dataId: r3.complexTensorInfos.real.dataId, dtype: r3.complexTensorInfos.real.dtype, shape: s2.shape }, { dataId: r3.complexTensorInfos.imag.dataId, dtype: r3.complexTensorInfos.imag.dtype, shape: s2.shape }, { dataId: a3.complexTensorInfos.real.dataId, dtype: a3.complexTensorInfos.real.dtype, shape: o2.shape }, { dataId: a3.complexTensorInfos.imag.dataId, dtype: a3.complexTensorInfos.imag.dtype, shape: o2.shape }];
        t3 = l2.runWebGPUProgram(e21, u3, "float32"), n3 = l2.runWebGPUProgram(i4, u3, "float32");
      }
      let i3 = BW({ inputs: { real: t3, imag: n3 }, backend: l2 });
      return l2.disposeData(t3.dataId), l2.disposeData(n3.dataId), i3;
    }
    let u2 = r2 || pi(s2.dtype, o2.dtype);
    if (("string" === s2.dtype || "string" === o2.dtype || l2.shouldExecuteOnCPU([s2, o2])) && null != t2) {
      let e21 = l2.tensorMap.get(s2.dataId).values, n3 = l2.tensorMap.get(o2.dataId).values, r3 = "string" === s2.dtype ? Uf.fromUint8ToStringArray(e21) : e21, a3 = "string" === s2.dtype ? Uf.fromUint8ToStringArray(n3) : n3, [i3, d3] = t2(s2.shape, o2.shape, r3, a3, u2);
      return l2.makeTensorInfo(d3, u2, i3);
    }
    let d2 = new DW(e20, s2.shape, o2.shape);
    return l2.runWebGPUProgram(d2, [s2, o2], u2);
  };
}
var { addImpl: XW, castImpl: qW, ceilImpl: ZW, concatImpl: KW, equalImpl: YW, expImpl: JW, expm1Impl: QW, floorImpl: eL, floorDivImpl: tL, gatherNdImpl: nL, gatherV2Impl: rL, greaterEqualImpl: aL, greaterImpl: iL, lessEqualImpl: sL, lessImpl: oL, logImpl: lL, maxImpl: uL, maximumImpl: dL, minimumImpl: cL, multiplyImpl: hL, negImpl: pL, notEqualImpl: fL, prodImpl: mL, rangeImpl: AL, rsqrtImpl: xL, scatterImpl: yL, simpleAbsImpl: bL, sliceImpl: gL, stridedSliceImpl: vL, stringNGramsImpl: wL, subImpl: kL, tileImpl: NL, topKImpl: CL, transposeImpl: $L } = Lx;
var RL = { kernelName: "Abs", backendName: "webgpu", kernelFunc: GW({ opType: hW.ABS, cpuKernelImpl: bL }) };
var SL = GW({ opType: hW.ACOS });
var IL = { kernelName: je, backendName: "webgpu", kernelFunc: SL };
var EL = GW({ opType: hW.ACOSH });
var TL = { kernelName: Ge, backendName: "webgpu", kernelFunc: EL };
var ML = { kernelName: "Add", backendName: "webgpu", kernelFunc: HW({ opType: cW.ADD, cpuKernelImpl: XW, supportsComplex: true }) };
var OL = class {
  constructor(e20) {
    this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20[0], this.variableNames = e20.map((e21, t2) => "T" + t2), this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.shaderKey = "addN";
  }
  getUserCode() {
    let e20 = [];
    this.variableNames.forEach((t3) => {
      e20.push(`let v${t3} = get${t3}ByOutputCoords(coords);`);
    });
    let t2 = this.variableNames.map((e21) => "v" + e21).join(" + ");
    return `
      ${GD("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e20.join("\n        ")}
            setOutputAtIndex(flatIndex, ${t2});
          }
        }
      }
    `;
  }
};
var FL = { kernelName: Xe, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, r2 = t2;
  if (1 === r2.length) return WW({ inputs: { x: r2[0] }, backend: n2 });
  let a2 = r2.map((e21) => e21.dtype).reduce((e21, t3) => pi(e21, t3)), i2 = r2.map((e21) => e21.shape), s2 = new OL(i2);
  return n2.runWebGPUProgram(s2, r2, a2);
} };
var PL = class {
  constructor(e20, t2) {
    this.variableNames = ["A"], this.workgroupSize = [16, 16, 1];
    let n2 = Array(e20.length);
    for (let r2 = 0; n2.length > r2; r2++) n2[r2] = e20[t2[r2]];
    this.outputShape = n2, this.dispatchLayout = { x: [0], y: [1] }, this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [1, 1, 1]), this.shaderKey = "transposeShared";
  }
  getUserCode() {
    va.assert(this.workgroupSize[0] === this.workgroupSize[1], () => `Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);
    let e20 = this.workgroupSize[0];
    return `
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0] + 1}>, ${this.workgroupSize[0]}>;
      ${GD()} {
        var x = i32(workgroupId.x) * ${e20} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e20} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e20} + i32(localId.x);
        y = i32(workgroupId.x) * ${e20} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `;
  }
};
var zL = class {
  constructor(e20, t2) {
    this.variableNames = ["A"], this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true;
    let n2 = Array(e20.length);
    for (let r2 = 0; n2.length > r2; r2++) n2[r2] = e20[t2[r2]];
    this.outputShape = n2, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.newDim = t2, this.shaderKey = "transpose_" + t2;
  }
  getUserCode() {
    let e20 = UD(this.outputShape.length), t2 = VL(this.newDim);
    return `
      ${GD("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e20}(${t2}), uniforms.aShape)]);
          }
        }
      }
    `;
  }
};
function VL(e20) {
  let t2 = e20.length;
  if (t2 > 6) throw Error(`Transpose for rank ${t2} is not yet supported`);
  let n2 = Array(t2);
  for (let r2 = 0; e20.length > r2; r2++) n2[e20[r2]] = "coords." + jD(r2);
  return n2.join();
}
function _L(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { perm: i2 } = r2, s2 = n2, o2 = Array(a2.shape.length);
  for (let u2 = 0; o2.length > u2; u2++) o2[u2] = a2.shape[i2[u2]];
  if (n2.shouldExecuteOnCPU([a2])) {
    let e21 = s2.tensorMap.get(a2.dataId).values, t3 = $L(e21, a2.shape, a2.dtype, i2, o2);
    return n2.makeTensorInfo(o2, a2.dtype, t3);
  }
  if (2 === a2.shape.length && va.arraysEqual(i2, [1, 0])) {
    let e21 = new PL(a2.shape, i2);
    return s2.runWebGPUProgram(e21, [a2], a2.dtype);
  }
  let l2 = new zL(a2.shape, i2);
  return s2.runWebGPUProgram(l2, [a2], a2.dtype);
}
var DL = { kernelName: Kr, backendName: "webgpu", kernelFunc: _L };
var WL = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["x"], this.uniforms = "reduceSize : i32,", this.size = true, this.inputShape = [e20.batchSize, e20.inSize];
    let [r2] = Uf.computeOutAndReduceShapes(this.inputShape, [1]);
    this.outputShape = 0 === r2.length ? [1] : r2, this.workgroupSize = 32768 > e20.inSize || 512 > n2 ? 4096 > e20.inSize ? [64, 1, 1] : [256, 1, 1] : [512, 1, 1], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, [1, 1, 1]), this.reduceType = t2, this.shaderKey = "reduce_" + t2;
  }
  getUserCode() {
    let e20 = "", t2 = "0.0", n2 = this.workgroupSize[0];
    "min" === this.reduceType || "max" === this.reduceType ? (e20 = `
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${"min" === this.reduceType ? "<" : ">"} bestValue)
           {  bestValue = candidate; }`, t2 = "f32(x[offset])") : "sum" === this.reduceType || "mean" === this.reduceType ? e20 = " bestValue = bestValue + candidate; " : "prod" === this.reduceType ? (e20 = " bestValue = bestValue * candidate; ", t2 = "1.0") : "all" === this.reduceType ? (e20 = " bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ", t2 = "1.0") : "any" === this.reduceType && (e20 = " bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ", t2 = "0.0");
    let r2 = "mean" === this.reduceType ? "setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));" : "setOutputAtIndex(outputIndex, bestValue);";
    return `
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       
         var<workgroup> xBestValues : array<f32, ${n2}>;
       
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${1 === this.outputShape.length ? "outputCoords" : "outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${GD("index")} {
         let outputIndex = index / ${n2};
         let offset = getOffset(outputIndex);
         var bestValue = ${t2};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${n2}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${n2}) {
           let candidate = f32(x[offset + k]);
           ${e20}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${n2}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e20}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${r2}
        }
       }
     `;
  }
};
var LL = { mean: "float32", all: "bool", any: "bool" };
function BL(e20, t2, n2, r2, a2) {
  let i2 = e20.shape.length, s2 = [], o2 = va.parseAxisParam(t2, e20.shape), l2 = o2, u2 = Uf.getAxesPermutation(l2, i2), d2 = e20;
  null != u2 && (d2 = _L({ inputs: { x: e20 }, attrs: { perm: u2 }, backend: a2 }), l2 = Uf.getInnerMostAxes(l2.length, i2), s2.push(d2)), Uf.assertAxesAreInnerMostDims(r2, l2, i2);
  let c2, [h2, p2] = Uf.computeOutAndReduceShapes(d2.shape, l2), f2 = h2;
  if (n2 && (f2 = Uf.expandShapeToKeepDim(h2, o2)), "max" !== r2 && "prod" !== r2 || !a2.shouldExecuteOnCPU([d2])) {
    let t3 = va.sizeFromShape(p2), n3 = { windowSize: t3, inSize: t3, batchSize: va.sizeFromShape(d2.shape) / t3, outSize: 1 }, i3 = LL[r2] || fi(e20.dtype), o3 = [{ type: "int32", data: [t3] }], l3 = new WL(n3, r2, a2.device.limits.maxComputeWorkgroupSizeX), u3 = a2.runWebGPUProgram(l3, [d2], i3, o3);
    s2.push(u3), c2 = FW({ inputs: { x: u3 }, attrs: { shape: f2 }, backend: a2 });
  } else {
    let t3 = a2.tensorMap.get(d2.dataId).values;
    switch (r2) {
      case "max":
        let n3 = uL(t3, va.sizeFromShape(p2), f2, e20.dtype);
        c2 = a2.makeTensorInfo(f2, e20.dtype, n3);
        break;
      case "prod":
        let { outVals: i3, outShape: s3, outDtype: o3 } = mL(d2.shape, d2.dtype, t3, l2);
        c2 = a2.makeTensorInfo(s3, o3, i3);
        break;
      default:
        throw Error(r2 + " CPU implementation is not yet supported.");
    }
  }
  return s2.forEach((e21) => a2.disposeData(e21.dataId)), c2;
}
var UL = { kernelName: "All", backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { keepDims: i2, axis: s2 } = r2;
  return BL(a2, s2, i2, "all", n2);
} };
var jL = { kernelName: "Any", backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { keepDims: i2, axis: s2 } = r2;
  return BL(a2, s2, i2, "any", n2);
} };
var GL = class {
  constructor(e20, t2, n2) {
    this.workgroupSize = [64, 1, 1], this.variableNames = ["x"], this.uniforms = "infinityValue : f32,", this.size = true;
    let r2 = [t2];
    this.op = "min" === n2 ? "<" : ">";
    let [a2, i2] = Uf.computeOutAndReduceShapes(e20, r2);
    this.outputShape = 0 === a2.length ? [1] : a2, this.dispatchLayout = oW(this.outputShape), 32 > va.sizeFromShape(i2) ? (this.type = "plain", this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize)) : (this.type = "shared", this.dispatch = rW(this.dispatchLayout, this.outputShape, [1, 1, 1])), this.inputShape = e20, this.shaderKey = `argMinMax_${this.op}_${this.type}`;
  }
  getUserCode() {
    let e20 = this.workgroupSize[0], t2 = () => 1 === this.inputShape.length ? "uniforms.xShape" : "uniforms.xShape." + jD(this.inputShape.length - 1), n2 = () => {
      let e21 = "";
      if (1 === this.outputShape.length) 1 !== this.inputShape.length && (e21 += "outputCoords,");
      else for (let t3 = 0; this.outputShape.length > t3; t3++) e21 += `outputCoords.${jD(t3)},`;
      return e21;
    };
    return "shared" === this.type ? `
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      
      var<workgroup> xBestIndices : array<i32, ${e20}>;
      var<workgroup> xBestValues : array<f32, ${e20}>;
    

      ${GD("index")} {
        let outputIndex = index / ${e20};
        let reduceLength = ${t2()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e20}) {
          let candidate = getX(${n2()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e20}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    ` : `
      ${GD("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${n2()} 0);
          let reduceLength = ${t2()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${n2()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `;
  }
};
var HL = { kernelName: Ke, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2 } = r2, s2 = va.parseAxisParam(i2, a2.shape), o2 = Uf.getAxesPermutation(s2, a2.shape.length), l2 = a2, u2 = [];
  null != o2 && (l2 = _L({ inputs: { x: a2 }, backend: n2, attrs: { perm: o2 } }), u2.push(l2), s2 = Uf.getInnerMostAxes(s2.length, l2.shape.length)), Uf.assertAxesAreInnerMostDims("argMax", [s2[0]], l2.shape.length);
  let d2 = new GL(l2.shape, s2[0], "max"), c2 = n2.runWebGPUProgram(d2, [l2], "int32", [{ type: "float32", data: [-Infinity] }]);
  return u2.forEach((e21) => n2.disposeData(e21.dataId)), c2;
} };
var XL = { kernelName: Ye, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2 } = r2, s2 = va.parseAxisParam(i2, a2.shape), o2 = Uf.getAxesPermutation(s2, a2.shape.length), l2 = a2, u2 = [];
  null != o2 && (l2 = _L({ inputs: { x: a2 }, backend: n2, attrs: { perm: o2 } }), u2.push(l2), s2 = Uf.getInnerMostAxes(s2.length, l2.shape.length)), Uf.assertAxesAreInnerMostDims("argMin", [s2[0]], l2.shape.length);
  let d2 = new GL(l2.shape, s2[0], "min"), c2 = n2.runWebGPUProgram(d2, [l2], "int32", [{ type: "float32", data: [Infinity] }]);
  return u2.forEach((e21) => n2.disposeData(e21.dataId)), c2;
} };
var qL = GW({ opType: hW.ASIN });
var ZL = { kernelName: Je, backendName: "webgpu", kernelFunc: qL };
var KL = GW({ opType: hW.ASINH });
var YL = { kernelName: Qe, backendName: "webgpu", kernelFunc: KL };
var JL = GW({ opType: hW.ATAN });
var QL = { kernelName: et, backendName: "webgpu", kernelFunc: JL };
var eB = HW({ opType: cW.ATAN2 });
var tB = { kernelName: nt, backendName: "webgpu", kernelFunc: eB };
var nB = GW({ opType: hW.ATANH });
var rB = { kernelName: tt, backendName: "webgpu", kernelFunc: nB };
var aB = class {
  constructor(e20) {
    this.variableNames = ["x"], this.uniforms = "strides : vec2<i32>,", this.workgroupSize = [256, 1, 1], this.size = true, this.outputShape = e20.outShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "poolWithFilterSizeEqualsOne";
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `;
  }
};
var iB = class {
  constructor(e20, t2, n2 = false, r2 = false, a2 = false) {
    if (this.variableNames = ["x"], this.uniforms = "strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,", this.workgroupSize = [128, 1, 1], this.size = true, "avg" === t2 && n2) throw Error("Cannot compute positions for average pool.");
    this.outputShape = e20.outShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.poolType = t2, this.computePositions = n2, this.flattenPositions = r2, this.includeBatchIndex = a2, this.shaderKey = `pool2D_${t2}_${n2}_${r2}_${a2}`;
  }
  getUserCode() {
    let e20;
    e20 = "avg" === this.poolType ? "resultValue = resultValue + value; count = count + 1.0;" : this.computePositions ? `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "wR * uniforms.filterDims.y + wC"};
      }` : "resultValue = max(value, resultValue);";
    let t2 = "resultValue";
    return "avg" === this.poolType && (t2 = "resultValue / max(count, 1.0)"), `
      ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions ? "var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;" : `var resultValue = ${"avg" === this.poolType ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e20}
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t2});`}
        }
      }
    `;
  }
};
var sB = class {
  constructor(e20, t2, n2 = false, r2 = false, a2 = false) {
    if (this.variableNames = ["x"], this.uniforms = "strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,", this.workgroupSize = [128, 1, 1], this.size = true, "avg" === t2 && n2) throw Error("Cannot compute positions for average pool.");
    this.outputShape = e20.outShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.poolType = t2, this.computePositions = n2, this.flattenPositions = r2, this.includeBatchIndex = a2, this.shaderKey = `pool3D_${t2}_${n2}_${r2}_${a2}`;
  }
  getUserCode() {
    let e20;
    e20 = "avg" === this.poolType ? "resultValue += value; count += 1.0;" : this.computePositions ? `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }` : "resultValue = max(value, resultValue);";
    let t2 = "resultValue";
    return "avg" === this.poolType && (t2 = "resultValue / max(count, 1.0)"), `
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions ? "var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;" : `var resultValue = ${"avg" === this.poolType ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e20}
              }
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t2});`}
        }
      }
    `;
  }
};
function oB(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { reductionIndices: i2, keepDims: s2 } = r2;
  return BL(a2, i2, s2, "max", n2);
}
var lB = { kernelName: "Max", backendName: "webgpu", kernelFunc: oB };
function uB(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { keepDims: i2, axis: s2 } = r2;
  return BL(a2, s2, i2, "mean", n2);
}
var dB = { kernelName: Fn, backendName: "webgpu", kernelFunc: uB };
function cB(e20, t2, n2, r2) {
  if (1 === t2.filterWidth && 1 === t2.filterHeight && va.arraysEqual(t2.inShape, t2.outShape)) return WW({ inputs: { x: e20 }, backend: r2 });
  if (t2.filterWidth === t2.inWidth && t2.filterHeight === t2.inHeight && 1 === t2.batchSize && "VALID" === t2.padInfo.type) {
    let a3, i3 = e20.shape.length, s2 = FW({ inputs: { x: e20 }, backend: r2, attrs: { shape: [e20.shape[i3 - 3] * e20.shape[i3 - 2], e20.shape[i3 - 1]] } });
    "avg" === n2 ? a3 = uB({ inputs: { x: s2 }, backend: r2, attrs: { axis: 0, keepDims: false } }) : (va.assert("max" === n2, () => "Invalid pool type " + n2), a3 = oB({ inputs: { x: s2 }, backend: r2, attrs: { reductionIndices: 0, keepDims: false } }));
    let o2 = FW({ inputs: { x: a3 }, backend: r2, attrs: { shape: t2.outShape } });
    return r2.disposeData(s2.dataId), r2.disposeData(a3.dataId), o2;
  }
  let a2, i2 = [{ type: "int32", data: [t2.strideHeight, t2.strideWidth] }];
  return 1 === t2.filterHeight && 1 === t2.filterWidth ? a2 = new aB(t2) : ("avg" === n2 ? a2 = new iB(t2, "avg") : (va.assert("max" === n2, () => "Invalid pool type " + n2), a2 = new iB(t2, "max")), i2.push({ type: "int32", data: [t2.padInfo.top, t2.padInfo.left] }, { type: "int32", data: [t2.dilationHeight, t2.dilationWidth] }, { type: "int32", data: [t2.inHeight, t2.inWidth] }, { type: "int32", data: [t2.effectiveFilterHeight, t2.effectiveFilterWidth] })), r2.runWebGPUProgram(a2, [e20], e20.dtype, i2);
}
var hB = { kernelName: rt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2 } = r2;
  return cB(a2, Uf.computePool2DInfo(a2.shape, i2, s2, 1, o2, l2), "avg", n2);
} };
var pB = { kernelName: it, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dataFormat: l2, dimRoundingMode: u2 } = r2, d2 = Uf.computePool3DInfo(a2.shape, i2, s2, [1, 1, 1], o2, u2, l2), c2 = new sB(d2, "avg");
  return n2.runWebGPUProgram(c2, [a2], a2.dtype, [{ type: "int32", data: [d2.strideDepth, d2.strideHeight, d2.strideWidth] }, { type: "int32", data: [d2.padInfo.front, d2.padInfo.top, d2.padInfo.left] }, { type: "int32", data: [d2.inDepth, d2.inHeight, d2.inWidth] }, { type: "int32", data: [d2.effectiveFilterDepth, d2.effectiveFilterHeight, d2.effectiveFilterWidth] }]);
} };
var fB = class {
  constructor(e20) {
    this.variableNames = ["dy"], this.uniforms = "strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.inShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "avgPool2DBackprop";
  }
  getUserCode() {
    return `
      ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
  }
};
var mB = class {
  constructor(e20) {
    this.variableNames = ["dy"], this.uniforms = "strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.inShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "avgPool3DBackprop";
  }
  getUserCode() {
    return `
      ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
  }
};
var AB = { kernelName: st, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, s2 = i2, { filterSize: o2, strides: l2, pad: u2, dimRoundingMode: d2 } = r2, c2 = Uf.computePool3DInfo(s2.shape, o2, l2, 1, u2, d2), h2 = new mB(c2);
  return n2.runWebGPUProgram(h2, [a2], s2.dtype, [{ type: "int32", data: [c2.strideDepth, c2.strideHeight, c2.strideWidth] }, { type: "int32", data: [c2.effectiveFilterDepth - 1 - c2.padInfo.front, c2.effectiveFilterHeight - 1 - c2.padInfo.top, c2.effectiveFilterWidth - 1 - c2.padInfo.left] }, { type: "int32", data: [c2.effectiveFilterDepth, c2.effectiveFilterHeight, c2.effectiveFilterWidth] }, { type: "int32", data: [c2.outDepth] }, { type: "int32", data: [c2.outHeight] }, { type: "int32", data: [c2.outWidth] }, { type: "float32", data: [1 / (c2.filterDepth * c2.filterHeight * c2.filterWidth)] }]);
} };
var xB = { kernelName: at, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, s2 = i2;
  dW([a2, i2], "avgPoolGrad");
  let { filterSize: o2, strides: l2, pad: u2 } = r2, d2 = Uf.computePool2DInfo(s2.shape, o2, l2, 1, u2), c2 = new fB(d2);
  return n2.runWebGPUProgram(c2, [a2], s2.dtype, [{ type: "int32", data: [d2.strideHeight, d2.strideWidth] }, { type: "int32", data: [d2.effectiveFilterHeight - 1 - d2.padInfo.top, d2.effectiveFilterWidth - 1 - d2.padInfo.left] }, { type: "int32", data: [d2.dilationHeight, d2.dilationWidth] }, { type: "int32", data: [d2.effectiveFilterHeight, d2.effectiveFilterWidth] }, { type: "int32", data: [d2.outHeight] }, { type: "int32", data: [d2.outWidth] }, { type: "float32", data: [1 / (d2.filterHeight * d2.filterWidth)] }]);
} };
var yB = { kernelName: ot, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { a: a2, b: i2 } = t2, { transposeA: s2, transposeB: o2 } = r2;
  return zW({ a: a2, b: i2, transposeA: s2, transposeB: o2, backend: n2 });
} };
var bB = class {
  constructor(e20, t2) {
    this.variableNames = ["source"], this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t2, this.rank = t2.length, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.start = e20, this.uniforms = `start : ${UD(e20.length)}, `, this.shaderKey = "slice";
  }
  getUserCode() {
    let e20, t2 = UD(this.rank), n2 = ((e21) => {
      if (1 === e21) return "sourceLoc";
      if (6 >= e21) return gB.slice(0, e21).map((e22) => "sourceLoc." + e22).join(",");
      throw Error(`Slicing for rank ${e21} is not yet supported`);
    })(this.rank);
    return e20 = this.outputShape.map(1 === this.start.length ? (e21, t3) => "sourceLoc = uniforms.start + coords;" : (e21, t3) => `sourceLoc.${gB[t3]} = uniforms.start.${jD(t3)} + coords.${gB[t3]};`), `
      ${GD("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${t2};
          let coords = getCoordsFromIndex(index);
          ${e20.join("\n")}
          setOutputAtIndex(index, getSource(${n2}));
        }
      }
    `;
  }
};
var gB = ["x", "y", "z", "w", "u", "v"];
function vB(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { begin: i2, size: s2 } = r2, [o2, l2] = xf.parseSliceParams(a2, i2, s2);
  if (xf.assertParamsValid(a2, o2, l2), n2.shouldExecuteOnCPU([a2]) || "string" === a2.dtype) {
    let e21 = n2.tensorMap.get(a2.dataId), t3 = gL(e21.values, o2, l2, a2.shape, a2.dtype);
    return n2.makeTensorInfo(l2, a2.dtype, t3);
  }
  if (0 === va.sizeFromShape(l2)) return n2.makeTensorInfo(l2, a2.dtype, []);
  let u2 = new bB(o2, l2);
  return n2.runWebGPUProgram(u2, [a2], a2.dtype, [{ type: "int32", data: o2 }]);
}
var wB = { kernelName: vr, backendName: "webgpu", kernelFunc: vB };
var kB = { kernelName: lt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockShape: i2, crops: s2 } = r2;
  va.assert(4 >= a2.shape.length, () => "batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");
  let o2 = i2.reduce((e21, t3) => e21 * t3), l2 = Uf.getReshaped(a2.shape, i2, o2), u2 = Uf.getPermuted(l2.length, i2.length), d2 = Uf.getReshapedPermuted(a2.shape, i2, o2), c2 = Uf.getSliceBeginCoords(s2, i2.length), h2 = Uf.getSliceSize(d2, s2, i2.length), p2 = [], f2 = FW({ inputs: { x: a2 }, backend: n2, attrs: { shape: l2 } }), m2 = _L({ inputs: { x: f2 }, backend: n2, attrs: { perm: u2 } }), A2 = FW({ inputs: { x: m2 }, backend: n2, attrs: { shape: d2 } }), x2 = vB({ inputs: { x: A2 }, backend: n2, attrs: { begin: c2, size: h2 } });
  return p2.push(f2), p2.push(m2), p2.push(A2), p2.forEach((e21) => n2.disposeData(e21.dataId)), x2;
} };
var NB = `
  fn bincount_write(index: i32, value: f32) {
    ${LD("&result[index]", "value", "float32")}
  }
`;
var CB = class {
  constructor(e20, t2, n2 = false) {
    this.outputShape = [], this.variableNames = ["x"], this.uniforms = "binCountSize : i32,", this.workgroupSize = [64, 1, 1], this.atomic = true, this.hasWeights = true, this.binaryOutput = false, this.outputShape = e20, this.rank = e20.length, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.binaryOutput = n2, n2 && (this.atomic = false), this.hasWeights = t2, this.hasWeights && this.variableNames.push("w"), this.shaderKey = `bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`;
  }
  getUserCode() {
    return `
    ${this.binaryOutput ? "\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n" : NB}
  ${GD("index")} {
    ${1 === this.rank ? `if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(index)" : "1."};
        bincount_write(indexVal, value);
      }
    }` : `let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(coord[0], coord[1])" : "1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `;
  }
};
var $B = { kernelName: ut, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, weights: i2 } = t2, { size: s2 } = r2, o2 = va.sizeFromShape(a2.shape), l2 = va.sizeFromShape(i2.shape) > 0, u2 = i2.dtype, d2 = MW({ backend: n2, attrs: { shape: [s2], value: 0, dtype: u2 } }), c2 = new CB([o2], l2);
  return n2.runWebGPUProgram(c2, l2 ? [a2, i2] : [a2], u2, [{ type: "int32", data: [s2] }], d2);
} };
var RB = class {
  constructor(e20) {
    this.outputShape = [], this.variableNames = ["s0", "s1"], this.uniforms = "s0Size : i32, s1Size : i32, ", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e20], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "broadcastArgs";
  }
  getUserCode() {
    return `
  ${GD("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `;
  }
};
var SB = { kernelName: ht, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { s0: r2, s1: a2 } = t2;
  if (n2.shouldExecuteOnCPU([r2, a2])) {
    let e21 = n2.tensorMap.get(r2.dataId), t3 = n2.tensorMap.get(a2.dataId).values, i3 = Uf.assertAndGetBroadcastShape(Array.from(e21.values), Array.from(t3));
    return n2.makeTensorInfo([i3.length], "int32", Int32Array.from(i3));
  }
  let i2 = va.sizeFromShape(r2.shape), s2 = va.sizeFromShape(a2.shape), o2 = new RB(Math.max(i2, s2));
  return n2.runWebGPUProgram(o2, [r2, a2], "int32", [{ type: "int32", data: [i2] }, { type: "int32", data: [s2] }]);
} };
var IB = HW({ opType: cW.NOT_EQUAL, dtype: "bool", cpuKernelImpl: fL });
var EB = { kernelName: Bn, backendName: "webgpu", kernelFunc: IB };
function TB(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2;
  return WW({ inputs: { x: n2.tensorMap.get(r2.dataId).complexTensorInfos.real }, backend: n2 });
}
var MB = { kernelName: ar, backendName: "webgpu", kernelFunc: TB };
var OB = { kernelName: pt, backendName: "webgpu", kernelFunc: function e18(t2) {
  let { inputs: n2, backend: r2, attrs: a2 } = t2, { x: i2 } = n2, { dtype: s2 } = a2;
  if ("complex64" === s2) {
    if ("complex64" === i2.dtype) return WW({ inputs: { x: i2 }, backend: r2 });
    let t3 = nd(i2.shape), n3 = e18({ inputs: { x: i2 }, backend: r2, attrs: { dtype: "float32" } }), a3 = BW({ inputs: { real: n3, imag: t3 }, backend: r2 });
    return t3.dispose(), r2.disposeData(n3.dataId), a3;
  }
  if ("complex64" === i2.dtype) {
    let t3 = TB({ inputs: { input: i2 }, backend: r2 }), n3 = e18({ inputs: { x: t3 }, backend: r2, attrs: { dtype: s2 } });
    return r2.disposeData(t3.dataId), n3;
  }
  if (!va.hasEncodingLoss(i2.dtype, s2)) {
    let e20 = WW({ inputs: { x: i2 }, backend: r2 });
    return { dataId: e20.dataId, shape: e20.shape, dtype: s2 };
  }
  if (r2.shouldExecuteOnCPU([i2])) {
    let e20 = r2.tensorMap.get(i2.dataId).values, [t3, n3, a3] = qW(e20, i2.shape, i2.dtype, s2);
    return r2.makeTensorInfo(t3, n3, a3);
  }
  if ("int32" === s2) return ((e20, t3) => {
    let n3 = new jW(e20.shape, hW.TO_INT), r3 = t3.runWebGPUProgram(n3, [e20], "int32");
    return { dataId: r3.dataId, shape: r3.shape, dtype: r3.dtype };
  })(i2, r2);
  if ("bool" === s2) {
    let e20 = r2.makeTensorInfo([], "bool", va.getTypedArrayFromDType("bool", 1)), t3 = IB({ inputs: { a: i2, b: e20 }, backend: r2 });
    return r2.disposeData(e20.dataId), t3;
  }
  throw Error(`Error in Cast: failed to cast ${i2.dtype} to ${s2}`);
} };
var FB = GW({ opType: hW.CEIL, cpuKernelImpl: ZW });
var PB = { kernelName: ft, backendName: "webgpu", kernelFunc: FB };
var zB = class {
  constructor(e20) {
    this.variableNames = ["A"], this.uniforms = "minVal : f32, maxVal : f32,", this.workPerThread = 4, this.workgroupSize = [64, 1, 1], this.outputComponent = 4, this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.shaderKey = "clipVec4";
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `;
  }
};
var VB = class {
  constructor(e20) {
    this.variableNames = ["A"], this.uniforms = "minVal : f32, maxVal : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "clip";
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `;
  }
};
var _B = { kernelName: mt, backendName: "webgpu", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2 } = n2, { clipValueMin: s2, clipValueMax: o2 } = a2, l2 = [{ type: "float32", data: [s2] }, { type: "float32", data: [o2] }];
  return t2 = va.sizeFromShape(i2.shape) % 4 == 0 ? new zB(i2.shape) : new VB(i2.shape), r2.runWebGPUProgram(t2, [i2], i2.dtype, l2);
} };
var DB = class {
  constructor(e20) {
    this.outputShape = [], this.variableNames = ["real", "imag"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "complexAbs";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `;
  }
};
function WB(e20, t2) {
  return { dataId: t2.dataId, dtype: t2.dtype, shape: e20.shape };
}
var LB = { kernelName: xt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2, a2 = n2.tensorMap.get(r2.dataId), i2 = new DB(r2.shape), s2 = [WB(r2, a2.complexTensorInfos.real), WB(r2, a2.complexTensorInfos.imag)];
  return n2.runWebGPUProgram(i2, s2, s2[0].dtype);
} };
var BB = class {
  constructor(e20) {
    this.uniforms = "", this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = Uf.computeOutShape(e20, 1), this.variableNames = e20.map((e21, t2) => "T" + t2), this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]), this.offsetLength = e20.length - 1;
    for (let t2 = 0; this.offsetLength > t2; t2++) this.uniforms += `offset${t2} : i32,`;
    this.shaderKey = "concat";
  }
  getUserCode() {
    let e20 = [];
    if (this.offsetLength > 0) {
      e20.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");
      for (let t2 = 1; this.offsetLength > t2; t2++) e20.push(`else if (yC < uniforms.offset${[t2]}){ setOutputAtCoords(coords.x, coords.y, getT${t2}(yR, yC - uniforms.offset${t2 - 1})); }`);
      e20.push(`else { setOutputAtCoords(coords.x, coords.y, getT${this.offsetLength}(yR, yC - uniforms.offset${this.offsetLength - 1})); }`);
    } else e20.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");
    return `
      ${GD("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e20.join("\n        ")}
          }
        }
      }
    `;
  }
};
function UB(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2;
  return WW({ inputs: { x: n2.tensorMap.get(r2.dataId).complexTensorInfos.imag }, backend: n2 });
}
var jB = { kernelName: ln, backendName: "webgpu", kernelFunc: UB };
function GB(e20, t2, n2) {
  let r2 = e20[0].dtype;
  if ("complex64" === r2) {
    let r3 = e20.map((e21) => TB({ inputs: { input: e21 }, backend: n2 })), a3 = e20.map((e21) => UB({ inputs: { input: e21 }, backend: n2 })), i3 = GB(r3, t2, n2), s3 = GB(a3, t2, n2), o3 = BW({ inputs: { real: i3, imag: s3 }, backend: n2 });
    return r3.forEach((e21) => n2.disposeData(e21.dataId)), a3.forEach((e21) => n2.disposeData(e21.dataId)), n2.disposeData(i3.dataId), n2.disposeData(s3.dataId), o3;
  }
  let a2 = n2.shouldExecuteOnCPU(e20);
  if ("string" === r2 && (a2 = true), a2) {
    let a3 = e20.map((e21) => {
      let r3 = [-1, va.sizeFromShape(e21.shape.slice(t2))];
      return FW({ inputs: { x: e21 }, backend: n2, attrs: { shape: r3 } });
    }), i3 = a3.map((e21) => ({ vals: n2.readSync(e21.dataId), shape: e21.shape })), s3 = Uf.computeOutShape(a3.map((e21) => e21.shape), 1), o3 = KW(i3, s3, r2, 1 === a3[0].shape[0]), l3 = Uf.computeOutShape(e20.map((e21) => e21.shape), t2), u3 = n2.makeTensorInfo(l3, r2, o3);
    return a3.forEach((e21) => n2.disposeData(e21.dataId)), u3;
  }
  let i2 = n2.device.limits.maxStorageBuffersPerShaderStage - 1;
  if (e20.length > i2) {
    let r3 = [];
    for (let s3 = 0; e20.length > s3; s3 += i2) {
      let a4 = e20.slice(s3, s3 + i2);
      r3.push(GB(a4, t2, n2));
    }
    let a3 = GB(r3, t2, n2);
    for (let e21 of r3) n2.disposeData(e21.dataId);
    return a3;
  }
  let { tensors2D: s2, outShape: o2 } = ((e21, t3, n3) => {
    let r3 = Uf.computeOutShape(e21.map((e22) => e22.shape), t3);
    return { tensors2D: e21.map((e22) => FW({ inputs: { x: e22 }, backend: n3, attrs: { shape: [va.sizeFromShape(e22.shape.slice(0, t3)), va.sizeFromShape(e22.shape.slice(t3))] } })), outShape: r3 };
  })(e20, t2, n2), l2 = s2.map((e21) => e21.shape), u2 = new BB(l2), d2 = [], c2 = Array(l2.length - 1);
  if (c2.length > 0) {
    c2[0] = l2[0][1], d2.push({ type: "int32", data: [c2[0]] });
    for (let e21 = 1; c2.length > e21; e21++) c2[e21] = c2[e21 - 1] + l2[e21][1], d2.push({ type: "int32", data: [c2[e21]] });
  }
  let h2 = n2.runWebGPUProgram(u2, s2, s2[0].dtype, d2);
  s2.forEach((e21) => n2.disposeData(e21.dataId));
  let p2 = FW({ inputs: { x: h2 }, backend: n2, attrs: { shape: o2 } });
  return n2.disposeData(h2.dataId), p2;
}
function HB(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { axis: a2 } = r2, i2 = va.parseAxisParam(a2, t2[0].shape)[0], s2 = t2.map((e21) => e21.shape);
  Uf.assertParamsConsistent(s2, i2);
  let o2 = Uf.computeOutShape(t2.map((e21) => e21.shape), i2);
  if (0 === va.sizeFromShape(o2)) return n2.makeTensorInfo(o2, t2[0].dtype, []);
  let l2 = t2.filter((e21) => va.sizeFromShape(e21.shape) > 0);
  return 1 === l2.length ? WW({ inputs: { x: l2[0] }, backend: n2 }) : GB(l2, i2, n2);
}
var XB = { kernelName: yt, backendName: "webgpu", kernelFunc: HB };
var qB = class {
  constructor(e20, t2, n2, r2, a2 = false, i2 = null, s2 = false, o2 = false) {
    this.variableNames = ["x", "W"], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = e20.outShape, this.isChannelsLast = "channelsLast" === e20.dataFormat, this.isVec4 = ((e20.inChannels % 4 == 0 || e20.inChannels % 3 == 0) && this.isChannelsLast || e20.outWidth % 4 == 0 && !this.isChannelsLast) && e20.outChannels % 4 == 0, this.dispatchLayout = this.isChannelsLast ? { x: [3], y: [1, 2], z: [0] } : { x: [2, 3], y: [1], z: [0] }, this.workgroupSize = iW(this.dispatchLayout, this.outputShape, this.isVec4), this.elementsPerThread = sW(this.dispatchLayout, this.outputShape, this.isVec4), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), this.isVec4 ? (this.outputComponent = 4, this.isChannelsLast && e20.inChannels % 4 != 0 ? (this.innerElementSize = 3, this.variableComponents = [1, 4]) : (this.innerElementSize = 4, this.variableComponents = [4, 4]), a2 && (this.variableNames.push("bias"), this.variableComponents.push(4)), s2 && (this.variableNames.push("preluActivationWeights"), this.variableComponents.push(4))) : (this.innerElementSize = this.elementsPerThread[0], a2 && this.variableNames.push("bias"), s2 && this.variableNames.push("preluActivationWeights")), this.sequentialAccessByThreads = o2, this.addBias = a2, this.activation = i2, this.hasPreluActivationWeights = s2, this.tileAOuter = this.workgroupSize[1] * this.elementsPerThread[1], this.tileBOuter = this.workgroupSize[0] * this.elementsPerThread[0], this.tileInner = Math.max(this.workgroupSize[0] * this.innerElementSize, this.workgroupSize[1]), this.fitAOuter = t2 % this.tileAOuter === 0, this.fitBOuter = n2 % this.tileBOuter === 0, this.fitInner = r2 % this.tileInner === 0, this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`;
  }
  getUserCode() {
    let e20 = this.isVec4 ? kW(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner) : CW(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner, false, null, this.sequentialAccessByThreads), t2 = this.isVec4 ? [this.innerElementSize, 4, 4] : [1, 1, 1];
    return `
    ${((e21, t3, n2, r2, a2 = false, i2 = null, s2 = false, o2 = 4, l2 = 4, u2 = 4) => {
      let d2 = e21 ? "\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      " : "\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ", c2 = e21 ? "\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      " : "\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ", h2 = e21 ? "uniforms.xShape[1]" : "uniforms.xShape[2]", p2 = e21 ? "uniforms.xShape[2]" : "uniforms.xShape[3]", f2 = e21 ? "row" : "col", m2 = e21 ? "col" : "row", A2 = `
      let inChannels = uniforms.wShape[2];
      let outWidth = ${e21 ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
      let outRow = ${f2} / outWidth;
      let outCol = ${f2} % outWidth;

      let WRow = ${m2} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${m2} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${m2} % inChannels;
      var resData = ${BD(o2)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${h2} && xCol >= 0 && xCol < ${p2}) {
        ${d2}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${((e22) => {
        switch (e22) {
          case 1:
            return "resData = f32(x[xIndex]);";
          case 3:
            return "resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";
          case 4:
            return "resData = vec4<f32>(x[xIndex / 4]);";
          default:
            throw Error(`innerElementSize ${e22} is not supported.`);
        }
      })(o2)}
      }
      return resData;`, x2 = e21 ? t3 && r2 ? "\n      " + A2 : `
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${A2}
      }
      return ${BD(o2)}(0.0);` : r2 && n2 ? "\n      " + A2 : `
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${A2}
      }
      return ${BD(o2)}(0.0);`, y2 = "" + ((e22) => {
        switch (e22) {
          case 1:
            return "return f32(W[row * uniforms.wShape[3] + col]);";
          case 4:
            return "return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";
          default:
            throw Error(`innerElementSize ${e22} is not supported.`);
        }
      })(l2), b2 = BD(u2), g2 = BD(e21 ? o2 : l2), v2 = BD(e21 ? l2 : o2);
      return `
      ${bW(i2, s2, 4 === u2, 4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${g2} {
        ${e21 ? x2 : y2}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${v2} {
        ${e21 ? y2 : x2}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${b2}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${e21 ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
        ${c2}
        ${gW(a2, i2)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`;
    })(this.isChannelsLast, this.fitAOuter, this.fitBOuter, this.fitInner, this.addBias, this.activation, this.hasPreluActivationWeights, t2[0], t2[1], t2[2])}
    ${e20}
  `;
  }
};
var ZB = class {
  constructor(e20, t2 = false, n2 = null, r2 = false) {
    this.variableNames = ["x", "W"], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,", this.workgroupSize = [4, 4, 8], this.outputShape = e20.outShape, this.isChannelsLast = "channelsLast" === e20.dataFormat, this.dispatchLayout = this.isChannelsLast ? { x: [2], y: [1], z: [0, 3] } : { x: [3], y: [2], z: [0, 1] }, this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.addBias = t2, this.activation = n2, this.hasPreluActivationWeights = r2, t2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.shaderKey = `conv2dnaive_${this.activation}_${this.isChannelsLast}`;
  }
  getUserCode() {
    return `
       ${bW(this.activation, this.hasPreluActivationWeights, false, 4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast ? "vec4<i32>(batch, row, col, chan);" : "vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${gW(this.addBias, this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${GD("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast ? "coords[3];" : "coords[1];"}
         let outRow = ${this.isChannelsLast ? "coords[1];" : "coords[2];"}
         let outCol = ${this.isChannelsLast ? "coords[2];" : "coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast ? "uniforms.xShape[3];" : "uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast ? "let v = readInp(batch, xRow, xCol, xChannel);" : "let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `;
  }
};
var KB = class {
  constructor(e20, t2) {
    this.variableNames = ["x"], this.uniforms = "pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = t2, this.shaderKey = "im2col_" + this.isChannelsLast;
  }
  getUserCode() {
    let e20 = this.isChannelsLast ? 1 : 2, t2 = this.isChannelsLast ? 2 : 3, n2 = this.isChannelsLast ? "coords[1]" : "coords[2]", r2 = this.isChannelsLast ? "coords[2]" : "coords[1]", a2 = this.isChannelsLast ? "getX(batch, xRow, xCol, ch)" : "getX(batch, ch, xRow, xCol)";
    return `
    ${GD("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${n2};
        let col = ${r2};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e20}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t2}] && xCol >= 0) {
            value = ${a2};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `;
  }
};
function YB(e20, t2) {
  let n2 = e20.length;
  return 3 > n2 ? !t2 && 1 === n2 && e20[0] > 1 ? [e20[0], 1] : null : t2 ? [...e20.slice(0, -3), e20[n2 - 3] * e20[n2 - 2], e20[n2 - 1]] : [...e20.slice(0, -3), e20[n2 - 3], e20[n2 - 2] * e20[n2 - 1]];
}
function JB({ x: e20, filter: t2, convInfo: n2, backend: r2, bias: a2 = null, preluActivationWeights: i2 = null, leakyreluAlpha: s2 = 0, activation: o2 = null }) {
  let l2 = null != a2, u2 = null != i2, d2 = "channelsLast" === n2.dataFormat, c2 = d2 && n2.filterHeight === n2.inHeight && n2.filterWidth === n2.inWidth && "VALID" === n2.padInfo.type, h2 = _e().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");
  if (!h2 && (c2 || 1 === n2.filterHeight && 1 === n2.filterWidth && 1 === n2.dilationHeight && 1 === n2.dilationWidth && 1 === n2.strideHeight && 1 === n2.strideWidth && ("SAME" === n2.padInfo.type || "VALID" === n2.padInfo.type))) return (({ x: e21, filter: t3, convInfo: n3, backend: r3, bias: a3 = null, preluActivationWeights: i3 = null, leakyreluAlpha: s3 = 0, activation: o3 = null }) => {
    let l3, u3, d3 = "channelsLast" === n3.dataFormat, c3 = !d3, h3 = [];
    if (d3 && n3.filterHeight === n3.inHeight && n3.filterWidth === n3.inWidth && "VALID" === n3.padInfo.type) {
      let a4 = n3.inHeight * n3.inWidth * n3.inChannels;
      l3 = FW({ inputs: { x: e21 }, backend: r3, attrs: { shape: [1, n3.batchSize, a4] } }), u3 = FW({ inputs: { x: t3 }, backend: r3, attrs: { shape: [1, a4, n3.outChannels] } });
    } else l3 = FW({ inputs: { x: e21 }, backend: r3, attrs: { shape: d3 ? [n3.batchSize, n3.inHeight * n3.inWidth, n3.inChannels] : [n3.batchSize, n3.inChannels, n3.inHeight * n3.inWidth] } }), u3 = FW({ inputs: { x: t3 }, backend: r3, attrs: { shape: [1, n3.inChannels, n3.outChannels] } });
    if (h3.push(l3), h3.push(u3), null != i3) {
      let e22 = YB(i3.shape, d3);
      null != e22 && (i3 = FW({ inputs: { x: i3 }, backend: r3, attrs: { shape: e22 } }), h3.push(i3));
    }
    if (null != a3) {
      let e22 = YB(a3.shape, d3);
      null != e22 && (a3 = FW({ inputs: { x: a3 }, backend: r3, attrs: { shape: e22 } }), h3.push(a3));
    }
    let p3 = zW({ a: d3 ? l3 : u3, b: d3 ? u3 : l3, transposeA: c3, transposeB: false, backend: r3, bias: a3, activation: o3, preluActivationWeights: i3, leakyreluAlpha: s3 }), f3 = FW({ inputs: { x: p3 }, backend: r3, attrs: { shape: n3.outShape } });
    h3.push(p3);
    for (let m3 of h3) r3.disposeData(m3.dataId);
    return f3;
  })({ x: e20, filter: t2, convInfo: n2, backend: r2, bias: a2, activation: o2, preluActivationWeights: i2, leakyreluAlpha: s2 });
  let p2 = _e().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), f2 = p2 > -1 ? p2 : r2.thresholdToIncreaseWorkgroups, m2 = n2.batchSize * Math.ceil(n2.outHeight * n2.outWidth / 32) * Math.ceil(n2.outChannels / 32);
  if (_e().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER") || f2 >= m2) return (({ x: e21, filter: t3, convInfo: n3, backend: r3, bias: a3 = null, preluActivationWeights: i3 = null, leakyreluAlpha: s3 = 0, activation: o3 = null }) => {
    let { filterWidth: l3, filterHeight: u3, inChannels: d3, strideWidth: c3, strideHeight: h3, padInfo: p3, outWidth: f3, outHeight: m3, dilationWidth: A3, dilationHeight: x3, dataFormat: y3 } = n3, b3 = "channelsLast" === y3, g3 = l3 * u3 * d3, v2 = m3 * f3, w2 = new KB(b3 ? [n3.batchSize, v2, g3] : [n3.batchSize, g3, v2], b3), k2 = r3.runWebGPUProgram(w2, [e21], e21.dtype, [{ type: "int32", data: [p3.top, p3.left] }, { type: "int32", data: [h3, c3] }, { type: "int32", data: [x3, A3] }, { type: "int32", data: [f3] }, { type: "int32", data: [d3 * l3] }, { type: "int32", data: [d3] }]), N2 = [];
    N2.push(k2);
    let C2 = FW({ inputs: { x: t3 }, backend: r3, attrs: { shape: [1, g3, -1] } });
    if (N2.push(C2), null != i3) {
      let e22 = YB(i3.shape, b3);
      null != e22 && (i3 = FW({ inputs: { x: i3 }, backend: r3, attrs: { shape: e22 } }), N2.push(i3));
    }
    if (null != a3) {
      let e22 = YB(a3.shape, b3);
      null != e22 && (a3 = FW({ inputs: { x: a3 }, backend: r3, attrs: { shape: e22 } }), N2.push(a3));
    }
    let $2 = zW({ a: b3 ? k2 : C2, b: b3 ? C2 : k2, transposeA: !b3, transposeB: false, backend: r3, bias: a3, activation: o3, preluActivationWeights: i3, leakyreluAlpha: s3 }), R2 = FW({ inputs: { x: $2 }, backend: r3, attrs: { shape: n3.outShape } });
    N2.push($2);
    for (let S2 of N2) r3.disposeData(S2.dataId);
    return R2;
  })({ x: e20, filter: t2, convInfo: n2, backend: r2, bias: a2, preluActivationWeights: i2, leakyreluAlpha: s2, activation: o2 });
  let A2, x2 = [{ type: "int32", data: [n2.filterHeight, n2.filterWidth] }, { type: "int32", data: [n2.padInfo.top, n2.padInfo.left] }, { type: "int32", data: [n2.strideHeight, n2.strideWidth] }, { type: "int32", data: [n2.dilationHeight, n2.dilationWidth] }];
  if (h2) A2 = new ZB(n2, l2, o2, u2);
  else {
    let e21 = d2 ? n2.outHeight * n2.outWidth : n2.outChannels, t3 = d2 ? n2.outChannels : n2.outHeight * n2.outWidth, a3 = n2.filterHeight * n2.filterWidth * n2.inChannels;
    x2.push({ type: "int32", data: [e21] }, { type: "int32", data: [t3] }, { type: "int32", data: [a3] });
    let i3 = r2.adapterInfo.isIntel();
    A2 = new qB(n2, e21, t3, a3, l2, o2, u2, i3);
  }
  let y2 = [], b2 = [e20, t2];
  l2 && (!d2 && 1 === a2.shape.length && (a2 = FW({ inputs: { x: a2 }, backend: r2, attrs: { shape: [a2.shape[0], 1, 1] } }), y2.push(a2)), b2.push(a2)), u2 && (!d2 && 1 === i2.shape.length && (i2 = FW({ inputs: { x: i2 }, backend: r2, attrs: { shape: [i2.shape[0], 1, 1] } }), y2.push(i2)), b2.push(i2)), "leakyrelu" === o2 && (x2.push({ type: "float32", data: [s2] }), A2.uniforms += " alpha : f32,");
  let g2 = r2.runWebGPUProgram(A2, b2, e20.dtype, x2);
  for (let v2 of y2) r2.disposeData(v2.dataId);
  return g2;
}
var QB;
var eU = { kernelName: bt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dataFormat: l2, dilations: u2, dimRoundingMode: d2 } = n2, c2 = Uf.convertConv2DDataFormat(l2);
  return JB({ x: a2, filter: i2, convInfo: Uf.computeConv2DInfo(a2.shape, i2.shape, s2, u2, o2, d2, false, c2), backend: r2 });
} };
var tU = class {
  constructor(e20) {
    this.variableNames = ["dy", "W"], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,", this.workgroupSize = [64, 1, 1], this.size = false, this.isVec4 = false, this.workPerThread = 1, this.outputShape = e20.inShape, this.isChannelsLast = "channelsLast" === e20.dataFormat, this.isVec4 = this.isChannelsLast && e20.outChannels % 4 == 0 && e20.inChannels % 4 == 0, this.isVec4 ? (this.workPerThread = 2, this.outputComponent = 4, this.workgroupSize = [4, 4, 4], this.dispatchLayout = { x: [3], y: [2], z: [0, 1] }, this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [4, this.workPerThread, 1])) : (this.size = true, this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize)), this.shaderKey = `conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`;
  }
  getUserCode() {
    let e20 = this.isChannelsLast ? 1 : 2, t2 = this.isChannelsLast ? 2 : 3, n2 = this.isChannelsLast ? 3 : 1, r2 = `
    ${GD()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;
    return this.isVec4 ? `
    ${r2}
    ` : `
    ${GD("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${n2}];

        let dyCorner = vec2<i32>(coords[${e20}], coords[${t2}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast ? "getDy(batch, idyR, idyC, d2)" : "getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
  }
};
var nU = class {
  constructor(e20) {
    this.variableNames = ["x", "dy"], this.uniforms = "pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.filterShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = "channelsLast" === e20.dataFormat, this.shaderKey = "conv2DDerFilter_" + this.isChannelsLast;
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
  }
};
var rU = class {
  constructor(e20) {
    this.variableNames = ["x", "dy"], this.uniforms = "pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.filterShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3DDerFilter";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
  }
};
var aU = class {
  constructor(e20) {
    this.variableNames = ["dy", "W"], this.uniforms = "filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.inShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3DDerInput";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
  }
};
var iU = { kernelName: gt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, pad: o2, dataFormat: l2, dimRoundingMode: u2, filterShape: d2 } = r2, c2 = Uf.convertConv2DDataFormat(l2), h2 = Uf.computeConv2DInfo(a2.shape, d2, s2, 1, o2, u2, false, c2), p2 = new nU(h2);
  return n2.runWebGPUProgram(p2, [a2, i2], a2.dtype, [{ type: "int32", data: [h2.padInfo.top, h2.padInfo.left] }, { type: "int32", data: [h2.strideHeight, h2.strideWidth] }, { type: "int32", data: [h2.batchSize] }, { type: "int32", data: [h2.outHeight] }, { type: "int32", data: [h2.outWidth] }, { type: "int32", data: [h2.inHeight] }, { type: "int32", data: [h2.inWidth] }]);
} };
var sU = class {
  constructor(e20) {
    this.variableNames = ["x", "W"], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", this.outputShape = e20.inShape, va.assert("channelsLast" === e20.dataFormat, () => "TODO: NCHW is unimplemented"), this.isVec4 = e20.inChannels % 4 == 0 && e20.outChannels % 4 == 0, this.dispatchLayout = { x: [3], y: [1, 2], z: [0] }, this.workgroupSize = iW(this.dispatchLayout, this.outputShape, this.isVec4), this.elementsPerThread = sW(this.dispatchLayout, this.outputShape, this.isVec4), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), this.isVec4 && (this.outputComponent = 4, this.variableComponents = [4, 1]), this.shaderKey = `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;
  }
  getUserCode() {
    let e20 = this.isVec4 ? kW(this.elementsPerThread, this.workgroupSize) : CW(this.elementsPerThread, this.workgroupSize);
    return `
    ${((e21 = 4) => {
      let t2 = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${BD(e21)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${BD(e21)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e21}];
      }
      return ${BD(e21)}(0.0);`;
      return `
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${BD(e21)} {
    ${t2}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${BD(e21)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${((e22) => {
        switch (e22) {
          case 1:
            return "return W[getIndexFromCoords4D(coord, uniforms.wShape)];";
          case 4:
            return "\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";
          default:
            throw Error(`innerElementSize ${e22} is not supported.`);
        }
      })(e21)}
    }
    return ${BD(e21)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${BD(e21)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e21}] = value;
    }
  }`;
    })(this.isVec4 ? 4 : 1)}
    ${e20}
    `;
  }
};
var oU = { kernelName: vt, backendName: "webgpu", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { dy: i2, filter: s2 } = n2, { inputShape: o2, strides: l2, pad: u2, dataFormat: d2, dimRoundingMode: c2 } = a2, h2 = Uf.convertConv2DDataFormat(d2), p2 = Uf.computeConv2DInfo(o2, s2.shape, l2, 1, u2, c2, false, h2), f2 = [{ type: "int32", data: [p2.filterHeight, p2.filterWidth] }, { type: "int32", data: [p2.filterHeight - 1 - p2.padInfo.top, p2.filterWidth - 1 - p2.padInfo.left] }, { type: "int32", data: [p2.strideHeight, p2.strideWidth] }, { type: "int32", data: [p2.batchSize, p2.outHeight, p2.outWidth, p2.outChannels] }];
  return _e().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE") || "channelsLast" !== p2.dataFormat ? t2 = new tU(p2) : (t2 = new sU(p2), f2.push({ type: "uint32", data: [p2.inHeight * p2.inWidth] }, { type: "uint32", data: [p2.inChannels] }, { type: "uint32", data: [p2.filterHeight * p2.filterWidth * p2.outChannels] })), r2.runWebGPUProgram(t2, [i2, s2], "float32", f2);
} };
var lU = class {
  constructor(e20) {
    this.variableNames = ["x", "W"], this.uniforms = "filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.outShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "conv3dnaive";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`;
  }
};
var uU = { kernelName: wt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dilations: l2 } = r2, u2 = Uf.computeConv3DInfo(a2.shape, i2.shape, s2, l2, o2), d2 = [{ type: "int32", data: [u2.filterDepth, u2.filterHeight, u2.filterWidth] }, { type: "int32", data: [u2.padInfo.front, u2.padInfo.top, u2.padInfo.left] }, { type: "int32", data: [u2.strideDepth, u2.strideHeight, u2.strideWidth] }, { type: "int32", data: [u2.dilationDepth, u2.dilationHeight, u2.dilationWidth] }], c2 = new lU(u2), h2 = pi(a2.dtype, i2.dtype);
  return n2.runWebGPUProgram(c2, [a2, i2], h2, d2);
} };
var dU = { kernelName: kt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, pad: o2, filterShape: l2 } = r2, u2 = Uf.computeConv3DInfo(a2.shape, l2, s2, 1, o2), d2 = new rU(u2);
  return n2.runWebGPUProgram(d2, [a2, i2], i2.dtype, [{ type: "int32", data: [u2.padInfo.front, u2.padInfo.top, u2.padInfo.left] }, { type: "int32", data: [u2.strideDepth, u2.strideHeight, u2.strideWidth] }, { type: "int32", data: [u2.batchSize] }, { type: "int32", data: [u2.outDepth] }, { type: "int32", data: [u2.outHeight] }, { type: "int32", data: [u2.outWidth] }, { type: "int32", data: [u2.inDepth] }, { type: "int32", data: [u2.inHeight] }, { type: "int32", data: [u2.inWidth] }]);
} };
var cU = { kernelName: Nt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = t2, { strides: s2, pad: o2, inputShape: l2 } = r2, u2 = Uf.computeConv3DInfo(l2, i2.shape, s2, 1, o2), d2 = new aU(u2);
  return n2.runWebGPUProgram(d2, [a2, i2], a2.dtype, [{ type: "int32", data: [u2.filterDepth, u2.filterHeight, u2.filterWidth] }, { type: "int32", data: [u2.filterDepth - 1 - u2.padInfo.front, u2.filterHeight - 1 - u2.padInfo.top, u2.filterWidth - 1 - u2.padInfo.left] }, { type: "int32", data: [u2.strideDepth, u2.strideHeight, u2.strideWidth] }, { type: "int32", data: [u2.outDepth] }, { type: "int32", data: [u2.outHeight] }, { type: "int32", data: [u2.outWidth] }, { type: "int32", data: [u2.outChannels] }]);
} };
var hU = { kernelName: "Cos", backendName: "webgpu", kernelFunc: GW({ opType: hW.COS }) };
var pU = GW({ opType: hW.COSH });
var fU = { kernelName: $t, backendName: "webgpu", kernelFunc: pU };
var mU = class {
  constructor(e20, t2, n2, r2) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.uniforms = "extrapolationValue : f32,", this.workgroupSize = [64, 1, 1], this.size = true;
    let [a2] = t2;
    this.outputShape = [a2, n2[0], n2[1], e20], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.methodId = "bilinear" === r2 ? 1 : 0, this.cropHeightBiggerThan1 = this.outputShape[1] > 1, this.cropWidthBiggerThan1 = this.outputShape[2] > 1, this.shaderKey = `cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;
  }
  getUserCode() {
    let [e20, t2] = ["f32(uniforms.imageShape[1] - 1)", "f32(uniforms.imageShape[2] - 1)"], [n2, r2, a2] = this.cropHeightBiggerThan1 ? [`(${e20} / f32(uniforms.outShape[1] - 1))`, "(y2-y1) * height_ratio", `y1*${e20} + f32(y)*(height_scale)`] : ["0.0", "0.0", "0.5 * (y1+y2) * " + e20], [i2, s2, o2] = this.cropWidthBiggerThan1 ? [`(${t2} / f32(uniforms.outShape[2] - 1))`, "(x2-x1) * width_ratio", `x1*${t2} + f32(x)*(width_scale)`] : ["0.0", "0.0", "0.5 * (x1+x2) * " + t2];
    return `
    ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${n2});
        let width_ratio = f32(${i2});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${r2};
        let width_scale = ${s2};
        let in_y = ${a2};
        if( in_y < 0.0 || in_y > ${e20} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${o2};
        if( in_x < 0.0 || in_x > ${t2} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `;
  }
};
var AU = { kernelName: It, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { image: a2, boxes: i2, boxInd: s2 } = t2, { cropSize: o2, method: l2, extrapolationValue: u2 } = r2, d2 = new mU(a2.shape[3], i2.shape, o2, l2);
  return n2.runWebGPUProgram(d2, [a2, i2, s2], "float32", [{ type: "float32", data: [u2] }]);
} };
((e20) => {
  e20.Prod = "*", e20.Sum = "+";
})(QB || (QB = {}));
var xU = class {
  constructor(e20, t2, n2, r2) {
    this.variableNames = ["x"], this.uniforms = "index : f32,", this.size = true, this.workgroupSize = [128, 1, 1], this.outputShape = t2, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.exclusive = n2, this.reverse = r2, this.op = e20, this.shaderKey = `cum_${this.op}_${this.exclusive}_${this.reverse}`;
  }
  getUserCode() {
    let e20 = this.outputShape.length, t2 = this.exclusive ? this.op === QB.Prod ? "1.0" : "0.0" : `getX(${yU(e20, "coords", this.op)})`, n2 = this.outputShape[this.outputShape.length - 1], r2 = "", a2 = "";
    return this.exclusive ? (r2 = this.reverse ? "end != " + (n2 - 1) : "end != 0", a2 = this.reverse ? "end + 1" : "end - 1") : (r2 = this.reverse ? "end + pow2 < " + n2 : "end >= pow2", a2 = this.reverse ? "end + pow2" : "end - pow2"), `
      ${GD("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${bU(e20, "coords", this.op)};
         var val = ${t2};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${r2}) {
           let idx = ${a2};
           ${bU(e20, "coords", this.op)} = idx;
           val ${this.op}= getX(${yU(e20, "coords", this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `;
  }
};
function yU(e20, t2, n2) {
  if (1 === e20) return "" + t2;
  if (2 === e20) return `${t2}.x, ${t2}.y`;
  if (3 === e20) return `${t2}.x, ${t2}.y, ${t2}.z`;
  if (4 === e20) return `${t2}.x, ${t2}.y, ${t2}.z, ${t2}.w`;
  throw Error(`Cumulative ${n2} for rank ${e20} is not yet supported`);
}
function bU(e20, t2, n2) {
  if (1 === e20) return "" + t2;
  if (2 === e20) return t2 + ".y";
  if (3 === e20) return t2 + ".z";
  if (4 === e20) return t2 + ".w";
  throw Error(`Cumulative ${n2} for rank ${e20} is not yet supported`);
}
function gU(e20, t2, n2, r2, a2, i2) {
  let s2 = t2.shape.length, o2 = Uf.getAxesPermutation([r2], s2), l2 = t2;
  null != o2 && (l2 = _L({ inputs: { x: t2 }, backend: n2, attrs: { perm: o2 } }));
  let u2 = Uf.getInnerMostAxes(1, s2)[0];
  if (u2 !== s2 - 1) throw Error(`WebGPU cumprod shader expects an inner-most axis=${t2.shape.length - 1} but got axis=${r2}`);
  let d2 = l2.shape[u2], c2 = WW({ inputs: { x: l2 }, backend: n2 });
  for (let h2 = 0; h2 <= Math.ceil(Math.log2(d2)) - 1; h2++) {
    let t3 = new xU(e20, l2.shape, false, i2), r3 = c2;
    c2 = n2.runWebGPUProgram(t3, [c2], c2.dtype, [{ type: "float32", data: [h2] }]), n2.disposeData(r3.dataId);
  }
  if (a2) {
    let t3 = new xU(e20, l2.shape, a2, i2), r3 = c2;
    c2 = n2.runWebGPUProgram(t3, [c2], c2.dtype, [{ type: "float32", data: [0] }]), n2.disposeData(r3.dataId);
  }
  if (null != o2) {
    let e21 = _L({ inputs: { x: c2 }, backend: n2, attrs: { perm: Uf.getUndoAxesPermutation(o2) } });
    return n2.disposeData(c2.dataId), n2.disposeData(l2.dataId), e21;
  }
  return c2;
}
var vU = { kernelName: Rt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, exclusive: s2, reverse: o2 } = r2;
  return gU(QB.Prod, a2, n2, i2, s2, o2);
} };
var wU = { kernelName: St, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, exclusive: s2, reverse: o2 } = r2;
  return gU(QB.Sum, a2, n2, i2, s2, o2);
} };
var kU = { kernelName: Et, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, weights: i2 } = t2, { size: s2, binaryOutput: o2 } = r2, l2 = 1 === a2.shape.length, u2 = va.sizeFromShape(i2.shape) > 0, d2 = i2.dtype, c2 = l2 ? [a2.shape[0]] : [a2.shape[0], a2.shape[1]], h2 = MW({ backend: n2, attrs: { shape: l2 ? [s2] : [a2.shape[0], s2], value: 0, dtype: d2 } }), p2 = new CB(c2, u2, o2);
  return n2.runWebGPUProgram(p2, u2 ? [a2, i2] : [a2], d2, [{ type: "int32", data: [s2] }], h2);
} };
var NU = class {
  constructor(e20, t2) {
    this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.uniforms = "blockSize : i32,", this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "depthToSpace_" + t2, this.dataFormat = t2;
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`;
  }
  getHeightCoordString() {
    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
  }
  getWidthCoordString() {
    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
  }
  getDepthCoordString() {
    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
  }
  getOutputDepthSize() {
    return "NHWC" === this.dataFormat ? "uniforms.outShape[3]" : "uniforms.outShape[1]";
  }
  getInputSamplingString() {
    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }
};
var CU = { kernelName: Tt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockSize: i2, dataFormat: s2 } = r2, o2 = a2.shape[0], l2 = ("NHWC" === s2 ? a2.shape[1] : a2.shape[2]) * i2, u2 = ("NHWC" === s2 ? a2.shape[2] : a2.shape[3]) * i2, d2 = ("NHWC" === s2 ? a2.shape[3] : a2.shape[1]) / (i2 * i2), c2 = [{ type: "int32", data: [i2] }], h2 = new NU("NHWC" === s2 ? [o2, l2, u2, d2] : [o2, d2, l2, u2], s2);
  return n2.runWebGPUProgram(h2, [a2], a2.dtype, c2);
} };
var $U = class {
  constructor(e20, t2, n2, r2 = false, a2 = null, i2 = false) {
    this.variableNames = ["x", "W"], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>,", this.workgroupSize = [16, 16, 1], this.outputShape = e20, this.dispatchLayout = { x: [3], y: [2], z: [0, 1] }, this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), r2 && this.variableNames.push("bias"), i2 && this.variableNames.push("preluActivationWeights"), this.addBias = r2, this.activation = a2, this.hasPreluActivation = i2, this.filterHeight = t2, this.filterWidth = n2, this.shaderKey = `depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`;
  }
  getUserCode() {
    let e20 = this.filterWidth * this.filterHeight, t2 = this.workgroupSize[0] * this.workgroupSize[1] * this.workgroupSize[2], n2 = this.workgroupSize[1] + this.filterHeight - 1, r2 = this.workgroupSize[0] + this.filterWidth - 1;
    return `
      ${bW(this.activation, this.hasPreluActivation, false, 4)}

      var<workgroup> mm_Asub : array<array<f32, ${r2}>, ${n2}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${GD()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${n2}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${r2}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${t2 > e20 ? `if (wIndex < ${e20})` : `for(; wIndex < ${e20}; wIndex = wIndex + ${t2})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${gW(this.addBias, this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
  }
};
var RU = class {
  constructor(e20, t2 = false, n2 = null, r2 = false) {
    this.variableNames = ["x", "W"], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,", this.workgroupSize = [64, 1, 1], this.workPerThread = 4, this.outputComponent = 4, this.outputShape = e20.outShape, this.virtualWidth = Math.ceil(this.outputShape[2] / this.workPerThread) * this.workPerThread;
    let a2 = [this.outputShape[0], this.outputShape[1], this.virtualWidth, this.outputShape[3]];
    this.dispatchLayout = oW(a2), this.dispatch = rW(this.dispatchLayout, a2, this.workgroupSize, [this.outputComponent * this.workPerThread, 1, 1]), va.assert("channelsLast" === e20.dataFormat, () => "TODO: NCHW is unimplemented"), t2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.convInfo = e20, this.addBias = t2, this.activation = n2, this.hasPreluActivation = r2, this.shaderKey = `depthwiseVec4_${n2}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`;
  }
  getUserCode() {
    let e20 = (this.workPerThread - 1) * this.convInfo.strideWidth + this.convInfo.filterWidth, t2 = this.convInfo.strideHeight, n2 = this.convInfo.strideWidth;
    return `
      ${bW(this.activation, this.hasPreluActivation, true, 4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${GD("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t2}, ${n2}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e20}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e20}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${n2} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${gW(this.addBias, this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `;
  }
};
var SU = class {
  constructor(e20, t2 = false, n2 = null, r2 = false) {
    this.variableNames = ["x", "W"], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,", this.workgroupSize = [256, 1, 1], this.size = true, this.outputShape = e20.outShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.isChannelsLast = "channelsLast" === e20.dataFormat, t2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.convInfo = e20, this.addBias = t2, this.activation = n2, this.hasPreluActivation = r2, this.shaderKey = `depthwise_${this.activation}_${this.isChannelsLast}`;
  }
  getUserCode() {
    let e20 = this.isChannelsLast ? "getX(batch, xR, xC, d1);" : "getX(batch, d1, xR, xC);";
    return `
      ${bW(this.activation, this.hasPreluActivation, false, 4)}

      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast ? "yz" : "zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast ? 3 : 1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e20};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e20};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${gW(this.addBias, this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
  }
};
var IU = { kernelName: Mt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dataFormat: l2, dilations: u2, dimRoundingMode: d2 } = r2, c2 = Uf.convertConv2DDataFormat(l2), h2 = u2;
  null == h2 && (h2 = [1, 1]);
  let p2, f2 = Uf.computeConv2DInfo(a2.shape, i2.shape, s2, h2, o2, d2, true, c2), m2 = [{ type: "int32", data: [f2.padInfo.top, f2.padInfo.left] }, { type: "int32", data: [f2.inHeight, f2.inWidth] }], A2 = "channelsLast" === f2.dataFormat;
  return !A2 && f2.inHeight > 16 && f2.inWidth > 16 && 1 === f2.strideHeight && 1 === f2.strideWidth && 1 === f2.dilationWidth && 1 === f2.dilationHeight && f2.inChannels === f2.outChannels ? p2 = new $U(f2.outShape, f2.filterHeight, f2.filterWidth) : A2 && f2.outHeight > 4 && f2.outWidth > 4 && 2 >= f2.strideWidth && f2.inChannels === f2.outChannels && 1 === f2.dilationHeight && 1 === f2.dilationWidth && f2.inChannels % 4 == 0 ? (p2 = new RU(f2), m2.push({ type: "int32", data: [p2.virtualWidth] })) : (p2 = new SU(f2), m2.push({ type: "int32", data: [f2.filterHeight] }, { type: "int32", data: [f2.filterWidth] }, { type: "int32", data: [f2.strideHeight, f2.strideWidth] }, { type: "int32", data: [f2.dilationHeight, f2.dilationWidth] })), n2.runWebGPUProgram(p2, [a2, i2], a2.dtype, m2);
} };
var EU = class {
  constructor(e20) {
    this.variableNames = ["x", "dy"], this.uniforms = "strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.filterShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "depthwise_conv2d_backprop_filter";
  }
  getUserCode() {
    return `
      ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
  }
};
var TU = class {
  constructor(e20) {
    this.variableNames = ["dy", "W"], this.uniforms = "strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.inShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "depthwise_conv2d_backprop_input";
  }
  getUserCode() {
    return `
      ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
  }
};
var MU = { kernelName: Ot, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, dy: i2 } = t2, { strides: s2, dilations: o2, pad: l2, dimRoundingMode: u2, filterShape: d2 } = r2, c2 = Uf.computeConv2DInfo(a2.shape, d2, s2, o2, l2, u2, true), h2 = new EU(c2);
  return n2.runWebGPUProgram(h2, [a2, i2], "float32", [{ type: "int32", data: [c2.strideHeight, c2.strideWidth] }, { type: "int32", data: [c2.padInfo.top, c2.padInfo.left] }, { type: "int32", data: [c2.filterHeight, c2.filterWidth] }, { type: "int32", data: [c2.outHeight] }, { type: "int32", data: [c2.outWidth] }, { type: "int32", data: [c2.inHeight] }, { type: "int32", data: [c2.inWidth] }, { type: "int32", data: [c2.batchSize] }, { type: "int32", data: [c2.outChannels / c2.inChannels] }]);
} };
var OU = { kernelName: Ft, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, filter: i2 } = t2, { strides: s2, dilations: o2, pad: l2, dimRoundingMode: u2, inputShape: d2 } = r2, c2 = Uf.computeConv2DInfo(d2, i2.shape, s2, o2, l2, u2, true), h2 = new TU(c2);
  return n2.runWebGPUProgram(h2, [a2, i2], a2.dtype, [{ type: "int32", data: [c2.strideHeight, c2.strideWidth] }, { type: "int32", data: [c2.filterHeight - 1 - c2.padInfo.top, c2.filterWidth - 1 - c2.padInfo.left] }, { type: "int32", data: [c2.filterHeight, c2.filterWidth] }, { type: "int32", data: [c2.outHeight] }, { type: "int32", data: [c2.outWidth] }, { type: "int32", data: [c2.outChannels / c2.inChannels] }]);
} };
var FU = class {
  constructor(e20) {
    this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e20, e20], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "diag";
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `;
  }
};
var PU = { kernelName: Pt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2, a2 = [...r2.shape, ...r2.shape], i2 = va.sizeFromShape(r2.shape), s2 = FW({ inputs: { x: r2 }, backend: n2, attrs: { shape: [i2] } }), o2 = new FU(i2), l2 = n2.runWebGPUProgram(o2, [s2], s2.dtype), u2 = FW({ inputs: { x: l2 }, backend: n2, attrs: { shape: a2 } });
  return n2.disposeData(s2.dataId), n2.disposeData(l2.dataId), u2;
} };
var zU = class {
  constructor(e20) {
    this.variableNames = ["x", "w"], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.outShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "dilation2d";
  }
  getUserCode() {
    return `
       ${GD("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `;
  }
};
var VU = { kernelName: zt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2 } = t2, { strides: s2, pad: o2, dilations: l2 } = r2, u2 = Uf.computeDilation2DInfo(a2.shape, i2.shape, s2, o2, "NHWC", l2), d2 = [{ type: "int32", data: [u2.filterHeight, u2.filterWidth] }, { type: "int32", data: [u2.padInfo.top, u2.padInfo.left] }, { type: "int32", data: [u2.strideHeight, u2.strideWidth] }, { type: "int32", data: [u2.dilationHeight, u2.dilationWidth] }], c2 = new zU(u2);
  return n2.runWebGPUProgram(c2, [a2, i2], a2.dtype, d2);
} };
var _U = class {
  constructor(e20, t2) {
    if (this.variableNames = ["x", "w", "dy"], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = e20.inShape, this.dispatchLayout = oW(e20.outShape), this.dispatch = rW(this.dispatchLayout, e20.outShape, this.workgroupSize), "float32" !== t2 && "int32" !== t2) throw Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t2} type.`);
    this.type = t2, this.shaderKey = "dilation2DBackpropInput";
  }
  getUserCode() {
    return `
       ${GD("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${LD("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
  }
};
var DU = class {
  constructor(e20, t2, n2) {
    if (this.variableNames = ["x", "w", "dy"], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = e20.filterShape, this.dispatchLayout = oW(e20.outShape), this.dispatch = rW(this.dispatchLayout, e20.outShape, this.workgroupSize), "float32" !== n2 && "int32" !== n2) throw Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${n2} type.`);
    this.type = n2, this.shaderKey = "dilation2DBackpropFilter";
  }
  getUserCode() {
    return `
       ${GD("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${LD("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
  }
};
var WU = { kernelName: _t, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2, dy: s2 } = t2, { strides: o2, pad: l2, dilations: u2 } = r2, d2 = Uf.computeDilation2DInfo(a2.shape, i2.shape, o2, l2, "NHWC", u2), c2 = i2.dtype, h2 = new DU(d2, i2.shape, c2), p2 = [{ type: "int32", data: [d2.filterHeight, d2.filterWidth] }, { type: "int32", data: [d2.padInfo.top, d2.padInfo.left] }, { type: "int32", data: [d2.strideHeight, d2.strideWidth] }, { type: "int32", data: [d2.dilationHeight, d2.dilationWidth] }, { type: "int32", data: [va.sizeFromShape(d2.outShape)] }], f2 = MW({ backend: n2, attrs: { shape: i2.shape, value: 0, dtype: c2 } });
  return n2.runWebGPUProgram(h2, [a2, i2, s2], c2, p2, f2);
} };
var LU = { kernelName: Vt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2, dy: s2 } = t2, { strides: o2, pad: l2, dilations: u2 } = r2, d2 = Uf.computeDilation2DInfo(a2.shape, i2.shape, o2, l2, "NHWC", u2), c2 = a2.dtype, h2 = new _U(d2, c2), p2 = [{ type: "int32", data: [d2.filterHeight, d2.filterWidth] }, { type: "int32", data: [d2.padInfo.top, d2.padInfo.left] }, { type: "int32", data: [d2.strideHeight, d2.strideWidth] }, { type: "int32", data: [d2.dilationHeight, d2.dilationWidth] }, { type: "int32", data: [va.sizeFromShape(d2.outShape)] }], f2 = MW({ backend: n2, attrs: { shape: d2.inShape, value: 0, dtype: c2 } });
  return n2.runWebGPUProgram(h2, [a2, i2, s2], c2, p2, f2);
} };
var BU = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["Image"], this.uniforms = "alpha: f32,", this.workgroupSize = [64, 1, 1], this.pixelsOpType = WD.DRAW, this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.type = t2, this.textureFormat = n2, this.shaderKey = `draw_${t2}_${n2}`;
  }
  getUserCode() {
    let e20, t2 = "float32" === this.type ? "value" : "value / 255.0";
    return e20 = `
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t2};
        rgba[1] = ${t2};
        rgba[2] = ${t2};
      } else {
        rgba[d] = ${t2};
      }`, `
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${GD("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e20}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `;
  }
};
var UU = { kernelName: Dt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { image: a2 } = t2, { canvas: i2, options: s2 } = r2, [o2, l2] = a2.shape.slice(0, 2), { imageOptions: u2 } = s2 || {}, d2 = (null == u2 ? void 0 : u2.alpha) || 1, c2 = n2.device.features.has("bgra8unorm-storage") ? "bgra8unorm" : "rgba8unorm", h2 = [o2, l2], p2 = new BU(h2, a2.dtype, c2);
  i2.width = l2, i2.height = o2;
  let f2, m2 = "webgpu", A2 = i2.getContext(m2);
  A2 || (f2 = new OffscreenCanvas(l2, o2), A2 = f2.getContext(m2));
  let x2 = 3 === a2.shape.length ? a2.shape[2] : 1;
  A2.configure({ device: n2.device, format: c2, usage: GPUTextureUsage.STORAGE_BINDING, alphaMode: "premultiplied" });
  let y2 = "int32", b2 = n2.makeTensorInfo(h2, y2), g2 = n2.tensorMap.get(b2.dataId);
  if (g2.resource = A2.getCurrentTexture(), g2.external = true, n2.runWebGPUProgram(p2, [a2], y2, [{ type: "uint32", data: [x2] }, { type: "float32", data: [d2] }], b2), f2) {
    let e21 = i2.getContext("2d");
    if (!e21) throw Error("Please make sure this canvas has only been used for 2d or webgpu context!");
    e21.drawImage(f2, 0, 0);
  }
  return n2.disposeData(b2.dataId), a2;
} };
var jU = HW({ opType: cW.MUL, cpuKernelImpl: hL, supportsComplex: true });
var GU = { kernelName: Wn, backendName: "webgpu", kernelFunc: jU };
function HU(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2;
  return BL(a2, i2, s2, "sum", n2);
}
var XU = { kernelName: "Sum", backendName: "webgpu", kernelFunc: HU };
var qU = { kernelName: Lt, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { equation: a2 } = r2, i2 = t2, { allDims: s2, summedDims: o2, idDims: l2 } = Uf.decodeEinsumEquation(a2, i2.length);
  Uf.checkEinsumDimSizes(s2.length, l2, i2);
  let { path: u2, steps: d2 } = Uf.getEinsumComputePath(o2, l2), c2 = d2.length, h2 = null, p2 = s2.length, f2 = [];
  for (let m2 = 0; c2 > m2; ++m2) {
    for (let e21 of d2[m2]) {
      let t3, { permutationIndices: r3, expandDims: a3 } = Uf.getEinsumPermutation(p2, l2[e21]);
      Uf.isIdentityPermutation(r3) ? t3 = i2[e21] : (t3 = _L({ inputs: { x: i2[e21] }, backend: n2, attrs: { perm: r3 } }), f2.push(t3));
      let s3 = t3.shape.slice();
      for (let e22 = 0; a3.length > e22; ++e22) s3.splice(a3[e22], 0, 1);
      va.arraysEqual(t3.shape, s3) || (t3 = FW({ inputs: { x: t3 }, backend: n2, attrs: { shape: s3 } }), f2.push(t3)), null === h2 ? h2 = t3 : (h2 = jU({ inputs: { a: t3, b: h2 }, backend: n2 }), f2.push(h2));
    }
    c2 - 1 > m2 && (u2[m2] >= 0 && (h2 = HU({ inputs: { x: h2 }, backend: n2, attrs: { axis: u2[m2] - (s2.length - p2), keepDims: false } }), f2.push(h2)), p2--);
  }
  for (let m2 of f2) m2 !== h2 && n2.disposeData(m2.dataId);
  return h2;
} };
var ZU = { kernelName: "Elu", backendName: "webgpu", kernelFunc: GW({ opType: hW.ELU }) };
var KU = { kernelName: Ut, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { dy: r2, y: a2 } = t2, i2 = new DW(cW.ELU_DER, r2.shape, a2.shape);
  return n2.runWebGPUProgram(i2, [r2, a2], r2.dtype);
} };
var YU = HW({ opType: cW.EQUAL, dtype: "bool", cpuKernelImpl: YW });
var JU = { kernelName: Gt, backendName: "webgpu", kernelFunc: YU };
var QU = { kernelName: "Erf", backendName: "webgpu", kernelFunc: GW({ opType: hW.ERF }) };
var ej = { kernelName: "Exp", backendName: "webgpu", kernelFunc: GW({ opType: hW.EXP, cpuKernelImpl: JW, dtype: "float32" }) };
function tj(e20) {
  let { inputs: t2, attrs: n2, backend: r2 } = e20, { dim: a2 } = n2, { input: i2 } = t2, s2 = i2.shape.length, o2 = i2.shape.slice(), l2 = a2;
  return 0 > a2 && (va.assert(a2 >= -(s2 + 1), () => `Axis must be in the interval [${-(s2 + 1)}, ${s2}]`), l2 = s2 + a2 + 1), o2.splice(l2, 0, 1), FW({ inputs: { x: i2 }, backend: r2, attrs: { shape: o2 } });
}
var nj = { kernelName: Xt, backendName: "webgpu", kernelFunc: tj };
var rj = GW({ opType: hW.EXPM1, cpuKernelImpl: QW });
var aj = { kernelName: qt, backendName: "webgpu", kernelFunc: rj };
var ij = class {
  constructor(e20, t2) {
    this.variableNames = ["real", "imag"], this.outputShape = [], this.uniforms = "exponentMultiplier : f32, denominator: f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t2, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.component = e20, this.shaderKey = "fft_" + e20;
  }
  getUserCode() {
    return `
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${"real" === this.component ? "return real * expR - imag * expI;" : "return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `;
  }
};
function sj(e20, t2, n2) {
  let r2 = n2.tensorMap.get(e20.dataId), a2 = va.sizeFromShape(e20.shape), i2 = e20.shape[e20.shape.length - 1], s2 = [], o2 = FW({ inputs: { x: e20 }, backend: n2, attrs: { shape: [a2 / i2, i2] } });
  s2.push(o2);
  let l2 = o2.shape, u2 = new ij("real", l2), d2 = new ij("imag", l2), c2 = [{ dataId: r2.complexTensorInfos.real.dataId, dtype: r2.complexTensorInfos.real.dtype, shape: l2 }, { dataId: r2.complexTensorInfos.imag.dataId, dtype: r2.complexTensorInfos.imag.dtype, shape: l2 }], h2 = [{ type: "float32", data: [t2 ? 2 * Math.PI : -2 * Math.PI] }, { type: "float32", data: [t2 ? l2[1] : 1] }], p2 = n2.runWebGPUProgram(u2, c2, "float32", h2);
  s2.push(p2);
  let f2 = n2.runWebGPUProgram(d2, c2, "float32", h2);
  s2.push(f2);
  let m2 = BW({ inputs: { real: p2, imag: f2 }, backend: n2 });
  s2.push(m2);
  let A2 = FW({ inputs: { x: m2 }, backend: n2, attrs: { shape: e20.shape } });
  return s2.forEach((e21) => n2.disposeData(e21.dataId)), A2;
}
var oj;
var lj = { kernelName: "FFT", backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2;
  return sj(r2, false, n2);
} };
var uj = class {
  constructor(e20) {
    this.outputShape = [], this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "flipLeftRight";
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `;
  }
};
var dj = { kernelName: Yt, backendName: "webgpu", kernelFunc({ inputs: e20, backend: t2 }) {
  let { image: n2 } = e20, r2 = t2, a2 = new uj(n2.shape);
  return r2.runWebGPUProgram(a2, [n2], n2.dtype);
} };
var cj = GW({ opType: hW.FLOOR, cpuKernelImpl: eL });
var hj = { kernelName: Jt, backendName: "webgpu", kernelFunc: cj };
var pj = HW({ opType: cW.FLOOR_DIV, cpuKernelImpl: tL, dtype: "int32" });
var fj = { kernelName: Qt, backendName: "webgpu", kernelFunc: pj };
var mj = class {
  constructor(e20, t2, n2 = false) {
    this.pixelsOpType = WD.FROM_PIXELS, this.outputShape = [0], this.variableNames = [], this.workgroupSize = [256, 1, 1], this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [t2, 1, 1]), this.importVideo = n2, this.shaderKey = "fromPixels_" + this.importVideo;
  }
  getUserCode() {
    let e20 = this.importVideo ? "textureLoad(src, vec2<i32>(coords.yx));" : "textureLoad(src, vec2<i32>(coords.yx), 0)";
    return `
      @binding(1) @group(0) var src: ${this.importVideo ? "texture_external" : "texture_2d<f32>"};
      ${GD("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e20};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `;
  }
};
var Aj = { kernelName: ra, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { pixels: a2 } = t2, { numChannels: i2 } = r2;
  if (null == a2) throw Error("pixels passed to tf.browser.fromPixels() can not be null");
  let s2 = "undefined" != typeof HTMLVideoElement && a2 instanceof HTMLVideoElement, o2 = "undefined" != typeof HTMLImageElement && a2 instanceof HTMLImageElement, l2 = "undefined" != typeof HTMLCanvasElement && a2 instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && a2 instanceof OffscreenCanvas, u2 = "undefined" != typeof ImageBitmap && a2 instanceof ImageBitmap, [d2, c2] = s2 ? [a2.videoWidth, a2.videoHeight] : [a2.width, a2.height], h2 = [c2, d2, i2], p2 = _e().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE") && s2, f2 = s2 || o2;
  if (u2 || l2 || f2) {
    let e21;
    if (p2) e21 = n2.device.importExternalTexture({ source: a2 });
    else {
      if (f2) {
        let e22 = _e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
        (null == oj || e22 !== xj) && (xj = e22, oj = document.createElement("canvas").getContext("2d", { willReadFrequently: xj })), oj.canvas.width = d2, oj.canvas.height = c2, oj.drawImage(a2, 0, 0, d2, c2), a2 = oj.canvas;
      }
      let t4 = GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING, r4 = n2.textureManager.acquireTexture(h2[1], h2[0], "rgba8unorm", t4);
      n2.queue.copyExternalImageToTexture({ source: a2 }, { texture: r4 }, [h2[1], h2[0]]), e21 = r4;
    }
    let t3 = va.sizeFromShape(h2), r3 = va.computeStrides(h2), s3 = new mj(h2, i2, p2), o3 = [{ type: "uint32", data: [t3] }, { type: "uint32", data: [i2] }, { type: "uint32", data: [...r3] }], l3 = n2.makeTensorInfo([c2, d2], "int32");
    n2.tensorMap.get(l3.dataId).resource = e21;
    let u3 = n2.runWebGPUProgram(s3, [l3], "int32", o3);
    return n2.disposeData(l3.dataId), u3;
  }
  let m2 = a2.data, A2 = m2;
  if (null != i2 && 4 !== i2) {
    A2 = new Uint8Array(a2.width * a2.height * i2);
    let e21 = m2.length, t3 = 0;
    for (let n3 = 0; e21 > n3; n3++) i2 > n3 % 4 && (A2[t3++] = m2[n3]);
  }
  let x2 = n2.makeTensorInfo(h2, "int32", new Int32Array(A2));
  return n2.uploadToGPU(x2.dataId), x2;
} };
var xj = _e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
var yj = class {
  constructor(e20, t2, n2, r2, a2) {
    this.uniforms = "varianceEpsilon : f32,", this.workgroupSize = [128, 1, 1], this.size = true, this.variableNames = ["x", "mean", "variance"], Uf.assertAndGetBroadcastShape(e20, t2), Uf.assertAndGetBroadcastShape(e20, n2), this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), null != r2 && (Uf.assertAndGetBroadcastShape(e20, r2), this.variableNames.push("offset")), null != a2 && (Uf.assertAndGetBroadcastShape(e20, a2), this.variableNames.push("scale")), this.offsetShape = r2, this.scaleShape = a2, this.shaderKey = "batchNorm";
  }
  getUserCode() {
    let e20 = "0.0";
    null != this.offsetShape && (e20 = "getOffsetByOutputIndex(index)");
    let t2 = "1.0";
    return null != this.scaleShape && (t2 = "getScaleByOutputIndex(index)"), `
      ${GD("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e20};
          let scaleValue = ${t2};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `;
  }
};
var bj = { kernelName: en, backendName: "webgpu", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { x: r2, scale: a2, offset: i2, mean: s2, variance: o2 } = e20, { varianceEpsilon: l2 } = t2, u2 = n2, d2 = [r2, s2, o2], c2 = null;
  null != i2 && (c2 = i2.shape, d2.push(i2));
  let h2 = null;
  null != a2 && (h2 = a2.shape, d2.push(a2));
  let p2 = new yj(r2.shape, s2.shape, o2.shape, c2, h2);
  return u2.runWebGPUProgram(p2, d2, r2.dtype, [{ type: "float32", data: [l2] }]);
} };
var gj = { kernelName: sa, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2, bias: s2, preluActivationWeights: o2 } = t2, { strides: l2, pad: u2, dataFormat: d2, dilations: c2, dimRoundingMode: h2, activation: p2, leakyreluAlpha: f2 } = r2, m2 = Uf.convertConv2DDataFormat(d2);
  return JB({ x: a2, filter: i2, convInfo: Uf.computeConv2DInfo(a2.shape, i2.shape, l2, c2, u2, h2, false, m2), backend: n2, bias: s2, preluActivationWeights: o2, leakyreluAlpha: f2, activation: p2 });
} };
var vj = { kernelName: oa, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, filter: i2, bias: s2, preluActivationWeights: o2 } = t2, { strides: l2, pad: u2, dilations: d2, dimRoundingMode: c2, activation: h2, leakyreluAlpha: p2 } = r2, f2 = d2;
  null == f2 && (f2 = [1, 1]), va.assert(Uf.eitherStridesOrDilationsAreOne(l2, f2), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l2} and dilations '${f2}'`);
  let m2 = Uf.computeConv2DInfo(a2.shape, i2.shape, l2, f2, u2, c2, true), A2 = [a2, i2], x2 = null != s2, y2 = null != o2;
  x2 && A2.push(s2), y2 && A2.push(o2);
  let b2, g2 = [{ type: "int32", data: [m2.padInfo.top, m2.padInfo.left] }, { type: "int32", data: [m2.inHeight, m2.inWidth] }];
  return m2.outHeight > 4 && m2.outWidth > 4 && 2 >= m2.strideWidth && m2.inChannels === m2.outChannels && 1 === m2.dilationHeight && 1 === m2.dilationWidth && m2.inChannels % 4 == 0 ? (b2 = new RU(m2, x2, h2, y2), g2.push({ type: "int32", data: [b2.virtualWidth] })) : (b2 = new SU(m2, x2, h2, y2), g2.push({ type: "int32", data: [m2.filterHeight] }, { type: "int32", data: [m2.filterWidth] }, { type: "int32", data: [m2.strideHeight, m2.strideWidth] }, { type: "int32", data: [m2.dilationHeight, m2.dilationWidth] })), "leakyrelu" === h2 && (g2.push({ type: "float32", data: [p2] }), b2.uniforms += " alpha : f32,"), n2.runWebGPUProgram(b2, A2, "float32", g2);
} };
var wj = class {
  constructor(e20, t2) {
    this.variableNames = ["A", "indices"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t2, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "gathernd_" + e20, this.sliceDim = e20, this.uniforms = `sliceDim : i32, strides : ${UD(e20)},`;
  }
  getUserCode() {
    let e20;
    return e20 = this.sliceDim > 1 ? "uniforms.strides[j]" : "uniforms.strides", `
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e20};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `;
  }
};
var kj = { kernelName: nn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { params: r2, indices: a2 } = t2, i2 = a2.shape, s2 = i2[i2.length - 1], o2 = va.sizeFromShape(r2.shape), [l2, u2, d2, c2] = Uf.prepareAndValidate(r2, a2), h2 = FW({ inputs: { x: a2 }, backend: n2, attrs: { shape: [u2, s2] } }), p2 = FW({ inputs: { x: r2 }, backend: n2, attrs: { shape: [va.sizeFromShape(r2.shape) / d2, d2] } });
  if (n2.shouldExecuteOnCPU([r2, a2]) || "string" === r2.dtype) {
    let e21 = n2.readSync(a2.dataId), t3 = n2.bufferSync(r2), i3 = nL(e21, t3, r2.dtype, u2, s2, d2, c2, r2.shape, o2);
    return n2.makeTensorInfo(l2, r2.dtype, i3.values);
  }
  let f2 = new wj(s2, [u2, d2]), m2 = n2.runWebGPUProgram(f2, [p2, h2], p2.dtype, [{ type: "int32", data: [s2] }, { type: "int32", data: c2 }]), A2 = FW({ inputs: { x: m2 }, backend: n2, attrs: { shape: l2 } });
  return n2.disposeData(h2.dataId), n2.disposeData(p2.dataId), n2.disposeData(m2.dataId), A2;
} };
var Nj = class {
  constructor(e20, t2) {
    this.variableNames = ["A", "indices"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.slice(), this.aShape = e20, this.outputShape = t2, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "gather";
  }
  getUserCode() {
    let e20 = ((e21) => {
      let t2 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], n2 = [];
      for (let r2 = 0; e21.length > r2; r2++) n2.push(2 === r2 ? "indexZ" : "" + t2[r2]);
      return n2.join();
    })(this.aShape);
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e20}));
        }
      }
    `;
  }
};
function Cj(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, indices: i2 } = t2, { axis: s2, batchDims: o2 } = r2, l2 = va.parseAxisParam(s2, a2.shape)[0], u2 = Uf.segment_util.collectGatherOpShapeInfo(a2, i2, l2, o2), d2 = va.sizeFromShape(i2.shape), c2 = [], h2 = FW({ inputs: { x: a2 }, backend: n2, attrs: { shape: [u2.batchSize, u2.outerSize, u2.dimSize, u2.sliceSize] } }), p2 = FW({ inputs: { x: i2 }, backend: n2, attrs: { shape: [u2.batchSize, d2 / u2.batchSize] } });
  c2.push(h2), c2.push(p2);
  let f2 = [u2.batchSize, u2.outerSize, d2 / u2.batchSize, u2.sliceSize];
  if (n2.shouldExecuteOnCPU([a2, i2])) {
    let e21 = n2.tensorMap.get(p2.dataId).values, t3 = uo(p2.shape, p2.dtype, e21), r3 = n2.tensorMap.get(h2.dataId).values, a3 = uo(h2.shape, h2.dtype, r3), i3 = rL(a3, t3, f2);
    return c2.forEach((e22) => n2.disposeData(e22.dataId)), n2.makeTensorInfo(u2.outputShape, i3.dtype, i3.values);
  }
  let m2 = new Nj(h2.shape, f2), A2 = n2.runWebGPUProgram(m2, [h2, p2], h2.dtype);
  c2.push(A2);
  let x2 = FW({ inputs: { x: A2 }, backend: n2, attrs: { shape: u2.outputShape } });
  return c2.forEach((e21) => n2.disposeData(e21.dataId)), x2;
}
var $j = { kernelName: tn, backendName: "webgpu", kernelFunc: Cj };
var Rj = HW({ opType: cW.GREATER, cpuKernelImpl: iL, dtype: "bool" });
var Sj = { kernelName: rn, backendName: "webgpu", kernelFunc: Rj };
var Ij = HW({ opType: cW.GREATER_EQUAL, dtype: "bool", cpuKernelImpl: aL });
var Ej = { kernelName: an, backendName: "webgpu", kernelFunc: Ij };
var Tj = { kernelName: on, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { input: r2 } = t2;
  return sj(r2, true, n2);
} };
var Mj = GW({ opType: hW.IS_FINITE, dtype: "bool" });
var Oj = { kernelName: un, backendName: "webgpu", kernelFunc: Mj };
var Fj = GW({ opType: hW.IS_INF, dtype: "bool" });
var Pj = { kernelName: dn, backendName: "webgpu", kernelFunc: Fj };
var zj = GW({ opType: hW.IS_NAN, dtype: "bool" });
var Vj = { kernelName: cn, backendName: "webgpu", kernelFunc: zj };
var _j = { kernelName: hn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { alpha: i2 } = r2, s2 = [{ type: "float32", data: [i2] }], o2 = new jW(a2.shape, hW.LEAKYRELU, "alpha : f32,");
  return n2.runWebGPUProgram(o2, [a2], "float32", s2);
} };
var Dj = HW({ opType: cW.LESS, dtype: "bool", cpuKernelImpl: oL });
var Wj = { kernelName: pn, backendName: "webgpu", kernelFunc: Dj };
var Lj = HW({ opType: cW.LESS_EQUAL, dtype: "bool", cpuKernelImpl: sL });
var Bj = { kernelName: fn, backendName: "webgpu", kernelFunc: Lj };
var Uj = class {
  constructor(e20) {
    this.variableNames = [], this.outputShape = [], this.uniforms = "start : f32, step : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e20], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "linSpace";
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `;
  }
};
var jj = { kernelName: mn, backendName: "webgpu", kernelFunc(e20) {
  let { backend: t2, attrs: n2 } = e20, { start: r2, stop: a2, num: i2 } = n2, s2 = (a2 - r2) / (i2 - 1), o2 = new Uj(i2);
  return t2.runWebGPUProgram(o2, [], "float32", [{ type: "float32", data: [r2] }, { type: "float32", data: [s2] }]);
} };
var Gj = { kernelName: "Log", backendName: "webgpu", kernelFunc: GW({ opType: hW.LOG, cpuKernelImpl: lL }) };
var Hj = GW({ opType: hW.LOG1P });
var Xj = { kernelName: xn, backendName: "webgpu", kernelFunc: Hj };
var qj = HW({ opType: cW.LOGICAL_AND, dtype: "bool" });
var Zj = { kernelName: yn, backendName: "webgpu", kernelFunc: qj };
var Kj = GW({ opType: hW.LOGICAL_NOT });
var Yj = { kernelName: bn, backendName: "webgpu", kernelFunc: Kj };
var Jj = HW({ opType: cW.LOGICAL_OR });
var Qj = { kernelName: gn, backendName: "webgpu", kernelFunc: Jj };
var eG = "\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";
var tG = class {
  constructor(e20) {
    this.outputShape = [], this.variableNames = ["x"], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "lrn";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${eG}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `;
  }
};
var nG = class {
  constructor(e20, t2) {
    this.outputShape = [], this.variableNames = ["x"], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [256, 1, 1], this.maxAllowRadius = 16, va.assert(this.maxAllowRadius >= t2, () => `Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t2}`), this.outputShape = e20, this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius, this.dispatchLayout = { x: [3], y: [2], z: [0, 1] }, this.dispatch = rW(this.dispatchLayout, this.outputShape, [this.elementsPerWorkgroup, this.workgroupSize[1], this.workgroupSize[2]]), this.shaderKey = "lrn_shared";
  }
  getUserCode() {
    return `
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${GD()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${eG}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `;
  }
};
var rG = { kernelName: "LRN", backendName: "webgpu", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2 } = n2, { depthRadius: s2, bias: o2, alpha: l2, beta: u2 } = a2;
  return t2 = s2 > 16 ? new tG(i2.shape) : new nG(i2.shape, s2), r2.runWebGPUProgram(t2, [i2], i2.dtype, [{ type: "int32", data: [s2] }, { type: "float32", data: [o2] }, { type: "float32", data: [l2] }, { type: "float32", data: [u2] }]);
} };
var aG = class {
  constructor(e20) {
    this.outputShape = [], this.variableNames = ["inputImage", "outputImage", "dy"], this.uniforms = "depthRadius : i32, bias : f32, alpha : f32, beta : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "lrn_grad";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `;
  }
};
var iG = { kernelName: Cn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, y: i2, dy: s2 } = t2, { depthRadius: o2, bias: l2, alpha: u2, beta: d2 } = r2, c2 = new aG(a2.shape);
  return n2.runWebGPUProgram(c2, [a2, i2, s2], a2.dtype, [{ type: "int32", data: [o2] }, { type: "float32", data: [l2] }, { type: "float32", data: [u2] }, { type: "float32", data: [d2] }]);
} };
var sG = HW({ opType: cW.MAX, cpuKernelImpl: dL });
var oG = { kernelName: Sn, backendName: "webgpu", kernelFunc: sG };
var lG = { kernelName: In, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dimRoundingMode: l2 } = r2;
  return cB(a2, Uf.computePool2DInfo(a2.shape, i2, s2, 1, o2, l2), "max", n2);
} };
var uG = { kernelName: Tn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { filterSize: i2, strides: s2, pad: o2, dataFormat: l2, dimRoundingMode: u2 } = r2, d2 = Uf.computePool3DInfo(a2.shape, i2, s2, [1, 1, 1], o2, u2, l2), c2 = new sB(d2, "max");
  return n2.runWebGPUProgram(c2, [a2], a2.dtype, [{ type: "int32", data: [d2.strideDepth, d2.strideHeight, d2.strideWidth] }, { type: "int32", data: [d2.padInfo.front, d2.padInfo.top, d2.padInfo.left] }, { type: "int32", data: [d2.inDepth, d2.inHeight, d2.inWidth] }, { type: "int32", data: [d2.effectiveFilterDepth, d2.effectiveFilterHeight, d2.effectiveFilterWidth] }]);
} };
var dG = class {
  constructor(e20) {
    this.variableNames = ["dy", "maxPos"], this.uniforms = "strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.inShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "maxPool2DBackprop";
  }
  getUserCode() {
    return `
      ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
  }
};
var cG = class {
  constructor(e20) {
    this.variableNames = ["dy", "maxPos"], this.uniforms = "strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20.inShape, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "maxPool3DBackprop";
  }
  getUserCode() {
    return `
      ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `;
  }
};
var hG = { kernelName: Mn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2 } = t2, s2 = i2, { filterSize: o2, strides: l2, pad: u2, dimRoundingMode: d2 } = r2, c2 = Uf.computePool3DInfo(s2.shape, o2, l2, [1, 1, 1], u2, d2), h2 = new sB(c2, "max", true), p2 = [{ type: "int32", data: [c2.strideDepth, c2.strideHeight, c2.strideWidth] }, { type: "int32", data: [c2.padInfo.front, c2.padInfo.top, c2.padInfo.left] }, { type: "int32", data: [c2.inDepth, c2.inHeight, c2.inWidth] }, { type: "int32", data: [c2.effectiveFilterDepth, c2.effectiveFilterHeight, c2.effectiveFilterWidth] }], f2 = n2.runWebGPUProgram(h2, [s2], "int32", p2), m2 = new cG(c2);
  p2 = [{ type: "int32", data: [c2.strideDepth, c2.strideHeight, c2.strideWidth] }, { type: "int32", data: [c2.effectiveFilterDepth - 1 - c2.padInfo.front, c2.effectiveFilterHeight - 1 - c2.padInfo.top, c2.effectiveFilterWidth - 1 - c2.padInfo.left] }, { type: "int32", data: [c2.effectiveFilterDepth, c2.effectiveFilterHeight, c2.effectiveFilterWidth] }, { type: "int32", data: [c2.outDepth] }, { type: "int32", data: [c2.outHeight] }, { type: "int32", data: [c2.outWidth] }];
  let A2 = n2.runWebGPUProgram(m2, [a2, f2], s2.dtype, p2);
  return n2.disposeData(f2.dataId), A2;
} };
var pG = { kernelName: En, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { dy: a2, input: i2, output: s2 } = t2, o2 = i2;
  dW([i2, s2], "maxPoolGrad");
  let { filterSize: l2, strides: u2, pad: d2, dimRoundingMode: c2 } = r2, h2 = Uf.computePool2DInfo(o2.shape, l2, u2, 1, d2, c2), p2 = new iB(h2, "max", true), f2 = [{ type: "int32", data: [h2.strideHeight, h2.strideWidth] }, { type: "int32", data: [h2.padInfo.top, h2.padInfo.left] }, { type: "int32", data: [h2.dilationHeight, h2.dilationWidth] }, { type: "int32", data: [h2.inHeight, h2.inWidth] }, { type: "int32", data: [h2.effectiveFilterHeight, h2.effectiveFilterWidth] }], m2 = n2.runWebGPUProgram(p2, [o2], "int32", f2), A2 = new dG(h2);
  f2 = [{ type: "int32", data: [h2.strideHeight, h2.strideWidth] }, { type: "int32", data: [h2.effectiveFilterHeight - 1 - h2.padInfo.top, h2.effectiveFilterWidth - 1 - h2.padInfo.left] }, { type: "int32", data: [h2.dilationHeight, h2.dilationWidth] }, { type: "int32", data: [h2.effectiveFilterHeight, h2.effectiveFilterWidth] }, { type: "int32", data: [h2.outHeight] }, { type: "int32", data: [h2.outWidth] }];
  let x2 = n2.runWebGPUProgram(A2, [a2, m2], o2.dtype, f2);
  return n2.disposeData(m2.dataId), x2;
} };
var fG = { kernelName: On, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { filterSize: a2, strides: i2, pad: s2, includeBatchInIndex: o2 } = r2, { x: l2 } = t2;
  va.assert(4 === l2.shape.length, () => `Error in maxPool: input must be rank 4 but got rank ${l2.shape.length}.`);
  let u2 = [1, 1];
  va.assert(Uf.eitherStridesOrDilationsAreOne(i2, u2), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i2} and dilations '${u2}'`);
  let d2 = Uf.computePool2DInfo(l2.shape, a2, i2, u2, s2), c2 = [{ type: "int32", data: [d2.strideHeight, d2.strideWidth] }, { type: "int32", data: [d2.padInfo.top, d2.padInfo.left] }, { type: "int32", data: [d2.dilationHeight, d2.dilationWidth] }, { type: "int32", data: [d2.inHeight, d2.inWidth] }, { type: "int32", data: [d2.effectiveFilterHeight, d2.effectiveFilterWidth] }], h2 = new iB(d2, "max", false), p2 = n2.runWebGPUProgram(h2, [l2], l2.dtype, c2);
  return h2 = new iB(d2, "max", true, true, o2), [p2, n2.runWebGPUProgram(h2, [l2], "int32", c2)];
} };
var mG = { kernelName: "Min", backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2;
  return BL(a2, i2, s2, "min", n2);
} };
var AG = HW({ opType: cW.MIN, cpuKernelImpl: cL });
var xG = { kernelName: zn, backendName: "webgpu", kernelFunc: AG };
var yG = class {
  constructor(e20, t2, n2) {
    this.uniforms = "", this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t2.map((t3, n3) => t3[0] + e20[n3] + t3[1]), this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.xShape = e20, t2.map((e21, t3) => {
      this.uniforms += ` pad${t3} : vec2<i32>,`;
    }), this.offset = "reflect" === n2 ? 0 : 1, this.shaderKey = "mirrorPad_" + n2;
  }
  getUserCode() {
    let e20 = this.xShape.length, t2 = this.xShape.map((e21, t3) => `uniforms.pad${t3}[0]`).join(","), n2 = this.xShape.map((t3, n3) => `uniforms.pad${n3}[0] + uniforms.xShape${e20 > 1 ? `[${n3}]` : ""}`).join(","), r2 = 1 === e20 ? "start" : "start[i]", a2 = 1 === e20 ? "end" : "end[i]", i2 = 1 === e20 ? "outC" : "outC[i]", s2 = UD(e20), o2 = e20 > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, e20) : "coords";
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let start = ${s2}(${t2});
          let end = ${s2}(${n2});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e20}; i = i + 1) {
            if (${i2} < ${r2}) {
              ${i2} = ${r2} * 2 - ${i2} - ${this.offset};
            } else if(${i2} >= ${a2}) {
              ${i2} = (${a2} - 1) * 2 - ${i2} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${o2}));
        }
      }
    `;
  }
};
var bG = { kernelName: Vn, backendName: "webgpu", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { x: r2 } = e20, { paddings: a2, mode: i2 } = t2, s2 = n2, o2 = a2.map((e21) => ({ type: "int32", data: [e21[0], e21[1]] })), l2 = new yG(r2.shape, a2, i2);
  return s2.runWebGPUProgram(l2, [r2], r2.dtype, o2);
} };
var gG = { kernelName: "Mod", backendName: "webgpu", kernelFunc: HW({ opType: cW.MOD }) };
var vG = class {
  constructor(e20, t2) {
    this.variableNames = ["probs"], this.outputShape = [], this.uniforms = "seed : f32, numOutcomes: i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e20, t2], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "multinomial";
  }
  getUserCode() {
    return `
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${GD("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `;
  }
};
var wG = class {
  constructor(e20) {
    this.variableNames = ["logits"], this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = [this.outputShape[0], 1, 1], this.workgroupSize = 4096 > this.outputShape[1] ? [64, 1, 1] : [256, 1, 1], this.shaderKey = "softmax";
  }
  getUserCode() {
    return `
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${GD("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `;
  }
};
function kG(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { logits: a2 } = t2, { dim: i2 } = r2, s2 = FW({ inputs: { x: a2 }, backend: n2, attrs: { shape: [va.sizeFromShape(a2.shape) / a2.shape[i2], a2.shape[i2]] } }), o2 = new wG(s2.shape), l2 = n2.runWebGPUProgram(o2, [s2], a2.dtype), u2 = FW({ inputs: { x: l2 }, backend: n2, attrs: { shape: a2.shape } });
  return n2.disposeData(s2.dataId), n2.disposeData(l2.dataId), u2;
}
var NG = { kernelName: Tr, backendName: "webgpu", kernelFunc: kG };
var CG = { kernelName: Dn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { logits: a2 } = t2, { numSamples: i2, seed: s2, normalized: o2 } = r2, l2 = o2 ? a2 : kG({ inputs: { logits: a2 }, backend: n2, attrs: { dim: a2.shape.length - 1 } }), u2 = l2.shape[1], d2 = new vG(l2.shape[0], i2), c2 = n2.runWebGPUProgram(d2, [l2], "int32", [{ type: "float32", data: [s2] }, { type: "int32", data: [u2] }]);
  return o2 || n2.disposeData(l2.dataId), c2;
} };
var $G = { kernelName: "Neg", backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2;
  if (n2.shouldExecuteOnCPU([r2])) {
    let e21 = n2.tensorMap.get(r2.dataId), [t3, a3] = pL(e21.values, r2.shape, r2.dtype);
    return n2.makeTensorInfo(a3, r2.dtype, t3);
  }
  let a2 = new jW(r2.shape, hW.NEG);
  return n2.runWebGPUProgram(a2, [r2], r2.dtype);
} };
var RG = { kernelName: Un, backendName: "webgpu", kernelFunc(e20) {
  console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { boxes: a2, scores: i2 } = t2, { maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2 } = r2, u2 = n2.readSync(a2.dataId), d2 = n2.readSync(i2.dataId), { selectedIndices: c2 } = Ym.nonMaxSuppressionV3Impl(u2, d2, s2, o2, l2);
  return n2.makeTensorInfo([c2.length], "int32", new Int32Array(c2));
} };
var SG = { kernelName: Gn, backendName: "webgpu", kernelFunc(e20) {
  console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { boxes: a2, scores: i2 } = t2, { maxOutputSize: s2, iouThreshold: o2, scoreThreshold: l2, softNmsSigma: u2 } = r2, d2 = n2.readSync(a2.dataId), c2 = n2.readSync(i2.dataId), h2 = s2, p2 = o2, f2 = l2, m2 = u2, { selectedIndices: A2, selectedScores: x2 } = Ym.nonMaxSuppressionV5Impl(d2, c2, h2, p2, f2, m2);
  return [n2.makeTensorInfo([A2.length], "int32", new Int32Array(A2)), n2.makeTensorInfo([x2.length], "float32", new Float32Array(x2))];
} };
var IG = class {
  constructor(e20, t2) {
    this.variableNames = ["x"], this.uniforms = "onValue : f32, offValue : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e20, t2], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "onehot";
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `;
  }
};
var EG = { kernelName: Xn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { indices: a2 } = t2, { dtype: i2, depth: s2, onValue: o2, offValue: l2 } = r2, u2 = va.sizeFromShape(a2.shape), d2 = new IG(u2, s2), c2 = FW({ inputs: { x: a2 }, backend: n2, attrs: { shape: [u2] } }), h2 = n2.runWebGPUProgram(d2, [c2], i2, [{ type: "float32", data: [o2] }, { type: "float32", data: [l2] }]);
  n2.disposeData(c2.dataId);
  let p2 = FW({ inputs: { x: h2 }, backend: n2, attrs: { shape: [...a2.shape, s2] } });
  return n2.disposeData(h2.dataId), p2;
} };
function TG(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2 } = t2;
  if ("complex64" === r2.dtype) {
    let e21 = TB({ inputs: { input: r2 }, backend: n2 }), t3 = TG({ inputs: { x: e21 }, backend: n2 }), a2 = UB({ inputs: { input: r2 }, backend: n2 }), i2 = TG({ inputs: { x: a2 }, backend: n2 }), s2 = BW({ inputs: { real: t3, imag: i2 }, backend: n2 });
    return n2.disposeData(e21.dataId), n2.disposeData(t3.dataId), n2.disposeData(a2.dataId), n2.disposeData(i2.dataId), s2;
  }
  return MW({ attrs: { shape: r2.shape, dtype: r2.dtype, value: "string" === r2.dtype ? "" : 0 }, backend: n2 });
}
var MG = { kernelName: ta, backendName: "webgpu", kernelFunc: TG };
var OG = { kernelName: Hn, backendName: "webgpu", kernelFunc: function e19(t2) {
  let { inputs: n2, backend: r2 } = t2, { x: a2 } = n2;
  if ("string" === a2.dtype) throw Error("onesLike is not supported under string dtype");
  if ("complex64" === a2.dtype) {
    let t3 = TB({ inputs: { input: a2 }, backend: r2 }), n3 = e19({ inputs: { x: t3 }, backend: r2 }), i2 = UB({ inputs: { input: a2 }, backend: r2 }), s2 = TG({ inputs: { x: i2 }, backend: r2 }), o2 = BW({ inputs: { real: n3, imag: s2 }, backend: r2 });
    return r2.disposeData(t3.dataId), r2.disposeData(n3.dataId), r2.disposeData(i2.dataId), r2.disposeData(s2.dataId), o2;
  }
  return MW({ attrs: { shape: a2.shape, dtype: a2.dtype, value: 1 }, backend: r2 });
} };
var FG = { kernelName: qn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { axis: a2 } = r2;
  if (1 === t2.length) return tj({ inputs: { input: t2[0] }, backend: n2, attrs: { dim: a2 } });
  let i2 = t2[0].shape, s2 = t2[0].dtype;
  t2.forEach((e21) => {
    va.assertShapesMatch(i2, e21.shape, "All tensors passed to stack must have matching shapes"), va.assert(s2 === e21.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  let o2 = [], l2 = HB({ inputs: t2.map((e21) => {
    let t3 = tj({ inputs: { input: e21 }, backend: n2, attrs: { dim: a2 } });
    return o2.push(t3), t3;
  }), backend: n2, attrs: { axis: a2 } });
  return o2.forEach((e21) => n2.disposeData(e21.dataId)), l2;
} };
function PG(e20, t2 = false) {
  let n2 = e20.length, r2 = UD(n2), a2 = e20.map((e21, t3) => `uniforms.pad${t3}[0]`).join(","), i2 = e20.map((e21, t3) => `uniforms.pad${t3}[0] + uniforms.xShape${n2 > 1 ? `[${t3}]` : ""}`).join(",");
  return `
        let start = ${n2 > 1 ? `${r2}(${a2})` : "" + a2};
        let end = ${n2 > 1 ? `${r2}(${i2})` : "" + i2};
        if (${n2 > 1 ? "any(paddedCoords < start)" : "paddedCoords < start"} || ${n2 > 1 ? "any(paddedCoords >= end)" : "paddedCoords >= end"}) {
          setOutputAtIndex(index, ${t2 ? 0 : "uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${n2 > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, n2) : "coords"}));
        }
  `;
}
var zG = class {
  constructor(e20, t2) {
    this.variableNames = ["x"], this.uniforms = "constantValue : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t2.map((t3, n2) => t3[0] + e20[n2] + t3[1]), this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), t2.map((e21, t3) => {
      this.uniforms += ` pad${t3} : vec2<i32>,`;
    }), this.xShape = e20, this.shaderKey = "pad";
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${PG(this.xShape)}
        }
      }
    `;
  }
};
var VG = { kernelName: Zn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { paddings: i2, constantValue: s2 } = r2;
  if (i2.every((e21) => va.arraysEqual(e21, [0, 0]))) return WW({ inputs: { x: a2 }, backend: n2 });
  if (0 === va.sizeFromShape(a2.shape)) return MW({ backend: n2, attrs: { shape: i2.map((e21, t3) => e21[0] + a2.shape[t3] + e21[1]), value: s2, dtype: a2.dtype } });
  let o2 = [{ type: "float32", data: [s2] }];
  i2.map((e21) => o2.push({ type: "int32", data: [e21[0], e21[1]] }));
  let l2 = new zG(a2.shape, i2);
  return n2.runWebGPUProgram(l2, [a2], a2.dtype, o2);
} };
var _G = { kernelName: "Pow", backendName: "webgpu", kernelFunc: HW({ opType: cW.POW }) };
var DG = { kernelName: Jn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { x: r2, alpha: a2 } = t2, i2 = new DW(cW.PRELU, r2.shape, a2.shape);
  return n2.runWebGPUProgram(i2, [r2, a2], "float32");
} };
var WG = { kernelName: Qn, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { axis: i2, keepDims: s2 } = r2;
  return BL(a2, i2, s2, "prod", n2);
} };
var LG = { kernelName: rr, backendName: "webgpu", kernelFunc(e20) {
  let { backend: t2, attrs: n2 } = e20, { start: r2, stop: a2, step: i2, dtype: s2 } = n2, o2 = AL(r2, a2, i2, s2);
  return t2.makeTensorInfo([o2.length], s2, o2);
} };
var BG = HW({ opType: cW.DIV });
var UG = { kernelName: Wt, backendName: "webgpu", kernelFunc: BG };
var jG = GW({ opType: hW.RECIPROCAL });
var GG = { kernelName: ir, backendName: "webgpu", kernelFunc: jG };
var HG = GW({ opType: hW.RELU });
var XG = { kernelName: sr, backendName: "webgpu", kernelFunc: HG };
var qG = GW({ opType: hW.RELU6 });
var ZG = { kernelName: hr, backendName: "webgpu", kernelFunc: qG };
var KG = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["x"], this.uniforms = "adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e20[0], t2, n2, e20[3]], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "resizeBilinear";
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `;
  }
};
var YG = { kernelName: dr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2 } = t2, { alignCorners: i2, size: s2, halfPixelCenters: o2 } = r2, [l2, u2] = s2, d2 = [{ type: "float32", data: [i2 && l2 > 1 ? 1 : 0, i2 && u2 > 1 ? 1 : 0] }, { type: "float32", data: [o2 ? 0.5 : 0] }], c2 = new KG(a2.shape, l2, u2);
  return n2.runWebGPUProgram(c2, [a2], "float32", d2);
} };
var JG = class {
  constructor(e20, t2) {
    this.variableNames = ["dy"], this.uniforms = "effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.alignCorners = t2, this.shaderKey = "resizeBilinearBackprop_" + t2;
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
  }
};
var QG = { kernelName: cr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2, dy: i2 } = t2, { alignCorners: s2 } = r2, [, o2, l2] = a2.shape, [, u2, d2] = i2.shape, c2 = [s2 && u2 > 1 ? o2 - 1 : o2, s2 && d2 > 1 ? l2 - 1 : l2], h2 = [s2 && u2 > 1 ? u2 - 1 : u2, s2 && d2 > 1 ? d2 - 1 : d2], p2 = c2[0] / h2[0], f2 = c2[1] / h2[1], m2 = 1 / p2, A2 = 1 / f2, x2 = 2 * Math.ceil(m2) + 2, y2 = 2 * Math.ceil(A2) + 2, b2 = new JG(a2.shape, s2);
  return n2.runWebGPUProgram(b2, [i2], i2.dtype, [{ type: "int32", data: c2 }, { type: "int32", data: h2 }, { type: "float32", data: [p2] }, { type: "float32", data: [f2] }, { type: "float32", data: [m2] }, { type: "float32", data: [A2] }, { type: "int32", data: [x2] }, { type: "int32", data: [y2] }]);
} };
var eH = class {
  constructor(e20, t2, n2, r2) {
    this.variableNames = ["x"], this.uniforms = "adjustHeightWidth : vec2<f32>, roundBase : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = [e20[0], t2, n2, e20[3]], this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.halfPixelCenters = r2, this.shaderKey = "resizeNearest_" + r2;
  }
  getUserCode() {
    let e20;
    return e20 = this.halfPixelCenters ? "max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))" : "vec2<f32>(rc) * effectiveInputOverOutputRatioRC", `
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e20};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `;
  }
};
var tH = { kernelName: lr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2 } = t2, { alignCorners: i2, halfPixelCenters: s2, size: o2 } = r2, [l2, u2] = o2, d2 = [{ type: "float32", data: [i2 && l2 > 1 ? 1 : 0, i2 && u2 > 1 ? 1 : 0] }, { type: "float32", data: [i2 ? 0.5 : 0] }], c2 = new eH(a2.shape, l2, u2, s2);
  return n2.runWebGPUProgram(c2, [a2], a2.dtype, d2);
} };
var nH = class {
  constructor(e20, t2) {
    this.variableNames = ["dy"], this.uniforms = "effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.alignCorners = t2, this.shaderKey = "resizeNearestNeigborBackprop_" + t2;
  }
  getUserCode() {
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners ? "floor(sourceFracRow + 0.5)" : "floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners ? "floor(sourceFracCol + 0.5)" : "floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
  }
};
var rH = { kernelName: ur, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { images: a2, dy: i2 } = t2, { alignCorners: s2 } = r2, [, o2, l2] = a2.shape, [, u2, d2] = i2.shape, c2 = [s2 && u2 > 1 ? o2 - 1 : o2, s2 && d2 > 1 ? l2 - 1 : l2], h2 = [s2 && u2 > 1 ? u2 - 1 : u2, s2 && d2 > 1 ? d2 - 1 : d2], p2 = 1 / (c2[0] / h2[0]), f2 = 1 / (c2[1] / h2[1]), m2 = 2 * Math.ceil(p2) + 2, A2 = 2 * Math.ceil(f2) + 2, x2 = new nH(a2.shape, s2);
  return n2.runWebGPUProgram(x2, [i2], i2.dtype, [{ type: "int32", data: c2 }, { type: "int32", data: h2 }, { type: "float32", data: [p2] }, { type: "float32", data: [f2] }, { type: "int32", data: [m2] }, { type: "int32", data: [A2] }]);
} };
var aH = class {
  constructor(e20) {
    this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = " axis : vec4<i32>,", this.shaderKey = "reverse";
  }
  getUserCode() {
    return `
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `;
  }
};
var iH = { kernelName: pr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { dims: i2 } = r2, s2 = a2.shape.length;
  if (0 === s2) return WW({ inputs: { x: a2 }, backend: n2 });
  let o2 = a2.shape, l2 = [1, 1, 1, 1];
  o2.forEach((e21, t3) => {
    l2[t3 + 4 - s2] = e21;
  });
  let u2 = va.parseAxisParam(i2, a2.shape), d2 = [0, 0, 0, 0];
  u2.forEach((e21) => {
    d2[e21 + 4 - s2] = 1;
  });
  let c2 = [{ type: "int32", data: d2 }], h2 = FW({ inputs: { x: a2 }, backend: n2, attrs: { shape: l2 } }), p2 = new aH(l2), f2 = n2.runWebGPUProgram(p2, [h2], h2.dtype, c2);
  n2.disposeData(h2.dataId);
  let m2 = FW({ inputs: { x: f2 }, backend: n2, attrs: { shape: o2 } });
  return n2.disposeData(f2.dataId), m2;
} };
var sH = class {
  constructor(e20, t2) {
    this.outputShape = [], this.variableNames = ["x"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = "centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,", this.shaderKey = "rotate", this.outputShape = e20, "number" == typeof t2 ? (this.uniforms += " fillValue : f32,", this.fillSnippet = "var outputValue = uniforms.fillValue;", this.shaderKey += "_float") : (this.uniforms += " fillValue : vec3<f32>,", this.fillSnippet = "var outputValue = uniforms.fillValue[coords[3]];", this.shaderKey += "_vec3");
  }
  getUserCode() {
    return `
        ${GD("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `;
  }
};
var oH = { kernelName: aa, backendName: "webgpu", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { image: r2 } = e20, { radians: a2, fillValue: i2, center: s2 } = t2, o2 = n2, l2 = new sH(r2.shape, i2), [u2, d2] = Uf.getImageCenter(s2, r2.shape[1], r2.shape[2]), c2 = [{ type: "float32", data: [u2] }, { type: "float32", data: [d2] }, { type: "float32", data: [Math.sin(a2)] }, { type: "float32", data: [Math.cos(a2)] }];
  return c2.push("number" == typeof i2 ? { type: "float32", data: [Number.parseFloat(i2.toFixed(2))] } : { type: "float32", data: i2 }), o2.runWebGPUProgram(l2, [r2], r2.dtype, c2);
} };
var lH = GW({ opType: hW.ROUND });
var uH = { kernelName: fr, backendName: "webgpu", kernelFunc: lH };
var dH = GW({ opType: hW.RSQRT, cpuKernelImpl: xL });
var cH = { kernelName: mr, backendName: "webgpu", kernelFunc: dH };
var hH = class {
  constructor(e20, t2, n2, r2, a2, i2, s2, o2 = true) {
    this.variableNames = ["updates", "indices"], this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = i2, this.type = s2, this.sumDupeIndices = o2, this.dispatchLayout = oW(e20), this.dispatch = rW(this.dispatchLayout, e20, this.workgroupSize), this.sliceDimGreaterThanOne = t2 > 1, this.shaderKey = `scatter_${n2}_${r2}_${this.sliceDimGreaterThanOne}_${s2}_${o2}_${a2.length}`;
    let l2 = UD(a2.length);
    this.uniforms = `sliceDim : i32, strides: ${l2}, updatesSize: i32,`, this.updatesRank = r2, this.indicesRank = n2;
  }
  getUserCode() {
    let e20 = "";
    1 === this.indicesRank ? e20 = "coords[0]" : 2 === this.indicesRank && (e20 = "coords[0], j");
    let t2 = `getIndices(${e20})`, n2 = this.sliceDimGreaterThanOne ? "uniforms.strides[j]" : "uniforms.strides", r2 = "", a2 = "";
    1 === this.dispatchLayout.x.length ? (r2 = "flattenedIndex", a2 = "\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      ") : 2 === this.dispatchLayout.x.length && (r2 = "vec2<i32>(flattenedIndex, coords[1])", a2 = "\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");
    let i2 = `getUpdates(${Array.from({ length: this.updatesRank }, (e21, t3) => `coords[${t3}]`).join(", ")})`;
    return `
    ${a2}
      ${GD("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t2}));
            flattenedIndex = flattenedIndex + indexInside * ${n2};
          }
          let updateValue =
              ${YD(this.type)}(${i2});
          let flatIndex = getOutputIndexFromCoords(${r2});

          ${this.sumDupeIndices ? LD("&result[flatIndex]", "updateValue", this.type) : "atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`;
  }
};
var pH = { kernelName: Ar, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { indices: a2, updates: i2 } = t2, { shape: s2 } = r2, { sliceRank: o2, numUpdates: l2, sliceSize: u2, strides: d2, outputSize: c2 } = Uf.calculateShapes(i2, a2, s2), h2 = [c2 / u2, u2];
  if (0 === c2) return n2.makeTensorInfo(s2, a2.dtype);
  let p2 = FW({ inputs: { x: a2 }, backend: n2, attrs: { shape: [l2, o2] } }), f2 = FW({ inputs: { x: i2 }, backend: n2, attrs: { shape: [l2, u2] } }), m2 = f2.dtype, A2 = MW({ backend: n2, attrs: { shape: h2, value: 0, dtype: m2 } }), x2 = [{ type: "int32", data: [o2] }, { type: "int32", data: d2 }, { type: "int32", data: [va.sizeFromShape(f2.shape)] }], y2 = new hH(f2.shape, o2, p2.shape.length, f2.shape.length, d2, h2, m2), b2 = n2.runWebGPUProgram(y2, [f2, p2], m2, x2, A2), g2 = FW({ inputs: { x: b2 }, backend: n2, attrs: { shape: s2 } });
  return n2.disposeData(p2.dataId), n2.disposeData(f2.dataId), n2.disposeData(b2.dataId), g2;
} };
var fH = class {
  constructor(e20, t2) {
    this.outputShape = [], this.variableNames = ["sortedSequence", "values"], this.uniforms = "numInputs : i32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.side = t2, this.shaderKey = "search_sorted_" + t2;
  }
  getUserCode() {
    return `
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${"left" === this.side ? "<" : "<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${GD("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `;
  }
};
var mH = { kernelName: yr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { sortedSequence: a2, values: i2 } = t2, { side: s2 } = r2, o2 = new fH([i2.shape[0], i2.shape[1]], s2);
  return n2.runWebGPUProgram(o2, [a2, i2], "int32", [{ type: "int32", data: [a2.shape[1]] }]);
} };
var AH = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["c", "a", "b"], this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = t2, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.cRank = e20, this.rank = n2, this.shaderKey = "select";
  }
  getUserCode() {
    let e20, t2;
    if (this.rank > 4) throw Error(`Where for rank ${this.rank} is not yet supported`);
    if (1 === this.rank) t2 = "resRC", e20 = "resRC";
    else {
      let n2 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], r2 = [], a2 = [];
      for (let e21 = 0; this.outputShape.length > e21; e21++) a2.push("" + n2[e21]), this.cRank > e21 && r2.push("" + n2[e21]);
      e20 = r2.join(), t2 = a2.join();
    }
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e20});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t2}));
          } else {
            setOutputAtIndex(index, getB(${t2}));
          }
        }
      }
    `;
  }
};
var xH = { kernelName: br, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { condition: r2, t: a2, e: i2 } = t2, s2 = new AH(r2.shape.length, a2.shape, a2.shape.length);
  return n2.runWebGPUProgram(s2, [r2, a2, i2], pi(a2.dtype, i2.dtype));
} };
var yH = GW({ opType: hW.SELU });
var bH = { kernelName: gr, backendName: "webgpu", kernelFunc: yH };
var gH = GW({ opType: hW.SIGMOID });
var vH = { kernelName: Cr, backendName: "webgpu", kernelFunc: gH };
var wH = GW({ opType: hW.SIGN });
var kH = { kernelName: Nr, backendName: "webgpu", kernelFunc: wH };
var NH = { kernelName: "Sin", backendName: "webgpu", kernelFunc: GW({ opType: hW.SIN }) };
var CH = GW({ opType: hW.SINH });
var $H = { kernelName: kr, backendName: "webgpu", kernelFunc: CH };
var RH = GW({ opType: hW.SOFTPLUS });
var SH = { kernelName: $r, backendName: "webgpu", kernelFunc: RH };
var IH = class {
  constructor(e20, t2, n2, r2, a2, i2) {
    this.variableNames = ["x"], this.outputShape = [], this.uniforms = "", this.workgroupSize = [64, 1, 1], this.size = true;
    let s2 = Array(r2.length);
    for (let o2 = 0; s2.length > o2; o2++) s2[o2] = r2[a2[o2]];
    this.outputShape = s2, this.newDim = a2, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.xShape = e20, this.paddedXShape = t2, this.uniforms += `reshapedPaddedXShape : ${UD(r2.length)}, paddedXShapeStrides : ${UD(i2)}, `, n2.map((e21, t3) => {
      this.uniforms += ` pad${t3} : vec2<i32>,`;
    }), this.shaderKey = "spaceToBatchND_" + a2;
  }
  getUserCode() {
    let e20 = UD(this.outputShape.length), t2 = VL(this.newDim);
    return `
      ${qD(this.paddedXShape, "PaddedX")}
      ${GD("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e20}(${t2}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${PG(this.xShape, true)}
        }
      }
    `;
  }
};
var EH = { kernelName: Ir, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { blockShape: i2, paddings: s2 } = r2;
  va.assert(4 >= a2.shape.length, () => "spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");
  let o2 = i2.reduce((e21, t3) => e21 * t3), l2 = [[0, 0]];
  l2.push(...s2);
  for (let y2 = 1 + i2.length; a2.shape.length > y2; ++y2) l2.push([0, 0]);
  let u2 = l2.map((e21, t3) => e21[0] + a2.shape[t3] + e21[1]), d2 = Uf.getReshaped(u2, i2, o2, false), c2 = Uf.getPermuted(d2.length, i2.length, false), h2 = Uf.getReshapedPermuted(u2, i2, o2, false), p2 = va.computeStrides(u2), f2 = new IH(a2.shape, u2, l2, d2, c2, p2.length), m2 = [{ type: "int32", data: d2 }, { type: "int32", data: p2 }];
  l2.map((e21) => m2.push({ type: "int32", data: [e21[0], e21[1]] }));
  let A2 = n2.runWebGPUProgram(f2, [a2], a2.dtype, m2), x2 = FW({ inputs: { x: A2 }, backend: n2, attrs: { shape: h2 } });
  return n2.disposeData(A2.dataId), x2;
} };
var TH = class {
  constructor(e20, t2, n2) {
    this.variableNames = ["input", "indices", "segmentIds"], this.outputShape = [], this.uniforms = "segmentSize : i32, sparseSize : i32,", this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = e20, this.type = n2, this.dispatchLayout = oW([t2]), this.dispatch = rW(this.dispatchLayout, [t2], this.workgroupSize), this.shaderKey = "sparseSegmentSum";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${LD("&result[outIndex]", "value", this.type)}
      }
    }
  `;
  }
};
var MH = class {
  constructor(e20, t2) {
    this.variableNames = ["segmentIds"], this.outputShape = [], this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = [e20], this.dispatchLayout = oW(t2), this.dispatch = rW(this.dispatchLayout, t2, this.workgroupSize), this.shaderKey = "sparseSegmentIdCountProgram";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${LD("&result[segmentId]", "1", "int32")}
      }
    }
  `;
  }
};
var OH = class {
  constructor(e20, t2) {
    this.variableNames = ["segmentSum", "sameSegmentIdCount"], this.outputShape = [], this.uniforms = "segmentSize : i32", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.type = t2, this.dispatchLayout = oW(e20), this.dispatch = rW(this.dispatchLayout, e20, this.workgroupSize), this.shaderKey = "sparseSegmentMean";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${"float32" === this.type ? "setOutputAtIndex(index, segmentSum[index] / f32(count));" : "setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `;
  }
};
function FH(e20, t2, n2, r2 = false, a2) {
  let i2, s2 = va.sizeFromShape(e20.shape) / e20.shape[0], o2 = e20.dtype, l2 = va.sizeFromShape(t2.shape), u2 = a2.readSync(n2.dataId), d2 = l2 > 0 ? u2[l2 - 1] + 1 : 0, c2 = e20.shape.slice();
  c2[0] = d2;
  let h2 = l2 * s2, p2 = MW({ backend: a2, attrs: { shape: c2, value: 0, dtype: o2 } });
  i2 = new TH(c2, h2, o2);
  let f2 = [{ type: "int32", data: [s2] }, { type: "int32", data: [h2] }], m2 = a2.runWebGPUProgram(i2, [e20, t2, n2], o2, f2, p2);
  if (r2) return m2;
  let A2 = MW({ backend: a2, attrs: { shape: [d2], value: 0, dtype: "int32" } });
  i2 = new MH(d2, n2.shape);
  let x2 = a2.runWebGPUProgram(i2, [n2], "int32", null, A2), y2 = MW({ backend: a2, attrs: { shape: c2, value: 0, dtype: o2 } });
  i2 = new OH(c2, o2), f2 = [{ type: "int32", data: [s2] }];
  let b2 = a2.runWebGPUProgram(i2, [m2, x2], o2, f2, y2);
  return a2.disposeData(m2.dataId), a2.disposeData(x2.dataId), b2;
}
var PH = { kernelName: Fr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { data: r2, indices: a2, segmentIds: i2 } = t2;
  return FH(r2, a2, i2, false, n2);
} };
var zH = { kernelName: Pr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { data: r2, indices: a2, segmentIds: i2 } = t2;
  return FH(r2, a2, i2, true, n2);
} };
var VH = class {
  constructor(e20, t2) {
    this.variableNames = ["A"], this.workgroupSize = [64, 1, 1], this.size = true;
    let n2 = Array(e20.length);
    for (let r2 = 0; n2.length > r2; r2++) n2[r2] = e20[r2] * t2[r2];
    this.outputShape = n2, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.rank = this.outputShape.length, this.shaderKey = "tile";
  }
  getUserCode() {
    let e20 = ((e21, t2 = "") => {
      if (e21 >= 5) throw Error(`Tile for rank ${e21} is not yet supported`);
      if (1 === e21) return `(resRC % ${t2}aShape)`;
      let n2 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], r2 = [];
      for (let a2 = 0; e21 > a2; a2++) r2.push(`(${n2[a2]} % ${t2}aShape[${a2}])`);
      return r2.join();
    })(this.rank, "uniforms.");
    return `
      ${GD("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e20}));
        }
      }
    `;
  }
};
function _H(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { reps: i2 } = r2;
  if (n2.shouldExecuteOnCPU([a2]) || "string" === a2.dtype || a2.shape.length >= 5) {
    let e21 = n2.readSync(a2.dataId), t3 = "string" === a2.dtype ? e21.map((e22) => va.decodeString(e22)) : e21, r3 = uo(a2.shape, a2.dtype, t3), s3 = NL(r3, i2);
    return n2.makeTensorInfo(s3.shape, s3.dtype, s3.values);
  }
  let s2 = new VH(a2.shape, i2);
  return n2.runWebGPUProgram(s2, [a2], a2.dtype);
}
var DH = { kernelName: Xr, backendName: "webgpu", kernelFunc: _H };
var WH = { kernelName: zr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { sparseIndices: a2, sparseValues: i2, defaultValue: s2 } = t2, { outputShape: o2 } = r2, { sliceRank: l2, numUpdates: u2, sliceSize: d2, strides: c2, outputSize: h2 } = Uf.calculateShapes(i2, a2, o2), p2 = false;
  if ("string" === i2.dtype) {
    let e21 = n2.bufferSync(a2), t3 = n2.bufferSync(i2), r3 = va.decodeString(n2.readSync(s2.dataId)[0]), f3 = yL(e21, t3, o2, h2, d2, u2, l2, c2, r3, p2);
    return n2.makeTensorInfo(o2, f3.dtype, f3.values);
  }
  let f2 = [h2 / d2, d2], m2 = FW({ inputs: { x: a2 }, backend: n2, attrs: { shape: [u2, l2] } }), A2 = i2.shape.length ? FW({ inputs: { x: i2 }, backend: n2, attrs: { shape: [u2, d2] } }) : WW({ inputs: { x: i2 }, backend: n2 }), x2 = A2.dtype, y2 = n2.makeTensorInfo([], x2, va.makeZerosTypedArray(1, x2)), b2 = FW({ inputs: { x: s2 }, backend: n2, attrs: { shape: Array(f2.length).fill(1) } }), g2 = _H({ inputs: { x: b2 }, backend: n2, attrs: { reps: f2 } }), v2 = [{ type: "int32", data: [l2] }, { type: "int32", data: c2 }, { type: "int32", data: [va.sizeFromShape([u2, d2])] }];
  switch (u2) {
    case 0:
      break;
    case 1:
      {
        let e21 = new hH([u2, d2], l2, m2.shape.length, A2.shape.length, c2, f2, x2, p2);
        n2.runWebGPUProgram(e21, [A2, m2], x2, v2, g2);
      }
      break;
    default:
      {
        let e21 = new hH([u2, d2], l2, m2.shape.length, y2.shape.length, c2, f2, x2, p2);
        n2.runWebGPUProgram(e21, [y2, m2], x2, v2, g2);
      }
      {
        let e21 = new hH([u2, d2], l2, m2.shape.length, A2.shape.length, c2, f2, x2);
        n2.runWebGPUProgram(e21, [A2, m2], x2, v2, g2);
      }
  }
  let w2 = FW({ inputs: { x: g2 }, backend: n2, attrs: { shape: o2 } });
  return n2.disposeData(m2.dataId), n2.disposeData(A2.dataId), n2.disposeData(b2.dataId), n2.disposeData(y2.dataId), n2.disposeData(g2.dataId), w2;
} };
var LH = { kernelName: Er, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { numOrSizeSplits: i2, axis: s2 } = r2, o2 = va.parseAxisParam(s2, a2.shape)[0], l2 = Uf.prepareSplitSize(a2, i2, o2), u2 = Array(a2.shape.length).fill(0), d2 = a2.shape.slice();
  return l2.map((e21) => {
    let t3 = [...d2];
    t3[o2] = e21;
    let r3 = vB({ inputs: { x: a2 }, backend: n2, attrs: { begin: u2, size: t3 } });
    return u2[o2] += e21, r3;
  });
} };
var BH = GW({ opType: hW.SQRT });
var UH = { kernelName: Rr, backendName: "webgpu", kernelFunc: BH };
var jH = { kernelName: _r, backendName: "webgpu", kernelFunc({ inputs: e20, backend: t2 }) {
  let { x: n2 } = e20, r2 = t2, a2 = new jW(n2.shape, hW.SQUARE);
  return r2.runWebGPUProgram(a2, [n2], n2.dtype);
} };
var GH = HW({ opType: cW.SQUARED_DIFFERENCE });
var HH = { kernelName: Vr, backendName: "webgpu", kernelFunc: GH };
var XH = { kernelName: na, backendName: "webgpu", kernelFunc({ inputs: e20, attrs: t2, backend: n2 }) {
  let { x: r2 } = e20, a2 = new jW(r2.shape, hW.STEP, "stepAlpha : f32,");
  return n2.runWebGPUProgram(a2, [r2], r2.dtype, [{ type: "float32", data: [t2.alpha] }]);
} };
var qH = class {
  constructor(e20) {
    this.variableNames = ["x"], this.workPerThread = 1, this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]);
    let t2 = UD(this.outputShape.length);
    this.uniforms = `begin : ${t2},  strides : ${t2}, `, this.shaderKey = "stridedSlice";
  }
  getUserCode() {
    let e20 = "";
    if (1 === this.outputShape.length) e20 = "coords * uniforms.strides + uniforms.begin";
    else {
      let t2 = 0;
      e20 = this.outputShape.map((e21, n2) => (t2++, 1 === this.outputShape.length ? `coords * uniforms.strides[${n2}] + uniforms.begin[${n2}]` : `coords[${t2 - 1}] * uniforms.strides[${n2}] + uniforms.begin[${n2}]`)).join(",");
    }
    return `
       ${GD("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${e20}));
         }
       }
     `;
  }
};
var ZH = { kernelName: Wr, backendName: "webgpu", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { x: i2 } = n2, { begin: s2, end: o2, strides: l2, beginMask: u2, endMask: d2, ellipsisMask: c2, newAxisMask: h2, shrinkAxisMask: p2 } = a2, { finalShapeSparse: f2, finalShape: m2, isIdentity: A2, sliceDim0: x2, isSimpleSlice: y2, begin: b2, end: g2, strides: v2 } = xf.sliceInfo(i2.shape, s2, o2, l2, u2, d2, c2, h2, p2);
  if (A2) t2 = FW({ inputs: { x: i2 }, backend: r2, attrs: { shape: m2 } });
  else if (x2 || y2) {
    va.assert(i2.shape.length >= 1, () => "Input must have rank at least 1, got: " + i2.shape.length);
    let e21 = xf.computeOutShape(b2, g2, v2), n3 = vB({ inputs: { x: i2 }, backend: r2, attrs: { begin: b2, size: e21 } });
    t2 = FW({ inputs: { x: n3 }, backend: r2, attrs: { shape: m2 } }), r2.disposeData(n3.dataId);
  } else if (r2.shouldExecuteOnCPU([i2])) {
    let e21 = r2.readSync(i2.dataId), n3 = uo(i2.shape, i2.dtype, e21), a3 = vL(f2, n3, v2, b2);
    t2 = r2.makeTensorInfo(m2, i2.dtype, a3.values);
  } else {
    let e21 = new qH(f2), n3 = r2.runWebGPUProgram(e21, [i2], i2.dtype, [{ type: "int32", data: b2 }, { type: "int32", data: v2 }]);
    t2 = FW({ inputs: { x: n3 }, backend: r2, attrs: { shape: m2 } }), r2.disposeData(n3.dataId);
  }
  return t2;
} };
var KH = { kernelName: Lr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { separator: a2, nGramWidths: i2, leftPad: s2, rightPad: o2, padWidth: l2, preserveShortSequences: u2 } = r2, { data: d2, dataSplits: c2 } = t2, h2 = n2.readSync(d2.dataId), p2 = n2.readSync(c2.dataId), [f2, m2] = wL(h2, p2, a2, i2, s2, o2, l2, u2);
  return [n2.makeTensorInfo([f2.length], "string", f2), n2.makeTensorInfo(c2.shape, "int32", m2)];
} };
var YH = { kernelName: "Sub", backendName: "webgpu", kernelFunc: HW({ opType: cW.SUB, cpuKernelImpl: kL, supportsComplex: true }) };
var JH = { kernelName: "Tan", backendName: "webgpu", kernelFunc: GW({ opType: hW.TAN }) };
var QH = GW({ opType: hW.TANH });
var eX = { kernelName: Hr, backendName: "webgpu", kernelFunc: QH };
var tX = { kernelName: xr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2 } = e20, { tensor: r2, indices: a2, updates: i2 } = t2, { sliceRank: s2, numUpdates: o2, sliceSize: l2, strides: u2, outputSize: d2 } = Uf.calculateShapes(i2, a2, r2.shape), c2 = [d2 / l2, l2];
  if (0 === d2) return n2.makeTensorInfo(r2.shape, a2.dtype);
  let h2 = [], p2 = FW({ inputs: { x: a2 }, backend: n2, attrs: { shape: [o2, s2] } });
  h2.push(p2);
  let f2 = FW({ inputs: { x: i2 }, backend: n2, attrs: { shape: [o2, l2] } });
  h2.push(f2);
  let m2 = FW({ inputs: { x: r2 }, backend: n2, attrs: { shape: c2 } });
  h2.push(m2);
  let A2 = _H({ inputs: { x: m2 }, backend: n2, attrs: { reps: Array(c2.length).fill(1) } }), x2 = new hH([o2, l2], s2, p2.shape.length, f2.shape.length, u2, c2, r2.dtype, false), y2 = va.sizeFromShape([o2, l2]), b2 = n2.runWebGPUProgram(x2, [f2, p2], m2.dtype, [{ type: "int32", data: [s2] }, { type: "int32", data: u2 }, { type: "int32", data: [y2] }], A2);
  h2.push(b2);
  let g2 = FW({ inputs: { x: b2 }, backend: n2, attrs: { shape: r2.shape } });
  return h2.forEach((e21) => n2.disposeData(e21.dataId)), g2;
} };
var nX = class {
  constructor(e20) {
    this.variableNames = ["x", "indices"], this.workgroupSize = [256, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = "inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,", this.shaderKey = "swap";
  }
  getUserCode() {
    return `
        ${GD("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
  }
};
var rX = class {
  constructor(e20) {
    this.variableNames = ["x", "indices"], this.workgroupSize = [256, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.uniforms = "inputSize : i32, firstPass : i32, k : i32,", this.shaderKey = "merge";
  }
  getUserCode() {
    return `
        ${GD("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
  }
};
function aX(e20, t2) {
  null !== t2 && e20.disposeData(t2.dataId);
}
function iX(e20) {
  let t2 = 1;
  for (; e20 > t2; ) t2 *= 2;
  return t2;
}
var sX = { kernelName: qr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2 } = t2, { k: i2, sorted: s2 } = r2, o2 = a2.shape, l2 = o2[o2.length - 1];
  if (n2.shouldExecuteOnCPU([a2])) {
    let e21 = n2.readSync(a2.dataId), [t3, r3] = CL(e21, o2, a2.dtype, i2, s2);
    return [n2.makeTensorInfo(t3.shape, t3.dtype, t3.values), n2.makeTensorInfo(r3.shape, r3.dtype, r3.values)];
  }
  if (0 === i2) return o2[o2.length - 1] = 0, [n2.makeTensorInfo(o2, a2.dtype, []), n2.makeTensorInfo(o2, "int32", [])];
  if (1 === l2) return [a2, MW({ attrs: { shape: o2, dtype: "int32", value: 0 }, backend: n2 })];
  let u2 = va.sizeFromShape(o2) / l2, d2 = FW({ inputs: { x: a2 }, attrs: { shape: [u2, l2] }, backend: n2 }), c2 = iX(i2), h2 = iX(l2), p2 = null, f2 = () => null === p2 ? [d2, d2] : [d2, p2], m2 = (e21, t3, r3) => {
    let a3 = f2(), i3 = new nX(r3), s3 = p2;
    p2 = n2.runWebGPUProgram(i3, a3, "int32", [{ type: "int32", data: [l2] }, { type: "int32", data: [null === p2 ? 1 : 0] }, { type: "float32", data: [-Infinity] }, { type: "int32", data: [e21] }, { type: "int32", data: [t3] }]), aX(n2, s3);
  };
  for (let g2 = 1; c2 > g2; g2 *= 2) {
    let e21 = 2 * g2;
    for (let t3 = g2; t3 >= 1; t3 /= 2) m2(e21, t3, [u2, h2]);
  }
  for (let g2 = h2; g2 > c2; g2 /= 2) {
    let e21 = f2(), t3 = new rX([u2, g2 / 2]), r3 = p2;
    p2 = n2.runWebGPUProgram(t3, e21, "int32", [{ type: "int32", data: [l2] }, { type: "int32", data: [null === p2 ? 1 : 0] }, { type: "int32", data: [c2] }]), aX(n2, r3);
    let a3 = c2 / 2, i3 = 2 * a3;
    for (let n3 = a3; n3 >= 1; n3 /= 2) m2(i3, n3, p2.shape);
  }
  let A2 = p2;
  p2 = vB({ inputs: { x: p2 }, backend: n2, attrs: { begin: 0, size: [u2, i2] } }), aX(n2, A2);
  let x2 = Cj({ inputs: { x: d2, indices: p2 }, backend: n2, attrs: { axis: 1, batchDims: 1 } });
  aX(n2, d2);
  let y2 = o2.slice(0, -1);
  y2.push(i2), A2 = p2, p2 = FW({ inputs: { x: p2 }, attrs: { shape: y2 }, backend: n2 }), aX(n2, A2);
  let b2 = x2;
  return x2 = FW({ inputs: { x: x2 }, attrs: { shape: y2 }, backend: n2 }), aX(n2, b2), [x2, p2];
} };
var oX = class {
  constructor(e20) {
    this.variableNames = ["Image", "Transforms"], this.uniforms = "interpolationModeId : i32, fillModeId : i32, fillValue : f32,", this.workgroupSize = [64, 1, 1], this.size = true, this.outputShape = e20, this.dispatchLayout = oW(this.outputShape), this.dispatch = rW(this.dispatchLayout, this.outputShape, this.workgroupSize), this.shaderKey = "transform";
  }
  getUserCode() {
    return `
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${GD("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `;
  }
};
var lX = { kernelName: Zr, backendName: "webgpu", kernelFunc(e20) {
  let t2, { inputs: n2, backend: r2, attrs: a2 } = e20, { image: i2, transforms: s2 } = n2, { interpolation: o2, fillMode: l2, fillValue: u2, outputShape: d2 } = a2, [c2, h2, p2, f2] = i2.shape, [m2, A2] = null != d2 ? d2 : [h2, p2], x2 = new oX([c2, m2, A2, f2]), y2 = "nearest" === o2 ? 1 : 2;
  switch (l2) {
    case "constant":
    default:
      t2 = 1;
      break;
    case "reflect":
      t2 = 2;
      break;
    case "wrap":
      t2 = 3;
      break;
    case "nearest":
      t2 = 4;
  }
  return r2.runWebGPUProgram(x2, [i2, s2], "float32", [{ type: "int32", data: [y2] }, { type: "int32", data: [t2] }, { type: "float32", data: [u2] }]);
} };
var uX = { kernelName: Jr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { value: a2 } = t2, { axis: i2 } = r2;
  0 > i2 && (i2 += a2.shape.length);
  let s2 = a2, o2 = s2.shape.length, l2 = a2.shape[i2], u2 = Array(o2 - 1), d2 = 0;
  for (let m2 = 0; o2 > m2; m2++) m2 !== i2 && (u2[d2++] = s2.shape[m2]);
  let c2 = [], h2 = Array(o2).fill(0), p2 = s2.shape.slice();
  p2[i2] = 1;
  let f2 = Array(l2);
  for (let m2 = 0; f2.length > m2; m2++) {
    h2[i2] = m2;
    let e21 = vB({ inputs: { x: s2 }, backend: n2, attrs: { begin: h2, size: p2 } }), t3 = FW({ inputs: { x: e21 }, backend: n2, attrs: { shape: u2 } });
    f2[m2] = t3, c2.push(e21);
  }
  return c2.forEach((e21) => n2.disposeData(e21.dataId)), f2;
} };
var dX = class {
  constructor(e20, t2, n2) {
    if (this.outputShape = [], this.variableNames = ["x", "segmentIds"], this.uniforms = "numSegments : i32, xSize: i32,", this.workgroupSize = [64, 1, 1], this.atomic = true, this.outputShape = t2, this.dispatchLayout = oW(e20), this.dispatch = rW(this.dispatchLayout, e20, this.workgroupSize), "float32" !== n2 && "int32" !== n2) throw Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${n2} type.`);
    this.type = n2, this.shaderKey = "unsortedSegmentSum";
  }
  getUserCode() {
    return `
    ${GD("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${LD("&result[flatIndex]", "value", this.type)}
        }
      }
    }
  `;
  }
};
var cX = { kernelName: Qr, backendName: "webgpu", kernelFunc(e20) {
  let { inputs: t2, backend: n2, attrs: r2 } = e20, { x: a2, segmentIds: i2 } = t2, { numSegments: s2 } = r2, o2 = a2.shape.length, l2 = [], u2 = 0, d2 = Uf.getAxesPermutation([u2], o2), c2 = a2;
  null != d2 && (c2 = _L({ inputs: { x: a2 }, backend: n2, attrs: { perm: d2 } }), l2.push(c2), u2 = Uf.getInnerMostAxes(1, o2)[0]);
  let h2 = Uf.segment_util.computeOutShape(c2.shape, u2, s2), p2 = va.sizeFromShape([c2.shape[u2]]), f2 = FW({ inputs: { x: c2 }, backend: n2, attrs: { shape: [-1, p2] } });
  l2.push(f2);
  let m2 = a2.dtype, A2 = [f2.shape[0], s2], x2 = MW({ backend: n2, attrs: { shape: A2, value: 0, dtype: m2 } }), y2 = new dX(f2.shape, A2, m2), b2 = [{ type: "int32", data: [s2] }, { type: "int32", data: [va.sizeFromShape(f2.shape)] }], g2 = n2.runWebGPUProgram(y2, [f2, i2], m2, b2, x2), v2 = FW({ inputs: { x: g2 }, backend: n2, attrs: { shape: h2 } });
  l2.push(g2);
  let w2 = v2;
  if (null != d2) {
    l2.push(v2);
    let e21 = Uf.getUndoAxesPermutation(d2);
    w2 = _L({ inputs: { x: w2 }, backend: n2, attrs: { perm: e21 } });
  }
  return l2.forEach((e21) => n2.disposeData(e21.dataId)), w2;
} };
var hX = [VW, RL, IL, TL, ML, FL, UL, jL, HL, XL, ZL, YL, QL, tB, rB, hB, pB, AB, xB, yB, kB, $B, SB, OB, PB, _B, UW, LB, XB, eU, iU, oU, uU, dU, cU, hU, fU, AU, vU, wU, kU, CU, MU, OU, IU, PU, VU, WU, LU, UU, qU, ZU, KU, JU, QU, ej, nj, aj, lj, OW, dj, Aj, hj, fj, bj, gj, vj, kj, $j, Sj, Ej, LW, Tj, jB, Oj, Pj, Vj, _j, Wj, Bj, jj, Xj, Gj, Zj, Yj, Qj, rG, iG, lB, oG, lG, pG, uG, hG, fG, dB, mG, xG, bG, gG, CG, GU, $G, RG, SG, EB, EG, OG, FG, VG, _G, DG, WG, LG, MB, UG, GG, XG, ZG, PW, YG, QG, tH, rH, iH, oH, uH, cH, pH, mH, xH, bH, vH, kH, NH, $H, wB, XH, ZH, KH, NG, SH, EH, PH, zH, WH, LH, UH, jH, HH, YH, XU, JH, eX, tX, DH, sX, lX, DL, uX, cX, MG];
for (let a0 of hX) ma(a0);
var pX = "4.22.0";
var fX = { tfjs: pX, "tfjs-core": pX, "tfjs-converter": "4.22.0", "tfjs-backend-cpu": "4.22.0", "tfjs-backend-webgl": "4.22.0", "tfjs-backend-wasm": "4.22.0", "tfjs-backend-webgpu": "4.22.0" };
var mX = void 0;
function AX(...e20) {
  const t2 = /* @__PURE__ */ new Date(), n2 = `${("" + t2.getHours()).padStart(2, "0")}:${("" + t2.getMinutes()).padStart(2, "0")}:${("" + t2.getSeconds()).padStart(2, "0")}.${("" + t2.getMilliseconds()).padStart(3, "0")}`;
  e20 && console.log(n2, "Human:", ...e20);
}
var xX = () => "undefined" != typeof performance ? performance.now() : parseInt("" + +process.hrtime.bigint() / 1e3 / 1e3);
function yX(e20, t2, n2 = "config", r2 = []) {
  for (const a2 of Object.keys(t2)) if ("object" == typeof t2[a2]) yX(e20[a2], t2[a2], a2, r2);
  else {
    const i2 = e20 && void 0 !== e20[a2];
    i2 || r2.push({ reason: "unknown property", where: `${n2}.${a2} = ${t2[a2]}` }), i2 && (!e20 || typeof e20[a2] != typeof t2[a2]) && r2.push({ reason: "property type mismatch", where: `${n2}.${a2} = ${t2[a2]}`, expected: typeof e20[a2] });
  }
  return t2.debug && "config" === n2 && r2.length > 0 && AX("invalid configuration", r2), r2;
}
function bX(...e20) {
  const t2 = (e21) => e21 && "object" == typeof e21;
  return e20.reduce((e21, n2) => (Object.keys(n2 || {}).forEach((r2) => {
    const a2 = e21[r2], i2 = n2[r2];
    e21[r2] = Array.isArray(a2) && Array.isArray(i2) ? a2.concat(...i2) : t2(a2) && t2(i2) ? bX(a2, i2) : i2;
  }), e21), {});
}
var gX = { backend: "", modelBasePath: "", cacheModels: true, validateModels: true, wasmPath: "", wasmPlatformFetch: false, debug: false, async: true, warmup: "full", cacheSensitivity: 0.7, skipAllowed: false, deallocate: false, flags: {}, softwareKernels: false, filter: { enabled: true, equalization: false, width: 0, height: 0, flip: false, return: true, autoBrightness: true, brightness: 0, contrast: 0, sharpness: 0, blur: 0, saturation: 0, hue: 0, negative: false, sepia: false, vintage: false, kodachrome: false, technicolor: false, polaroid: false, pixelate: 0 }, gesture: { enabled: true }, face: { enabled: true, detector: { modelPath: "blazeface.json", rotation: false, maxDetected: 1, skipFrames: 99, skipTime: 2500, minConfidence: 0.2, minSize: 0, iouThreshold: 0.1, scale: 1.4, mask: false, return: false }, mesh: { enabled: true, modelPath: "facemesh.json", keepInvalid: false }, attention: { enabled: false, modelPath: "facemesh-attention.json" }, iris: { enabled: true, scale: 2.3, modelPath: "iris.json" }, emotion: { enabled: true, minConfidence: 0.1, skipFrames: 99, skipTime: 1500, modelPath: "emotion.json" }, description: { enabled: true, modelPath: "faceres.json", skipFrames: 99, skipTime: 3e3, minConfidence: 0.1 }, antispoof: { enabled: false, skipFrames: 99, skipTime: 4e3, modelPath: "antispoof.json" }, liveness: { enabled: false, skipFrames: 99, skipTime: 4e3, modelPath: "liveness.json" } }, body: { enabled: true, modelPath: "movenet-lightning.json", maxDetected: -1, minConfidence: 0.3, skipFrames: 1, skipTime: 200 }, hand: { enabled: true, rotation: true, skipFrames: 99, skipTime: 1e3, minConfidence: 0.5, iouThreshold: 0.2, maxDetected: -1, landmarks: true, detector: { modelPath: "handtrack.json" }, skeleton: { modelPath: "handlandmark-lite.json" } }, object: { enabled: false, modelPath: "centernet.json", minConfidence: 0.2, iouThreshold: 0.4, maxDetected: 10, skipFrames: 99, skipTime: 2e3 }, segmentation: { enabled: false, modelPath: "rvm.json", ratio: 0.5, mode: "default" } };
var vX = (e20, t2, n2) => {
  const r2 = RegExp("\\b" + t2 + " \\w+ (\\w+)", "ig");
  e20.replace(r2, (e21, t3) => (n2[t3] = 0, e21));
};
var wX = class {
  constructor(e20, t2, n2) {
    r(this, "uniform", {}), r(this, "attribute", {}), r(this, "gl"), r(this, "id"), r(this, "compile", (e21, t3) => {
      const n3 = this.gl.createShader(t3);
      return n3 ? (this.gl.shaderSource(n3, e21), this.gl.compileShader(n3), this.gl.getShaderParameter(n3, this.gl.COMPILE_STATUS) ? n3 : (AX("filter: gl compile failed: " + (this.gl.getShaderInfoLog(n3) || "unknown")), null)) : (AX("filter: could not create shader"), null);
    }), this.gl = e20;
    const a2 = this.compile(t2, this.gl.VERTEX_SHADER), i2 = this.compile(n2, this.gl.FRAGMENT_SHADER);
    if (this.id = this.gl.createProgram(), a2 && i2) if (this.id) if (this.gl.attachShader(this.id, a2), this.gl.attachShader(this.id, i2), this.gl.linkProgram(this.id), this.gl.getProgramParameter(this.id, this.gl.LINK_STATUS)) {
      this.gl.useProgram(this.id), vX(t2, "attribute", this.attribute);
      for (const e21 in this.attribute) this.attribute[e21] = this.gl.getAttribLocation(this.id, e21);
      vX(t2, "uniform", this.uniform), vX(n2, "uniform", this.uniform);
      for (const e21 in this.uniform) this.uniform[e21] = this.gl.getUniformLocation(this.id, e21);
    } else AX("filter: gl link failed: " + (this.gl.getProgramInfoLog(this.id) || "unknown"));
    else AX("filter: could not create webgl program");
  }
};
function kX() {
  let e20 = 0, t2 = null, n2 = false, r2 = -1, a2 = [null, null], i2 = [], s2 = null, o2 = null;
  const l2 = PX(100, 100), u2 = {}, d2 = l2.getContext("webgl");
  if (!d2) return void AX("filter: cannot get webgl context");
  function c2(e21) {
    return a2[e21] = a2[e21] || ((e22, t3) => {
      const n3 = d2.createFramebuffer();
      d2.bindFramebuffer(d2.FRAMEBUFFER, n3);
      const r3 = d2.createRenderbuffer();
      d2.bindRenderbuffer(d2.RENDERBUFFER, r3);
      const a3 = d2.createTexture();
      return d2.bindTexture(d2.TEXTURE_2D, a3), d2.texImage2D(d2.TEXTURE_2D, 0, d2.RGBA, e22, t3, 0, d2.RGBA, d2.UNSIGNED_BYTE, null), d2.texParameteri(d2.TEXTURE_2D, d2.TEXTURE_MAG_FILTER, d2.LINEAR), d2.texParameteri(d2.TEXTURE_2D, d2.TEXTURE_MIN_FILTER, d2.LINEAR), d2.texParameteri(d2.TEXTURE_2D, d2.TEXTURE_WRAP_S, d2.CLAMP_TO_EDGE), d2.texParameteri(d2.TEXTURE_2D, d2.TEXTURE_WRAP_T, d2.CLAMP_TO_EDGE), d2.framebufferTexture2D(d2.FRAMEBUFFER, d2.COLOR_ATTACHMENT0, d2.TEXTURE_2D, a3, 0), d2.bindTexture(d2.TEXTURE_2D, null), d2.bindFramebuffer(d2.FRAMEBUFFER, null), { fbo: n3, texture: a3 };
    })(l2.width, l2.height), a2[e21];
  }
  function h2(a3 = 0) {
    if (!o2) return;
    let i3 = null, s3 = null, l3 = false;
    i3 = 0 === e20 ? t2 : c2(r2).texture || null, e20++, !n2 || 1 & a3 ? (r2 = (r2 + 1) % 2, s3 = c2(r2).fbo || null) : (s3 = null, l3 = e20 % 2 == 0), d2.bindTexture(d2.TEXTURE_2D, i3), d2.bindFramebuffer(d2.FRAMEBUFFER, s3), d2.uniform1f(o2.uniform.flipY, l3 ? -1 : 1), d2.drawArrays(d2.TRIANGLES, 0, 6);
  }
  function p2(e21) {
    if (u2[e21]) return o2 = u2[e21], d2.useProgram((o2 ? o2.id : null) || null), o2;
    if (o2 = new wX(d2, "\n  precision highp float;\n  attribute vec2 pos;\n  attribute vec2 uv;\n  varying vec2 vUv;\n  uniform float flipY;\n  void main(void) {\n    vUv = uv;\n    gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);\n  }\n", e21), !o2) return AX("filter: could not get webgl program"), null;
    const t3 = Float32Array.BYTES_PER_ELEMENT, n3 = 4 * t3;
    return d2.enableVertexAttribArray(o2.attribute.pos), d2.vertexAttribPointer(o2.attribute.pos, 2, d2.FLOAT, false, n3, 0 * t3), d2.enableVertexAttribArray(o2.attribute.uv), d2.vertexAttribPointer(o2.attribute.uv, 2, d2.FLOAT, false, n3, 2 * t3), u2[e21] = o2, o2;
  }
  this.gl = d2;
  const f2 = { colorMatrix(e21) {
    const t3 = new Float32Array(e21);
    t3[4] /= 255, t3[9] /= 255, t3[14] /= 255, t3[19] /= 255;
    const n3 = p2(1 === t3[18] && 0 === t3[3] && 0 === t3[8] && 0 === t3[13] && 0 === t3[15] && 0 === t3[16] && 0 === t3[17] && 0 === t3[19] ? "\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform float m[20];\n  void main(void) {\n    vec4 c = texture2D(texture, vUv);\n    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];\n    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];\n    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];\n    gl_FragColor.a = c.a;\n  }\n" : "\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform float m[20];\n  void main(void) {\n    vec4 c = texture2D(texture, vUv);\n    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];\n    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];\n    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];\n    gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];\n  }\n");
    n3 && (d2.uniform1fv(n3.uniform.m, t3), h2());
  }, brightness(e21) {
    const t3 = (e21 || 0) + 1;
    f2.colorMatrix([t3, 0, 0, 0, 0, 0, t3, 0, 0, 0, 0, 0, t3, 0, 0, 0, 0, 0, 1, 0]);
  }, saturation(e21) {
    const t3 = 2 * (e21 || 0) / 3 + 1, n3 = -0.5 * (t3 - 1);
    f2.colorMatrix([t3, n3, n3, 0, 0, n3, t3, n3, 0, 0, n3, n3, t3, 0, 0, 0, 0, 0, 1, 0]);
  }, desaturate() {
    f2.saturation(-1);
  }, contrast(e21) {
    const t3 = (e21 || 0) + 1, n3 = -128 * (t3 - 1);
    f2.colorMatrix([t3, 0, 0, 0, n3, 0, t3, 0, 0, n3, 0, 0, t3, 0, n3, 0, 0, 0, 1, 0]);
  }, negative() {
    f2.contrast(-2);
  }, hue(e21) {
    const t3 = Math.cos(e21 = (e21 || 0) / 180 * Math.PI), n3 = Math.sin(e21), r3 = 0.213, a3 = 0.715, i3 = 0.072;
    f2.colorMatrix([r3 + 0.787 * t3 + n3 * -r3, a3 + t3 * -a3 + n3 * -a3, i3 + t3 * -i3 + 0.928 * n3, 0, 0, r3 + t3 * -r3 + 0.143 * n3, a3 + t3 * (1 - a3) + 0.14 * n3, i3 + t3 * -i3 + -0.283 * n3, 0, 0, r3 + t3 * -r3 + -0.787 * n3, a3 + t3 * -a3 + n3 * a3, i3 + 0.928 * t3 + n3 * i3, 0, 0, 0, 0, 0, 1, 0]);
  }, desaturateLuminance() {
    f2.colorMatrix([0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0]);
  }, sepia() {
    f2.colorMatrix([0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0]);
  }, brownie() {
    f2.colorMatrix([0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0]);
  }, vintagePinhole() {
    f2.colorMatrix([0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0]);
  }, kodachrome() {
    f2.colorMatrix([1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0]);
  }, technicolor() {
    f2.colorMatrix([1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0]);
  }, polaroid() {
    f2.colorMatrix([1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
  }, shiftToBGR() {
    f2.colorMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]);
  }, convolution(e21) {
    const t3 = new Float32Array(e21), n3 = 1 / l2.width, r3 = 1 / l2.height, a3 = p2("\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform vec2 px;\n  uniform float m[9];\n  void main(void) {\n    vec4 c11 = texture2D(texture, vUv - px); // top left\n    vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y)); // top center\n    vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y)); // top right\n    vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) ); // mid left\n    vec4 c22 = texture2D(texture, vUv); // mid center\n    vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) ); // mid right\n    vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) ); // bottom left\n    vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) ); // bottom center\n    vec4 c33 = texture2D(texture, vUv + px ); // bottom right\n    gl_FragColor = \n    c11 * m[0] + c12 * m[1] + c22 * m[2] +\n    c21 * m[3] + c22 * m[4] + c23 * m[5] +\n    c31 * m[6] + c32 * m[7] + c33 * m[8];\n    gl_FragColor.a = c22.a;\n  }\n");
    a3 && (d2.uniform1fv(a3.uniform.m, t3), d2.uniform2f(a3.uniform.px, n3, r3), h2());
  }, detectEdges: () => {
    f2.convolution.call(this, [0, 1, 0, 1, -4, 1, 0, 1, 0]);
  }, sobelX: () => {
    f2.convolution.call(this, [-1, 0, 1, -2, 0, 2, -1, 0, 1]);
  }, sobelY: () => {
    f2.convolution.call(this, [-1, -2, -1, 0, 0, 0, 1, 2, 1]);
  }, sharpen: (e21) => {
    const t3 = e21 || 1;
    f2.convolution.call(this, [0, -1 * t3, 0, -1 * t3, 1 + 4 * t3, -1 * t3, 0, -1 * t3, 0]);
  }, emboss: (e21) => {
    const t3 = e21 || 1;
    f2.convolution.call(this, [-2 * t3, -1 * t3, 0, -1 * t3, 1, 1 * t3, 0, 1 * t3, 2 * t3]);
  }, blur(e21) {
    const t3 = e21 / 7 / l2.width, n3 = e21 / 7 / l2.height, r3 = p2("\n  precision highp float;\n  varying vec2 vUv;\n  uniform sampler2D texture;\n  uniform vec2 px;\n  void main(void) {\n    gl_FragColor = vec4(0.0);\n    gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;\n    gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;\n    gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;\n    gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;\n    gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;\n    gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;\n    gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;\n    gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;\n    gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;\n    gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;\n    gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;\n    gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;\n    gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;\n    gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;\n    gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;\n  }\n");
    r3 && (d2.uniform2f(r3.uniform.px, 0, n3), h2(1), d2.uniform2f(r3.uniform.px, t3, 0), h2());
  }, pixelate(e21) {
    const t3 = e21 / l2.width, n3 = e21 / l2.height, r3 = p2("\n  precision highp float;\n  varying vec2 vUv;\n  uniform vec2 size;\n  uniform sampler2D texture;\n  vec2 pixelate(vec2 coord, vec2 size) {\n    return floor( coord / size ) * size;\n  }\n  void main(void) {\n    gl_FragColor = vec4(0.0);\n    vec2 coord = pixelate(vUv, size);\n    gl_FragColor += texture2D(texture, coord);\n  }\n");
    r3 && (d2.uniform2f(r3.uniform.size, t3, n3), h2());
  } };
  this.add = function(e21) {
    const t3 = [].slice.call(arguments, 1);
    i2.push({ func: f2[e21], args: t3 });
  }, this.reset = () => {
    i2 = [];
  }, this.get = () => i2, this.apply = function(r3) {
    ((e21, t3) => {
      if (e21 !== l2.width || t3 !== l2.height) {
        if (l2.width = e21, l2.height = t3, !s2) {
          const e22 = new Float32Array([-1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 1, 1, 1, 1, 1, 0]);
          s2 = d2.createBuffer(), d2.bindBuffer(d2.ARRAY_BUFFER, s2), d2.bufferData(d2.ARRAY_BUFFER, e22, d2.STATIC_DRAW), d2.pixelStorei(d2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        }
        d2.viewport(0, 0, l2.width, l2.height), a2 = [null, null];
      }
    })(r3.width, r3.height), e20 = 0, t2 || (t2 = d2.createTexture()), d2.bindTexture(d2.TEXTURE_2D, t2), d2.texParameteri(d2.TEXTURE_2D, d2.TEXTURE_WRAP_S, d2.CLAMP_TO_EDGE), d2.texParameteri(d2.TEXTURE_2D, d2.TEXTURE_WRAP_T, d2.CLAMP_TO_EDGE), d2.texParameteri(d2.TEXTURE_2D, d2.TEXTURE_MIN_FILTER, d2.NEAREST), d2.texParameteri(d2.TEXTURE_2D, d2.TEXTURE_MAG_FILTER, d2.NEAREST), d2.texImage2D(d2.TEXTURE_2D, 0, d2.RGBA, d2.RGBA, d2.UNSIGNED_BYTE, r3);
    for (let e21 = 0; i2.length > e21; e21++) {
      n2 = e21 === i2.length - 1;
      const t3 = i2[e21];
      t3.func.apply(this, t3.args || []);
    }
    return l2;
  }, this.draw = function(e21) {
    return this.add("brightness", 0), this.apply(e21);
  };
}
function NX(e20) {
  return __async(this, null, function* () {
    const t2 = 4 === e20.shape.length ? Rc(e20) : e20, n2 = Nc(t2, 3, 2), r2 = [nu(n2[0]), nu(n2[1]), nu(n2[2])], a2 = [tu(n2[0]), tu(n2[1]), tu(n2[2])], i2 = yield Promise.all(a2.map((e21) => e21.data())), s2 = Math.max(i2[0][0], i2[1][0], i2[2][0]), o2 = (s2 > 1 ? 255 : 1) / s2;
    let l2;
    if (o2 > 1) {
      const e21 = [Lu(n2[0], r2[0]), Lu(n2[1], r2[1]), Lu(n2[2], r2[2])], i3 = [Lu(a2[0], r2[0]), Lu(a2[1], r2[1]), Lu(a2[2], r2[2])], s3 = [xo(e21[0], o2), xo(e21[1], o2), xo(e21[2], o2)], u2 = Sc([s3[0], s3[1], s3[2]], 2);
      l2 = Ho(u2, [1, t2.shape[0] || 0, t2.shape[1] || 0, 3]), ts([...e21, ...i3, ...s3, u2]);
    } else l2 = hu(t2, 0);
    return ts([...n2, ...r2, ...a2, n2, t2, e20]), l2;
  });
}
var CX;
var $X;
var RX;
var SX;
var IX = 3840;
var EX = null;
var TX = null;
var MX = null;
var OX = { inputSum: 0, cacheDiff: 1, sumMethod: 0, inputTensor: void 0 };
function FX() {
  OX.inputSum = 0, OX.cacheDiff = 1, OX.sumMethod = 0, OX.inputTensor = void 0;
}
function PX(e20, t2) {
  let n2;
  if (_X.browser) if (_X.worker) {
    if ("undefined" == typeof OffscreenCanvas) throw Error("canvas error: attempted to run in web worker but OffscreenCanvas is not supported");
    n2 = new OffscreenCanvas(e20, t2);
  } else if ("undefined" != typeof document) n2 = document.createElement("canvas"), n2.width = e20, n2.height = t2;
  else {
    if ("undefined" == typeof navigator || "ReactNative" !== navigator.product) throw Error("canvas error: attempted to run in browser but DOM is not defined");
    if (void 0 !== _X.Canvas) n2 = new _X.Canvas(e20, t2);
    else {
      if (void 0 === globalThis.Canvas) throw Error("canvas error: attempted to use canvas in react-native without canvas support installed");
      n2 = new globalThis.Canvas(e20, t2);
    }
  }
  else void 0 !== _X.Canvas ? n2 = new _X.Canvas(e20, t2) : void 0 !== globalThis.Canvas && (n2 = new globalThis.Canvas(e20, t2));
  return n2;
}
function zX(e20, t2) {
  const n2 = t2 || PX(e20.width, e20.height);
  return n2.getContext("2d").drawImage(e20, 0, 0), n2;
}
function VX(e20, t2, n2 = true) {
  return __async(this, null, function* () {
    var r2, a2, i2;
    if (!e20) return t2.debug && AX("input error: input is missing"), { tensor: null, canvas: null };
    if (!(e20 instanceof ni || "undefined" != typeof Image && e20 instanceof Image || void 0 !== globalThis.Canvas && e20 instanceof globalThis.Canvas || "undefined" != typeof ImageData && e20 instanceof ImageData || "undefined" != typeof ImageBitmap && e20 instanceof ImageBitmap || "undefined" != typeof HTMLImageElement && e20 instanceof HTMLImageElement || "undefined" != typeof HTMLMediaElement && e20 instanceof HTMLMediaElement || "undefined" != typeof HTMLVideoElement && e20 instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && e20 instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e20 instanceof OffscreenCanvas)) throw Error("input error: type not recognized");
    if (e20 instanceof ni) {
      let n3 = null;
      if (e20.isDisposedInternal) throw Error("input error: attempted to use tensor but it is disposed");
      if (!e20.shape) throw Error("input error: attempted to use tensor without a shape");
      if (3 === e20.shape.length) {
        if (3 === e20.shape[2]) n3 = hu(e20, 0);
        else if (4 === e20.shape[2]) {
          const t3 = yc(e20, [0, 0, 0], [-1, -1, 3]);
          n3 = hu(t3, 0), ts(t3);
        }
      } else 4 === e20.shape.length && (3 === e20.shape[3] ? n3 = ho(e20) : 4 === e20.shape[3] && (n3 = bc(e20, [0, 0, 0, 0], [-1, -1, -1, 3])));
      if (null == n3 || 4 !== n3.shape.length || 1 !== n3.shape[0] || 3 !== n3.shape[3]) throw Error("input error: attempted to use tensor with unrecognized shape: " + e20.shape);
      if ("int32" === n3.dtype) {
        const e21 = co(n3, "float32");
        ts(n3), n3 = e21;
      }
      return { tensor: n3, canvas: t2.filter.return ? TX : null };
    }
    if (void 0 !== e20.readyState && 2 >= e20.readyState) return t2.debug && AX("input stream is not ready"), { tensor: null, canvas: EX };
    const s2 = e20.naturalWidth || e20.videoWidth || e20.width || e20.shape && e20.shape[1] > 0, o2 = e20.naturalHeight || e20.videoHeight || e20.height || e20.shape && e20.shape[2] > 0;
    if (!s2 || !o2) return t2.debug && AX("cannot determine input dimensions"), { tensor: null, canvas: EX };
    let l2 = s2, u2 = o2;
    if (l2 > IX && (l2 = IX, u2 = Math.trunc(l2 * o2 / s2)), u2 > IX && (u2 = IX, l2 = Math.trunc(u2 * s2 / o2)), ((null == (r2 = t2.filter) ? void 0 : r2.width) || 0) > 0 ? l2 = t2.filter.width : ((null == (a2 = t2.filter) ? void 0 : a2.height) || 0) > 0 && (l2 = s2 * ((t2.filter.height || 0) / o2)), (t2.filter.height || 0) > 0 ? u2 = t2.filter.height : (t2.filter.width || 0) > 0 && (u2 = o2 * ((t2.filter.width || 0) / s2)), !l2 || !u2) throw Error("input error: cannot determine dimension");
    EX && EX.width === l2 && EX.height === u2 || (EX = PX(l2, u2));
    const d2 = EX.getContext("2d");
    if ("undefined" != typeof ImageData && e20 instanceof ImageData ? d2.putImageData(e20, 0, 0) : t2.filter.flip && void 0 !== d2.translate ? (d2.translate(s2, 0), d2.scale(-1, 1), d2.drawImage(e20, 0, 0, s2, o2, 0, 0, EX.width, EX.height), d2.setTransform(1, 0, 0, 1, 0, 0)) : d2.drawImage(e20, 0, 0, s2, o2, 0, 0, EX.width, EX.height), TX && EX.width === TX.width && EX.height === TX.height || (TX = PX(EX.width, EX.height)), t2.filter.enabled && _X.webgl.supported ? (CX || (CX = _X.browser ? new kX() : null), _X.filter = !!CX, (null == CX ? void 0 : CX.add) ? (CX.reset(), 0 !== t2.filter.brightness && CX.add("brightness", t2.filter.brightness), 0 !== t2.filter.contrast && CX.add("contrast", t2.filter.contrast), 0 !== t2.filter.sharpness && CX.add("sharpen", t2.filter.sharpness), 0 !== t2.filter.blur && CX.add("blur", t2.filter.blur), 0 !== t2.filter.saturation && CX.add("saturation", t2.filter.saturation), 0 !== t2.filter.hue && CX.add("hue", t2.filter.hue), t2.filter.negative && CX.add("negative"), t2.filter.sepia && CX.add("sepia"), t2.filter.vintage && CX.add("brownie"), t2.filter.sepia && CX.add("sepia"), t2.filter.kodachrome && CX.add("kodachrome"), t2.filter.technicolor && CX.add("technicolor"), t2.filter.polaroid && CX.add("polaroid"), 0 !== t2.filter.pixelate && CX.add("pixelate", t2.filter.pixelate), TX = (null == (i2 = CX.get()) ? void 0 : i2.length) > 1 ? CX.apply(EX) : CX.draw(EX)) : (t2.debug && AX("input process error: cannot initialize filters"), _X.webgl.supported = false, t2.filter.enabled = false, zX(EX, TX))) : (zX(EX, TX), CX && (CX = null), _X.filter = !!CX), !n2) return { tensor: null, canvas: TX };
    if (!TX) throw Error("canvas error: cannot create output");
    let c2, h2 = 3;
    if ("undefined" != typeof ImageData && e20 instanceof ImageData || e20.data && e20.width && e20.height) _X.browser && of ? c2 = of ? of.fromPixels(e20) : null : (h2 = e20.data.length / e20.height / e20.width, c2 = Ui(new Uint8Array(e20.data.buffer), [e20.height, e20.width, h2], "int32"));
    else if (MX && TX.width === MX.width && TX.height === MX.height || (MX = PX(TX.width, TX.height)), of && _X.browser) "webgl" === t2.backend || "humangl" === t2.backend || "webgpu" === t2.backend ? c2 = of.fromPixels(TX) : (MX = zX(TX), c2 = of.fromPixels(MX));
    else {
      const e21 = zX(TX).getContext("2d").getImageData(0, 0, l2, u2);
      h2 = e21.data.length / l2 / u2, c2 = Ui(new Uint8Array(e21.data.buffer), [l2, u2, h2]);
    }
    if (4 === h2) {
      const e21 = yc(c2, [0, 0, 0], [-1, -1, 3]);
      ts(c2), c2 = e21;
    }
    if (!c2) throw Error("input error: cannot create tensor");
    const p2 = co(c2, "float32"), f2 = t2.filter.equalization ? yield NX(p2) : hu(p2, 0);
    if (ts([c2, p2]), t2.filter.autoBrightness) {
      const e21 = tu(f2), n3 = yield e21.data();
      t2.filter.brightness = n3[0] > 1 ? 1 - n3[0] / 255 : 1 - n3[0], ts(e21);
    }
    return { tensor: f2, canvas: t2.filter.return ? TX : null };
  });
}
$X = /* @__PURE__ */ new WeakMap(), RX = /* @__PURE__ */ new WeakMap(), SX = /* @__PURE__ */ new WeakMap();
var _X = new class {
  constructor() {
    if (r(this, "browser"), r(this, "node"), r(this, "worker"), r(this, "platform", ""), r(this, "agent", ""), r(this, "backends", []), r(this, "initial"), r(this, "filter"), r(this, "tfjs"), r(this, "offscreen"), r(this, "perfadd", false), r(this, "tensorflow", { version: void 0, gpu: void 0 }), r(this, "wasm", { supported: void 0, backend: void 0, simd: void 0, multithread: void 0 }), r(this, "webgl", { supported: void 0, backend: void 0, version: void 0, renderer: void 0, shader: void 0, vendor: void 0 }), r(this, "webgpu", { supported: void 0, backend: void 0, adapter: void 0 }), r(this, "cpu", { model: void 0, flags: [] }), r(this, "kernels", []), s(this, $X), s(this, RX), s(this, SX), this.browser = "undefined" != typeof navigator && void 0 !== navigator.appVersion, this.node = "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node, this.tfjs = { version: fX["tfjs-core"] }, this.offscreen = "undefined" != typeof OffscreenCanvas, this.initial = true, this.worker = this.browser && this.offscreen ? "undefined" != typeof WorkerGlobalScope : void 0, "undefined" != typeof navigator && void 0 !== navigator.userAgent) {
      const e20 = navigator.userAgent || "", t2 = e20.match(/\(([^()]+)\)/g);
      if (null == t2 ? void 0 : t2[0]) {
        const n2 = t2[0].match(/\(([^()]+)\)/g);
        this.platform = (null == n2 ? void 0 : n2[0]) ? n2[0].replace(/\(|\)/g, "") : "", this.agent = e20.replace(t2[0], ""), this.platform[1] && (this.agent = this.agent.replace(t2[1], "")), this.agent = this.agent.replace(/  /g, " ");
      }
    } else "undefined" != typeof process && (this.platform = `${process.platform} ${process.arch}`, this.agent = "NodeJS " + process.version);
  }
  get Canvas() {
    return i(this, $X);
  }
  set Canvas(e20) {
    o(this, $X, e20), globalThis.Canvas = e20;
  }
  get Image() {
    return i(this, RX);
  }
  set Image(e20) {
    o(this, RX, e20), globalThis.Image = e20;
  }
  get ImageData() {
    return i(this, SX);
  }
  set ImageData(e20) {
    o(this, SX, e20), globalThis.ImageData = e20;
  }
  updateBackend() {
    return __async(this, null, function* () {
      this.backends = Object.keys(Yi().registryFactory);
      try {
        this.tensorflow = { version: cs().binding ? cs().binding.TF_Version : void 0, gpu: cs().binding ? cs().binding.isUsingGpuDevice() : void 0 };
      } catch (n2) {
      }
      this.wasm.supported = "undefined" != typeof WebAssembly, this.wasm.backend = this.backends.includes("wasm"), this.wasm.supported && this.wasm.backend && (this.wasm.simd = yield _e().getAsync("WASM_HAS_SIMD_SUPPORT"), this.wasm.multithread = yield _e().getAsync("WASM_HAS_MULTITHREAD_SUPPORT"));
      const e20 = PX(100, 100), t2 = e20 ? e20.getContext("webgl2") : void 0;
      this.webgl.supported = void 0 !== t2, this.webgl.backend = this.backends.includes("webgl"), this.webgl.supported && this.webgl.backend && t2 && (this.webgl.version = t2.getParameter(t2.VERSION), this.webgl.vendor = t2.getParameter(t2.VENDOR), this.webgl.renderer = t2.getParameter(t2.RENDERER), this.webgl.shader = t2.getParameter(t2.SHADING_LANGUAGE_VERSION)), this.webgpu.supported = this.browser && "undefined" != typeof navigator && void 0 !== navigator.gpu, this.webgpu.backend = this.backends.includes("webgpu");
      try {
        if (this.webgpu.supported) {
          const e21 = yield navigator.gpu.requestAdapter();
          e21 && (this.webgpu.adapter = "requestAdapterInfo" in e21 ? yield e21.requestAdapterInfo() : yield e21.info);
        }
      } catch (n2) {
        this.webgpu.supported = false;
      }
      try {
        this.kernels = fa(ss()).map((e21) => e21.kernelName.toLowerCase());
      } catch (n2) {
      }
    });
  }
  updateCPU() {
    const e20 = { model: "", flags: [] };
    this.node && this.platform.startsWith("linux"), this.cpu ? this.cpu = e20 : Object.defineProperty(this, "cpu", { value: e20 });
  }
}();
var DX = class {
  constructor() {
    r(this, "config"), r(this, "element"), r(this, "stream"), r(this, "devices", []), r(this, "enumerate", () => __async(this, null, function* () {
      try {
        const e20 = yield navigator.mediaDevices.enumerateDevices();
        this.devices = e20.filter((e21) => "videoinput" === e21.kind);
      } catch (e20) {
        this.devices = [];
      }
      return this.devices;
    })), r(this, "start", (e20) => __async(this, null, function* () {
      var t2, n2;
      if ((null == e20 ? void 0 : e20.debug) && (this.config.debug = null == e20 ? void 0 : e20.debug), (null == e20 ? void 0 : e20.crop) && (this.config.crop = null == e20 ? void 0 : e20.crop), (null == e20 ? void 0 : e20.mode) && (this.config.mode = null == e20 ? void 0 : e20.mode), (null == e20 ? void 0 : e20.width) && (this.config.width = null == e20 ? void 0 : e20.width), (null == e20 ? void 0 : e20.height) && (this.config.height = null == e20 ? void 0 : e20.height), (null == e20 ? void 0 : e20.id) && (this.config.id = null == e20 ? void 0 : e20.id), null == e20 ? void 0 : e20.element) if ("string" == typeof e20.element) {
        const t3 = document.getElementById(e20.element);
        if (!(t3 && t3 instanceof HTMLVideoElement)) return this.config.debug && AX("webcam", "cannot get dom element", e20.element), "webcam error: cannot get dom element: " + e20.element;
        this.element = t3;
      } else {
        if (!(e20.element instanceof HTMLVideoElement)) return this.config.debug && AX("webcam", "unknown dom element", e20.element), "webcam error: unknown dom element: " + e20.element;
        this.element = e20.element;
      }
      else this.element = document.createElement("video");
      const r2 = { audio: false, video: { facingMode: "front" === this.config.mode ? "user" : "environment", resizeMode: this.config.crop ? "crop-and-scale" : "none" } };
      if ((null == (t2 = this.config) ? void 0 : t2.width) > 0 && (r2.video.width = { ideal: this.config.width }), (null == (n2 = this.config) ? void 0 : n2.height) > 0 && (r2.video.height = { ideal: this.config.height }), this.config.id && (r2.video.deviceId = this.config.id), this.element.addEventListener("play", () => {
        this.config.debug && AX("webcam", "play");
      }), this.element.addEventListener("pause", () => {
        this.config.debug && AX("webcam", "pause");
      }), this.element.addEventListener("click", () => __async(this, null, function* () {
        this.element && this.stream && (this.element.paused ? yield this.element.play() : this.element.pause());
      })), !(null == navigator ? void 0 : navigator.mediaDevices)) return this.config.debug && AX("webcam error", "no devices"), "webcam error: no devices";
      try {
        this.stream = yield navigator.mediaDevices.getUserMedia(r2);
      } catch (i2) {
        return AX("webcam", i2), "webcam error: " + i2;
      }
      if (!this.stream) return this.config.debug && AX("webcam error", "no stream"), "webcam error no stream";
      this.element.srcObject = this.stream;
      const a2 = new Promise((e21) => {
        this.element ? this.element.onloadeddata = () => e21(true) : e21(false);
      });
      return yield a2, yield this.element.play(), this.config.debug && AX("webcam", { width: this.width, height: this.height, label: this.label, stream: this.stream, track: this.track, settings: this.settings, constraints: this.constraints, capabilities: this.capabilities }), "webcam: " + this.label;
    })), r(this, "pause", () => {
      this.element && this.element.pause();
    }), r(this, "play", () => __async(this, null, function* () {
      this.element && (yield this.element.play());
    })), r(this, "stop", () => {
      this.config.debug && AX("webcam", "stop"), this.track && this.track.stop();
    }), this.config = { element: void 0, debug: true, mode: "front", crop: false, width: 0, height: 0 };
  }
  get track() {
    if (this.stream) return this.stream.getVideoTracks()[0];
  }
  get capabilities() {
    if (this.track) return this.track.getCapabilities ? this.track.getCapabilities() : void 0;
  }
  get constraints() {
    if (this.track) return this.track.getConstraints ? this.track.getConstraints() : void 0;
  }
  get settings() {
    if (!this.stream) return;
    const e20 = this.stream.getVideoTracks()[0];
    return e20.getSettings ? e20.getSettings() : void 0;
  }
  get label() {
    return this.track ? this.track.label : "";
  }
  get paused() {
    var e20;
    return (null == (e20 = this.element) ? void 0 : e20.paused) || false;
  }
  get width() {
    var e20;
    return (null == (e20 = this.element) ? void 0 : e20.videoWidth) || 0;
  }
  get height() {
    var e20;
    return (null == (e20 = this.element) ? void 0 : e20.videoHeight) || 0;
  }
};
var WX = {};
n(WX, { "affectnet-mobilenet"() {
  return QX;
}, age() {
  return eq;
}, "anti-spoofing"() {
  return Mq;
}, antispoof() {
  return LX;
}, blazeface() {
  return BX;
}, "blazeface-back"() {
  return tq;
}, "blazeface-front"() {
  return nq;
}, "blazepose-detector"() {
  return rq;
}, "blazepose-full"() {
  return aq;
}, "blazepose-heavy"() {
  return iq;
}, "blazepose-lite"() {
  return sq;
}, centernet() {
  return UX;
}, default() {
  return Gq;
}, efficientpose() {
  return oq;
}, "efficientpose-i-lite"() {
  return Oq;
}, "efficientpose-ii-lite"() {
  return Fq;
}, "efficientpose-iv"() {
  return Pq;
}, emotion() {
  return jX;
}, faceboxes() {
  return lq;
}, facemesh() {
  return GX;
}, "facemesh-attention"() {
  return dq;
}, "facemesh-attention-pinto"() {
  return uq;
}, "facemesh-detection-full"() {
  return cq;
}, "facemesh-detection-short"() {
  return hq;
}, faceres() {
  return HX;
}, "faceres-deep"() {
  return pq;
}, gear() {
  return Aq;
}, "gear-e1"() {
  return fq;
}, "gear-e2"() {
  return mq;
}, gender() {
  return yq;
}, "gender-ssrnet-imdb"() {
  return xq;
}, handdetect() {
  return bq;
}, "handlandmark-full"() {
  return gq;
}, "handlandmark-lite"() {
  return XX;
}, "handlandmark-sparse"() {
  return vq;
}, handskeleton() {
  return wq;
}, handtrack() {
  return qX;
}, "insightface-efficientnet-b0"() {
  return zq;
}, "insightface-ghostnet-strides1"() {
  return Vq;
}, "insightface-ghostnet-strides2"() {
  return _q;
}, "insightface-mobilenet-emore"() {
  return Dq;
}, "insightface-mobilenet-swish"() {
  return Wq;
}, iris() {
  return ZX;
}, liveness() {
  return KX;
}, meet() {
  return kq;
}, mobileface() {
  return Nq;
}, mobilefacenet() {
  return Cq;
}, models() {
  return YX;
}, "movenet-lightning"() {
  return JX;
}, "movenet-multipose"() {
  return $q;
}, "movenet-thunder"() {
  return Rq;
}, nanodet() {
  return Sq;
}, "nanodet-e"() {
  return Lq;
}, "nanodet-g"() {
  return Bq;
}, "nanodet-m"() {
  return Uq;
}, "nanodet-t"() {
  return jq;
}, posenet() {
  return Iq;
}, rvm() {
  return Eq;
}, selfie() {
  return Tq;
} });
var LX = 853098;
var BX = 538928;
var UX = 4030290;
var jX = 820516;
var GX = 1477958;
var HX = 6978814;
var XX = 2023432;
var qX = 2964837;
var ZX = 2599092;
var KX = 592976;
var YX = 0;
var JX = 4650216;
var QX = 6920630;
var eq = 161240;
var tq = 538928;
var nq = 402048;
var rq = 5928856;
var aq = 6339202;
var iq = 27502466;
var sq = 2726402;
var oq = 5651240;
var lq = 2013002;
var uq = 2387598;
var dq = 2382414;
var cq = 1026192;
var hq = 201268;
var pq = 13957620;
var fq = 112438;
var mq = 112438;
var Aq = 1498916;
var xq = 161236;
var yq = 201808;
var bq = 3515612;
var gq = 5431368;
var vq = 5286322;
var wq = 5502280;
var kq = 372228;
var Nq = 2183192;
var Cq = 5171976;
var $q = 9448838;
var Rq = 12477112;
var Sq = 7574558;
var Iq = 5032780;
var Eq = 3739355;
var Tq = 212886;
var Mq = 853098;
var Oq = 2269064;
var Fq = 5651240;
var Pq = 25643252;
var zq = 13013224;
var Vq = 8093408;
var _q = 8049584;
var Dq = 6938536;
var Wq = 12168584;
var Lq = 12319156;
var Bq = 7574558;
var Uq = 1887474;
var jq = 5294216;
var Gq = { antispoof: LX, blazeface: BX, centernet: UX, emotion: jX, facemesh: GX, faceres: HX, "handlandmark-lite": XX, handtrack: qX, iris: ZX, liveness: KX, models: YX, "movenet-lightning": JX, "affectnet-mobilenet": QX, age: eq, "blazeface-back": tq, "blazeface-front": nq, "blazepose-detector": rq, "blazepose-full": aq, "blazepose-heavy": iq, "blazepose-lite": sq, efficientpose: oq, faceboxes: lq, "facemesh-attention-pinto": uq, "facemesh-attention": dq, "facemesh-detection-full": cq, "facemesh-detection-short": hq, "faceres-deep": pq, "gear-e1": fq, "gear-e2": mq, gear: Aq, "gender-ssrnet-imdb": xq, gender: yq, handdetect: bq, "handlandmark-full": gq, "handlandmark-sparse": vq, handskeleton: wq, meet: kq, mobileface: Nq, mobilefacenet: Cq, "movenet-multipose": $q, "movenet-thunder": Rq, nanodet: Sq, posenet: Iq, rvm: Eq, selfie: Tq, "anti-spoofing": Mq, "efficientpose-i-lite": Oq, "efficientpose-ii-lite": Fq, "efficientpose-iv": Pq, "insightface-efficientnet-b0": zq, "insightface-ghostnet-strides1": Vq, "insightface-ghostnet-strides2": _q, "insightface-mobilenet-emore": Dq, "insightface-mobilenet-swish": Wq, "nanodet-e": Lq, "nanodet-g": Bq, "nanodet-m": Uq, "nanodet-t": jq };
var Hq = { cacheModels: true, cacheSupported: true, verbose: true, modelBasePath: "" };
var Xq = {};
function qq(e20) {
  return __async(this, null, function* () {
    var t2, n2, r2, a2, i2, s2;
    let o2 = ((e21, t3) => {
      const n3 = e21.endsWith("/") ? "" : "/", r3 = t3.startsWith(".") || t3.startsWith("/") || t3.startsWith("http:") || t3.startsWith("https:") || t3.startsWith("file:") ? "" + t3 : `${e21}${n3}${t3}`;
      if (!r3.toLocaleLowerCase().includes(".json")) throw Error("modelpath error: expecting json file: " + r3);
      return r3;
    })(Hq.modelBasePath, e20 || "");
    o2.toLowerCase().endsWith(".json") || (o2 += ".json");
    const l2 = o2.includes("/") ? o2.split("/") : o2.split("\\"), u2 = l2[l2.length - 1].replace(".json", ""), d2 = "indexeddb://" + u2;
    Xq[u2] = { name: u2, loaded: false, sizeFromManifest: 0, sizeLoadedWeights: 0, sizeDesired: WX[u2], inCache: false, url: "" }, Hq.cacheSupported = "undefined" != typeof indexedDB;
    let c2 = {};
    try {
      c2 = Hq.cacheSupported && Hq.cacheModels ? yield zp.listModels() : {};
    } catch (f2) {
      Hq.cacheSupported = false;
    }
    Xq[u2].inCache = Hq.cacheSupported && Hq.cacheModels && Object.keys(c2).includes(d2), Xq[u2].url = Xq[u2].inCache ? d2 : o2;
    const h2 = "undefined" == typeof fetch ? {} : { fetchFunc(e21, t3) {
      return ((e22, t4) => __async(null, null, function* () {
        return fetch(e22, t4);
      }))(e21, t3);
    } };
    let p2 = new Fx(Xq[u2].url, h2);
    Xq[u2].loaded = false;
    try {
      p2.findIOHandler();
    } catch (m2) {
      AX("error finding model i/o handler:", o2, m2);
    }
    try {
      const e21 = (yield null == (t2 = p2.handler) ? void 0 : t2.load()) || null;
      Xq[u2].sizeFromManifest = (null == (n2 = null == e21 ? void 0 : e21.weightData) ? void 0 : n2.byteLength) || 0, e21 ? p2.loadSync(e21) : p2 = yield Px(Xq[u2].inCache ? d2 : o2, h2), Xq[u2].sizeLoadedWeights = (null == (a2 = null == (r2 = p2.artifacts) ? void 0 : r2.weightData) ? void 0 : a2.byteLength) || (null == (s2 = null == (i2 = p2.artifacts) ? void 0 : i2.weightData) ? void 0 : s2[0].byteLength) || 0, Hq.verbose && AX("load:", { model: u2, url: p2.modelUrl, bytes: Xq[u2].sizeLoadedWeights }), Xq[u2].loaded = true;
    } catch (m2) {
      AX("error loading model:", o2, m2);
    }
    if (Xq[u2].loaded && Hq.cacheModels && Hq.cacheSupported && !Xq[u2].inCache) try {
      yield p2.save(d2);
    } catch (m2) {
      AX("error saving model:", o2, m2);
    }
    return p2;
  });
}
var Zq = "3.3.6";
var Kq = { name: "humangl", priority: 999, canvas: null, gl: null, extensions: [], webGLattr: { alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: false, desynchronized: true } };
var Yq = { tf255: 255, tf1: 1, tf2: 2, tf05: 0.5, tf127: 127.5, rgb: [0.2989, 0.587, 0.114] };
var Jq = {};
function Qq(e20, t2 = false) {
  return __async(this, null, function* () {
    var n2, r2;
    if (e20.state = "backend", 0 === (null == (n2 = e20.config.backend) ? void 0 : n2.length) && (e20.config.backend = yield (() => __async(null, null, function* () {
      var e21;
      return yield _X.updateBackend(), (null == (e21 = _X.tensorflow) ? void 0 : e21.version) ? "tensorflow" : _X.webgpu.supported && _X.webgpu.backend ? "webgpu" : _X.webgl.supported && _X.webgl.backend ? "webgl" : _X.wasm.supported && _X.wasm.backend ? "wasm" : "cpu";
    }))()), t2 || _X.initial || e20.config.backend && e20.config.backend.length > 0 && ss() !== e20.config.backend) {
      const t3 = xX();
      if (e20.config.backend && e20.config.backend.length > 0) {
        "undefined" == typeof window && "undefined" != typeof WorkerGlobalScope && e20.config.debug && e20.config.debug && AX("running inside web worker"), "undefined" != typeof navigator && (null == (r2 = null == navigator ? void 0 : navigator.userAgent) ? void 0 : r2.toLowerCase().includes("electron")) && e20.config.debug && AX("running inside electron");
        let t4 = Object.keys(Yi().registryFactory);
        if ("humangl" !== e20.config.backend || t4.includes("humangl") || (((e21) => {
          var t5;
          if ("humangl" === e21.config.backend && (Kq.name in Yi().registry && !(null == (t5 = null == Kq ? void 0 : Kq.gl) ? void 0 : t5.getParameter(Kq.gl.VERSION)) && (AX("humangl error: backend invalid context"), e21.models.reset()), !ls(Kq.name))) {
            try {
              Kq.canvas = PX(100, 100);
            } catch (n3) {
              return void AX("humangl error: cannot create canvas:", n3);
            }
            try {
              if (Kq.gl = Kq.canvas.getContext("webgl2", Kq.webGLattr), !Kq.gl) return void AX("humangl error: cannot get webgl context");
              if (!Kq.gl.getParameter(Kq.gl.VERSION).includes("2.0")) return AX("backend override: using fallback webgl backend as webgl 2.0 is not detected"), void (e21.config.backend = "webgl");
              Kq.canvas && (Kq.canvas.addEventListener("webglcontextlost", (t7) => {
                throw AX("humangl error:", t7.type), AX("possible browser memory leak using webgl or conflict with multiple backend registrations"), e21.emit("error"), Error("backend error: webgl context lost");
              }), Kq.canvas.addEventListener("webglcontextrestored", (e22) => {
                AX("humangl error: context restored:", e22);
              }), Kq.canvas.addEventListener("webglcontextcreationerror", (e22) => {
                AX("humangl error: context create:", e22);
              }));
            } catch (n3) {
              return void AX("humangl error: cannot get webgl context:", n3);
            }
            try {
              kN(2, Kq.gl);
            } catch (n3) {
              return void AX("humangl error: cannot set webgl context:", n3);
            }
            try {
              const e22 = new $$(Kq.gl);
              ds(Kq.name, () => new LR(e22), Kq.priority);
            } catch (n3) {
              return void AX("humangl error: cannot register webgl backend:", n3);
            }
            try {
              fa("webgl").forEach((e22) => {
                ma(__spreadProps(__spreadValues({}, e22), { backendName: Kq.name }));
              });
            } catch (n3) {
              return void AX("humangl error: cannot update webgl backend registration:", n3);
            }
            try {
              _e().flagRegistry.WEBGL_VERSION && _e().set("WEBGL_VERSION", 2);
            } catch (n3) {
              return void AX("humangl error: cannot set WebGL backend flags:", n3);
            }
            (() => {
              const e22 = Kq.gl;
              e22 && (Kq.extensions = e22.getSupportedExtensions());
            })();
            const t6 = cs(), r3 = void 0 !== t6.gpgpu ? t6.getGPGPUContext().gl : null;
            r3 ? e21.config.debug && AX("humangl backend registered:", { webgl: r3.getParameter(r3.VERSION), renderer: r3.getParameter(r3.RENDERER) }) : AX("humangl error: no current gl context:", r3, Kq.gl);
          }
        })(e20), t4 = Object.keys(Yi().registryFactory)), e20.config.debug && AX("available backends:", t4), _X.browser && !_X.node && "tensorflow" === e20.config.backend && t4.includes("webgl") && (e20.config.debug && AX("override: backend set to tensorflow while running in browser"), e20.config.backend = "webgl"), !_X.node || _X.browser || "webgl" !== e20.config.backend && "humangl" !== e20.config.backend || !t4.includes("tensorflow") || (e20.config.debug && AX(`override: backend set to ${e20.config.backend} while running in nodejs`), e20.config.backend = "tensorflow"), _X.browser && "webgpu" === e20.config.backend) if ("undefined" == typeof navigator || void 0 === navigator.gpu) AX("override: backend set to webgpu but browser does not support webgpu"), e20.config.backend = "webgl";
        else {
          const t5 = yield navigator.gpu.requestAdapter();
          if (e20.config.debug && AX("enumerated webgpu adapter:", t5), t5) {
            let e21;
            e21 = "requestAdapterInfo" in t5 ? yield null == t5 ? void 0 : t5.requestAdapterInfo() : t5.info, AX("webgpu adapter info:", e21);
          } else AX("override: backend set to webgpu but browser reports no available gpu"), e20.config.backend = "webgl";
        }
        if (t4.includes(e20.config.backend) || (AX(`error: backend ${e20.config.backend} not found in registry`), e20.config.backend = _X.node ? "tensorflow" : "webgl", e20.config.debug && AX("override: setting backend " + e20.config.backend)), e20.config.debug && AX("setting backend:", [e20.config.backend]), "wasm" === e20.config.backend) {
          if (_e().flagRegistry.CANVAS2D_WILL_READ_FREQUENTLY && _e().set("CANVAS2D_WILL_READ_FREQUENTLY", true), e20.config.debug && AX("wasm path:", e20.config.wasmPath), void 0 === $D) throw Error("backend error: attempting to use wasm backend but wasm path is not set");
          $D(e20.config.wasmPath, e20.config.wasmPlatformFetch);
          let t5 = false, n3 = false;
          try {
            t5 = yield _e().getAsync("WASM_HAS_MULTITHREAD_SUPPORT"), n3 = yield _e().getAsync("WASM_HAS_SIMD_SUPPORT"), e20.config.debug && AX(`wasm execution: ${n3 ? "simd" : "no simd"} ${t5 ? "multithreaded" : "singlethreaded"}`), e20.config.debug && !n3 && AX("warning: wasm simd support is not enabled");
          } catch (a2) {
            AX("wasm detection failed");
          }
        }
        try {
          yield as(e20.config.backend), yield is();
        } catch (i2) {
          return AX("error: cannot set backend:", e20.config.backend, i2), false;
        }
        e20.config.debug && (Jq = JSON.parse(JSON.stringify(_e().flags)));
      }
      if ("humangl" !== ss() && "webgl" !== ss() || (_e().flagRegistry.WEBGL_USE_SHAPES_UNIFORMS && _e().set("WEBGL_USE_SHAPES_UNIFORMS", true), _e().flagRegistry.WEBGL_EXP_CONV && _e().set("WEBGL_EXP_CONV", true), e20.config.debug && void 0 !== e20.config.deallocate && e20.config.deallocate && (AX("changing webgl: WEBGL_DELETE_TEXTURE_THRESHOLD:", true), _e().set("WEBGL_DELETE_TEXTURE_THRESHOLD", 0))), e20.config.debug) {
        const t4 = _e().flags, n3 = {};
        for (const e21 of Object.keys(t4)) Jq[e21] !== t4[e21] && (n3[e21] = t4[e21]);
        e20.config.debug && Object.keys(n3).length > 0 && AX("backend:", ss(), "flags:", n3);
      }
      if (e20.config.flags && Object.keys(e20.config.flags).length > 0) {
        e20.config.debug && AX("flags:", e20.config.flags);
        for (const [t4, n3] of Object.entries(e20.config.flags)) _e().set(t4, n3);
      }
      Hi(), Yq.tf255 = au(255, "float32"), Yq.tf1 = au(1, "float32"), Yq.tf2 = au(2, "float32"), Yq.tf05 = au(0.5, "float32"), Yq.tf127 = au(127.5, "float32"), Yq.rgb = Mc([0.2989, 0.587, 0.114], "float32"), e20.performance.initBackend = Math.trunc(xX() - t3), e20.config.backend = ss(), yield _X.updateBackend(), ((e21) => {
        const t4 = [];
        _X.kernels.includes("mod") || (ma({ kernelName: "Mod", backendName: ss(), kernelFunc: (e22) => es(() => Lu(e22.inputs.a, xo(Ao(e22.inputs.a, e22.inputs.b), e22.inputs.b))) }), _X.kernels.push("mod"), t4.push("mod")), _X.kernels.includes("floormod") || (ma({ kernelName: "FloorMod", backendName: ss(), kernelFunc: (e22) => es(() => fo(xo(mo(e22.inputs.a, e22.inputs.b), e22.inputs.b), od(e22.inputs.a, e22.inputs.b))) }), _X.kernels.push("floormod"), t4.push("floormod")), !_X.kernels.includes("rotatewithoffset") && e21.softwareKernels && (ma({ kernelName: "RotateWithOffset", backendName: ss(), kernelFunc: (e22) => es(() => {
          const t5 = ss();
          as("cpu");
          const n3 = mp.rotateWithOffset(e22.inputs.image, e22.attrs.radians, e22.attrs.fillValue, e22.attrs.center);
          return as(t5), n3;
        }) }), _X.kernels.push("rotatewithoffset"), t4.push("rotatewithoffset")), t4.length > 0 && e21.debug && AX("registered kernels:", t4);
      })(e20.config);
    }
    return true;
  });
}
function eZ(e20, t2) {
  for (const n2 of e20) ma({ kernelName: n2, backendName: t2.backend, kernelFunc(e21) {
    var r2;
    return t2.debug && AX("kernelFunc", n2, t2.backend, e21), null == (r2 = null == e21 ? void 0 : e21.inputs) ? void 0 : r2.info;
  } });
  _X.kernels = fa(ss()).map((e21) => e21.kernelName.toLowerCase());
}
var tZ = {};
n(tZ, { all() {
  return BZ;
}, body() {
  return OZ;
}, canvas() {
  return WZ;
}, face() {
  return MZ;
}, gesture() {
  return zZ;
}, hand() {
  return FZ;
}, init() {
  return UZ;
}, object() {
  return PZ;
}, options() {
  return hZ;
}, person() {
  return DZ;
}, tensor() {
  return LZ;
} });
var nZ = (e20) => {
  if (e20) if (e20.getContext) {
    const t2 = e20.getContext("2d", { willReadFrequently: true });
    if (t2) return t2;
    AX("draw error: cannot get canvas context");
  } else AX("draw error: canvas context not defined");
  else AX("draw error: invalid canvas");
  return null;
};
var rZ = (e20) => Math.round(180 * e20 / Math.PI);
var aZ = (e20, t2, n2) => e20.replace(t2, "number" == typeof n2 ? n2.toFixed(1) : n2);
var iZ = (e20, t2) => {
  if (!t2.useDepth || void 0 === e20) return t2.color;
  const n2 = Uint8ClampedArray.from([127 + 2 * e20, 127 - 2 * e20, 255]);
  return `rgba(${n2[0]}, ${n2[1]}, ${n2[2]}, ${t2.alpha})`;
};
function sZ(e20, t2, n2, r2, a2) {
  const i2 = t2.replace(/\[.*\]/g, "").split("\n").map((e21) => e21.trim()), s2 = Math.max(0, n2);
  for (let o2 = i2.length - 1; o2 >= 0; o2--) {
    const t3 = o2 * a2.lineHeight + r2;
    a2.shadowColor && "" !== a2.shadowColor && (e20.fillStyle = a2.shadowColor, e20.fillText(i2[o2], s2 + 5, t3 + 16)), e20.fillStyle = a2.labelColor, e20.fillText(i2[o2], s2 + 4, t3 + 15);
  }
}
function oZ(e20, t2, n2, r2, a2) {
  e20.fillStyle = iZ(r2, a2), e20.beginPath(), e20.arc(t2, n2, a2.pointSize, 0, 2 * Math.PI), e20.fill();
}
function lZ(e20, t2, n2, r2, a2, i2) {
  e20.beginPath(), e20.lineWidth = i2.lineWidth, i2.useCurves ? e20.ellipse((t2 + t2 + r2) / 2, (n2 + n2 + a2) / 2, r2 / 2, a2 / 2, 0, 0, 2 * Math.PI) : (e20.moveTo(t2 + i2.roundRect, n2), e20.lineTo(t2 + r2 - i2.roundRect, n2), e20.quadraticCurveTo(t2 + r2, n2, t2 + r2, n2 + i2.roundRect), e20.lineTo(t2 + r2, n2 + a2 - i2.roundRect), e20.quadraticCurveTo(t2 + r2, n2 + a2, t2 + r2 - i2.roundRect, n2 + a2), e20.lineTo(t2 + i2.roundRect, n2 + a2), e20.quadraticCurveTo(t2, n2 + a2, t2, n2 + a2 - i2.roundRect), e20.lineTo(t2, n2 + i2.roundRect), e20.quadraticCurveTo(t2, n2, t2 + i2.roundRect, n2), e20.closePath()), e20.stroke();
}
function uZ(e20, t2, n2) {
  if (t2.length >= 2) {
    e20.beginPath(), e20.moveTo(t2[0][0], t2[0][1]);
    for (const r2 of t2) e20.strokeStyle = iZ(r2[2] || 0, n2), e20.lineTo(Math.trunc(r2[0]), Math.trunc(r2[1]));
    e20.stroke(), n2.fillPolygons && (e20.closePath(), e20.fill());
  }
}
function dZ(e20, t2, n2) {
  if (t2.length >= 2) if (e20.lineWidth = n2.lineWidth, n2.useCurves && t2.length > 2) {
    e20.moveTo(t2[0][0], t2[0][1]);
    for (let n3 = 0; t2.length - 2 > n3; n3++) e20.quadraticCurveTo(t2[n3][0], t2[n3][1], (t2[n3][0] + t2[n3 + 1][0]) / 2, (t2[n3][1] + t2[n3 + 1][1]) / 2);
    e20.quadraticCurveTo(t2[t2.length - 2][0], t2[t2.length - 2][1], t2[t2.length - 1][0], t2[t2.length - 1][1]), e20.stroke(), n2.fillPolygons && (e20.closePath(), e20.fill());
  } else uZ(e20, t2, n2);
}
function cZ(e20, t2, n2, r2 = 5) {
  let a2, i2, s2;
  e20.beginPath(), e20.moveTo(t2[0], t2[1]), e20.lineTo(n2[0], n2[1]), a2 = Math.atan2(n2[1] - t2[1], n2[0] - t2[0]), i2 = r2 * Math.cos(a2) + n2[0], s2 = r2 * Math.sin(a2) + n2[1], e20.moveTo(i2, s2), a2 += 1 / 3 * 2 * Math.PI, i2 = r2 * Math.cos(a2) + n2[0], s2 = r2 * Math.sin(a2) + n2[1], e20.lineTo(i2, s2), a2 += 1 / 3 * 2 * Math.PI, i2 = r2 * Math.cos(a2) + n2[0], s2 = r2 * Math.sin(a2) + n2[1], e20.lineTo(i2, s2), e20.closePath(), e20.stroke(), e20.fill();
}
var hZ = { color: "rgba(173, 216, 230, 0.6)", labelColor: "rgba(173, 216, 230, 1)", shadowColor: "black", alpha: 0.5, font: 'small-caps 16px "Segoe UI"', lineHeight: 18, lineWidth: 4, pointSize: 2, roundRect: 8, drawPoints: false, drawLabels: true, drawBoxes: true, drawAttention: true, drawGestures: true, drawPolygons: true, drawGaze: true, fillPolygons: false, useDepth: true, useCurves: false, faceLabels: "", bodyLabels: "", bodyPartLabels: "", objectLabels: "", handLabels: "", fingerLabels: "", gestureLabels: "" };
var pZ = { silhouette: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109], lipsUpperOuter: [185, 40, 39, 37, 0, 267, 269, 270, 409], lipsLowerOuter: [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291], lipsUpperInner: [191, 80, 81, 82, 13, 312, 311, 310, 415], lipsLowerInner: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308], lipsLowerSemiOuter: [76, 77, 90, 180, 85, 16, 315, 404, 320, 307, 306], lipsUpperSemiOuter: [184, 74, 73, 72, 11, 302, 303, 304, 408], lipsLowerSemiInner: [62, 96, 89, 179, 86, 15, 316, 403, 319, 325, 292], lipsUpperSemiInner: [183, 42, 41, 38, 12, 268, 271, 272, 407], rightEyeUpper0: [246, 161, 160, 159, 158, 157, 173], rightEyeLower0: [33, 7, 163, 144, 145, 153, 154, 155, 133], rightEyeUpper1: [247, 30, 29, 27, 28, 56, 190], rightEyeLower1: [130, 25, 110, 24, 23, 22, 26, 112, 243], rightEyeUpper2: [113, 225, 224, 223, 222, 221, 189], rightEyeLower2: [226, 31, 228, 229, 230, 231, 232, 233, 244], rightEyeLower3: [143, 111, 117, 118, 119, 120, 121, 128, 245], rightEyebrowUpper: [156, 70, 63, 105, 66, 107, 55, 193], rightEyebrowLower: [35, 124, 46, 53, 52, 65], rightEyeIris: [473, 474, 475, 476, 477], leftEyeUpper0: [466, 388, 387, 386, 385, 384, 398], leftEyeLower0: [263, 249, 390, 373, 374, 380, 381, 382, 362], leftEyeUpper1: [467, 260, 259, 257, 258, 286, 414], leftEyeLower1: [359, 255, 339, 254, 253, 252, 256, 341, 463], leftEyeUpper2: [342, 445, 444, 443, 442, 441, 413], leftEyeLower2: [446, 261, 448, 449, 450, 451, 452, 453, 464], leftEyeLower3: [372, 340, 346, 347, 348, 349, 350, 357, 465], leftEyebrowUpper: [383, 300, 293, 334, 296, 336, 285, 417], leftEyebrowLower: [265, 353, 276, 283, 282, 295], leftEyeIris: [468, 469, 470, 471, 472], midwayBetweenEyes: [168], noseTip: [1], noseBottom: [2], noseRightCorner: [98], noseLeftCorner: [327], rightCheek: [205], leftCheek: [425] };
var fZ = { count: 468, symmetryLine: [13, pZ.midwayBetweenEyes[0]] };
var mZ = { leftEye: 0, rightEye: 1, nose: 2, mouth: 3, leftEar: 4, rightEar: 5, symmetryLine: [3, 2] };
var AZ = [{ key: "EyeUpper0", indices: [9, 10, 11, 12, 13, 14, 15] }, { key: "EyeUpper1", indices: [25, 26, 27, 28, 29, 30, 31] }, { key: "EyeUpper2", indices: [41, 42, 43, 44, 45, 46, 47] }, { key: "EyeLower0", indices: [0, 1, 2, 3, 4, 5, 6, 7, 8] }, { key: "EyeLower1", indices: [16, 17, 18, 19, 20, 21, 22, 23, 24] }, { key: "EyeLower2", indices: [32, 33, 34, 35, 36, 37, 38, 39, 40] }, { key: "EyeLower3", indices: [54, 55, 56, 57, 58, 59, 60, 61, 62] }, { key: "EyebrowUpper", indices: [63, 64, 65, 66, 67, 68, 69, 70] }, { key: "EyebrowLower", indices: [48, 49, 50, 51, 52, 53] }];
var xZ = [127, 34, 139, 11, 0, 37, 232, 231, 120, 72, 37, 39, 128, 121, 47, 232, 121, 128, 104, 69, 67, 175, 171, 148, 157, 154, 155, 118, 50, 101, 73, 39, 40, 9, 151, 108, 48, 115, 131, 194, 204, 211, 74, 40, 185, 80, 42, 183, 40, 92, 186, 230, 229, 118, 202, 212, 214, 83, 18, 17, 76, 61, 146, 160, 29, 30, 56, 157, 173, 106, 204, 194, 135, 214, 192, 203, 165, 98, 21, 71, 68, 51, 45, 4, 144, 24, 23, 77, 146, 91, 205, 50, 187, 201, 200, 18, 91, 106, 182, 90, 91, 181, 85, 84, 17, 206, 203, 36, 148, 171, 140, 92, 40, 39, 193, 189, 244, 159, 158, 28, 247, 246, 161, 236, 3, 196, 54, 68, 104, 193, 168, 8, 117, 228, 31, 189, 193, 55, 98, 97, 99, 126, 47, 100, 166, 79, 218, 155, 154, 26, 209, 49, 131, 135, 136, 150, 47, 126, 217, 223, 52, 53, 45, 51, 134, 211, 170, 140, 67, 69, 108, 43, 106, 91, 230, 119, 120, 226, 130, 247, 63, 53, 52, 238, 20, 242, 46, 70, 156, 78, 62, 96, 46, 53, 63, 143, 34, 227, 173, 155, 133, 123, 117, 111, 44, 125, 19, 236, 134, 51, 216, 206, 205, 154, 153, 22, 39, 37, 167, 200, 201, 208, 36, 142, 100, 57, 212, 202, 20, 60, 99, 28, 158, 157, 35, 226, 113, 160, 159, 27, 204, 202, 210, 113, 225, 46, 43, 202, 204, 62, 76, 77, 137, 123, 116, 41, 38, 72, 203, 129, 142, 64, 98, 240, 49, 102, 64, 41, 73, 74, 212, 216, 207, 42, 74, 184, 169, 170, 211, 170, 149, 176, 105, 66, 69, 122, 6, 168, 123, 147, 187, 96, 77, 90, 65, 55, 107, 89, 90, 180, 101, 100, 120, 63, 105, 104, 93, 137, 227, 15, 86, 85, 129, 102, 49, 14, 87, 86, 55, 8, 9, 100, 47, 121, 145, 23, 22, 88, 89, 179, 6, 122, 196, 88, 95, 96, 138, 172, 136, 215, 58, 172, 115, 48, 219, 42, 80, 81, 195, 3, 51, 43, 146, 61, 171, 175, 199, 81, 82, 38, 53, 46, 225, 144, 163, 110, 246, 33, 7, 52, 65, 66, 229, 228, 117, 34, 127, 234, 107, 108, 69, 109, 108, 151, 48, 64, 235, 62, 78, 191, 129, 209, 126, 111, 35, 143, 163, 161, 246, 117, 123, 50, 222, 65, 52, 19, 125, 141, 221, 55, 65, 3, 195, 197, 25, 7, 33, 220, 237, 44, 70, 71, 139, 122, 193, 245, 247, 130, 33, 71, 21, 162, 153, 158, 159, 170, 169, 150, 188, 174, 196, 216, 186, 92, 144, 160, 161, 2, 97, 167, 141, 125, 241, 164, 167, 37, 72, 38, 12, 145, 159, 160, 38, 82, 13, 63, 68, 71, 226, 35, 111, 158, 153, 154, 101, 50, 205, 206, 92, 165, 209, 198, 217, 165, 167, 97, 220, 115, 218, 133, 112, 243, 239, 238, 241, 214, 135, 169, 190, 173, 133, 171, 208, 32, 125, 44, 237, 86, 87, 178, 85, 86, 179, 84, 85, 180, 83, 84, 181, 201, 83, 182, 137, 93, 132, 76, 62, 183, 61, 76, 184, 57, 61, 185, 212, 57, 186, 214, 207, 187, 34, 143, 156, 79, 239, 237, 123, 137, 177, 44, 1, 4, 201, 194, 32, 64, 102, 129, 213, 215, 138, 59, 166, 219, 242, 99, 97, 2, 94, 141, 75, 59, 235, 24, 110, 228, 25, 130, 226, 23, 24, 229, 22, 23, 230, 26, 22, 231, 112, 26, 232, 189, 190, 243, 221, 56, 190, 28, 56, 221, 27, 28, 222, 29, 27, 223, 30, 29, 224, 247, 30, 225, 238, 79, 20, 166, 59, 75, 60, 75, 240, 147, 177, 215, 20, 79, 166, 187, 147, 213, 112, 233, 244, 233, 128, 245, 128, 114, 188, 114, 217, 174, 131, 115, 220, 217, 198, 236, 198, 131, 134, 177, 132, 58, 143, 35, 124, 110, 163, 7, 228, 110, 25, 356, 389, 368, 11, 302, 267, 452, 350, 349, 302, 303, 269, 357, 343, 277, 452, 453, 357, 333, 332, 297, 175, 152, 377, 384, 398, 382, 347, 348, 330, 303, 304, 270, 9, 336, 337, 278, 279, 360, 418, 262, 431, 304, 408, 409, 310, 415, 407, 270, 409, 410, 450, 348, 347, 422, 430, 434, 313, 314, 17, 306, 307, 375, 387, 388, 260, 286, 414, 398, 335, 406, 418, 364, 367, 416, 423, 358, 327, 251, 284, 298, 281, 5, 4, 373, 374, 253, 307, 320, 321, 425, 427, 411, 421, 313, 18, 321, 405, 406, 320, 404, 405, 315, 16, 17, 426, 425, 266, 377, 400, 369, 322, 391, 269, 417, 465, 464, 386, 257, 258, 466, 260, 388, 456, 399, 419, 284, 332, 333, 417, 285, 8, 346, 340, 261, 413, 441, 285, 327, 460, 328, 355, 371, 329, 392, 439, 438, 382, 341, 256, 429, 420, 360, 364, 394, 379, 277, 343, 437, 443, 444, 283, 275, 440, 363, 431, 262, 369, 297, 338, 337, 273, 375, 321, 450, 451, 349, 446, 342, 467, 293, 334, 282, 458, 461, 462, 276, 353, 383, 308, 324, 325, 276, 300, 293, 372, 345, 447, 382, 398, 362, 352, 345, 340, 274, 1, 19, 456, 248, 281, 436, 427, 425, 381, 256, 252, 269, 391, 393, 200, 199, 428, 266, 330, 329, 287, 273, 422, 250, 462, 328, 258, 286, 384, 265, 353, 342, 387, 259, 257, 424, 431, 430, 342, 353, 276, 273, 335, 424, 292, 325, 307, 366, 447, 345, 271, 303, 302, 423, 266, 371, 294, 455, 460, 279, 278, 294, 271, 272, 304, 432, 434, 427, 272, 407, 408, 394, 430, 431, 395, 369, 400, 334, 333, 299, 351, 417, 168, 352, 280, 411, 325, 319, 320, 295, 296, 336, 319, 403, 404, 330, 348, 349, 293, 298, 333, 323, 454, 447, 15, 16, 315, 358, 429, 279, 14, 15, 316, 285, 336, 9, 329, 349, 350, 374, 380, 252, 318, 402, 403, 6, 197, 419, 318, 319, 325, 367, 364, 365, 435, 367, 397, 344, 438, 439, 272, 271, 311, 195, 5, 281, 273, 287, 291, 396, 428, 199, 311, 271, 268, 283, 444, 445, 373, 254, 339, 263, 466, 249, 282, 334, 296, 449, 347, 346, 264, 447, 454, 336, 296, 299, 338, 10, 151, 278, 439, 455, 292, 407, 415, 358, 371, 355, 340, 345, 372, 390, 249, 466, 346, 347, 280, 442, 443, 282, 19, 94, 370, 441, 442, 295, 248, 419, 197, 263, 255, 359, 440, 275, 274, 300, 383, 368, 351, 412, 465, 263, 467, 466, 301, 368, 389, 380, 374, 386, 395, 378, 379, 412, 351, 419, 436, 426, 322, 373, 390, 388, 2, 164, 393, 370, 462, 461, 164, 0, 267, 302, 11, 12, 374, 373, 387, 268, 12, 13, 293, 300, 301, 446, 261, 340, 385, 384, 381, 330, 266, 425, 426, 423, 391, 429, 355, 437, 391, 327, 326, 440, 457, 438, 341, 382, 362, 459, 457, 461, 434, 430, 394, 414, 463, 362, 396, 369, 262, 354, 461, 457, 316, 403, 402, 315, 404, 403, 314, 405, 404, 313, 406, 405, 421, 418, 406, 366, 401, 361, 306, 408, 407, 291, 409, 408, 287, 410, 409, 432, 436, 410, 434, 416, 411, 264, 368, 383, 309, 438, 457, 352, 376, 401, 274, 275, 4, 421, 428, 262, 294, 327, 358, 433, 416, 367, 289, 455, 439, 462, 370, 326, 2, 326, 370, 305, 460, 455, 254, 449, 448, 255, 261, 446, 253, 450, 449, 252, 451, 450, 256, 452, 451, 341, 453, 452, 413, 464, 463, 441, 413, 414, 258, 442, 441, 257, 443, 442, 259, 444, 443, 260, 445, 444, 467, 342, 445, 459, 458, 250, 289, 392, 290, 290, 328, 460, 376, 433, 435, 250, 290, 392, 411, 416, 433, 341, 463, 464, 453, 464, 465, 357, 465, 412, 343, 412, 399, 360, 363, 440, 437, 399, 456, 420, 456, 363, 401, 435, 288, 372, 383, 353, 339, 255, 249, 448, 261, 255, 133, 243, 190, 133, 155, 112, 33, 246, 247, 33, 130, 25, 398, 384, 286, 362, 398, 414, 362, 463, 341, 263, 359, 467, 263, 249, 255, 466, 467, 260, 75, 60, 166, 238, 239, 79, 162, 127, 139, 72, 11, 37, 121, 232, 120, 73, 72, 39, 114, 128, 47, 233, 232, 128, 103, 104, 67, 152, 175, 148, 173, 157, 155, 119, 118, 101, 74, 73, 40, 107, 9, 108, 49, 48, 131, 32, 194, 211, 184, 74, 185, 191, 80, 183, 185, 40, 186, 119, 230, 118, 210, 202, 214, 84, 83, 17, 77, 76, 146, 161, 160, 30, 190, 56, 173, 182, 106, 194, 138, 135, 192, 129, 203, 98, 54, 21, 68, 5, 51, 4, 145, 144, 23, 90, 77, 91, 207, 205, 187, 83, 201, 18, 181, 91, 182, 180, 90, 181, 16, 85, 17, 205, 206, 36, 176, 148, 140, 165, 92, 39, 245, 193, 244, 27, 159, 28, 30, 247, 161, 174, 236, 196, 103, 54, 104, 55, 193, 8, 111, 117, 31, 221, 189, 55, 240, 98, 99, 142, 126, 100, 219, 166, 218, 112, 155, 26, 198, 209, 131, 169, 135, 150, 114, 47, 217, 224, 223, 53, 220, 45, 134, 32, 211, 140, 109, 67, 108, 146, 43, 91, 231, 230, 120, 113, 226, 247, 105, 63, 52, 241, 238, 242, 124, 46, 156, 95, 78, 96, 70, 46, 63, 116, 143, 227, 116, 123, 111, 1, 44, 19, 3, 236, 51, 207, 216, 205, 26, 154, 22, 165, 39, 167, 199, 200, 208, 101, 36, 100, 43, 57, 202, 242, 20, 99, 56, 28, 157, 124, 35, 113, 29, 160, 27, 211, 204, 210, 124, 113, 46, 106, 43, 204, 96, 62, 77, 227, 137, 116, 73, 41, 72, 36, 203, 142, 235, 64, 240, 48, 49, 64, 42, 41, 74, 214, 212, 207, 183, 42, 184, 210, 169, 211, 140, 170, 176, 104, 105, 69, 193, 122, 168, 50, 123, 187, 89, 96, 90, 66, 65, 107, 179, 89, 180, 119, 101, 120, 68, 63, 104, 234, 93, 227, 16, 15, 85, 209, 129, 49, 15, 14, 86, 107, 55, 9, 120, 100, 121, 153, 145, 22, 178, 88, 179, 197, 6, 196, 89, 88, 96, 135, 138, 136, 138, 215, 172, 218, 115, 219, 41, 42, 81, 5, 195, 51, 57, 43, 61, 208, 171, 199, 41, 81, 38, 224, 53, 225, 24, 144, 110, 105, 52, 66, 118, 229, 117, 227, 34, 234, 66, 107, 69, 10, 109, 151, 219, 48, 235, 183, 62, 191, 142, 129, 126, 116, 111, 143, 7, 163, 246, 118, 117, 50, 223, 222, 52, 94, 19, 141, 222, 221, 65, 196, 3, 197, 45, 220, 44, 156, 70, 139, 188, 122, 245, 139, 71, 162, 145, 153, 159, 149, 170, 150, 122, 188, 196, 206, 216, 92, 163, 144, 161, 164, 2, 167, 242, 141, 241, 0, 164, 37, 11, 72, 12, 144, 145, 160, 12, 38, 13, 70, 63, 71, 31, 226, 111, 157, 158, 154, 36, 101, 205, 203, 206, 165, 126, 209, 217, 98, 165, 97, 237, 220, 218, 237, 239, 241, 210, 214, 169, 140, 171, 32, 241, 125, 237, 179, 86, 178, 180, 85, 179, 181, 84, 180, 182, 83, 181, 194, 201, 182, 177, 137, 132, 184, 76, 183, 185, 61, 184, 186, 57, 185, 216, 212, 186, 192, 214, 187, 139, 34, 156, 218, 79, 237, 147, 123, 177, 45, 44, 4, 208, 201, 32, 98, 64, 129, 192, 213, 138, 235, 59, 219, 141, 242, 97, 97, 2, 141, 240, 75, 235, 229, 24, 228, 31, 25, 226, 230, 23, 229, 231, 22, 230, 232, 26, 231, 233, 112, 232, 244, 189, 243, 189, 221, 190, 222, 28, 221, 223, 27, 222, 224, 29, 223, 225, 30, 224, 113, 247, 225, 99, 60, 240, 213, 147, 215, 60, 20, 166, 192, 187, 213, 243, 112, 244, 244, 233, 245, 245, 128, 188, 188, 114, 174, 134, 131, 220, 174, 217, 236, 236, 198, 134, 215, 177, 58, 156, 143, 124, 25, 110, 7, 31, 228, 25, 264, 356, 368, 0, 11, 267, 451, 452, 349, 267, 302, 269, 350, 357, 277, 350, 452, 357, 299, 333, 297, 396, 175, 377, 381, 384, 382, 280, 347, 330, 269, 303, 270, 151, 9, 337, 344, 278, 360, 424, 418, 431, 270, 304, 409, 272, 310, 407, 322, 270, 410, 449, 450, 347, 432, 422, 434, 18, 313, 17, 291, 306, 375, 259, 387, 260, 424, 335, 418, 434, 364, 416, 391, 423, 327, 301, 251, 298, 275, 281, 4, 254, 373, 253, 375, 307, 321, 280, 425, 411, 200, 421, 18, 335, 321, 406, 321, 320, 405, 314, 315, 17, 423, 426, 266, 396, 377, 369, 270, 322, 269, 413, 417, 464, 385, 386, 258, 248, 456, 419, 298, 284, 333, 168, 417, 8, 448, 346, 261, 417, 413, 285, 326, 327, 328, 277, 355, 329, 309, 392, 438, 381, 382, 256, 279, 429, 360, 365, 364, 379, 355, 277, 437, 282, 443, 283, 281, 275, 363, 395, 431, 369, 299, 297, 337, 335, 273, 321, 348, 450, 349, 359, 446, 467, 283, 293, 282, 250, 458, 462, 300, 276, 383, 292, 308, 325, 283, 276, 293, 264, 372, 447, 346, 352, 340, 354, 274, 19, 363, 456, 281, 426, 436, 425, 380, 381, 252, 267, 269, 393, 421, 200, 428, 371, 266, 329, 432, 287, 422, 290, 250, 328, 385, 258, 384, 446, 265, 342, 386, 387, 257, 422, 424, 430, 445, 342, 276, 422, 273, 424, 306, 292, 307, 352, 366, 345, 268, 271, 302, 358, 423, 371, 327, 294, 460, 331, 279, 294, 303, 271, 304, 436, 432, 427, 304, 272, 408, 395, 394, 431, 378, 395, 400, 296, 334, 299, 6, 351, 168, 376, 352, 411, 307, 325, 320, 285, 295, 336, 320, 319, 404, 329, 330, 349, 334, 293, 333, 366, 323, 447, 316, 15, 315, 331, 358, 279, 317, 14, 316, 8, 285, 9, 277, 329, 350, 253, 374, 252, 319, 318, 403, 351, 6, 419, 324, 318, 325, 397, 367, 365, 288, 435, 397, 278, 344, 439, 310, 272, 311, 248, 195, 281, 375, 273, 291, 175, 396, 199, 312, 311, 268, 276, 283, 445, 390, 373, 339, 295, 282, 296, 448, 449, 346, 356, 264, 454, 337, 336, 299, 337, 338, 151, 294, 278, 455, 308, 292, 415, 429, 358, 355, 265, 340, 372, 388, 390, 466, 352, 346, 280, 295, 442, 282, 354, 19, 370, 285, 441, 295, 195, 248, 197, 457, 440, 274, 301, 300, 368, 417, 351, 465, 251, 301, 389, 385, 380, 386, 394, 395, 379, 399, 412, 419, 410, 436, 322, 387, 373, 388, 326, 2, 393, 354, 370, 461, 393, 164, 267, 268, 302, 12, 386, 374, 387, 312, 268, 13, 298, 293, 301, 265, 446, 340, 380, 385, 381, 280, 330, 425, 322, 426, 391, 420, 429, 437, 393, 391, 326, 344, 440, 438, 458, 459, 461, 364, 434, 394, 428, 396, 262, 274, 354, 457, 317, 316, 402, 316, 315, 403, 315, 314, 404, 314, 313, 405, 313, 421, 406, 323, 366, 361, 292, 306, 407, 306, 291, 408, 291, 287, 409, 287, 432, 410, 427, 434, 411, 372, 264, 383, 459, 309, 457, 366, 352, 401, 1, 274, 4, 418, 421, 262, 331, 294, 358, 435, 433, 367, 392, 289, 439, 328, 462, 326, 94, 2, 370, 289, 305, 455, 339, 254, 448, 359, 255, 446, 254, 253, 449, 253, 252, 450, 252, 256, 451, 256, 341, 452, 414, 413, 463, 286, 441, 414, 286, 258, 441, 258, 257, 442, 257, 259, 443, 259, 260, 444, 260, 467, 445, 309, 459, 250, 305, 289, 290, 305, 290, 460, 401, 376, 435, 309, 250, 392, 376, 411, 433, 453, 341, 464, 357, 453, 465, 343, 357, 412, 437, 343, 399, 344, 360, 440, 420, 437, 456, 360, 420, 363, 361, 401, 288, 265, 372, 353, 390, 339, 249, 339, 448, 255];
function yZ(e20) {
  const t2 = e20.map((e21) => e21[0]);
  return t2.push(e20[e20.length - 1][1]), t2;
}
function bZ(e20) {
  const t2 = e20.map((e21) => e21[0]);
  return t2.push(e20[e20.length - 1][1]), t2;
}
yZ([[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]]), yZ([[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]]), yZ([[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]]), yZ([[474, 475], [475, 476], [476, 477], [477, 474]]), yZ([[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]]), yZ([[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]]), yZ([[469, 470], [470, 471], [471, 472], [472, 469]]), yZ([[10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]]);
var gZ = { lips: bZ([[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]]), leftEye: bZ([[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]]), leftEyebrow: bZ([[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]]), leftIris: bZ([[474, 475], [475, 476], [476, 477], [477, 474]]), rightEye: bZ([[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]]), rightEyebrow: bZ([[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]]), rightIris: bZ([[469, 470], [470, 471], [471, 472], [472, 469]]), faceOval: bZ([[10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]]) };
var vZ = Object.entries(gZ).map(([e20, t2]) => t2.map((t3) => [t3, e20])).flat();
new Map(vZ);
var wZ;
var kZ = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 185, 40, 39, 37, 0, 267, 269, 270, 409, 78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 191, 80, 81, 82, 13, 312, 311, 310, 415, 76, 77, 90, 180, 85, 16, 315, 404, 320, 307, 306, 184, 74, 73, 72, 11, 302, 303, 304, 408, 62, 96, 89, 179, 86, 15, 316, 403, 319, 325, 292, 183, 42, 41, 38, 12, 268, 271, 272, 407];
var NZ = [33, 7, 163, 144, 145, 153, 154, 155, 133, 246, 161, 160, 159, 158, 157, 173, 130, 25, 110, 24, 23, 22, 26, 112, 243, 247, 30, 29, 27, 28, 56, 190, 226, 31, 228, 229, 230, 231, 232, 233, 244, 113, 225, 224, 223, 222, 221, 189, 35, 124, 46, 53, 52, 65, 143, 111, 117, 118, 119, 120, 121, 128, 245, 156, 70, 63, 105, 66, 107, 55, 193];
var CZ = [263, 249, 390, 373, 374, 380, 381, 382, 362, 466, 388, 387, 386, 385, 384, 398, 359, 255, 339, 254, 253, 252, 256, 341, 463, 467, 260, 259, 257, 258, 286, 414, 446, 261, 448, 449, 450, 451, 452, 453, 464, 342, 445, 444, 443, 442, 441, 413, 265, 353, 276, 283, 282, 295, 372, 340, 346, 347, 348, 349, 350, 357, 465, 383, 300, 293, 334, 296, 336, 285, 417];
function $Z(e20, t2) {
  var n2, r2, a2, i2, s2, o2, l2, u2, d2;
  if (!wZ.drawLabels || 0 === (null == (n2 = wZ.faceLabels) ? void 0 : n2.length)) return;
  let c2 = wZ.faceLabels.slice();
  if (c2 = aZ(c2, "[id]", e20.id.toFixed(0)), e20.score && (c2 = aZ(c2, "[score]", 100 * e20.score)), e20.gender && (c2 = aZ(c2, "[gender]", e20.gender)), e20.genderScore && (c2 = aZ(c2, "[genderScore]", 100 * e20.genderScore)), e20.age && (c2 = aZ(c2, "[age]", e20.age)), e20.distance && (c2 = aZ(c2, "[distance]", 100 * e20.distance)), e20.real && (c2 = aZ(c2, "[real]", 100 * e20.real)), e20.live && (c2 = aZ(c2, "[live]", 100 * e20.live)), e20.emotion && e20.emotion.length > 0) {
    const t3 = e20.emotion.map((e21) => `${Math.trunc(100 * e21.score)}% ${e21.emotion}`);
    t3.length > 3 && (t3.length = 3), c2 = aZ(c2, "[emotions]", t3.join(" "));
  }
  (null == (a2 = null == (r2 = e20.rotation) ? void 0 : r2.angle) ? void 0 : a2.roll) && (c2 = aZ(c2, "[roll]", rZ(e20.rotation.angle.roll))), (null == (s2 = null == (i2 = e20.rotation) ? void 0 : i2.angle) ? void 0 : s2.yaw) && (c2 = aZ(c2, "[yaw]", rZ(e20.rotation.angle.yaw))), (null == (l2 = null == (o2 = e20.rotation) ? void 0 : o2.angle) ? void 0 : l2.pitch) && (c2 = aZ(c2, "[pitch]", rZ(e20.rotation.angle.pitch))), (null == (d2 = null == (u2 = e20.rotation) ? void 0 : u2.gaze) ? void 0 : d2.bearing) && (c2 = aZ(c2, "[gaze]", rZ(e20.rotation.gaze.bearing))), sZ(t2, c2, e20.box[0], e20.box[1], wZ);
}
function RZ(e20, t2) {
  var n2;
  if (wZ.drawGaze && (null == (n2 = e20.rotation) ? void 0 : n2.angle) && "undefined" != typeof Path2D) {
    t2.strokeStyle = "pink";
    const n3 = e20.box[0] + e20.box[2] / 2 - e20.box[3] * rZ(e20.rotation.angle.yaw) / 90, r2 = e20.box[1] + e20.box[3] / 2 + e20.box[2] * rZ(e20.rotation.angle.pitch) / 90, a2 = new Path2D(`
      M ${e20.box[0] + e20.box[2] / 2} ${e20.box[1]}
      C
        ${n3} ${e20.box[1]},
        ${n3} ${e20.box[1] + e20.box[3]},
        ${e20.box[0] + e20.box[2] / 2} ${e20.box[1] + e20.box[3]}
    `), i2 = new Path2D(`
      M ${e20.box[0]} ${e20.box[1] + e20.box[3] / 2}
      C 
        ${e20.box[0]} ${r2},
        ${e20.box[0] + e20.box[2]} ${r2},
        ${e20.box[0] + e20.box[2]} ${e20.box[1] + e20.box[3] / 2}
    `);
    t2.stroke(i2), t2.stroke(a2);
  }
}
function SZ(e20, t2) {
  var n2;
  if (wZ.drawGaze && (null == (n2 = e20.rotation) ? void 0 : n2.gaze.strength) && e20.rotation.gaze.bearing && e20.annotations.leftEyeIris && e20.annotations.rightEyeIris && e20.annotations.leftEyeIris[0] && e20.annotations.rightEyeIris[0]) {
    t2.strokeStyle = "pink", t2.fillStyle = "pink";
    const n3 = [e20.annotations.leftEyeIris[0][0] + Math.sin(e20.rotation.gaze.bearing) * e20.rotation.gaze.strength * e20.box[3], e20.annotations.leftEyeIris[0][1] + Math.cos(e20.rotation.gaze.bearing) * e20.rotation.gaze.strength * e20.box[2]];
    cZ(t2, [e20.annotations.leftEyeIris[0][0], e20.annotations.leftEyeIris[0][1]], [n3[0], n3[1]], 4);
    const r2 = [e20.annotations.rightEyeIris[0][0] + Math.sin(e20.rotation.gaze.bearing) * e20.rotation.gaze.strength * e20.box[3], e20.annotations.rightEyeIris[0][1] + Math.cos(e20.rotation.gaze.bearing) * e20.rotation.gaze.strength * e20.box[2]];
    cZ(t2, [e20.annotations.rightEyeIris[0][0], e20.annotations.rightEyeIris[0][1]], [r2[0], r2[1]], 4);
  }
}
function IZ(e20, t2) {
  if (wZ.drawPolygons && e20.mesh.length >= 468) {
    t2.lineWidth = 1;
    for (let n2 = 0; xZ.length / 3 > n2; n2++) uZ(t2, [xZ[3 * n2 + 0], xZ[3 * n2 + 1], xZ[3 * n2 + 2]].map((t3) => e20.mesh[t3]), wZ);
    ((e21, t3) => {
      var n2, r2, a2, i2;
      (null == (n2 = e21.annotations) ? void 0 : n2.leftEyeIris) && (null == (r2 = e21.annotations) ? void 0 : r2.leftEyeIris[0]) && (t3.strokeStyle = wZ.useDepth ? "rgba(255, 200, 255, 0.3)" : wZ.color, t3.beginPath(), t3.ellipse(e21.annotations.leftEyeIris[0][0], e21.annotations.leftEyeIris[0][1], Math.abs(e21.annotations.leftEyeIris[3][0] - e21.annotations.leftEyeIris[1][0]) / 2, Math.abs(e21.annotations.leftEyeIris[4][1] - e21.annotations.leftEyeIris[2][1]) / 2, 0, 0, 2 * Math.PI), t3.stroke(), wZ.fillPolygons && (t3.fillStyle = wZ.useDepth ? "rgba(255, 255, 200, 0.3)" : wZ.color, t3.fill())), (null == (a2 = e21.annotations) ? void 0 : a2.rightEyeIris) && (null == (i2 = e21.annotations) ? void 0 : i2.rightEyeIris[0]) && (t3.strokeStyle = wZ.useDepth ? "rgba(255, 200, 255, 0.3)" : wZ.color, t3.beginPath(), t3.ellipse(e21.annotations.rightEyeIris[0][0], e21.annotations.rightEyeIris[0][1], Math.abs(e21.annotations.rightEyeIris[3][0] - e21.annotations.rightEyeIris[1][0]) / 2, Math.abs(e21.annotations.rightEyeIris[4][1] - e21.annotations.rightEyeIris[2][1]) / 2, 0, 0, 2 * Math.PI), t3.stroke(), wZ.fillPolygons && (t3.fillStyle = wZ.useDepth ? "rgba(255, 255, 200, 0.3)" : wZ.color, t3.fill()));
    })(e20, t2);
  }
}
function EZ(e20, t2) {
  if (wZ.drawPoints) if (468 > (null == e20 ? void 0 : e20.mesh.length)) for (const [n2, r2] of Object.entries((null == e20 ? void 0 : e20.annotations) || {})) {
    if (!(null == r2 ? void 0 : r2[0])) continue;
    const e21 = r2[0];
    oZ(t2, e21[0], e21[1], 0, wZ), wZ.drawLabels && sZ(t2, n2, e21[0], e21[1], wZ);
  }
  else for (let n2 = 0; e20.mesh.length > n2; n2++) oZ(t2, e20.mesh[n2][0], e20.mesh[n2][1], e20.mesh[n2][2], wZ), wZ.drawAttention && (kZ.includes(n2) && oZ(t2, e20.mesh[n2][0], e20.mesh[n2][1], e20.mesh[n2][2] + 127, wZ), NZ.includes(n2) && oZ(t2, e20.mesh[n2][0], e20.mesh[n2][1], e20.mesh[n2][2] - 127, wZ), CZ.includes(n2) && oZ(t2, e20.mesh[n2][0], e20.mesh[n2][1], e20.mesh[n2][2] - 127, wZ));
}
function TZ(e20, t2) {
  wZ.drawBoxes && lZ(t2, e20.box[0], e20.box[1], e20.box[2], e20.box[3], wZ);
}
function MZ(e20, t2, n2) {
  if (wZ = bX(hZ, n2), !t2 || !e20) return;
  const r2 = nZ(e20);
  if (r2) {
    r2.font = wZ.font, r2.strokeStyle = wZ.color, r2.fillStyle = wZ.color;
    for (const e21 of t2) TZ(e21, r2), $Z(e21, r2), e21.mesh && e21.mesh.length > 0 && (EZ(e21, r2), IZ(e21, r2), RZ(e21, r2), SZ(e21, r2));
  }
}
function OZ(e20, t2, n2) {
  var r2, a2;
  const i2 = bX(hZ, n2);
  if (!t2 || !e20) return;
  const s2 = nZ(e20);
  if (s2) {
    s2.lineJoin = "round";
    for (let e21 = 0; t2.length > e21; e21++) {
      if (s2.strokeStyle = i2.color, s2.fillStyle = i2.color, s2.lineWidth = i2.lineWidth, s2.font = i2.font, i2.drawBoxes && t2[e21].box && 4 === t2[e21].box.length && (lZ(s2, t2[e21].box[0], t2[e21].box[1], t2[e21].box[2], t2[e21].box[3], i2), i2.drawLabels && (null == (r2 = i2.bodyLabels) ? void 0 : r2.length) > 0)) {
        let n3 = i2.bodyLabels.slice();
        n3 = aZ(n3, "[id]", t2[e21].id.toFixed(0)), n3 = aZ(n3, "[score]", 100 * t2[e21].score), sZ(s2, n3, t2[e21].box[0], t2[e21].box[1], i2);
      }
      if (i2.drawPoints && t2[e21].keypoints) for (let n3 = 0; t2[e21].keypoints.length > n3; n3++) t2[e21].keypoints[n3].score && 0 !== t2[e21].keypoints[n3].score && (s2.fillStyle = iZ(t2[e21].keypoints[n3].position[2], i2), oZ(s2, t2[e21].keypoints[n3].position[0], t2[e21].keypoints[n3].position[1], 0, i2));
      if (i2.drawLabels && (null == (a2 = i2.bodyPartLabels) ? void 0 : a2.length) > 0 && t2[e21].keypoints) {
        s2.font = i2.font;
        for (const n3 of t2[e21].keypoints) {
          if (!n3.score || 0 === n3.score) continue;
          let e22 = i2.bodyPartLabels.slice();
          e22 = aZ(e22, "[label]", n3.part), e22 = aZ(e22, "[score]", 100 * n3.score), sZ(s2, e22, n3.position[0], n3.position[1], i2);
        }
      }
      if (i2.drawPolygons && t2[e21].keypoints && t2[e21].annotations) for (const n3 of Object.values(t2[e21].annotations)) for (const e22 of n3) dZ(s2, e22, i2);
    }
  }
}
function FZ(e20, t2, n2) {
  var r2, a2;
  const i2 = bX(hZ, n2);
  if (!t2 || !e20) return;
  const s2 = nZ(e20);
  if (s2) {
    s2.lineJoin = "round", s2.font = i2.font;
    for (const e21 of t2) {
      if (i2.drawBoxes) {
        if (s2.strokeStyle = i2.color, s2.fillStyle = i2.color, lZ(s2, e21.box[0], e21.box[1], e21.box[2], e21.box[3], i2), i2.drawLabels && (null == (r2 = i2.handLabels) ? void 0 : r2.length) > 0) {
          let t3 = i2.handLabels.slice();
          t3 = aZ(t3, "[id]", e21.id.toFixed(0)), t3 = aZ(t3, "[label]", e21.label), t3 = aZ(t3, "[score]", 100 * e21.score), sZ(s2, t3, e21.box[0], e21.box[1], i2);
        }
        s2.stroke();
      }
      if (i2.drawPoints && e21.keypoints && e21.keypoints.length > 0) for (const t3 of e21.keypoints) s2.fillStyle = iZ(t3[2], i2), oZ(s2, t3[0], t3[1], 0, i2);
      if (i2.drawLabels && e21.annotations && (null == (a2 = i2.fingerLabels) ? void 0 : a2.length) > 0) for (const [t3, n3] of Object.entries(e21.annotations)) {
        let e22 = i2.fingerLabels.slice();
        e22 = aZ(e22, "[label]", t3), sZ(s2, e22, n3[n3.length - 1][0], n3[n3.length - 1][1], i2);
      }
      if (i2.drawPolygons && e21.annotations) {
        const t3 = (e22) => {
          if (e22 && 0 !== e22.length && e22[0]) for (let t4 = 0; e22.length > t4; t4++) s2.beginPath(), s2.strokeStyle = iZ(t4 * (e22[t4][2] || 0), i2), s2.moveTo(e22[t4 > 0 ? t4 - 1 : 0][0], e22[t4 > 0 ? t4 - 1 : 0][1]), s2.lineTo(e22[t4][0], e22[t4][1]), s2.stroke();
        };
        s2.lineWidth = i2.lineWidth, t3(e21.annotations.index), t3(e21.annotations.middle), t3(e21.annotations.ring), t3(e21.annotations.pinky), t3(e21.annotations.thumb);
      }
    }
  }
}
function PZ(e20, t2, n2) {
  var r2;
  const a2 = bX(hZ, n2);
  if (!t2 || !e20) return;
  const i2 = nZ(e20);
  if (i2) {
    i2.lineJoin = "round", i2.font = a2.font;
    for (const e21 of t2) if (a2.drawBoxes) {
      if (i2.strokeStyle = a2.color, i2.fillStyle = a2.color, lZ(i2, e21.box[0], e21.box[1], e21.box[2], e21.box[3], a2), a2.drawLabels && (null == (r2 = a2.objectLabels) ? void 0 : r2.length) > 0) {
        let t3 = a2.objectLabels.slice();
        t3 = aZ(t3, "[id]", e21.id.toFixed(0)), t3 = aZ(t3, "[label]", e21.label), t3 = aZ(t3, "[score]", 100 * e21.score), sZ(i2, t3, e21.box[0], e21.box[1], a2);
      }
      i2.stroke();
    }
  }
}
function zZ(e20, t2, n2) {
  var r2;
  const a2 = bX(hZ, n2);
  if (t2 && e20 && a2.drawGestures && (null == (r2 = a2.gestureLabels) ? void 0 : r2.length) > 0) {
    const n3 = nZ(e20);
    if (!n3) return;
    n3.font = a2.font, n3.fillStyle = a2.color;
    let r3 = 1;
    for (let e21 = 0; t2.length > e21; e21++) {
      const [i2, s2] = Object.entries(t2[e21]);
      if (s2.length > 1 && s2[1].length > 0) {
        const e22 = i2[1] > 0 ? "#" + i2[1] : "";
        let t3 = a2.gestureLabels.slice();
        t3 = aZ(t3, "[where]", i2[0]), t3 = aZ(t3, "[who]", e22), t3 = aZ(t3, "[what]", s2[1]), sZ(n3, t3, 8, 2 + r3 * a2.lineHeight, a2), r3 += 1;
      }
    }
  }
}
var VZ = { face: "face\n    confidence: [score]%\n    [gender] [genderScore]%\n    age: [age] years\n    distance: [distance]cm\n    real: [real]%\n    live: [live]%\n    [emotions]\n    roll: [roll] yaw:[yaw] pitch:[pitch]\n    gaze: [gaze]", body: "body [score]%", bodyPart: "[label] [score]%", object: "[label] [score]%", hand: "[label] [score]%", finger: "[label]", gesture: "[where] [who]: [what]" };
var _Z = 0;
function DZ(e20, t2, n2) {
  const r2 = bX(hZ, n2);
  if (!t2 || !e20) return;
  const a2 = nZ(e20);
  if (a2) {
    a2.lineJoin = "round", a2.font = r2.font;
    for (let e21 = 0; t2.length > e21; e21++) if (r2.drawBoxes) {
      if (a2.strokeStyle = r2.color, a2.fillStyle = r2.color, lZ(a2, t2[e21].box[0], t2[e21].box[1], t2[e21].box[2], t2[e21].box[3], r2), r2.drawLabels) {
        const n3 = "person #" + e21;
        r2.shadowColor && "" !== r2.shadowColor && (a2.fillStyle = r2.shadowColor, a2.fillText(n3, t2[e21].box[0] + 3, 1 + t2[e21].box[1] + r2.lineHeight, t2[e21].box[2])), a2.fillStyle = r2.labelColor, a2.fillText(n3, t2[e21].box[0] + 2, 0 + t2[e21].box[1] + r2.lineHeight, t2[e21].box[2]);
      }
      a2.stroke();
    }
  }
}
function WZ(e20, t2) {
  if (!e20 || !t2) return;
  const n2 = nZ(t2);
  n2 && n2.drawImage(e20, 0, 0);
}
function LZ(e20, t2) {
  return __async(this, null, function* () {
    e20 && t2 && _X.browser && (yield of.toPixels(e20, t2));
  });
}
function BZ(e20, t2, n2) {
  return __async(this, null, function* () {
    if (!(null == t2 ? void 0 : t2.performance) || !e20) return null;
    const r2 = xX(), a2 = bX(hZ, n2), i2 = Promise.all([MZ(e20, t2.face, a2), OZ(e20, t2.body, a2), FZ(e20, t2.hand, a2), PZ(e20, t2.object, a2), zZ(e20, t2.gesture, a2)]);
    return _Z = _X.perfadd ? _Z + Math.round(xX() - r2) : Math.round(xX() - r2), t2.performance.draw = _Z, i2;
  });
}
function UZ() {
  hZ.faceLabels = VZ.face, hZ.bodyLabels = VZ.body, hZ.bodyPartLabels = VZ.bodyPart, hZ.handLabels = VZ.hand, hZ.fingerLabels = VZ.finger, hZ.objectLabels = VZ.object, hZ.gestureLabels = VZ.gesture;
}
var jZ = {};
n(jZ, { connected() {
  return ZZ;
}, kpt() {
  return qZ;
} });
var GZ;
var HZ;
var XZ;
var qZ = ["nose", "leftEyeInside", "leftEye", "leftEyeOutside", "rightEyeInside", "rightEye", "rightEyeOutside", "leftEar", "rightEar", "leftMouth", "rightMouth", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftPinky", "rightPinky", "leftIndex", "rightIndex", "leftThumb", "rightThumb", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle", "leftHeel", "rightHeel", "leftFoot", "rightFoot", "bodyCenter", "bodyTop", "leftPalm", "leftHand", "rightPalm", "rightHand"];
var ZZ = { shoulders: ["leftShoulder", "rightShoulder"], hips: ["rightHip", "leftHip"], mouth: ["leftMouth", "rightMouth"], leftLegUpper: ["leftHip", "leftKnee"], leftLegLower: ["leftKnee", "leftAnkle"], leftFoot: ["leftAnkle", "leftHeel", "leftFoot"], leftTorso: ["leftShoulder", "leftHip"], leftArmUpper: ["leftShoulder", "leftElbow"], leftArmLower: ["leftElbow", "leftWrist"], leftHand: ["leftWrist", "leftPalm"], leftHandPinky: ["leftPalm", "leftPinky"], leftHandIndex: ["leftPalm", "leftIndex"], leftHandThumb: ["leftPalm", "leftThumb"], leftEyeOutline: ["leftEyeInside", "leftEyeOutside"], rightLegUpper: ["rightHip", "rightKnee"], rightLegLower: ["rightKnee", "rightAnkle"], rightFoot: ["rightAnkle", "rightHeel", "rightFoot"], rightTorso: ["rightShoulder", "rightHip"], rightArmUpper: ["rightShoulder", "rightElbow"], rightArmLower: ["rightElbow", "rightWrist"], rightHand: ["rightWrist", "rightPalm"], rightHandPinky: ["rightPalm", "rightPinky"], rightHandIndex: ["rightPalm", "rightIndex"], rightHandThumb: ["rightPalm", "rightThumb"], rightEyeOutline: ["rightEyeInside", "rightEyeOutside"] };
var KZ = 224;
var YZ = [8, 16, 32, 32, 32];
function JZ(e20, t2 = [1, 1]) {
  const n2 = [e20.map((e21) => e21[0]), e20.map((e21) => e21[1])], r2 = [Math.min(...n2[0]), Math.min(...n2[1])], a2 = [Math.max(...n2[0]), Math.max(...n2[1])], i2 = [r2[0], r2[1], a2[0] - r2[0], a2[1] - r2[1]];
  return { box: i2, boxRaw: [i2[0] / t2[0], i2[1] / t2[1], i2[2] / t2[0], i2[3] / t2[1]] };
}
function QZ(e20, t2 = [1, 1]) {
  const n2 = [e20.map((e21) => e21[0]), e20.map((e21) => e21[1])], r2 = [Math.min(...n2[0]), Math.min(...n2[1])], a2 = [Math.max(...n2[0]), Math.max(...n2[1])], i2 = [(r2[0] + a2[0]) / 2, (r2[1] + a2[1]) / 2], s2 = Math.max(i2[0] - r2[0], i2[1] - r2[1], -i2[0] + a2[0], -i2[1] + a2[1]), o2 = [Math.trunc(i2[0] - s2), Math.trunc(i2[1] - s2), Math.trunc(2 * s2), Math.trunc(2 * s2)];
  return { box: o2, boxRaw: [o2[0] / t2[0], o2[1] / t2[1], o2[2] / t2[0], o2[3] / t2[1]] };
}
function eK(e20, t2) {
  const n2 = [e20[2] * t2, e20[3] * t2];
  return [e20[0] - (n2[0] - e20[2]) / 2, e20[1] - (n2[1] - e20[3]) / 2, n2[0], n2[1]];
}
var tK = 256;
var nK = Number.MAX_SAFE_INTEGER;
var rK = ["ld_3d", "activation_segmentation", "activation_heatmap", "world_3d", "output_poseflag"];
var aK = [];
var iK = [[0, 0], [0, 0], [0, 0], [0, 0]];
var sK = 0;
var oK = (e20) => 1 - 1 / (1 + Math.exp(e20));
function lK(e20, t2, n2) {
  var r2, a2;
  const i2 = {};
  if (!(null == (r2 = null == e20 ? void 0 : e20.shape) ? void 0 : r2[1]) || !(null == (a2 = null == e20 ? void 0 : e20.shape) ? void 0 : a2[2])) return e20;
  let s2;
  if (n2 && (i2.cropped = mp.cropAndResize(e20, [n2], [0], [e20.shape[1], e20.shape[2]])), e20.shape[1] !== e20.shape[2]) {
    const n3 = [e20.shape[2] > e20.shape[1] ? Math.trunc((e20.shape[2] - e20.shape[1]) / 2) : 0, e20.shape[2] > e20.shape[1] ? Math.trunc((e20.shape[2] - e20.shape[1]) / 2) : 0], r3 = [e20.shape[1] > e20.shape[2] ? Math.trunc((e20.shape[1] - e20.shape[2]) / 2) : 0, e20.shape[1] > e20.shape[2] ? Math.trunc((e20.shape[1] - e20.shape[2]) / 2) : 0];
    i2.pad = md(i2.cropped || e20, iK = [[0, 0], n3, r3, [0, 0]]), i2.resize = mp.resizeBilinear(i2.pad, [t2, t2]), s2 = Ao(i2.resize, Yq.tf255);
  } else e20.shape[1] !== t2 ? (i2.resize = mp.resizeBilinear(i2.cropped || e20, [t2, t2]), s2 = Ao(i2.resize, Yq.tf255)) : s2 = Ao(i2.cropped || e20, Yq.tf255);
  return Object.keys(i2).forEach((e21) => ts(i2[e21])), s2;
}
function uK(e20, t2, n2) {
  return __async(this, null, function* () {
    if (!(null == XZ ? void 0 : XZ.executor)) return null;
    const r2 = {};
    [r2.ld, r2.segmentation, r2.heatmap, r2.world, r2.poseflag] = null == XZ ? void 0 : XZ.execute(e20, rK);
    const a2 = (yield r2.poseflag.data())[0], i2 = yield r2.ld.data(), s2 = yield r2.world.data();
    Object.keys(r2).forEach((e21) => ts(r2[e21]));
    const o2 = [];
    for (let c2 = 0; i2.length / 5 > c2; c2++) {
      const e21 = oK(i2[5 * c2 + 3]), t3 = oK(i2[5 * c2 + 4]), r3 = Math.trunc(100 * e21 * t3 * a2) / 100, l3 = [i2[5 * c2 + 0] / tK, i2[5 * c2 + 1] / tK, i2[5 * c2 + 2] + 0], u3 = [Math.trunc(n2[0] * l3[0]), Math.trunc(n2[1] * l3[1]), l3[2]];
      o2.push({ part: qZ[c2], positionRaw: l3, position: u3, distance: [s2[5 * c2 + 0], s2[5 * c2 + 1], s2[5 * c2 + 2] + 0], score: r3 });
    }
    if ((t2.body.minConfidence || 0) > a2) return null;
    ((e21) => {
      const t3 = e21.find((e22) => "leftPalm" === e22.part), n3 = e21.find((e22) => "leftWrist" === e22.part), r3 = e21.find((e22) => "leftIndex" === e22.part);
      t3.position[2] = ((n3.position[2] || 0) + (r3.position[2] || 0)) / 2;
      const a3 = e21.find((e22) => "rightPalm" === e22.part), i3 = e21.find((e22) => "rightWrist" === e22.part), s3 = e21.find((e22) => "rightIndex" === e22.part);
      a3.position[2] = ((i3.position[2] || 0) + (s3.position[2] || 0)) / 2;
    })(o2);
    const l2 = ((e21, t3) => {
      for (const n3 of e21) n3.position = [Math.trunc(n3.position[0] * (t3[0] + iK[2][0] + iK[2][1]) / t3[0] - iK[2][0]), Math.trunc(n3.position[1] * (t3[1] + iK[1][0] + iK[1][1]) / t3[1] - iK[1][0]), n3.position[2]], n3.positionRaw = [n3.position[0] / t3[0], n3.position[1] / t3[1], 2 * n3.position[2] / (t3[0] + t3[1])];
      return e21;
    })(o2, n2), u2 = JZ(l2.map((e21) => e21.position), [n2[0], n2[1]]), d2 = {};
    for (const [c2, h2] of Object.entries(ZZ)) {
      const e21 = [];
      for (let t3 = 0; h2.length - 1 > t3; t3++) {
        const n3 = l2.find((e22) => e22.part === h2[t3]), r3 = l2.find((e22) => e22.part === h2[t3 + 1]);
        n3 && r3 && e21.push([n3.position, r3.position]);
      }
      d2[c2] = e21;
    }
    return { id: 0, score: Math.trunc(100 * a2) / 100, box: u2.box, boxRaw: u2.boxRaw, keypoints: l2, annotations: d2 };
  });
}
function dK(e20, t2) {
  return __async(this, null, function* () {
    var n2, r2, a2;
    const i2 = [e20.shape[2] || 0, e20.shape[1] || 0], s2 = (t2.body.skipTime || 0) > xX() - sK;
    if (t2.skipAllowed && s2 && (t2.body.skipFrames || 0) > nK && null !== aK) nK++;
    else {
      let s3 = [];
      if (null == (r2 = null == (n2 = t2.body) ? void 0 : n2.detector) ? void 0 : r2.enabled) {
        const n3 = lK(e20, 224);
        s3 = yield ((e21, t3, n4) => __async(null, null, function* () {
          const r3 = {};
          r3.res = null == GZ ? void 0 : GZ.execute(e21, ["Identity"]), r3.logitsRaw = Jo(r3.res, [0, 0, 0], [1, -1, 1]), r3.boxesRaw = Jo(r3.res, [0, 0, 1], [1, -1, -1]), r3.logits = Rc(r3.logitsRaw), r3.boxes = Rc(r3.boxesRaw);
          const a3 = yield ((e22, t4, n5, r4) => __async(null, null, function* () {
            var a4, i3;
            const s4 = [], o2 = {};
            o2.boxes = ((e23, t5) => es(() => {
              const n6 = Nc(e23, 12, 1);
              let r5 = Rc(n6[0]), a5 = Rc(n6[1]), i4 = Rc(n6[2]), s5 = Rc(n6[3]);
              r5 = fo(Ao(r5, KZ), t5.x), a5 = fo(Ao(a5, KZ), t5.y), i4 = xo(Ao(i4, KZ), 5), s5 = xo(Ao(s5, KZ), 5);
              const o3 = Lu(r5, Ao(i4, 2)), l3 = Lu(a5, Ao(s5, 2)), u3 = fo(o3, i4), d3 = fo(l3, s5);
              return Sc([o3, l3, u3, d3], 1);
            }))(e22, HZ), o2.scores = Yo(t4), o2.nms = yield mp.nonMaxSuppressionAsync(o2.boxes, o2.scores, 1, (null == (a4 = n5.body.detector) ? void 0 : a4.minConfidence) || 0.1, (null == (i3 = n5.body.detector) ? void 0 : i3.iouThreshold) || 0.1);
            const l2 = yield o2.nms.data(), u2 = yield o2.scores.data(), d2 = yield o2.boxes.array();
            for (const c2 of Array.from(l2)) {
              const e23 = d2[c2];
              s4.push({ score: u2[c2], boxRaw: e23, box: [Math.round(e23[0] * r4[0]), Math.round(e23[1] * r4[1]), Math.round(e23[2] * r4[0]), Math.round(e23[3] * r4[1])] });
            }
            return Object.keys(o2).forEach((e23) => ts(o2[e23])), s4;
          }))(r3.boxes, r3.logits, t3, n4);
          return Object.keys(r3).forEach((e22) => ts(r3[e22])), a3;
        }))(n3, t2, i2), ts(n3);
      } else s3 = [{ box: [0, 0, 0, 0], boxRaw: [0, 0, 1, 1], score: 0 }];
      for (let n3 = 0; s3.length > n3; n3++) {
        const r3 = lK(e20, 256, null == (a2 = s3[n3]) ? void 0 : a2.boxRaw);
        aK.length = 0;
        const o2 = yield uK(r3, t2, i2);
        ts(r3), o2 && (o2.id = n3, aK.push(o2));
      }
      sK = xX(), nK = 0;
    }
    return aK;
  });
}
var cK;
var hK = [{ class: 1, label: "person" }, { class: 2, label: "bicycle" }, { class: 3, label: "car" }, { class: 4, label: "motorcycle" }, { class: 5, label: "airplane" }, { class: 6, label: "bus" }, { class: 7, label: "train" }, { class: 8, label: "truck" }, { class: 9, label: "boat" }, { class: 10, label: "traffic light" }, { class: 11, label: "fire hydrant" }, { class: 12, label: "stop sign" }, { class: 13, label: "parking meter" }, { class: 14, label: "bench" }, { class: 15, label: "bird" }, { class: 16, label: "cat" }, { class: 17, label: "dog" }, { class: 18, label: "horse" }, { class: 19, label: "sheep" }, { class: 20, label: "cow" }, { class: 21, label: "elephant" }, { class: 22, label: "bear" }, { class: 23, label: "zebra" }, { class: 24, label: "giraffe" }, { class: 25, label: "backpack" }, { class: 26, label: "umbrella" }, { class: 27, label: "handbag" }, { class: 28, label: "tie" }, { class: 29, label: "suitcase" }, { class: 30, label: "frisbee" }, { class: 31, label: "skis" }, { class: 32, label: "snowboard" }, { class: 33, label: "sports ball" }, { class: 34, label: "kite" }, { class: 35, label: "baseball bat" }, { class: 36, label: "baseball glove" }, { class: 37, label: "skateboard" }, { class: 38, label: "surfboard" }, { class: 39, label: "tennis racket" }, { class: 40, label: "bottle" }, { class: 41, label: "wine glass" }, { class: 42, label: "cup" }, { class: 43, label: "fork" }, { class: 44, label: "knife" }, { class: 45, label: "spoon" }, { class: 46, label: "bowl" }, { class: 47, label: "banana" }, { class: 48, label: "apple" }, { class: 49, label: "sandwich" }, { class: 50, label: "orange" }, { class: 51, label: "broccoli" }, { class: 52, label: "carrot" }, { class: 53, label: "hot dog" }, { class: 54, label: "pizza" }, { class: 55, label: "donut" }, { class: 56, label: "cake" }, { class: 57, label: "chair" }, { class: 58, label: "couch" }, { class: 59, label: "potted plant" }, { class: 60, label: "bed" }, { class: 61, label: "dining table" }, { class: 62, label: "toilet" }, { class: 63, label: "tv" }, { class: 64, label: "laptop" }, { class: 65, label: "mouse" }, { class: 66, label: "remote" }, { class: 67, label: "keyboard" }, { class: 68, label: "cell phone" }, { class: 69, label: "microwave" }, { class: 70, label: "oven" }, { class: 71, label: "toaster" }, { class: 72, label: "sink" }, { class: 73, label: "refrigerator" }, { class: 74, label: "book" }, { class: 75, label: "clock" }, { class: 76, label: "vase" }, { class: 77, label: "scissors" }, { class: 78, label: "teddy bear" }, { class: 79, label: "hair drier" }, { class: 80, label: "toothbrush" }];
var pK = 0;
var fK = [];
var mK = 0;
var AK = Number.MAX_SAFE_INTEGER;
function xK(e20, t2) {
  return __async(this, null, function* () {
    if (!(null == cK ? void 0 : cK.executor)) return [];
    const n2 = (t2.object.skipTime || 0) > xX() - mK;
    return t2.skipAllowed && n2 && (t2.object.skipFrames || 0) > AK && fK.length > 0 ? (AK++, fK) : (AK = 0, new Promise((n3) => __async(null, null, function* () {
      const r2 = [e20.shape[2] || 0, e20.shape[1] || 0], a2 = mp.resizeBilinear(e20, [pK, pK]), i2 = t2.object.enabled ? null == cK ? void 0 : cK.execute(a2, ["tower_0/detections"]) : null;
      mK = xX(), ts(a2);
      const s2 = yield ((e21, t3, n4) => __async(null, null, function* () {
        if (!e21) return [];
        const r3 = {}, a3 = [], i3 = yield e21.array();
        r3.squeeze = Rc(e21);
        const s3 = Nc(r3.squeeze, 6, 1);
        r3.stack = Sc([s3[1], s3[0], s3[3], s3[2]], 1), r3.boxes = Rc(r3.stack), r3.scores = Rc(s3[4]), r3.classes = Rc(s3[5]), ts([e21, ...s3]), r3.nms = yield mp.nonMaxSuppressionAsync(r3.boxes, r3.scores, n4.object.maxDetected || 0, n4.object.iouThreshold, n4.object.minConfidence || 0);
        const o2 = yield r3.nms.data();
        let l2 = 0;
        for (const u2 of Array.from(o2)) {
          const e22 = Math.trunc(100 * i3[0][u2][4]) / 100, n5 = i3[0][u2][5];
          if (Number.isNaN(n5)) continue;
          const r4 = hK[n5].label, [s4, o3] = [i3[0][u2][0] / pK, i3[0][u2][1] / pK], d2 = [s4, o3, i3[0][u2][2] / pK - s4, i3[0][u2][3] / pK - o3], c2 = [Math.trunc(d2[0] * t3[0]), Math.trunc(d2[1] * t3[1]), Math.trunc(d2[2] * t3[0]), Math.trunc(d2[3] * t3[1])];
          a3.push({ id: l2++, score: e22, class: n5, label: r4, box: c2, boxRaw: d2 });
        }
        return Object.keys(r3).forEach((e22) => ts(r3[e22])), a3;
      }))(i2, r2, t2);
      fK = s2, n3(s2);
    })));
  });
}
var yK = {};
n(yK, { connected() {
  return vK;
}, kpt() {
  return gK;
} });
var bK;
var gK = ["head", "neck", "rightShoulder", "rightElbow", "rightWrist", "chest", "leftShoulder", "leftElbow", "leftWrist", "bodyCenter", "rightHip", "rightKnee", "rightAnkle", "leftHip", "leftKnee", "leftAnkle"];
var vK = { leftLeg: ["leftHip", "leftKnee", "leftAnkle"], rightLeg: ["rightHip", "rightKnee", "rightAnkle"], torso: ["leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder"], leftArm: ["leftShoulder", "leftElbow", "leftWrist"], rightArm: ["rightShoulder", "rightElbow", "rightWrist"], head: [] };
var wK = 0;
var kK = { id: 0, keypoints: [], box: [0, 0, 0, 0], boxRaw: [0, 0, 0, 0], score: 0, annotations: {} };
var NK = Number.MAX_SAFE_INTEGER;
function CK(e20, t2) {
  return __async(this, null, function* () {
    const [n2, r2] = e20.shape, a2 = Ho(e20, [r2 * n2]), i2 = tu(a2, 0), s2 = (yield i2.data())[0];
    if (s2 > t2) {
      const e21 = No(a2, 0), t3 = od(e21, n2), r3 = (yield t3.data())[0], o2 = Ao(e21, n2), l2 = (yield o2.data())[0];
      return ts([a2, i2, e21, t3, o2]), [r3, l2, s2];
    }
    return ts([a2, i2]), [0, 0, s2];
  });
}
function $K(e20, t2) {
  return __async(this, null, function* () {
    if (!(null == bK ? void 0 : bK.executor) || !(null == bK ? void 0 : bK.inputs[0].shape)) return [];
    const n2 = (t2.body.skipTime || 0) > xX() - wK;
    return t2.skipAllowed && n2 && (t2.body.skipFrames || 0) > NK && Object.keys(kK.keypoints).length > 0 ? (NK++, [kK]) : (NK = 0, new Promise((n3) => __async(null, null, function* () {
      const r2 = es(() => {
        var t3, n4;
        const r3 = mp.resizeBilinear(e20, [(null == (t3 = null == bK ? void 0 : bK.inputs[0].shape) ? void 0 : t3[2]) || 0, (null == (n4 = null == bK ? void 0 : bK.inputs[0].shape) ? void 0 : n4[1]) || 0], false), a3 = xo(r3, Yq.tf2);
        return Lu(a3, Yq.tf1);
      });
      let a2;
      if (t2.body.enabled && (a2 = null == bK ? void 0 : bK.execute(r2)), wK = xX(), ts(r2), a2) {
        kK.keypoints.length = 0;
        const n4 = Rc(a2);
        ts(a2);
        const r3 = Xc(n4, 2);
        ts(n4);
        for (let a3 = 0; r3.length > a3; a3++) {
          const [n5, i3, s3] = yield CK(r3[a3], t2.body.minConfidence);
          s3 > (t2.body.minConfidence || 0) && kK.keypoints.push({ score: Math.round(100 * s3) / 100, part: gK[a3], positionRaw: [n5 / bK.inputs[0].shape[2], i3 / bK.inputs[0].shape[1]], position: [Math.round(e20.shape[2] * n5 / bK.inputs[0].shape[2]), Math.round(e20.shape[1] * i3 / bK.inputs[0].shape[1])] });
        }
        r3.forEach((e21) => ts(e21));
      }
      kK.score = kK.keypoints.reduce((e21, t3) => t3.score > e21 ? t3.score : e21, 0);
      const i2 = kK.keypoints.map((e21) => e21.position[0]), s2 = kK.keypoints.map((e21) => e21.position[1]);
      kK.box = [Math.min(...i2), Math.min(...s2), Math.max(...i2) - Math.min(...i2), Math.max(...s2) - Math.min(...s2)];
      const o2 = kK.keypoints.map((e21) => e21.positionRaw[0]), l2 = kK.keypoints.map((e21) => e21.positionRaw[1]);
      kK.boxRaw = [Math.min(...o2), Math.min(...l2), Math.max(...o2) - Math.min(...o2), Math.max(...l2) - Math.min(...l2)];
      for (const [e21, u2] of Object.entries(vK)) {
        const n4 = [];
        for (let e22 = 0; u2.length - 1 > e22; e22++) {
          const r3 = kK.keypoints.find((t3) => t3.part === u2[e22]), a3 = kK.keypoints.find((t3) => t3.part === u2[e22 + 1]);
          r3 && a3 && r3.score > (t2.body.minConfidence || 0) && a3.score > (t2.body.minConfidence || 0) && n4.push([r3.position, a3.position]);
        }
        kK.annotations[e21] = n4;
      }
      n3([kK]);
    })));
  });
}
var RK = (e20) => [Math.abs(e20.endPoint[0] - e20.startPoint[0]), Math.abs(e20.endPoint[1] - e20.startPoint[1])];
var SK = (e20) => [e20.startPoint[0] + (e20.endPoint[0] - e20.startPoint[0]) / 2, e20.startPoint[1] + (e20.endPoint[1] - e20.startPoint[1]) / 2, 1];
var IK = (e20, t2) => e20 ? [Math.trunc(Math.max(0, e20.startPoint[0])), Math.trunc(Math.max(0, e20.startPoint[1])), Math.trunc(Math.min(t2.shape[2] || 0, e20.endPoint[0]) - Math.max(0, e20.startPoint[0])), Math.trunc(Math.min(t2.shape[1] || 0, e20.endPoint[1]) - Math.max(0, e20.startPoint[1]))] : [0, 0, 0, 0];
var EK = (e20, t2) => e20 ? [e20.startPoint[0] / (t2.shape[2] || 0), e20.startPoint[1] / (t2.shape[1] || 0), (e20.endPoint[0] - e20.startPoint[0]) / (t2.shape[2] || 0), (e20.endPoint[1] - e20.startPoint[1]) / (t2.shape[1] || 0)] : [0, 0, 0, 0];
var TK = (e20, t2, n2) => ({ startPoint: [e20.startPoint[0] * t2[0], e20.startPoint[1] * t2[1]], endPoint: [e20.endPoint[0] * t2[0], e20.endPoint[1] * t2[1]], landmarks: e20.landmarks.map((e21) => [(e21[0] + n2[0]) * t2[0], (e21[1] + n2[1]) * t2[1]]), confidence: e20.confidence });
var MK = (e20, t2, n2) => {
  const r2 = t2.shape[1], a2 = t2.shape[2], i2 = mp.cropAndResize(t2, [[e20.startPoint[1] / r2, e20.startPoint[0] / a2, e20.endPoint[1] / r2, e20.endPoint[0] / a2]], [0], n2), s2 = Ao(i2, Yq.tf255);
  return ts(i2), s2;
};
var OK = (e20, t2) => {
  const n2 = SK(e20), r2 = RK(e20), a2 = [t2 * r2[0] / 2, t2 * r2[1] / 2];
  return { startPoint: [n2[0] - a2[0], n2[1] - a2[1]], endPoint: [n2[0] + a2[0], n2[1] + a2[1]], landmarks: e20.landmarks, confidence: e20.confidence, size: r2 };
};
var FK = (e20) => {
  const t2 = SK(e20), n2 = RK(e20), r2 = Math.max(...n2) / 2;
  return { startPoint: [Math.round(t2[0] - r2), Math.round(t2[1] - r2)], endPoint: [Math.round(t2[0] + r2), Math.round(t2[1] + r2)], landmarks: e20.landmarks, confidence: e20.confidence, size: [Math.round(n2[0]), Math.round(n2[1])] };
};
var PK = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
var zK = (e20, t2) => [[1, 0, e20], [0, 1, t2], [0, 0, 1]];
var VK = (e20, t2) => {
  let n2 = 0;
  for (let r2 = 0; e20.length > r2; r2++) n2 += e20[r2] * t2[r2];
  return n2;
};
var _K = (e20, t2) => {
  const n2 = [];
  for (let r2 = 0; e20.length > r2; r2++) n2.push(e20[r2][t2]);
  return n2;
};
var DK = (e20, t2) => {
  const n2 = [], r2 = e20.length;
  for (let a2 = 0; r2 > a2; a2++) {
    n2.push([]);
    for (let i2 = 0; r2 > i2; i2++) n2[a2].push(VK(e20[a2], _K(t2, i2)));
  }
  return n2;
};
var WK = (e20, t2) => {
  const n2 = Math.cos(e20), r2 = Math.sin(e20), a2 = [[n2, -r2, 0], [r2, n2, 0], [0, 0, 1]], i2 = zK(t2[0], t2[1]), s2 = DK(i2, a2), o2 = zK(-t2[0], -t2[1]);
  return DK(s2, o2);
};
var LK = (e20, t2) => [VK(e20, t2[0]), VK(e20, t2[1])];
function BK(e20, t2, n2, r2, a2) {
  const i2 = RK(t2), s2 = e20.map((e21) => [i2[0] / a2 * (e21[0] - a2 / 2), i2[1] / a2 * (e21[1] - a2 / 2), e21[2] || 0]), o2 = n2 && 0 !== n2 && Math.abs(n2) > 0.2, l2 = o2 ? WK(n2, [0, 0]) : PK, u2 = o2 ? s2.map((e21) => [...LK(e21, l2), e21[2]]) : s2, d2 = o2 ? ((e21) => {
    const t3 = [[e21[0][0], e21[1][0]], [e21[0][1], e21[1][1]]], n3 = [e21[0][2], e21[1][2]], r3 = [-VK(t3[0], n3), -VK(t3[1], n3)];
    return [t3[0].concat(r3[0]), t3[1].concat(r3[1]), [0, 0, 1]];
  })(r2) : PK, c2 = SK(t2), h2 = [VK(c2, d2[0]), VK(c2, d2[1])];
  return u2.map((e21) => [Math.trunc(e21[0] + h2[0]), Math.trunc(e21[1] + h2[1]), Math.trunc(e21[2] || 0)]);
}
function UK(e20, t2, n2, r2) {
  const a2 = fZ.count > t2.landmarks.length ? mZ.symmetryLine : fZ.symmetryLine;
  let i2, s2 = 0, o2 = PK;
  if (e20 && _X.kernels.includes("rotatewithoffset")) if (s2 = ((e21, t3) => {
    return (n3 = Math.PI / 2 - Math.atan2(-(t3[1] - e21[1]), t3[0] - e21[0])) - 2 * Math.PI * Math.floor((n3 + Math.PI) / (2 * Math.PI));
    var n3;
  })(t2.landmarks[a2[0]], t2.landmarks[a2[1]]), s2 && 0 !== s2 && Math.abs(s2) > 0.2) {
    const e21 = SK(t2), a3 = [e21[0] / n2.shape[2], e21[1] / n2.shape[1]], l2 = mp.rotateWithOffset(n2, s2, 0, [a3[0], a3[1]]);
    o2 = WK(-s2, e21), i2 = MK(t2, l2, [r2, r2]), ts(l2);
  } else i2 = MK(t2, n2, [r2, r2]);
  else i2 = MK(t2, n2, [r2, r2]);
  return [s2, o2, i2];
}
var jK;
var GK;
var HK = (e20, t2) => {
  const n2 = ((e21) => {
    const t3 = e21.map((e22) => e22[0]), n3 = e21.map((e22) => e22[1]);
    return [Math.min(...t3) + (Math.max(...t3) - Math.min(...t3)) / 2, Math.min(...n3) + (Math.max(...n3) - Math.min(...n3)) / 2];
  })(e20), r2 = RK(t2);
  return { startPoint: [n2[0] - r2[0] / 2, n2[1] - r2[1] / 2], endPoint: [n2[0] + r2[0] / 2, n2[1] + r2[1] / 2] };
};
var XK = null;
var qK = 0;
var ZK = null;
var KK = () => qK;
var YK = 0;
var JK = pZ.leftEyeLower0;
var QK = pZ.rightEyeLower0;
var eY = { leftBounds: [JK[0], JK[JK.length - 1]], rightBounds: [QK[0], QK[QK.length - 1]] };
function tY(e20, t2, n2, r2) {
  for (let a2 = 0; AZ.length > a2; a2++) {
    const { key: i2, indices: s2 } = AZ[a2], o2 = pZ[`${n2}${i2}`];
    if (!r2 || r2.includes(i2)) for (let n3 = 0; s2.length > n3; n3++) {
      const r3 = s2[n3];
      e20[o2[n3]] = [t2[r3][0], t2[r3][1], (t2[r3][2] + e20[o2[n3]][2]) / 2];
    }
  }
}
var nY = (e20, t2, n2, r2, a2, i2 = false, s2 = 2.3) => {
  const o2 = FK(OK(((e21) => {
    const t3 = e21.map((e22) => e22[0]), n3 = e21.map((e22) => e22[1]);
    return { startPoint: [Math.min(...t3), Math.min(...n3)], endPoint: [Math.max(...t3), Math.max(...n3)], landmarks: e21 };
  })([e20[n2], e20[r2]]), s2)), l2 = RK(o2);
  let u2 = mp.cropAndResize(t2, [[o2.startPoint[1] / a2, o2.startPoint[0] / a2, o2.endPoint[1] / a2, o2.endPoint[0] / a2]], [0], [YK, YK]);
  if (i2 && _X.kernels.includes("flipleftright")) {
    const e21 = mp.flipLeftRight(u2);
    ts(u2), u2 = e21;
  }
  return { box: o2, boxSize: l2, crop: u2 };
};
var rY = (e20, t2, n2, r2 = false) => {
  const a2 = [];
  for (let i2 = 0; 76 > i2; i2++) {
    const s2 = e20[3 * i2];
    a2.push([(r2 ? 1 - s2 / YK : s2 / YK) * n2[0] + t2.startPoint[0], e20[3 * i2 + 1] / YK * n2[1] + t2.startPoint[1], e20[3 * i2 + 2]]);
  }
  return { rawCoords: a2, iris: a2.slice(71) };
};
var aY = (e20, t2, n2) => {
  const r2 = e20[pZ[n2 + "EyeUpper0"][3]][2], a2 = e20[pZ[n2 + "EyeLower0"][4]][2], i2 = (r2 + a2) / 2;
  return t2.map((e21, t3) => {
    let n3 = i2;
    return 2 === t3 ? n3 = r2 : 4 === t3 && (n3 = a2), [e21[0], e21[1], n3];
  });
};
function iY(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2;
    if (!(null == GK ? void 0 : GK.executor)) return e20;
    const { box: s2, boxSize: o2, crop: l2 } = nY(e20, t2, eY.leftBounds[0], eY.leftBounds[1], n2, true, (null == (a2 = r2.face.iris) ? void 0 : a2.scale) || 2.3), { box: u2, boxSize: d2, crop: c2 } = nY(e20, t2, eY.rightBounds[0], eY.rightBounds[1], n2, true, (null == (i2 = r2.face.iris) ? void 0 : i2.scale) || 2.3), h2 = Zo([l2, c2]);
    ts(l2), ts(c2);
    const p2 = GK.execute(h2);
    ts(h2);
    const f2 = yield p2.data();
    ts(p2);
    const m2 = f2.slice(0, 228), { rawCoords: A2, iris: x2 } = rY(m2, s2, o2, true), y2 = f2.slice(228), { rawCoords: b2, iris: g2 } = rY(y2, u2, d2, false), v2 = ((e21) => e21[eY.leftBounds[0]][2] - e21[eY.rightBounds[0]][2])(e20);
    30 > Math.abs(v2) ? (tY(e20, A2, "left", null), tY(e20, b2, "right", null)) : 1 > v2 ? tY(e20, A2, "left", ["EyeUpper0", "EyeLower0"]) : tY(e20, b2, "right", ["EyeUpper0", "EyeLower0"]);
    const w2 = aY(e20, x2, "left"), k2 = aY(e20, g2, "right");
    return e20.concat(w2).concat(k2);
  });
}
function sY(e20, t2) {
  return __async(this, null, function* () {
    var n2, r2, a2, i2, s2, o2, l2, u2, d2, c2;
    const h2 = { lips: yield null == (r2 = null == (n2 = t2.filter((e21) => 160 === e21.size)) ? void 0 : n2[0]) ? void 0 : r2.data(), irisL: yield null == (i2 = null == (a2 = t2.filter((e21) => 10 === e21.size)) ? void 0 : a2[0]) ? void 0 : i2.data(), eyeL: yield null == (o2 = null == (s2 = t2.filter((e21) => 142 === e21.size)) ? void 0 : s2[0]) ? void 0 : o2.data(), irisR: yield null == (u2 = null == (l2 = t2.filter((e21) => 10 === e21.size)) ? void 0 : l2[1]) ? void 0 : u2.data(), eyeR: yield null == (c2 = null == (d2 = t2.filter((e21) => 142 === e21.size)) ? void 0 : d2[1]) ? void 0 : c2.data() };
    for (const m2 of Object.values(h2)) if (!m2) return e20;
    const p2 = NZ.reduce((t3, n3) => t3 + e20[n3][2], 0) / NZ.length;
    for (let m2 = 0; h2.irisL.length / 2 > m2; m2++) e20.push([h2.irisL[2 * m2 + 0], h2.irisL[2 * m2 + 1], p2]);
    const f2 = CZ.reduce((t3, n3) => t3 + e20[n3][2], 0) / CZ.length;
    for (let m2 = 0; h2.irisR.length / 2 > m2; m2++) e20.push([h2.irisR[2 * m2 + 0], h2.irisR[2 * m2 + 1], f2]);
    for (let m2 = 0; h2.eyeL.length / 2 > m2; m2++) e20[NZ[m2]] = [h2.eyeL[2 * m2 + 0], h2.eyeL[2 * m2 + 1], e20[NZ[m2]][2]];
    for (let m2 = 0; h2.eyeR.length / 2 > m2; m2++) e20[CZ[m2]] = [h2.eyeR[2 * m2 + 0], h2.eyeR[2 * m2 + 1], e20[CZ[m2]][2]];
    for (let m2 = 0; h2.lips.length / 2 > m2; m2++) e20[kZ[m2]] = [h2.lips[2 * m2 + 0], h2.lips[2 * m2 + 1], e20[kZ[m2]][2]];
    return e20;
  });
}
var oY;
var lY;
var uY = { boxes: [], skipped: Number.MAX_SAFE_INTEGER, timestamp: 0 };
var dY = null;
var cY = 0;
var hY = xZ;
var pY = [[0.499976992607117, 0.652534008026123], [0.500025987625122, 0.547487020492554], [0.499974012374878, 0.602371990680695], [0.482113003730774, 0.471979022026062], [0.500150978565216, 0.527155995368958], [0.499909996986389, 0.498252987861633], [0.499523013830185, 0.40106201171875], [0.289712011814117, 0.380764007568359], [0.499954998493195, 0.312398016452789], [0.499987006187439, 0.269918978214264], [0.500023007392883, 0.107050001621246], [0.500023007392883, 0.666234016418457], [0.5000159740448, 0.679224014282227], [0.500023007392883, 0.692348003387451], [0.499976992607117, 0.695277988910675], [0.499976992607117, 0.70593398809433], [0.499976992607117, 0.719385027885437], [0.499976992607117, 0.737019002437592], [0.499967992305756, 0.781370997428894], [0.499816000461578, 0.562981009483337], [0.473773002624512, 0.573909997940063], [0.104906998574734, 0.254140973091125], [0.365929991006851, 0.409575998783112], [0.338757991790771, 0.41302502155304], [0.311120003461838, 0.409460008144379], [0.274657994508743, 0.389131009578705], [0.393361985683441, 0.403706014156342], [0.345234006643295, 0.344011008739471], [0.370094001293182, 0.346076011657715], [0.319321990013123, 0.347265005111694], [0.297903001308441, 0.353591024875641], [0.24779200553894, 0.410809993743896], [0.396889001131058, 0.842755019664764], [0.280097991228104, 0.375599980354309], [0.106310002505779, 0.399955987930298], [0.2099249958992, 0.391353011131287], [0.355807989835739, 0.534406006336212], [0.471751004457474, 0.65040397644043], [0.474155008792877, 0.680191993713379], [0.439785003662109, 0.657229006290436], [0.414617002010345, 0.66654098033905], [0.450374007225037, 0.680860996246338], [0.428770989179611, 0.682690978050232], [0.374971002340317, 0.727805018424988], [0.486716985702515, 0.547628998756409], [0.485300987958908, 0.527395009994507], [0.257764995098114, 0.314490020275116], [0.401223003864288, 0.455172002315521], [0.429818987846375, 0.548614978790283], [0.421351999044418, 0.533740997314453], [0.276895999908447, 0.532056987285614], [0.483370006084442, 0.499586999416351], [0.33721199631691, 0.282882988452911], [0.296391993761063, 0.293242990970612], [0.169294998049736, 0.193813979625702], [0.447580009698868, 0.302609980106354], [0.392390012741089, 0.353887975215912], [0.354490011930466, 0.696784019470215], [0.067304998636246, 0.730105042457581], [0.442739009857178, 0.572826027870178], [0.457098007202148, 0.584792017936707], [0.381974011659622, 0.694710969924927], [0.392388999462128, 0.694203019142151], [0.277076005935669, 0.271932005882263], [0.422551989555359, 0.563233017921448], [0.385919004678726, 0.281364023685455], [0.383103013038635, 0.255840003490448], [0.331431001424789, 0.119714021682739], [0.229923993349075, 0.232002973556519], [0.364500999450684, 0.189113974571228], [0.229622006416321, 0.299540996551514], [0.173287004232407, 0.278747975826263], [0.472878992557526, 0.666198015213013], [0.446828007698059, 0.668527007102966], [0.422762006521225, 0.673889994621277], [0.445307999849319, 0.580065965652466], [0.388103008270264, 0.693961024284363], [0.403039008378983, 0.706539988517761], [0.403629004955292, 0.693953037261963], [0.460041999816895, 0.557139039039612], [0.431158006191254, 0.692366003990173], [0.452181994915009, 0.692366003990173], [0.475387006998062, 0.692366003990173], [0.465828001499176, 0.779190003871918], [0.472328990697861, 0.736225962638855], [0.473087012767792, 0.717857003211975], [0.473122000694275, 0.704625964164734], [0.473033010959625, 0.695277988910675], [0.427942007780075, 0.695277988910675], [0.426479011774063, 0.703539967536926], [0.423162013292313, 0.711845993995667], [0.4183090031147, 0.720062971115112], [0.390094995498657, 0.639572978019714], [0.013953999616206, 0.560034036636353], [0.499913990497589, 0.58014702796936], [0.413199990987778, 0.69539999961853], [0.409626007080078, 0.701822996139526], [0.468080013990402, 0.601534962654114], [0.422728985548019, 0.585985004901886], [0.463079988956451, 0.593783974647522], [0.37211999297142, 0.47341400384903], [0.334562003612518, 0.496073007583618], [0.411671012639999, 0.546965003013611], [0.242175996303558, 0.14767599105835], [0.290776997804642, 0.201445996761322], [0.327338010072708, 0.256527006626129], [0.399509996175766, 0.748921036720276], [0.441727995872498, 0.261676013469696], [0.429764986038208, 0.187834024429321], [0.412198007106781, 0.108901023864746], [0.288955003023148, 0.398952007293701], [0.218936994671822, 0.435410976409912], [0.41278201341629, 0.398970007896423], [0.257135003805161, 0.355440020561218], [0.427684992551804, 0.437960982322693], [0.448339998722076, 0.536936044692993], [0.178560003638268, 0.45755398273468], [0.247308000922203, 0.457193970680237], [0.286267012357712, 0.467674970626831], [0.332827985286713, 0.460712015628815], [0.368755996227264, 0.447206974029541], [0.398963987827301, 0.432654976844788], [0.476410001516342, 0.405806005001068], [0.189241006970406, 0.523923993110657], [0.228962004184723, 0.348950982093811], [0.490725994110107, 0.562400996685028], [0.404670000076294, 0.485132992267609], [0.019469000399113, 0.401564002037048], [0.426243007183075, 0.420431017875671], [0.396993011236191, 0.548797011375427], [0.266469985246658, 0.376977026462555], [0.439121007919312, 0.51895797252655], [0.032313998788595, 0.644356966018677], [0.419054001569748, 0.387154996395111], [0.462783008813858, 0.505746960639954], [0.238978996872902, 0.779744982719421], [0.198220998048782, 0.831938028335571], [0.107550002634525, 0.540755033493042], [0.183610007166862, 0.740257024765015], [0.134409993886948, 0.333683013916016], [0.385764002799988, 0.883153975009918], [0.490967005491257, 0.579378008842468], [0.382384985685349, 0.508572995662689], [0.174399003386497, 0.397670984268188], [0.318785011768341, 0.39623498916626], [0.343364000320435, 0.400596976280212], [0.396100014448166, 0.710216999053955], [0.187885001301765, 0.588537991046906], [0.430987000465393, 0.944064974784851], [0.318993002176285, 0.898285031318665], [0.266247987747192, 0.869701027870178], [0.500023007392883, 0.190576016902924], [0.499976992607117, 0.954452991485596], [0.366169989109039, 0.398822009563446], [0.393207013607025, 0.39553701877594], [0.410373002290726, 0.391080021858215], [0.194993004202843, 0.342101991176605], [0.388664990663528, 0.362284004688263], [0.365961998701096, 0.355970978736877], [0.343364000320435, 0.355356991291046], [0.318785011768341, 0.35834002494812], [0.301414996385574, 0.363156020641327], [0.058132998645306, 0.319076001644135], [0.301414996385574, 0.387449026107788], [0.499987989664078, 0.618434011936188], [0.415838003158569, 0.624195992946625], [0.445681989192963, 0.566076993942261], [0.465844005346298, 0.620640993118286], [0.49992299079895, 0.351523995399475], [0.288718998432159, 0.819945991039276], [0.335278987884521, 0.852819979190826], [0.440512001514435, 0.902418971061707], [0.128294005990028, 0.791940987110138], [0.408771991729736, 0.373893976211548], [0.455606997013092, 0.451801002025604], [0.499877005815506, 0.908990025520325], [0.375436991453171, 0.924192011356354], [0.11421000212431, 0.615022003650665], [0.448662012815475, 0.695277988910675], [0.4480200111866, 0.704632043838501], [0.447111994028091, 0.715808033943176], [0.444831997156143, 0.730794012546539], [0.430011987686157, 0.766808986663818], [0.406787008047104, 0.685672998428345], [0.400738000869751, 0.681069016456604], [0.392399996519089, 0.677703022956848], [0.367855995893478, 0.663918972015381], [0.247923001646996, 0.601333022117615], [0.452769994735718, 0.420849978923798], [0.43639200925827, 0.359887003898621], [0.416164010763168, 0.368713974952698], [0.413385987281799, 0.692366003990173], [0.228018000721931, 0.683571994304657], [0.468268007040024, 0.352671027183533], [0.411361992359161, 0.804327011108398], [0.499989002943039, 0.469825029373169], [0.479153990745544, 0.442654013633728], [0.499974012374878, 0.439637005329132], [0.432112008333206, 0.493588984012604], [0.499886006116867, 0.866917014122009], [0.49991300702095, 0.821729004383087], [0.456548988819122, 0.819200992584229], [0.344549000263214, 0.745438992977142], [0.37890899181366, 0.574010014533997], [0.374292999505997, 0.780184984207153], [0.319687992334366, 0.570737957954407], [0.357154995203018, 0.604269981384277], [0.295284003019333, 0.621580958366394], [0.447750002145767, 0.862477004528046], [0.410986006259918, 0.508723020553589], [0.31395098567009, 0.775308012962341], [0.354128003120422, 0.812552988529205], [0.324548006057739, 0.703992962837219], [0.189096003770828, 0.646299958229065], [0.279776990413666, 0.71465802192688], [0.1338230073452, 0.682700991630554], [0.336768001317978, 0.644733011722565], [0.429883986711502, 0.466521978378296], [0.455527991056442, 0.548622965812683], [0.437114000320435, 0.558896005153656], [0.467287987470627, 0.529924988746643], [0.414712011814117, 0.335219979286194], [0.37704598903656, 0.322777986526489], [0.344107985496521, 0.320150971412659], [0.312875986099243, 0.32233202457428], [0.283526003360748, 0.333190023899078], [0.241245999932289, 0.382785975933075], [0.102986000478268, 0.468762993812561], [0.267612010240555, 0.424560010433197], [0.297879010438919, 0.433175981044769], [0.333433985710144, 0.433878004550934], [0.366427004337311, 0.426115989685059], [0.396012008190155, 0.416696012020111], [0.420121014118195, 0.41022801399231], [0.007561000064015, 0.480777025222778], [0.432949006557465, 0.569517970085144], [0.458638995885849, 0.479089021682739], [0.473466008901596, 0.545744001865387], [0.476087987422943, 0.563830018043518], [0.468472003936768, 0.555056989192963], [0.433990985155106, 0.582361996173859], [0.483518004417419, 0.562983989715576], [0.482482999563217, 0.57784903049469], [0.42645001411438, 0.389798998832703], [0.438998997211456, 0.39649498462677], [0.450067013502121, 0.400434017181396], [0.289712011814117, 0.368252992630005], [0.276670008897781, 0.363372981548309], [0.517862021923065, 0.471948027610779], [0.710287988185883, 0.380764007568359], [0.526226997375488, 0.573909997940063], [0.895093023777008, 0.254140973091125], [0.634069979190826, 0.409575998783112], [0.661242008209229, 0.41302502155304], [0.688880026340485, 0.409460008144379], [0.725341975688934, 0.389131009578705], [0.606630027294159, 0.40370500087738], [0.654766023159027, 0.344011008739471], [0.629905998706818, 0.346076011657715], [0.680678009986877, 0.347265005111694], [0.702096998691559, 0.353591024875641], [0.75221198797226, 0.410804986953735], [0.602918028831482, 0.842862963676453], [0.719901978969574, 0.375599980354309], [0.893692970275879, 0.399959981441498], [0.790081977844238, 0.391354024410248], [0.643998026847839, 0.534487962722778], [0.528249025344849, 0.65040397644043], [0.525849997997284, 0.680191040039062], [0.560214996337891, 0.657229006290436], [0.585384011268616, 0.66654098033905], [0.549625992774963, 0.680860996246338], [0.57122802734375, 0.682691991329193], [0.624852001667023, 0.72809898853302], [0.513050019741058, 0.547281980514526], [0.51509702205658, 0.527251958847046], [0.742246985435486, 0.314507007598877], [0.598631024360657, 0.454979002475739], [0.570338010787964, 0.548575043678284], [0.578631997108459, 0.533622980117798], [0.723087012767792, 0.532054007053375], [0.516445994377136, 0.499638974666595], [0.662801027297974, 0.282917976379395], [0.70362401008606, 0.293271005153656], [0.830704987049103, 0.193813979625702], [0.552385985851288, 0.302568018436432], [0.607609987258911, 0.353887975215912], [0.645429015159607, 0.696707010269165], [0.932694971561432, 0.730105042457581], [0.557260990142822, 0.572826027870178], [0.542901992797852, 0.584792017936707], [0.6180260181427, 0.694710969924927], [0.607590973377228, 0.694203019142151], [0.722943007946014, 0.271963000297546], [0.577413976192474, 0.563166975975037], [0.614082992076874, 0.281386971473694], [0.616907000541687, 0.255886018276215], [0.668509006500244, 0.119913995265961], [0.770092010498047, 0.232020974159241], [0.635536015033722, 0.189248979091644], [0.77039098739624, 0.299556016921997], [0.826722025871277, 0.278755009174347], [0.527121007442474, 0.666198015213013], [0.553171992301941, 0.668527007102966], [0.577238023281097, 0.673889994621277], [0.554691970348358, 0.580065965652466], [0.611896991729736, 0.693961024284363], [0.59696102142334, 0.706539988517761], [0.596370995044708, 0.693953037261963], [0.539958000183105, 0.557139039039612], [0.568841993808746, 0.692366003990173], [0.547818005084991, 0.692366003990173], [0.52461302280426, 0.692366003990173], [0.534089982509613, 0.779141008853912], [0.527670979499817, 0.736225962638855], [0.526912987232208, 0.717857003211975], [0.526877999305725, 0.704625964164734], [0.526966989040375, 0.695277988910675], [0.572058022022247, 0.695277988910675], [0.573521018028259, 0.703539967536926], [0.57683801651001, 0.711845993995667], [0.581691026687622, 0.720062971115112], [0.609944999217987, 0.639909982681274], [0.986046016216278, 0.560034036636353], [0.5867999792099, 0.69539999961853], [0.590372025966644, 0.701822996139526], [0.531915009021759, 0.601536989212036], [0.577268004417419, 0.585934996604919], [0.536915004253387, 0.593786001205444], [0.627542972564697, 0.473352015018463], [0.665585994720459, 0.495950996875763], [0.588353991508484, 0.546862006187439], [0.757824003696442, 0.14767599105835], [0.709249973297119, 0.201507985591888], [0.672684013843536, 0.256581008434296], [0.600408971309662, 0.74900496006012], [0.55826598405838, 0.261672019958496], [0.570303976535797, 0.187870979309082], [0.588165998458862, 0.109044015407562], [0.711045026779175, 0.398952007293701], [0.781069993972778, 0.435405015945435], [0.587247014045715, 0.398931980133057], [0.742869973182678, 0.355445981025696], [0.572156012058258, 0.437651991844177], [0.55186802148819, 0.536570012569427], [0.821442008018494, 0.457556009292603], [0.752701997756958, 0.457181990146637], [0.71375697851181, 0.467626988887787], [0.66711300611496, 0.460672974586487], [0.631101012229919, 0.447153985500336], [0.6008620262146, 0.432473003864288], [0.523481011390686, 0.405627012252808], [0.810747981071472, 0.523926019668579], [0.771045982837677, 0.348959028720856], [0.509127020835876, 0.562718033790588], [0.595292985439301, 0.485023975372314], [0.980530977249146, 0.401564002037048], [0.573499977588654, 0.420000016689301], [0.602994978427887, 0.548687994480133], [0.733529984951019, 0.376977026462555], [0.560611009597778, 0.519016981124878], [0.967685997486115, 0.644356966018677], [0.580985009670258, 0.387160003185272], [0.537728011608124, 0.505385041236877], [0.760966002941132, 0.779752969741821], [0.801778972148895, 0.831938028335571], [0.892440974712372, 0.54076099395752], [0.816350996494293, 0.740260004997253], [0.865594983100891, 0.333687007427216], [0.614073991775513, 0.883246004581451], [0.508952975273132, 0.579437971115112], [0.617941975593567, 0.508316040039062], [0.825608015060425, 0.397674977779388], [0.681214988231659, 0.39623498916626], [0.656635999679565, 0.400596976280212], [0.603900015354156, 0.710216999053955], [0.81208598613739, 0.588539004325867], [0.56801301240921, 0.944564998149872], [0.681007981300354, 0.898285031318665], [0.733752012252808, 0.869701027870178], [0.633830010890961, 0.398822009563446], [0.606792986392975, 0.39553701877594], [0.589659988880157, 0.391062021255493], [0.805015981197357, 0.342108011245728], [0.611334979534149, 0.362284004688263], [0.634037971496582, 0.355970978736877], [0.656635999679565, 0.355356991291046], [0.681214988231659, 0.35834002494812], [0.698584973812103, 0.363156020641327], [0.941866993904114, 0.319076001644135], [0.698584973812103, 0.387449026107788], [0.584177017211914, 0.624107003211975], [0.554318010807037, 0.566076993942261], [0.534153997898102, 0.62064003944397], [0.711217999458313, 0.819975018501282], [0.664629995822906, 0.852871000766754], [0.559099972248077, 0.902631998062134], [0.871706008911133, 0.791940987110138], [0.591234028339386, 0.373893976211548], [0.544341027736664, 0.451583981513977], [0.624562978744507, 0.924192011356354], [0.88577002286911, 0.615028977394104], [0.551338016986847, 0.695277988910675], [0.551980018615723, 0.704632043838501], [0.552887976169586, 0.715808033943176], [0.555167973041534, 0.730794012546539], [0.569944024085999, 0.767035007476807], [0.593203008174896, 0.685675978660583], [0.599261999130249, 0.681069016456604], [0.607599973678589, 0.677703022956848], [0.631937980651855, 0.663500010967255], [0.752032995223999, 0.601315021514893], [0.547226011753082, 0.420395016670227], [0.563543975353241, 0.359827995300293], [0.583841025829315, 0.368713974952698], [0.586614012718201, 0.692366003990173], [0.771915018558502, 0.683578014373779], [0.531597018241882, 0.352482974529266], [0.588370978832245, 0.804440975189209], [0.52079701423645, 0.442565023899078], [0.567984998226166, 0.493479013442993], [0.543282985687256, 0.819254994392395], [0.655317008495331, 0.745514988899231], [0.621008992195129, 0.574018001556396], [0.625559985637665, 0.78031200170517], [0.680198013782501, 0.570719003677368], [0.64276397228241, 0.604337990283966], [0.704662978649139, 0.621529996395111], [0.552012026309967, 0.862591981887817], [0.589071989059448, 0.508637011051178], [0.685944974422455, 0.775357007980347], [0.645735025405884, 0.812640011310577], [0.675342977046967, 0.703978002071381], [0.810858011245728, 0.646304965019226], [0.72012197971344, 0.714666962623596], [0.866151988506317, 0.682704985141754], [0.663187026977539, 0.644596993923187], [0.570082008838654, 0.466325998306274], [0.544561982154846, 0.548375964164734], [0.562758982181549, 0.558784961700439], [0.531987011432648, 0.530140042304993], [0.585271000862122, 0.335177004337311], [0.622952997684479, 0.32277899980545], [0.655896008014679, 0.320163011550903], [0.687132000923157, 0.322345972061157], [0.716481983661652, 0.333200991153717], [0.758756995201111, 0.382786989212036], [0.897013008594513, 0.468769013881683], [0.732392013072968, 0.424547016620636], [0.70211398601532, 0.433162987232208], [0.66652500629425, 0.433866024017334], [0.633504986763, 0.426087975502014], [0.603875994682312, 0.416586995124817], [0.579657971858978, 0.409945011138916], [0.992439985275269, 0.480777025222778], [0.567192018032074, 0.569419980049133], [0.54136598110199, 0.478899002075195], [0.526564002037048, 0.546118021011353], [0.523913025856018, 0.563830018043518], [0.531529009342194, 0.555056989192963], [0.566035985946655, 0.582329034805298], [0.51631098985672, 0.563053965568542], [0.5174720287323, 0.577877044677734], [0.573594987392426, 0.389806985855103], [0.560697972774506, 0.395331978797913], [0.549755990505219, 0.399751007556915], [0.710287988185883, 0.368252992630005], [0.723330020904541, 0.363372981548309]];
var fY = [];
var mY = [];
var AY = 0;
var xY = 0;
var yY = Number.MAX_SAFE_INTEGER;
var bY = false;
function gY(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2;
    if (!oY) return [];
    const s2 = yY < ((null == (a2 = t2.face.emotion) ? void 0 : a2.skipFrames) || 0), o2 = ((null == (i2 = t2.face.emotion) ? void 0 : i2.skipTime) || 0) > xX() - xY;
    return t2.skipAllowed && o2 && s2 && AY === r2 && mY[n2] && mY[n2].length > 0 ? (yY++, mY[n2]) : (yY = 0, new Promise((a3) => __async(null, null, function* () {
      var i3, s3, o3;
      const l2 = [];
      if (null == (i3 = t2.face.emotion) ? void 0 : i3.enabled) {
        const n3 = {}, r3 = (null == oY ? void 0 : oY.inputs[0].shape) ? oY.inputs[0].shape[2] : 0;
        if ((null == (s3 = t2.face.emotion) ? void 0 : s3.crop) > 0) {
          const a5 = null == (o3 = t2.face.emotion) ? void 0 : o3.crop;
          n3.resize = mp.cropAndResize(e20, [[a5, a5, 1 - a5, 1 - a5]], [0], [r3, r3]);
        } else n3.resize = mp.resizeBilinear(e20, [r3, r3], false);
        bY ? (n3.mul = xo(n3.resize, 255), n3.normalize = Lu(n3.mul, [103.939, 116.779, 123.68]), n3.emotion = null == oY ? void 0 : oY.execute(n3.normalize)) : (n3.channels = xo(n3.resize, Yq.rgb), n3.grayscale = ou(n3.channels, 3, true), n3.grayscaleSub = Lu(n3.grayscale, Yq.tf05), n3.grayscaleMul = xo(n3.grayscaleSub, Yq.tf2), n3.emotion = null == oY ? void 0 : oY.execute(n3.grayscaleMul)), xY = xX();
        const a4 = yield n3.emotion.data();
        for (let e21 = 0; a4.length > e21; e21++) a4[e21] > (t2.face.emotion.minConfidence || 0) && l2.push({ score: Math.min(0.99, Math.trunc(100 * a4[e21]) / 100), emotion: fY[e21] });
        l2.sort((e21, t3) => t3.score - e21.score), Object.keys(n3).forEach((e21) => ts(n3[e21]));
      }
      mY[n2] = l2, AY = r2, a3(l2);
    })));
  });
}
var vY = [];
var wY = 0;
var kY = 0;
var NY = Number.MAX_SAFE_INTEGER;
function CY(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2, s2, o2;
    const l2 = { age: 0, gender: "unknown", genderScore: 0, descriptor: [] };
    if (!(null == lY ? void 0 : lY.executor)) return l2;
    const u2 = NY < ((null == (a2 = t2.face.description) ? void 0 : a2.skipFrames) || 0), d2 = ((null == (i2 = t2.face.description) ? void 0 : i2.skipTime) || 0) > xX() - wY;
    return t2.skipAllowed && u2 && d2 && kY === r2 && (null == (s2 = null == vY ? void 0 : vY[n2]) ? void 0 : s2.age) > 0 && (null == (o2 = null == vY ? void 0 : vY[n2]) ? void 0 : o2.genderScore) > 0 ? (NY++, vY[n2]) : (NY = 0, new Promise((a3) => __async(null, null, function* () {
      var i3;
      if (null == (i3 = t2.face.description) ? void 0 : i3.enabled) {
        const n3 = ((e21, t3) => {
          var n4, r4;
          const a5 = e21.image || e21.tensor || e21;
          if (!(null == lY ? void 0 : lY.inputs[0].shape)) return a5;
          let i5;
          if ((null == (n4 = t3.face.description) ? void 0 : n4.crop) > 0) {
            const e22 = null == (r4 = t3.face.description) ? void 0 : r4.crop;
            i5 = mp.cropAndResize(a5, [[e22, e22, 1 - e22, 1 - e22]], [0], [lY.inputs[0].shape[2], lY.inputs[0].shape[1]]);
          } else i5 = mp.resizeBilinear(a5, [lY.inputs[0].shape[2], lY.inputs[0].shape[1]], false);
          const s4 = xo(i5, Yq.tf255);
          return ts(i5), s4;
        })(e20, t2), r3 = null == lY ? void 0 : lY.execute(n3);
        wY = xX(), ts(n3);
        const a4 = r3.find((e21) => 1 === e21.shape[1]), i4 = yield a4.data(), s3 = Math.trunc(200 * Math.abs(i4[0] - 0.5)) / 100;
        s3 > (t2.face.description.minConfidence || 0) && (l2.gender = i4[0] > 0.5 ? "male" : "female", l2.genderScore = Math.min(0.99, s3));
        const o3 = No(r3.find((e21) => 100 === e21.shape[1]), 1), u3 = (yield o3.data())[0];
        ts(o3);
        const d3 = r3.find((e21) => 100 === e21.shape[1]), c2 = yield d3.data();
        l2.age = Math.round(c2[u3 - 1] > c2[u3 + 1] ? 10 * u3 - 100 * c2[u3 - 1] : 10 * u3 + 100 * c2[u3 + 1]) / 10, (Number.isNaN(i4[0]) || Number.isNaN(c2[0])) && AX("faceres error:", { model: lY, result: r3 });
        const h2 = r3.find((e21) => 1024 === e21.shape[1]), p2 = h2 ? yield h2.data() : [];
        l2.descriptor = Array.from(p2), r3.forEach((e21) => ts(e21));
      }
      vY[n2] = l2, kY = r2, a3(l2);
    })));
  });
}
var $Y;
var RY = 0.1;
function SY(e20, t2, n2) {
  let r2 = false, a2 = n2.length - 1;
  for (let i2 = 0; n2.length > i2; a2 = i2++) n2[i2].y > t2 != n2[a2].y > t2 && (n2[a2].x - n2[i2].x) * (t2 - n2[i2].y) / (n2[a2].y - n2[i2].y) + n2[i2].x > e20 && (r2 = !r2);
  return r2;
}
function IY(e20) {
  return __async(this, null, function* () {
    if (!e20.tensor) return e20.tensor;
    if (!e20.mesh || 100 > e20.mesh.length) return e20.tensor;
    const t2 = e20.tensor.shape[2] || 0, n2 = e20.tensor.shape[1] || 0, r2 = yield e20.tensor.buffer();
    let a2 = [];
    for (const i2 of pZ.silhouette) a2.push({ x: (e20.mesh[i2][0] - e20.box[0]) / e20.box[2], y: (e20.mesh[i2][1] - e20.box[1]) / e20.box[3] });
    a2 = a2.map((e21) => ({ x: e21.x > 0.5 ? e21.x + RY : e21.x - RY, y: e21.y > 0.5 ? e21.y + RY : e21.y - RY }));
    for (let i2 = 0; t2 > i2; i2++) for (let e21 = 0; n2 > e21; e21++) SY(i2 / t2, e21 / t2, a2) || (r2.set(0.5 * r2.get(0, e21, i2, 0), 0, e21, i2, 0), r2.set(0.5 * r2.get(0, e21, i2, 1), 0, e21, i2, 1), r2.set(0.5 * r2.get(0, e21, i2, 2), 0, e21, i2, 2));
    return r2.toTensor();
  });
}
var EY;
var TY = [];
var MY = Number.MAX_SAFE_INTEGER;
var OY = 0;
var FY = 0;
function PY(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2;
    if (!(null == $Y ? void 0 : $Y.executor)) return 0;
    const s2 = ((null == (a2 = t2.face.antispoof) ? void 0 : a2.skipTime) || 0) > xX() - FY, o2 = MY < ((null == (i2 = t2.face.antispoof) ? void 0 : i2.skipFrames) || 0);
    return t2.skipAllowed && s2 && o2 && OY === r2 && TY[n2] ? (MY++, TY[n2]) : (MY = 0, new Promise((t3) => __async(null, null, function* () {
      const a3 = mp.resizeBilinear(e20, [(null == $Y ? void 0 : $Y.inputs[0].shape) ? $Y.inputs[0].shape[2] : 0, (null == $Y ? void 0 : $Y.inputs[0].shape) ? $Y.inputs[0].shape[1] : 0], false), i3 = null == $Y ? void 0 : $Y.execute(a3), s3 = (yield i3.data())[0];
      TY[n2] = Math.round(100 * s3) / 100, OY = r2, FY = xX(), ts([a3, i3]), t3(TY[n2]);
    })));
  });
}
var zY;
var VY = [];
var _Y = Number.MAX_SAFE_INTEGER;
var DY = 0;
var WY = 0;
function LY(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2;
    if (!(null == EY ? void 0 : EY.executor)) return 0;
    const s2 = ((null == (a2 = t2.face.liveness) ? void 0 : a2.skipTime) || 0) > xX() - WY, o2 = _Y < ((null == (i2 = t2.face.liveness) ? void 0 : i2.skipFrames) || 0);
    return t2.skipAllowed && s2 && o2 && DY === r2 && VY[n2] ? (_Y++, VY[n2]) : (_Y = 0, new Promise((t3) => __async(null, null, function* () {
      const a3 = mp.resizeBilinear(e20, [(null == EY ? void 0 : EY.inputs[0].shape) ? EY.inputs[0].shape[2] : 0, (null == EY ? void 0 : EY.inputs[0].shape) ? EY.inputs[0].shape[1] : 0], false), i3 = null == EY ? void 0 : EY.execute(a3), s3 = (yield i3.data())[0];
      VY[n2] = Math.round(100 * s3) / 100, DY = r2, WY = xX(), ts([a3, i3]), t3(VY[n2]);
    })));
  });
}
var BY;
var UY = [];
var jY = ["white", "black", "asian", "indian", "other"];
var GY = [15, 23, 28, 35.5, 45.5, 55.5, 65];
var HY = 0;
var XY = 0;
var qY = Number.MAX_SAFE_INTEGER;
function ZY(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2;
    if (!zY) return { age: 0, gender: "unknown", genderScore: 0, race: [] };
    const s2 = qY < ((null == (a2 = t2.face.gear) ? void 0 : a2.skipFrames) || 0), o2 = ((null == (i2 = t2.face.gear) ? void 0 : i2.skipTime) || 0) > xX() - XY;
    return t2.skipAllowed && o2 && s2 && HY === r2 && UY[n2] ? (qY++, UY[n2]) : (qY = 0, new Promise((a3) => __async(null, null, function* () {
      var i3, s3, o3, l2;
      if (!(null == zY ? void 0 : zY.inputs[0].shape)) return;
      const u2 = {};
      let d2 = [[0, 0.1, 0.9, 0.9]];
      if ((null == (i3 = t2.face.gear) ? void 0 : i3.crop) > 0) {
        const e21 = null == (s3 = t2.face.gear) ? void 0 : s3.crop;
        d2 = [[e21, e21, 1 - e21, 1 - e21]];
      }
      u2.resize = mp.cropAndResize(e20, d2, [0], [zY.inputs[0].shape[2], zY.inputs[0].shape[1]]);
      const c2 = { age: 0, gender: "unknown", genderScore: 0, race: [] };
      (null == (o3 = t2.face.gear) ? void 0 : o3.enabled) && ([u2.age, u2.gender, u2.race] = zY.execute(u2.resize, ["age_output", "gender_output", "race_output"]));
      const h2 = yield u2.gender.data();
      c2.gender = h2[0] > h2[1] ? "male" : "female", c2.genderScore = Math.round(100 * (h2[0] > h2[1] ? h2[0] : h2[1])) / 100;
      const p2 = yield u2.race.data();
      for (let e21 = 0; p2.length > e21; e21++) p2[e21] > ((null == (l2 = t2.face.gear) ? void 0 : l2.minConfidence) || 0.2) && c2.race.push({ score: Math.round(100 * p2[e21]) / 100, race: jY[e21] });
      c2.race.sort((e21, t3) => t3.score - e21.score);
      const f2 = Array.from(yield u2.age.data()).map((e21, t3) => [GY[t3], e21]).sort((e21, t3) => t3[1] - e21[1]);
      let m2 = f2[0][0];
      for (let e21 = 1; f2.length > e21; e21++) m2 += f2[e21][1] * (f2[e21][0] - m2);
      c2.age = Math.round(10 * m2) / 10, Object.keys(u2).forEach((e21) => ts(u2[e21])), UY[n2] = c2, HY = r2, XY = xX(), a3(c2);
    })));
  });
}
var KY;
var YY = [];
var JY = 0;
var QY = 0;
var eJ = Number.MAX_SAFE_INTEGER;
function tJ(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2, s2, o2;
    if (!BY) return { age: 0 };
    const l2 = eJ < ((null == (a2 = t2.face.ssrnet) ? void 0 : a2.skipFrames) || 0), u2 = ((null == (i2 = t2.face.ssrnet) ? void 0 : i2.skipTime) || 0) > xX() - QY;
    return t2.skipAllowed && l2 && u2 && JY === r2 && (null == (s2 = YY[n2]) ? void 0 : s2.age) && (null == (o2 = YY[n2]) ? void 0 : o2.age) > 0 ? (eJ++, YY[n2]) : (eJ = 0, new Promise((a3) => __async(null, null, function* () {
      var i3, s3, o3;
      if (!(null == BY ? void 0 : BY.inputs) || !BY.inputs[0] || !BY.inputs[0].shape) return;
      const l3 = {};
      if ((null == (i3 = t2.face.ssrnet) ? void 0 : i3.crop) > 0) {
        const n3 = null == (s3 = t2.face.ssrnet) ? void 0 : s3.crop;
        l3.resize = mp.cropAndResize(e20, [[n3, n3, 1 - n3, 1 - n3]], [0], [BY.inputs[0].shape[2], BY.inputs[0].shape[1]]);
      } else l3.resize = mp.resizeBilinear(e20, [BY.inputs[0].shape[2], BY.inputs[0].shape[1]], false);
      l3.enhance = xo(l3.resize, Yq.tf255);
      const u3 = { age: 0 };
      if ((null == (o3 = t2.face.ssrnet) ? void 0 : o3.enabled) && (l3.age = BY.execute(l3.enhance)), l3.age) {
        const e21 = yield l3.age.data();
        u3.age = Math.trunc(10 * e21[0]) / 10;
      }
      Object.keys(l3).forEach((e21) => ts(l3[e21])), YY[n2] = u3, JY = r2, QY = xX(), a3(u3);
    })));
  });
}
var nJ;
var rJ = [];
var aJ = 0;
var iJ = 0;
var sJ = Number.MAX_SAFE_INTEGER;
function oJ(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2, s2, o2;
    if (!KY) return { gender: "unknown", genderScore: 0 };
    const l2 = sJ < ((null == (a2 = t2.face.ssrnet) ? void 0 : a2.skipFrames) || 0), u2 = ((null == (i2 = t2.face.ssrnet) ? void 0 : i2.skipTime) || 0) > xX() - iJ;
    return t2.skipAllowed && l2 && u2 && aJ === r2 && (null == (s2 = rJ[n2]) ? void 0 : s2.gender) && (null == (o2 = rJ[n2]) ? void 0 : o2.genderScore) > 0 ? (sJ++, rJ[n2]) : (sJ = 0, new Promise((a3) => __async(null, null, function* () {
      var i3, s3, o3;
      if (!(null == KY ? void 0 : KY.inputs[0].shape)) return;
      const l3 = {};
      if ((null == (i3 = t2.face.ssrnet) ? void 0 : i3.crop) > 0) {
        const n3 = null == (s3 = t2.face.ssrnet) ? void 0 : s3.crop;
        l3.resize = mp.cropAndResize(e20, [[n3, n3, 1 - n3, 1 - n3]], [0], [KY.inputs[0].shape[2], KY.inputs[0].shape[1]]);
      } else l3.resize = mp.resizeBilinear(e20, [KY.inputs[0].shape[2], KY.inputs[0].shape[1]], false);
      l3.enhance = es(() => {
        var e21, t3;
        let n3;
        if (1 === (null == (t3 = null == (e21 = null == KY ? void 0 : KY.inputs) ? void 0 : e21[0].shape) ? void 0 : t3[3])) {
          const [e22, t4, r3] = Nc(l3.resize, 3, 3), a4 = xo(e22, 0.2989), i4 = xo(t4, 0.587), s4 = xo(r3, 0.114), o4 = vo([a4, i4, s4]);
          n3 = xo(Lu(o4, Yq.tf05), 2);
        } else n3 = xo(Lu(l3.resize, Yq.tf05), 2);
        return n3;
      });
      const u3 = { gender: "unknown", genderScore: 0 };
      (null == (o3 = t2.face.ssrnet) ? void 0 : o3.enabled) && (l3.gender = KY.execute(l3.enhance));
      const d2 = yield l3.gender.data();
      u3.gender = d2[0] > d2[1] ? "female" : "male", u3.genderScore = d2[0] > d2[1] ? Math.trunc(100 * d2[0]) / 100 : Math.trunc(100 * d2[1]) / 100, Object.keys(l3).forEach((e21) => ts(l3[e21])), rJ[n2] = u3, aJ = r2, iJ = xX(), a3(u3);
    })));
  });
}
var lJ;
var uJ = [];
var dJ = 0;
var cJ = 0;
var hJ = Number.MAX_SAFE_INTEGER;
function pJ(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2;
    if (!(null == nJ ? void 0 : nJ.executor)) return [];
    const s2 = hJ < ((null == (a2 = t2.face.mobilefacenet) ? void 0 : a2.skipFrames) || 0), o2 = ((null == (i2 = t2.face.mobilefacenet) ? void 0 : i2.skipTime) || 0) > xX() - cJ;
    return t2.skipAllowed && o2 && s2 && dJ === r2 && uJ[n2] ? (hJ++, uJ[n2]) : new Promise((a3) => __async(null, null, function* () {
      var i3;
      let s3 = [];
      if ((null == (i3 = t2.face.mobilefacenet) ? void 0 : i3.enabled) && (null == nJ ? void 0 : nJ.inputs[0].shape)) {
        const t3 = {};
        t3.crop = mp.resizeBilinear(e20, [nJ.inputs[0].shape[2], nJ.inputs[0].shape[1]], false), t3.data = nJ.execute(t3.crop);
        const n3 = yield t3.data.data();
        s3 = Array.from(n3), Object.keys(t3).forEach((e21) => ts(t3[e21]));
      }
      uJ[n2] = s3, dJ = r2, cJ = xX(), a3(s3);
    }));
  });
}
var fJ = [];
var mJ = 0;
var AJ = 0;
var xJ = Number.MAX_SAFE_INTEGER;
function yJ(e20, t2, n2, r2) {
  return __async(this, null, function* () {
    var a2, i2;
    if (!(null == lJ ? void 0 : lJ.executor)) return [];
    const s2 = xJ < ((null == (a2 = t2.face.insightface) ? void 0 : a2.skipFrames) || 0), o2 = ((null == (i2 = t2.face.insightface) ? void 0 : i2.skipTime) || 0) > xX() - AJ;
    return t2.skipAllowed && o2 && s2 && mJ === r2 && fJ[n2] ? (xJ++, fJ[n2]) : new Promise((a3) => __async(null, null, function* () {
      var i3;
      let s3 = [];
      if ((null == (i3 = t2.face.insightface) ? void 0 : i3.enabled) && (null == lJ ? void 0 : lJ.inputs[0].shape)) {
        const t3 = {};
        t3.crop = mp.resizeBilinear(e20, [lJ.inputs[0].shape[2], lJ.inputs[0].shape[1]], false), t3.data = lJ.execute(t3.crop);
        const n3 = yield t3.data.data();
        s3 = Array.from(n3), Object.keys(t3).forEach((e21) => ts(t3[e21]));
      }
      fJ[n2] = s3, mJ = r2, AJ = xX(), a3(s3);
    }));
  });
}
var bJ = (e20, t2) => {
  const n2 = (e21) => {
    const t3 = Math.sqrt(e21[0] * e21[0] + e21[1] * e21[1] + e21[2] * e21[2]);
    return e21[0] /= t3, e21[1] /= t3, e21[2] /= t3, e21;
  }, r2 = (e21, t3) => [e21[0] - t3[0], e21[1] - t3[1], e21[2] - t3[2]], a2 = (e21, t3) => [e21[1] * t3[2] - e21[2] * t3[1], e21[2] * t3[0] - e21[0] * t3[2], e21[0] * t3[1] - e21[1] * t3[0]], i2 = e20.meshRaw;
  if (!i2 || 300 > i2.length) return { angle: { pitch: 0, yaw: 0, roll: 0 }, matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1], gaze: { bearing: 0, strength: 0 } };
  const s2 = Math.max(e20.boxRaw[2] * t2[0], e20.boxRaw[3] * t2[1]) / 1.5, o2 = [i2[10], i2[152], i2[234], i2[454]].map((e21) => [e21[0] * t2[0] / s2, e21[1] * t2[1] / s2, e21[2]]), l2 = n2(r2(o2[1], o2[0]));
  let u2 = n2(r2(o2[3], o2[2]));
  const d2 = n2(a2(u2, l2));
  u2 = a2(l2, d2);
  const c2 = [u2[0], u2[1], u2[2], l2[0], l2[1], l2[2], d2[0], d2[1], d2[2]], h2 = ((e21) => {
    const [t3, n3, r3, a3, i3, s3, o3, l3, u3] = e21;
    let d3, c3, h3;
    return 1 > a3 ? a3 > -1 ? (h3 = Math.atan2(a3, Math.sqrt(t3 * t3 + o3 * o3)), c3 = Math.atan2(-o3, t3), d3 = Math.atan2(-s3, i3)) : (h3 = -Math.PI / 2, c3 = -Math.atan2(l3, u3), d3 = 0) : (h3 = Math.PI / 2, c3 = Math.atan2(l3, u3), d3 = 0), Number.isNaN(d3) && (d3 = 0), Number.isNaN(c3) && (c3 = 0), Number.isNaN(h3) && (h3 = 0), { pitch: -d3, yaw: -c3, roll: -h3 };
  })(c2), p2 = 478 === i2.length ? ((e21) => {
    if (!e21.annotations.rightEyeIris || !e21.annotations.leftEyeIris) return { bearing: 0, strength: 0 };
    const t3 = (e21.mesh[33][2] || 0) > (e21.mesh[263][2] || 0), n3 = t3 ? e21.mesh[473] : e21.mesh[468], r3 = t3 ? [(e21.mesh[133][0] + e21.mesh[33][0]) / 2, (e21.mesh[133][1] + e21.mesh[33][1]) / 2] : [(e21.mesh[263][0] + e21.mesh[362][0]) / 2, (e21.mesh[263][1] + e21.mesh[362][1]) / 2], a3 = t3 ? [e21.mesh[133][0] - e21.mesh[33][0], e21.mesh[23][1] - e21.mesh[27][1]] : [e21.mesh[263][0] - e21.mesh[362][0], e21.mesh[253][1] - e21.mesh[257][1]], i3 = [(r3[0] - n3[0]) / a3[0] - 0, 1 * (n3[1] - r3[1]) / a3[1] - -0.1];
    let s3 = Math.sqrt(i3[0] * i3[0] + i3[1] * i3[1]);
    var o3;
    return s3 = Math.min(s3, e21.boxRaw[2] / 2, e21.boxRaw[3] / 2), { bearing: (Math.atan2(0 - (o3 = i3)[1], 0 - o3[0]) + Math.PI / 2) % Math.PI, strength: s3 };
  })(e20) : { bearing: 0, strength: 0 };
  return { angle: h2, matrix: c2, gaze: p2 };
};
function gJ(e20, t2) {
  const n2 = null == e20 ? void 0 : e20.annotations;
  return (null == n2 ? void 0 : n2.leftEyeIris) && (null == n2 ? void 0 : n2.rightEyeIris) ? Math.round(1.17 / (Math.max(Math.abs(n2.leftEyeIris[3][0] - n2.leftEyeIris[1][0]), Math.abs(n2.rightEyeIris[3][0] - n2.rightEyeIris[1][0])) / t2)) / 100 : 0;
}
var vJ = (e20, t2) => __async(null, null, function* () {
  var n2, r2, a2, i2, s2, o2, l2, u2, d2, c2, h2, p2, f2, m2, A2, x2, y2, b2, g2, v2, w2, k2, N2;
  let C2, $2, R2, S2, I2, E2, T2, M2, O2, F2 = xX();
  const P2 = [];
  e20.state = "run:face";
  const z2 = yield ((e21, t3) => __async(null, null, function* () {
    var n3, r3, a3, i3, s3, o3, l3, u3, d3, c3;
    const h3 = ((null == (n3 = t3.face.detector) ? void 0 : n3.skipTime) || 0) > xX() - uY.timestamp, p3 = uY.skipped < ((null == (r3 = t3.face.detector) ? void 0 : r3.skipFrames) || 0);
    t3.skipAllowed && h3 && p3 && 0 !== uY.boxes.length ? uY.skipped++ : (uY.boxes = yield ((e22, t4) => __async(null, null, function* () {
      var n4, r4, a4, i4, s4, o4, l4, u4, d4;
      if (!e22 || e22.isDisposedInternal || 4 !== e22.shape.length || 1 > e22.shape[1] || 1 > e22.shape[2]) return [];
      const c4 = {};
      let h4 = [0, 0], p4 = [1, 1];
      if (null == (r4 = null == (n4 = null == t4 ? void 0 : t4.face) ? void 0 : n4.detector) ? void 0 : r4.square) {
        const t5 = Math.max(e22.shape[2], e22.shape[1]);
        h4 = [Math.floor((t5 - e22.shape[2]) / 2), Math.floor((t5 - e22.shape[1]) / 2)], c4.padded = md(e22, [[0, 0], [h4[1], h4[1]], [h4[0], h4[0]], [0, 0]]), p4 = [e22.shape[2] / t5, e22.shape[1] / t5], h4 = [h4[0] / qK, h4[1] / qK];
      } else c4.padded = e22.clone();
      c4.resized = mp.resizeBilinear(c4.padded, [qK, qK]), c4.div = Ao(c4.resized, Yq.tf127), c4.normalized = Lu(c4.div, Yq.tf1);
      const f4 = null == jK ? void 0 : jK.execute(c4.normalized);
      if (Array.isArray(f4) && f4.length > 2) {
        const e23 = f4.sort((e24, t5) => e24.size - t5.size);
        c4.concat384 = Zo([e23[0], e23[2]], 2), c4.concat512 = Zo([e23[1], e23[3]], 2), c4.concat = Zo([c4.concat512, c4.concat384], 1), c4.batch = Rc(c4.concat, [0]);
      } else c4.batch = Rc(Array.isArray(f4) ? f4[0] : f4);
      ts(f4), c4.boxes = ((e23) => {
        if (!XK || !ZK) return nd([0, 0]);
        const t5 = {};
        t5.boxStarts = Jo(e23, [0, 1], [-1, 2]), t5.centers = fo(t5.boxStarts, XK), t5.boxSizes = Jo(e23, [0, 3], [-1, 2]), t5.boxSizesNormalized = Ao(t5.boxSizes, ZK), t5.centersNormalized = Ao(t5.centers, ZK), t5.halfBoxSize = Ao(t5.boxSizesNormalized, Yq.tf2), t5.starts = Lu(t5.centersNormalized, t5.halfBoxSize), t5.ends = fo(t5.centersNormalized, t5.halfBoxSize), t5.startNormalized = xo(t5.starts, ZK), t5.endNormalized = xo(t5.ends, ZK);
        const n5 = ml([t5.startNormalized, t5.endNormalized], 1);
        return Object.keys(t5).forEach((e24) => ts(t5[e24])), n5;
      })(c4.batch), c4.logits = Jo(c4.batch, [0, 0], [-1, 1]), c4.sigmoid = Yo(c4.logits), c4.scores = Rc(c4.sigmoid), c4.nms = yield mp.nonMaxSuppressionAsync(c4.boxes, c4.scores, (null == (a4 = t4.face.detector) ? void 0 : a4.maxDetected) || 0, (null == (i4 = t4.face.detector) ? void 0 : i4.iouThreshold) || 0, (null == (s4 = t4.face.detector) ? void 0 : s4.minConfidence) || 0);
      const m4 = yield c4.nms.array(), A4 = [], x4 = yield c4.scores.data();
      for (let y3 = 0; m4.length > y3; y3++) {
        const n5 = x4[m4[y3]];
        if (n5 > ((null == (o4 = t4.face.detector) ? void 0 : o4.minConfidence) || 0)) {
          const r5 = {};
          r5.bbox = Jo(c4.boxes, [m4[y3], 0], [1, -1]), r5.slice = Jo(c4.batch, [m4[y3], 5], [1, -1]), r5.squeeze = Rc(r5.slice), r5.landmarks = Ho(r5.squeeze, [6, -1]);
          const a5 = yield r5.bbox.data(), i5 = [a5[0] * p4[0] - h4[0], a5[1] * p4[1] - h4[1], a5[2] * p4[0] - h4[0], a5[3] * p4[1] - h4[1]], s5 = { startPoint: [i5[0], i5[1]], endPoint: [i5[2], i5[3]], landmarks: yield r5.landmarks.array(), confidence: n5 };
          r5.anchor = Jo(XK, [m4[y3], 0], [1, 2]);
          const o5 = yield r5.anchor.data(), f5 = TK(s5, [(e22.shape[2] || 0) / qK, (e22.shape[1] || 0) / qK], o5), x5 = OK(f5, (null == (l4 = t4.face.detector) ? void 0 : l4.scale) || 1.4), b3 = FK(x5);
          b3.size[0] > ((null == (u4 = t4.face.detector) ? void 0 : u4.minSize) || 0) && b3.size[1] > ((null == (d4 = t4.face.detector) ? void 0 : d4.minSize) || 0) && A4.push(b3), Object.keys(r5).forEach((e23) => ts(r5[e23]));
        }
      }
      return Object.keys(c4).forEach((e23) => ts(c4[e23])), A4;
    }))(e21, t3), uY.timestamp = xX(), uY.skipped = 0);
    const f3 = [], m3 = [];
    let A3 = 0;
    const x3 = cY;
    for (let y3 = 0; uY.boxes.length > y3; y3++) {
      const n4 = uY.boxes[y3];
      let r4, h4 = 0;
      const p4 = { id: A3++, mesh: [], meshRaw: [], box: [0, 0, 0, 0], boxRaw: [0, 0, 0, 0], score: 0, boxScore: 0, faceScore: 0, size: [0, 0], annotations: {} };
      if ([h4, r4, p4.tensor] = UK(null == (a3 = t3.face.detector) ? void 0 : a3.rotation, n4, e21, (null == (i3 = t3.face.mesh) ? void 0 : i3.enabled) ? cY : KK()), t3.filter.equalization) {
        const e22 = p4.tensor ? yield NX(p4.tensor) : void 0;
        ts(p4.tensor), e22 && (p4.tensor = e22);
      }
      if (p4.boxScore = Math.round(100 * n4.confidence) / 100, (null == (s3 = t3.face.mesh) ? void 0 : s3.enabled) && (null == dY ? void 0 : dY.executor)) if (dY) {
        if ((null == (o3 = t3.face.attention) ? void 0 : o3.enabled) && !_X.kernels.includes("atan2")) return t3.face.attention.enabled = false, ts(p4.tensor), f3;
        const a4 = dY.execute(p4.tensor), i4 = a4.find((e22) => 1 === e22.shape[e22.shape.length - 1]), s4 = yield i4.data();
        if (p4.faceScore = Math.round(100 * s4[0]) / 100, p4.faceScore < ((null == (l3 = t3.face.detector) ? void 0 : l3.minConfidence) || 1)) {
          if (n4.confidence = p4.faceScore, t3.face.mesh.keepInvalid) {
            p4.box = IK(n4, e21), p4.boxRaw = EK(n4, e21), p4.size = n4.size, p4.score = p4.boxScore, p4.mesh = n4.landmarks, p4.meshRaw = p4.mesh.map((t4) => [t4[0] / (e21.shape[2] || 1), t4[1] / (e21.shape[1] || 1), (t4[2] || 0) / x3]);
            for (const e22 of Object.keys(mZ)) p4.annotations[e22] = [p4.mesh[mZ[e22]]];
          }
        } else {
          const i5 = a4.find((e22) => 1404 === e22.shape[e22.shape.length - 1]), s5 = Ho(i5, [-1, 3]);
          let o4 = yield s5.array();
          ts(s5), (null == (u3 = t3.face.attention) ? void 0 : u3.enabled) ? o4 = yield sY(o4, a4) : (null == (d3 = t3.face.iris) ? void 0 : d3.enabled) && (o4 = yield iY(o4, p4.tensor, cY, t3)), p4.mesh = BK(o4, n4, h4, r4, cY), p4.meshRaw = p4.mesh.map((t4) => [t4[0] / (e21.shape[2] || 0), t4[1] / (e21.shape[1] || 0), (t4[2] || 0) / x3]);
          for (const e22 of Object.keys(pZ)) p4.annotations[e22] = pZ[e22].map((e23) => p4.mesh[e23]);
          p4.score = p4.faceScore;
          const l4 = __spreadProps(__spreadValues({}, HK(p4.mesh, n4)), { confidence: n4.confidence, landmarks: n4.landmarks, size: n4.size });
          p4.box = IK(l4, e21), p4.boxRaw = EK(l4, e21), p4.size = l4.size, m3.push(l4);
        }
        ts(a4);
      } else t3.debug && AX("face mesh detection requested, but model is not loaded");
      else {
        p4.box = IK(n4, e21), p4.boxRaw = EK(n4, e21), p4.score = p4.boxScore, p4.size = n4.size, p4.mesh = n4.landmarks, p4.meshRaw = p4.mesh.map((t4) => [t4[0] / (e21.shape[2] || 0), t4[1] / (e21.shape[1] || 0), (t4[2] || 0) / x3]);
        for (const e22 of Object.keys(mZ)) p4.annotations[e22] = [p4.mesh[mZ[e22]]];
      }
      p4.score > ((null == (c3 = t3.face.detector) ? void 0 : c3.minConfidence) || 1) ? f3.push(p4) : ts(p4.tensor);
    }
    return uY.boxes = m3, f3;
  }))(t2, e20.config);
  if (e20.performance.face = _X.perfadd ? (e20.performance.face || 0) + Math.trunc(xX() - F2) : Math.trunc(xX() - F2), !t2.shape || 4 !== t2.shape.length) return [];
  if (!z2) return [];
  for (let V2 = 0; z2.length > V2; V2++) {
    if (e20.analyze("Get Face"), !z2[V2].tensor || z2[V2].tensor.isDisposedInternal) {
      AX("Face object is disposed:", z2[V2].tensor);
      continue;
    }
    if (null == (n2 = e20.config.face.detector) ? void 0 : n2.mask) {
      const e21 = yield IY(z2[V2]);
      ts(z2[V2].tensor), e21 && (z2[V2].tensor = e21);
    }
    const _2 = z2[V2].mesh && z2[V2].mesh.length > 200 ? bJ(z2[V2], [t2.shape[2], t2.shape[1]]) : null;
    e20.analyze("Start Emotion:"), e20.config.async ? S2 = (null == (r2 = e20.config.face.emotion) ? void 0 : r2.enabled) ? gY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : [] : (e20.state = "run:emotion", F2 = xX(), S2 = (null == (a2 = e20.config.face.emotion) ? void 0 : a2.enabled) ? yield gY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : [], e20.performance.emotion = _X.perfadd ? (e20.performance.emotion || 0) + Math.trunc(xX() - F2) : Math.trunc(xX() - F2)), e20.analyze("End Emotion:"), e20.analyze("Start AntiSpoof:"), e20.config.async ? T2 = (null == (i2 = e20.config.face.antispoof) ? void 0 : i2.enabled) ? PY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : 0 : (e20.state = "run:antispoof", F2 = xX(), T2 = (null == (s2 = e20.config.face.antispoof) ? void 0 : s2.enabled) ? yield PY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : 0, e20.performance.antispoof = _X.perfadd ? (e20.performance.antispoof || 0) + Math.trunc(xX() - F2) : Math.trunc(xX() - F2)), e20.analyze("End AntiSpoof:"), e20.analyze("Start Liveness:"), e20.config.async ? M2 = (null == (o2 = e20.config.face.liveness) ? void 0 : o2.enabled) ? LY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : 0 : (e20.state = "run:liveness", F2 = xX(), M2 = (null == (l2 = e20.config.face.liveness) ? void 0 : l2.enabled) ? yield LY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : 0, e20.performance.liveness = _X.perfadd ? (e20.performance.antispoof || 0) + Math.trunc(xX() - F2) : Math.trunc(xX() - F2)), e20.analyze("End Liveness:"), e20.analyze("Start GEAR:"), e20.config.async ? $2 = (null == (u2 = e20.config.face.gear) ? void 0 : u2.enabled) ? ZY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null : (e20.state = "run:gear", F2 = xX(), $2 = (null == (d2 = e20.config.face.gear) ? void 0 : d2.enabled) ? yield ZY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null, e20.performance.gear = Math.trunc(xX() - F2)), e20.analyze("End GEAR:"), e20.analyze("Start SSRNet:"), e20.config.async ? (C2 = (null == (c2 = e20.config.face.ssrnet) ? void 0 : c2.enabled) ? tJ(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null, R2 = (null == (h2 = e20.config.face.ssrnet) ? void 0 : h2.enabled) ? oJ(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null) : (e20.state = "run:ssrnet", F2 = xX(), C2 = (null == (p2 = e20.config.face.ssrnet) ? void 0 : p2.enabled) ? yield tJ(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null, R2 = (null == (f2 = e20.config.face.ssrnet) ? void 0 : f2.enabled) ? yield oJ(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null, e20.performance.ssrnet = Math.trunc(xX() - F2)), e20.analyze("End SSRNet:"), e20.analyze("Start MobileFaceNet:"), e20.config.async ? I2 = (null == (m2 = e20.config.face.mobilefacenet) ? void 0 : m2.enabled) ? pJ(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null : (e20.state = "run:mobilefacenet", F2 = xX(), I2 = (null == (A2 = e20.config.face.mobilefacenet) ? void 0 : A2.enabled) ? yield pJ(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null, e20.performance.mobilefacenet = Math.trunc(xX() - F2)), e20.analyze("End MobileFaceNet:"), e20.analyze("Start InsightFace:"), e20.config.async ? E2 = (null == (x2 = e20.config.face.insightface) ? void 0 : x2.enabled) ? yJ(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null : (e20.state = "run:mobilefacenet", F2 = xX(), E2 = (null == (y2 = e20.config.face.insightface) ? void 0 : y2.enabled) ? yield yJ(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : null, e20.performance.mobilefacenet = Math.trunc(xX() - F2)), e20.analyze("End InsightFace:"), e20.analyze("Start Description:"), e20.config.async ? O2 = CY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length) : (e20.state = "run:description", F2 = xX(), O2 = yield CY(z2[V2].tensor || Ui([]), e20.config, V2, z2.length), e20.performance.description = _X.perfadd ? (e20.performance.description || 0) + Math.trunc(xX() - F2) : Math.trunc(xX() - F2)), e20.analyze("End Description:"), e20.config.async && ([C2, R2, S2, I2, E2, O2, $2, T2, M2] = yield Promise.all([C2, R2, S2, I2, E2, O2, $2, T2, M2])), e20.analyze("Finish Face:"), (null == (b2 = e20.config.face.ssrnet) ? void 0 : b2.enabled) && C2 && R2 && (O2 = __spreadProps(__spreadValues({}, O2), { age: C2.age, gender: R2.gender, genderScore: R2.genderScore })), (null == (g2 = e20.config.face.gear) ? void 0 : g2.enabled) && $2 && (O2 = __spreadProps(__spreadValues({}, O2), { age: $2.age, gender: $2.gender, genderScore: $2.genderScore, race: $2.race })), (null == (v2 = e20.config.face.mobilefacenet) ? void 0 : v2.enabled) && I2 && (O2.descriptor = I2), (null == (w2 = e20.config.face.insightface) ? void 0 : w2.enabled) && E2 && (O2.descriptor = E2);
    const D2 = (null == (k2 = e20.config.face.iris) ? void 0 : k2.enabled) ? gJ(z2[V2], t2.shape[2]) : 0, W2 = (null == (N2 = e20.config.face.detector) ? void 0 : N2.return) ? Rc(z2[V2].tensor) : null;
    ts(z2[V2].tensor), z2[V2].tensor && delete z2[V2].tensor;
    const L2 = __spreadProps(__spreadValues({}, z2[V2]), { id: V2 });
    O2.age && (L2.age = O2.age), O2.gender && (L2.gender = O2.gender), O2.genderScore && (L2.genderScore = O2.genderScore), O2.descriptor && (L2.embedding = O2.descriptor), O2.race && (L2.race = O2.race), S2 && (L2.emotion = S2), T2 && (L2.real = T2), M2 && (L2.live = M2), D2 > 0 && (L2.distance = D2), _2 && (L2.rotation = _2), W2 && (L2.tensor = W2), P2.push(L2), e20.analyze("End Face");
  }
  return e20.analyze("End FaceMesh:"), e20.config.async && (e20.performance.face && delete e20.performance.face, e20.performance.age && delete e20.performance.age, e20.performance.gender && delete e20.performance.gender, e20.performance.emotion && delete e20.performance.emotion), P2;
});
var wJ = { thumb: 0, index: 1, middle: 2, ring: 3, pinky: 4, all: [0, 1, 2, 3, 4], nameMapping: { 0: "thumb", 1: "index", 2: "middle", 3: "ring", 4: "pinky" }, pointsMapping: { 0: [[0, 1], [1, 2], [2, 3], [3, 4]], 1: [[0, 5], [5, 6], [6, 7], [7, 8]], 2: [[0, 9], [9, 10], [10, 11], [11, 12]], 3: [[0, 13], [13, 14], [14, 15], [15, 16]], 4: [[0, 17], [17, 18], [18, 19], [19, 20]] }, getName(e20) {
  return wJ.nameMapping[e20];
}, getPoints(e20) {
  return wJ.pointsMapping[e20];
} };
var kJ = { none: 0, half: 1, full: 2, nameMapping: { 0: "none", 1: "half", 2: "full" }, getName(e20) {
  return kJ.nameMapping[e20];
} };
var NJ = { verticalUp: 0, verticalDown: 1, horizontalLeft: 2, horizontalRight: 3, diagonalUpRight: 4, diagonalUpLeft: 5, diagonalDownRight: 6, diagonalDownLeft: 7, nameMapping: { 0: "verticalUp", 1: "verticalDown", 2: "horizontalLeft", 3: "horizontalRight", 4: "diagonalUpRight", 5: "diagonalUpLeft", 6: "diagonalDownRight", 7: "diagonalDownLeft" }, getName(e20) {
  return NJ.nameMapping[e20];
} };
var CJ = class {
  constructor(e20) {
    r(this, "name"), r(this, "curls"), r(this, "directions"), r(this, "weights"), r(this, "weightsRelative"), this.name = e20, this.curls = {}, this.directions = {}, this.weights = [1, 1, 1, 1, 1], this.weightsRelative = [1, 1, 1, 1, 1];
  }
  curl(e20, t2, n2) {
    void 0 === this.curls[e20] && (this.curls[e20] = []), this.curls[e20].push([t2, n2]);
  }
  direction(e20, t2, n2) {
    this.directions[e20] || (this.directions[e20] = []), this.directions[e20].push([t2, n2]);
  }
  weight(e20, t2) {
    this.weights[e20] = t2;
    const n2 = this.weights.reduce((e21, t3) => e21 + t3, 0);
    this.weightsRelative = this.weights.map((e21) => 5 * e21 / n2);
  }
  matchAgainst(e20, t2) {
    let n2 = 0;
    for (const r2 in e20) {
      const t3 = e20[r2], a2 = this.curls[r2];
      if (void 0 !== a2) {
        for (const [e21, i2] of a2) if (t3 === e21) {
          n2 += i2 * this.weightsRelative[r2];
          break;
        }
      } else n2 += this.weightsRelative[r2];
    }
    for (const r2 in t2) {
      const e21 = t2[r2], a2 = this.directions[r2];
      if (void 0 !== a2) {
        for (const [t3, i2] of a2) if (e21 === t3) {
          n2 += i2 * this.weightsRelative[r2];
          break;
        }
      } else n2 += this.weightsRelative[r2];
    }
    return n2 / 10;
  }
};
var { thumb: $J, index: RJ, middle: SJ, ring: IJ, pinky: EJ } = wJ;
var { none: TJ, half: MJ, full: OJ } = kJ;
var { verticalUp: FJ, horizontalLeft: PJ, horizontalRight: zJ, diagonalUpRight: VJ, diagonalUpLeft: _J } = NJ;
var DJ = new CJ("thumbs up");
DJ.curl($J, TJ, 1), DJ.direction($J, FJ, 1), DJ.direction($J, _J, 0.25), DJ.direction($J, VJ, 0.25);
for (const a0 of [wJ.index, wJ.middle, wJ.ring, wJ.pinky]) DJ.curl(a0, OJ, 1), DJ.direction(a0, PJ, 1), DJ.direction(a0, zJ, 1);
var WJ = new CJ("victory");
WJ.curl($J, MJ, 0.5), WJ.curl($J, TJ, 0.5), WJ.direction($J, FJ, 1), WJ.direction($J, _J, 1), WJ.curl(RJ, TJ, 1), WJ.direction(RJ, FJ, 0.75), WJ.direction(RJ, _J, 1), WJ.curl(SJ, TJ, 1), WJ.direction(SJ, FJ, 1), WJ.direction(SJ, _J, 0.75), WJ.curl(IJ, OJ, 1), WJ.direction(IJ, FJ, 0.2), WJ.direction(IJ, _J, 1), WJ.direction(IJ, PJ, 0.2), WJ.curl(EJ, OJ, 1), WJ.direction(EJ, FJ, 0.2), WJ.direction(EJ, _J, 1), WJ.direction(EJ, PJ, 0.2), WJ.weight(RJ, 2), WJ.weight(SJ, 2);
var LJ = new CJ("point");
LJ.curl($J, OJ, 1), LJ.curl(RJ, TJ, 0.5), LJ.curl(SJ, OJ, 0.5), LJ.curl(IJ, OJ, 0.5), LJ.curl(EJ, OJ, 0.5), LJ.weight(RJ, 2), LJ.weight(SJ, 2);
var BJ = new CJ("middle finger");
BJ.curl($J, TJ, 1), BJ.curl(RJ, OJ, 0.5), BJ.curl(SJ, OJ, 0.5), BJ.curl(IJ, OJ, 0.5), BJ.curl(EJ, OJ, 0.5), BJ.weight(RJ, 2), BJ.weight(SJ, 2);
var UJ = new CJ("open palm");
UJ.curl($J, TJ, 0.75), UJ.curl(RJ, TJ, 0.75), UJ.curl(SJ, TJ, 0.75), UJ.curl(IJ, TJ, 0.75), UJ.curl(EJ, TJ, 0.75);
var jJ = [DJ, WJ, LJ, BJ, UJ];
function GJ(e20, t2, n2, r2) {
  let a2 = 180 * Math.atan((t2 - r2) / (e20 - n2)) / Math.PI;
  return a2 > 0 ? a2 > 0 && (a2 = 180 - a2) : a2 = -a2, a2;
}
function HJ(e20, t2) {
  if (!e20 || !t2) return [0, 0];
  const n2 = GJ(e20[0], e20[1], t2[0], t2[1]);
  return 2 === e20.length ? n2 : [n2, GJ(e20[1], e20[2], t2[1], t2[2])];
}
function XJ(e20, t2 = 1) {
  let n2 = 0, r2 = 0, a2 = 0;
  return 75 > e20 || e20 > 105 ? 25 > e20 || e20 > 155 ? a2 = 1 * t2 : r2 = 1 * t2 : n2 = 1 * t2, [n2, r2, a2];
}
function qJ(e20, t2, n2) {
  const r2 = e20[0] - t2[0], a2 = e20[0] - n2[0], i2 = t2[0] - n2[0], s2 = e20[1] - t2[1], o2 = e20[1] - n2[1], l2 = t2[1] - n2[1], u2 = e20[2] - t2[2], d2 = e20[2] - n2[2], c2 = t2[2] - n2[2], h2 = Math.sqrt(r2 * r2 + s2 * s2 + u2 * u2), p2 = Math.sqrt(a2 * a2 + o2 * o2 + d2 * d2), f2 = Math.sqrt(i2 * i2 + l2 * l2 + c2 * c2);
  let m2 = (f2 * f2 + h2 * h2 - p2 * p2) / (2 * f2 * h2);
  m2 > 1 ? m2 = 1 : -1 > m2 && (m2 = -1);
  let A2, x2 = Math.acos(m2);
  return x2 = 57.2958 * x2 % 180, A2 = x2 > 130 ? kJ.none : x2 > 60 ? kJ.half : kJ.full, A2;
}
function ZJ(e20, t2, n2, r2) {
  let a2;
  return a2 = r2 === Math.abs(e20) ? e20 > 0 ? NJ.horizontalLeft : NJ.horizontalRight : r2 === Math.abs(t2) ? t2 > 0 ? NJ.horizontalLeft : NJ.horizontalRight : n2 > 0 ? NJ.horizontalLeft : NJ.horizontalRight, a2;
}
function KJ(e20, t2, n2, r2) {
  let a2;
  return a2 = r2 === Math.abs(e20) ? 0 > e20 ? NJ.verticalDown : NJ.verticalUp : r2 === Math.abs(t2) ? 0 > t2 ? NJ.verticalDown : NJ.verticalUp : 0 > n2 ? NJ.verticalDown : NJ.verticalUp, a2;
}
function YJ(e20, t2, n2, r2) {
  const a2 = e20[0] - t2[0], i2 = e20[0] - n2[0], s2 = t2[0] - n2[0], o2 = e20[1] - t2[1], l2 = e20[1] - n2[1], u2 = t2[1] - n2[1], d2 = Math.max(Math.abs(a2), Math.abs(i2), Math.abs(s2)), c2 = Math.max(Math.abs(o2), Math.abs(l2), Math.abs(u2));
  let h2 = 0, p2 = 0, f2 = 0;
  const m2 = c2 / (d2 + 1e-5);
  m2 > 1.5 ? h2 += 1.1 : m2 > 0.66 ? p2 += 1.1 : f2 += 1.1;
  const A2 = Math.sqrt(a2 * a2 + o2 * o2), x2 = Math.sqrt(i2 * i2 + l2 * l2), y2 = Math.sqrt(s2 * s2 + u2 * u2), b2 = Math.max(A2, x2, y2);
  let g2 = e20[0], v2 = e20[1], w2 = n2[0], k2 = n2[1];
  b2 === A2 ? (w2 = n2[0], k2 = n2[1]) : b2 === y2 && (g2 = t2[0], v2 = t2[1]);
  const N2 = XJ(HJ([g2, v2], [w2, k2]), 1.6);
  h2 += N2[0], p2 += N2[1], f2 += N2[2];
  for (const $2 of r2) {
    const e21 = XJ($2, 0.9);
    h2 += e21[0], p2 += e21[1], f2 += e21[2];
  }
  let C2;
  return C2 = h2 === Math.max(h2, p2, f2) ? KJ(l2, o2, u2, c2) : f2 === Math.max(p2, f2) ? ZJ(i2, a2, s2, d2) : ((e21, t3, n3, r3, a3, i3, s3, o3) => {
    let l3;
    const u3 = KJ(e21, t3, n3, r3), d3 = ZJ(a3, i3, s3, o3);
    return l3 = u3 === NJ.verticalUp ? d3 === NJ.horizontalLeft ? NJ.diagonalUpLeft : NJ.diagonalUpRight : d3 === NJ.horizontalLeft ? NJ.diagonalDownLeft : NJ.diagonalDownRight, l3;
  })(l2, o2, u2, c2, i2, a2, s2, d2), C2;
}
function JJ(e20) {
  const t2 = [], n2 = [], r2 = [];
  if (!e20) return { curls: n2, directions: r2 };
  for (const a2 of wJ.all) {
    const n3 = wJ.getPoints(a2), r3 = [], i2 = [];
    for (const t3 of n3) {
      const n4 = HJ(e20[t3[0]], e20[t3[1]]), a3 = n4[1];
      r3.push(n4[0]), i2.push(a3);
    }
    t2.push(r3);
  }
  for (const a2 of wJ.all) {
    const i2 = a2 === wJ.thumb ? 1 : 0, s2 = wJ.getPoints(a2), o2 = e20[s2[i2][0]], l2 = e20[s2[i2 + 1][1]], u2 = e20[s2[3][1]], d2 = qJ(o2, l2, u2), c2 = YJ(o2, l2, u2, t2[a2].slice(i2));
    n2[a2] = d2, r2[a2] = c2;
  }
  return { curls: n2, directions: r2 };
}
function QJ(e20) {
  if (!e20 || 0 === e20.length) return null;
  const t2 = JJ(e20), n2 = {};
  for (const r2 of wJ.all) n2[wJ.getName(r2)] = { curl: kJ.getName(t2.curls[r2]), direction: NJ.getName(t2.directions[r2]) };
  return n2;
}
function eQ(e20) {
  const t2 = [];
  if (!e20 || 0 === e20.length) return t2;
  const n2 = JJ(e20);
  for (const r2 of jJ) {
    const e21 = r2.matchAgainst(n2.curls, n2.directions);
    0.7 > e21 || t2.push({ name: r2.name, confidence: e21 });
  }
  return t2;
}
var tQ = (e20) => {
  if (!e20) return [];
  const t2 = [];
  for (let n2 = 0; e20.length > n2; n2++) {
    const r2 = e20[n2].keypoints.find((e21) => "leftWrist" === e21.part), a2 = e20[n2].keypoints.find((e21) => "rightWrist" === e21.part), i2 = e20[n2].keypoints.find((e21) => "nose" === e21.part);
    i2 && r2 && a2 && i2.position[1] > r2.position[1] && i2.position[1] > a2.position[1] ? t2.push({ body: n2, gesture: "i give up" }) : i2 && r2 && i2.position[1] > r2.position[1] ? t2.push({ body: n2, gesture: "raise left hand" }) : i2 && a2 && i2.position[1] > a2.position[1] && t2.push({ body: n2, gesture: "raise right hand" });
    const s2 = e20[n2].keypoints.find((e21) => "leftShoulder" === e21.part), o2 = e20[n2].keypoints.find((e21) => "rightShoulder" === e21.part);
    s2 && o2 && Math.abs(s2.positionRaw[1] - o2.positionRaw[1]) > 0.1 && t2.push({ body: n2, gesture: "leaning " + (s2.position[1] > o2.position[1] ? "left" : "right") });
  }
  return t2;
};
var nQ = (e20) => {
  if (!e20) return [];
  const t2 = [];
  for (let n2 = 0; e20.length > n2; n2++) if (e20[n2].mesh && e20[n2].mesh.length > 450) {
    const r2 = (e20[n2].mesh[33][2] || 0) - (e20[n2].mesh[263][2] || 0);
    t2.push(Math.abs(r2 / (e20[n2].mesh[33][0] - e20[n2].mesh[263][0])) > 0.15 ? { face: n2, gesture: "facing " + (0 > r2 ? "left" : "right") } : { face: n2, gesture: "facing center" }), 0.2 > Math.abs(e20[n2].mesh[374][1] - e20[n2].mesh[386][1]) / Math.abs(e20[n2].mesh[443][1] - e20[n2].mesh[450][1]) && t2.push({ face: n2, gesture: "blink left eye" }), 0.2 > Math.abs(e20[n2].mesh[145][1] - e20[n2].mesh[159][1]) / Math.abs(e20[n2].mesh[223][1] - e20[n2].mesh[230][1]) && t2.push({ face: n2, gesture: "blink right eye" });
    const a2 = Math.min(100, 500 * Math.abs(e20[n2].mesh[13][1] - e20[n2].mesh[14][1]) / Math.abs(e20[n2].mesh[10][1] - e20[n2].mesh[152][1]));
    a2 > 10 && t2.push({ face: n2, gesture: `mouth ${Math.trunc(a2)}% open` });
    const i2 = e20[n2].mesh[152][2] || 0;
    Math.abs(i2) > 10 && t2.push({ face: n2, gesture: "head " + (0 > i2 ? "up" : "down") });
  }
  return t2;
};
var rQ = (e20) => {
  var t2, n2, r2, a2;
  if (!e20) return [];
  const i2 = [];
  for (let s2 = 0; e20.length > s2; s2++) {
    if (!(null == (n2 = null == (t2 = e20[s2].annotations) ? void 0 : t2.leftEyeIris) ? void 0 : n2[0]) || !(null == (a2 = null == (r2 = e20[s2].annotations) ? void 0 : r2.rightEyeIris) ? void 0 : a2[0])) continue;
    const o2 = Math.abs((e20[s2].annotations.leftEyeIris[3][0] - e20[s2].annotations.leftEyeIris[1][0]) * (e20[s2].annotations.leftEyeIris[4][1] - e20[s2].annotations.leftEyeIris[2][1])), l2 = Math.abs((e20[s2].annotations.rightEyeIris[3][0] - e20[s2].annotations.rightEyeIris[1][0]) * (e20[s2].annotations.rightEyeIris[4][1] - e20[s2].annotations.rightEyeIris[2][1]));
    let u2 = false;
    0.25 > Math.abs(o2 - l2) / Math.max(o2, l2) && (u2 = true, i2.push({ iris: s2, gesture: "facing center" }));
    const d2 = Math.abs(e20[s2].mesh[263][0] - e20[s2].annotations.leftEyeIris[0][0]) / e20[s2].box[2], c2 = Math.abs(e20[s2].mesh[33][0] - e20[s2].annotations.rightEyeIris[0][0]) / e20[s2].box[2];
    (d2 > 0.06 || c2 > 0.06) && (u2 = false), d2 > c2 ? c2 > 0.04 && i2.push({ iris: s2, gesture: "looking right" }) : d2 > 0.04 && i2.push({ iris: s2, gesture: "looking left" });
    const h2 = Math.abs(e20[s2].mesh[145][1] - e20[s2].annotations.rightEyeIris[0][1]) / e20[s2].box[3], p2 = Math.abs(e20[s2].mesh[374][1] - e20[s2].annotations.leftEyeIris[0][1]) / e20[s2].box[3];
    (0.01 > p2 || 0.01 > h2 || p2 > 0.022 || h2 > 0.022) && (u2 = false), (0.01 > p2 || 0.01 > h2) && i2.push({ iris: s2, gesture: "looking down" }), (p2 > 0.022 || h2 > 0.022) && i2.push({ iris: s2, gesture: "looking up" }), u2 && i2.push({ iris: s2, gesture: "looking center" });
  }
  return i2;
};
var aQ = (e20) => {
  if (!e20) return [];
  const t2 = [];
  for (let n2 = 0; e20.length > n2; n2++) {
    const r2 = [];
    if (e20[n2].annotations) for (const [t3, a2] of Object.entries(e20[n2].annotations)) "palmBase" !== t3 && Array.isArray(a2) && a2[0] && r2.push({ name: t3.toLowerCase(), position: a2[0] });
    if (r2 && r2.length > 0) {
      const e21 = r2.reduce((e22, t3) => (t3.position[2] || 0) > (e22.position[2] || 0) ? e22 : t3);
      t2.push({ hand: n2, gesture: e21.name + " forward" });
      const a2 = r2.reduce((e22, t3) => t3.position[1] > e22.position[1] ? e22 : t3);
      t2.push({ hand: n2, gesture: a2.name + " up" });
    }
    if (e20[n2].keypoints) {
      const r3 = eQ(e20[n2].keypoints);
      for (const e21 of r3) t2.push({ hand: n2, gesture: e21.name });
    }
  }
  return t2;
};
function iQ(e20) {
  return [Math.abs(e20.endPoint[0] - e20.startPoint[0]), Math.abs(e20.endPoint[1] - e20.startPoint[1])];
}
function sQ(e20) {
  return [e20.startPoint[0] + (e20.endPoint[0] - e20.startPoint[0]) / 2, e20.startPoint[1] + (e20.endPoint[1] - e20.startPoint[1]) / 2];
}
function oQ(e20, t2, n2) {
  const r2 = t2.shape[1], a2 = t2.shape[2];
  return mp.cropAndResize(t2, [[e20.startPoint[1] / r2, e20.startPoint[0] / a2, e20.endPoint[1] / r2, e20.endPoint[0] / a2]], [0], n2);
}
function lQ(e20, t2) {
  return { startPoint: [e20.startPoint[0] * t2[0], e20.startPoint[1] * t2[1]], endPoint: [e20.endPoint[0] * t2[0], e20.endPoint[1] * t2[1]], palmLandmarks: e20.palmLandmarks.map((e21) => [e21[0] * t2[0], e21[1] * t2[1]]), confidence: e20.confidence };
}
function uQ(e20, t2 = 1.5) {
  const n2 = sQ(e20), r2 = iQ(e20), a2 = [t2 * r2[0] / 2, t2 * r2[1] / 2];
  return { startPoint: [n2[0] - a2[0], n2[1] - a2[1]], endPoint: [n2[0] + a2[0], n2[1] + a2[1]], palmLandmarks: e20.palmLandmarks };
}
function dQ(e20) {
  const t2 = sQ(e20), n2 = iQ(e20), r2 = Math.max(...n2) / 2;
  return { startPoint: [t2[0] - r2, t2[1] - r2], endPoint: [t2[0] + r2, t2[1] + r2], palmLandmarks: e20.palmLandmarks };
}
function cQ(e20, t2) {
  return (n2 = Math.PI / 2 - Math.atan2(-(t2[1] - e20[1]), t2[0] - e20[0])) - 2 * Math.PI * Math.floor((n2 + Math.PI) / (2 * Math.PI));
  var n2;
}
var hQ = (e20, t2) => [[1, 0, e20], [0, 1, t2], [0, 0, 1]];
function pQ(e20, t2) {
  let n2 = 0;
  for (let r2 = 0; e20.length > r2; r2++) n2 += e20[r2] * t2[r2];
  return n2;
}
function fQ(e20, t2) {
  const n2 = [];
  for (let r2 = 0; e20.length > r2; r2++) n2.push(e20[r2][t2]);
  return n2;
}
function mQ(e20, t2) {
  const n2 = [], r2 = e20.length;
  for (let a2 = 0; r2 > a2; a2++) {
    n2.push([]);
    for (let i2 = 0; r2 > i2; i2++) n2[a2].push(pQ(e20[a2], fQ(t2, i2)));
  }
  return n2;
}
function AQ(e20, t2) {
  const n2 = Math.cos(e20), r2 = Math.sin(e20), a2 = [[n2, -r2, 0], [r2, n2, 0], [0, 0, 1]], i2 = mQ(hQ(t2[0], t2[1]), a2);
  return mQ(i2, hQ(-t2[0], -t2[1]));
}
function xQ(e20, t2) {
  return [pQ(e20, t2[0]), pQ(e20, t2[1])];
}
var yQ;
var bQ;
var gQ;
var vQ = [{ x: 0.015625, y: 0.015625 }, { x: 0.015625, y: 0.015625 }, { x: 0.046875, y: 0.015625 }, { x: 0.046875, y: 0.015625 }, { x: 0.078125, y: 0.015625 }, { x: 0.078125, y: 0.015625 }, { x: 0.109375, y: 0.015625 }, { x: 0.109375, y: 0.015625 }, { x: 0.140625, y: 0.015625 }, { x: 0.140625, y: 0.015625 }, { x: 0.171875, y: 0.015625 }, { x: 0.171875, y: 0.015625 }, { x: 0.203125, y: 0.015625 }, { x: 0.203125, y: 0.015625 }, { x: 0.234375, y: 0.015625 }, { x: 0.234375, y: 0.015625 }, { x: 0.265625, y: 0.015625 }, { x: 0.265625, y: 0.015625 }, { x: 0.296875, y: 0.015625 }, { x: 0.296875, y: 0.015625 }, { x: 0.328125, y: 0.015625 }, { x: 0.328125, y: 0.015625 }, { x: 0.359375, y: 0.015625 }, { x: 0.359375, y: 0.015625 }, { x: 0.390625, y: 0.015625 }, { x: 0.390625, y: 0.015625 }, { x: 0.421875, y: 0.015625 }, { x: 0.421875, y: 0.015625 }, { x: 0.453125, y: 0.015625 }, { x: 0.453125, y: 0.015625 }, { x: 0.484375, y: 0.015625 }, { x: 0.484375, y: 0.015625 }, { x: 0.515625, y: 0.015625 }, { x: 0.515625, y: 0.015625 }, { x: 0.546875, y: 0.015625 }, { x: 0.546875, y: 0.015625 }, { x: 0.578125, y: 0.015625 }, { x: 0.578125, y: 0.015625 }, { x: 0.609375, y: 0.015625 }, { x: 0.609375, y: 0.015625 }, { x: 0.640625, y: 0.015625 }, { x: 0.640625, y: 0.015625 }, { x: 0.671875, y: 0.015625 }, { x: 0.671875, y: 0.015625 }, { x: 0.703125, y: 0.015625 }, { x: 0.703125, y: 0.015625 }, { x: 0.734375, y: 0.015625 }, { x: 0.734375, y: 0.015625 }, { x: 0.765625, y: 0.015625 }, { x: 0.765625, y: 0.015625 }, { x: 0.796875, y: 0.015625 }, { x: 0.796875, y: 0.015625 }, { x: 0.828125, y: 0.015625 }, { x: 0.828125, y: 0.015625 }, { x: 0.859375, y: 0.015625 }, { x: 0.859375, y: 0.015625 }, { x: 0.890625, y: 0.015625 }, { x: 0.890625, y: 0.015625 }, { x: 0.921875, y: 0.015625 }, { x: 0.921875, y: 0.015625 }, { x: 0.953125, y: 0.015625 }, { x: 0.953125, y: 0.015625 }, { x: 0.984375, y: 0.015625 }, { x: 0.984375, y: 0.015625 }, { x: 0.015625, y: 0.046875 }, { x: 0.015625, y: 0.046875 }, { x: 0.046875, y: 0.046875 }, { x: 0.046875, y: 0.046875 }, { x: 0.078125, y: 0.046875 }, { x: 0.078125, y: 0.046875 }, { x: 0.109375, y: 0.046875 }, { x: 0.109375, y: 0.046875 }, { x: 0.140625, y: 0.046875 }, { x: 0.140625, y: 0.046875 }, { x: 0.171875, y: 0.046875 }, { x: 0.171875, y: 0.046875 }, { x: 0.203125, y: 0.046875 }, { x: 0.203125, y: 0.046875 }, { x: 0.234375, y: 0.046875 }, { x: 0.234375, y: 0.046875 }, { x: 0.265625, y: 0.046875 }, { x: 0.265625, y: 0.046875 }, { x: 0.296875, y: 0.046875 }, { x: 0.296875, y: 0.046875 }, { x: 0.328125, y: 0.046875 }, { x: 0.328125, y: 0.046875 }, { x: 0.359375, y: 0.046875 }, { x: 0.359375, y: 0.046875 }, { x: 0.390625, y: 0.046875 }, { x: 0.390625, y: 0.046875 }, { x: 0.421875, y: 0.046875 }, { x: 0.421875, y: 0.046875 }, { x: 0.453125, y: 0.046875 }, { x: 0.453125, y: 0.046875 }, { x: 0.484375, y: 0.046875 }, { x: 0.484375, y: 0.046875 }, { x: 0.515625, y: 0.046875 }, { x: 0.515625, y: 0.046875 }, { x: 0.546875, y: 0.046875 }, { x: 0.546875, y: 0.046875 }, { x: 0.578125, y: 0.046875 }, { x: 0.578125, y: 0.046875 }, { x: 0.609375, y: 0.046875 }, { x: 0.609375, y: 0.046875 }, { x: 0.640625, y: 0.046875 }, { x: 0.640625, y: 0.046875 }, { x: 0.671875, y: 0.046875 }, { x: 0.671875, y: 0.046875 }, { x: 0.703125, y: 0.046875 }, { x: 0.703125, y: 0.046875 }, { x: 0.734375, y: 0.046875 }, { x: 0.734375, y: 0.046875 }, { x: 0.765625, y: 0.046875 }, { x: 0.765625, y: 0.046875 }, { x: 0.796875, y: 0.046875 }, { x: 0.796875, y: 0.046875 }, { x: 0.828125, y: 0.046875 }, { x: 0.828125, y: 0.046875 }, { x: 0.859375, y: 0.046875 }, { x: 0.859375, y: 0.046875 }, { x: 0.890625, y: 0.046875 }, { x: 0.890625, y: 0.046875 }, { x: 0.921875, y: 0.046875 }, { x: 0.921875, y: 0.046875 }, { x: 0.953125, y: 0.046875 }, { x: 0.953125, y: 0.046875 }, { x: 0.984375, y: 0.046875 }, { x: 0.984375, y: 0.046875 }, { x: 0.015625, y: 0.078125 }, { x: 0.015625, y: 0.078125 }, { x: 0.046875, y: 0.078125 }, { x: 0.046875, y: 0.078125 }, { x: 0.078125, y: 0.078125 }, { x: 0.078125, y: 0.078125 }, { x: 0.109375, y: 0.078125 }, { x: 0.109375, y: 0.078125 }, { x: 0.140625, y: 0.078125 }, { x: 0.140625, y: 0.078125 }, { x: 0.171875, y: 0.078125 }, { x: 0.171875, y: 0.078125 }, { x: 0.203125, y: 0.078125 }, { x: 0.203125, y: 0.078125 }, { x: 0.234375, y: 0.078125 }, { x: 0.234375, y: 0.078125 }, { x: 0.265625, y: 0.078125 }, { x: 0.265625, y: 0.078125 }, { x: 0.296875, y: 0.078125 }, { x: 0.296875, y: 0.078125 }, { x: 0.328125, y: 0.078125 }, { x: 0.328125, y: 0.078125 }, { x: 0.359375, y: 0.078125 }, { x: 0.359375, y: 0.078125 }, { x: 0.390625, y: 0.078125 }, { x: 0.390625, y: 0.078125 }, { x: 0.421875, y: 0.078125 }, { x: 0.421875, y: 0.078125 }, { x: 0.453125, y: 0.078125 }, { x: 0.453125, y: 0.078125 }, { x: 0.484375, y: 0.078125 }, { x: 0.484375, y: 0.078125 }, { x: 0.515625, y: 0.078125 }, { x: 0.515625, y: 0.078125 }, { x: 0.546875, y: 0.078125 }, { x: 0.546875, y: 0.078125 }, { x: 0.578125, y: 0.078125 }, { x: 0.578125, y: 0.078125 }, { x: 0.609375, y: 0.078125 }, { x: 0.609375, y: 0.078125 }, { x: 0.640625, y: 0.078125 }, { x: 0.640625, y: 0.078125 }, { x: 0.671875, y: 0.078125 }, { x: 0.671875, y: 0.078125 }, { x: 0.703125, y: 0.078125 }, { x: 0.703125, y: 0.078125 }, { x: 0.734375, y: 0.078125 }, { x: 0.734375, y: 0.078125 }, { x: 0.765625, y: 0.078125 }, { x: 0.765625, y: 0.078125 }, { x: 0.796875, y: 0.078125 }, { x: 0.796875, y: 0.078125 }, { x: 0.828125, y: 0.078125 }, { x: 0.828125, y: 0.078125 }, { x: 0.859375, y: 0.078125 }, { x: 0.859375, y: 0.078125 }, { x: 0.890625, y: 0.078125 }, { x: 0.890625, y: 0.078125 }, { x: 0.921875, y: 0.078125 }, { x: 0.921875, y: 0.078125 }, { x: 0.953125, y: 0.078125 }, { x: 0.953125, y: 0.078125 }, { x: 0.984375, y: 0.078125 }, { x: 0.984375, y: 0.078125 }, { x: 0.015625, y: 0.109375 }, { x: 0.015625, y: 0.109375 }, { x: 0.046875, y: 0.109375 }, { x: 0.046875, y: 0.109375 }, { x: 0.078125, y: 0.109375 }, { x: 0.078125, y: 0.109375 }, { x: 0.109375, y: 0.109375 }, { x: 0.109375, y: 0.109375 }, { x: 0.140625, y: 0.109375 }, { x: 0.140625, y: 0.109375 }, { x: 0.171875, y: 0.109375 }, { x: 0.171875, y: 0.109375 }, { x: 0.203125, y: 0.109375 }, { x: 0.203125, y: 0.109375 }, { x: 0.234375, y: 0.109375 }, { x: 0.234375, y: 0.109375 }, { x: 0.265625, y: 0.109375 }, { x: 0.265625, y: 0.109375 }, { x: 0.296875, y: 0.109375 }, { x: 0.296875, y: 0.109375 }, { x: 0.328125, y: 0.109375 }, { x: 0.328125, y: 0.109375 }, { x: 0.359375, y: 0.109375 }, { x: 0.359375, y: 0.109375 }, { x: 0.390625, y: 0.109375 }, { x: 0.390625, y: 0.109375 }, { x: 0.421875, y: 0.109375 }, { x: 0.421875, y: 0.109375 }, { x: 0.453125, y: 0.109375 }, { x: 0.453125, y: 0.109375 }, { x: 0.484375, y: 0.109375 }, { x: 0.484375, y: 0.109375 }, { x: 0.515625, y: 0.109375 }, { x: 0.515625, y: 0.109375 }, { x: 0.546875, y: 0.109375 }, { x: 0.546875, y: 0.109375 }, { x: 0.578125, y: 0.109375 }, { x: 0.578125, y: 0.109375 }, { x: 0.609375, y: 0.109375 }, { x: 0.609375, y: 0.109375 }, { x: 0.640625, y: 0.109375 }, { x: 0.640625, y: 0.109375 }, { x: 0.671875, y: 0.109375 }, { x: 0.671875, y: 0.109375 }, { x: 0.703125, y: 0.109375 }, { x: 0.703125, y: 0.109375 }, { x: 0.734375, y: 0.109375 }, { x: 0.734375, y: 0.109375 }, { x: 0.765625, y: 0.109375 }, { x: 0.765625, y: 0.109375 }, { x: 0.796875, y: 0.109375 }, { x: 0.796875, y: 0.109375 }, { x: 0.828125, y: 0.109375 }, { x: 0.828125, y: 0.109375 }, { x: 0.859375, y: 0.109375 }, { x: 0.859375, y: 0.109375 }, { x: 0.890625, y: 0.109375 }, { x: 0.890625, y: 0.109375 }, { x: 0.921875, y: 0.109375 }, { x: 0.921875, y: 0.109375 }, { x: 0.953125, y: 0.109375 }, { x: 0.953125, y: 0.109375 }, { x: 0.984375, y: 0.109375 }, { x: 0.984375, y: 0.109375 }, { x: 0.015625, y: 0.140625 }, { x: 0.015625, y: 0.140625 }, { x: 0.046875, y: 0.140625 }, { x: 0.046875, y: 0.140625 }, { x: 0.078125, y: 0.140625 }, { x: 0.078125, y: 0.140625 }, { x: 0.109375, y: 0.140625 }, { x: 0.109375, y: 0.140625 }, { x: 0.140625, y: 0.140625 }, { x: 0.140625, y: 0.140625 }, { x: 0.171875, y: 0.140625 }, { x: 0.171875, y: 0.140625 }, { x: 0.203125, y: 0.140625 }, { x: 0.203125, y: 0.140625 }, { x: 0.234375, y: 0.140625 }, { x: 0.234375, y: 0.140625 }, { x: 0.265625, y: 0.140625 }, { x: 0.265625, y: 0.140625 }, { x: 0.296875, y: 0.140625 }, { x: 0.296875, y: 0.140625 }, { x: 0.328125, y: 0.140625 }, { x: 0.328125, y: 0.140625 }, { x: 0.359375, y: 0.140625 }, { x: 0.359375, y: 0.140625 }, { x: 0.390625, y: 0.140625 }, { x: 0.390625, y: 0.140625 }, { x: 0.421875, y: 0.140625 }, { x: 0.421875, y: 0.140625 }, { x: 0.453125, y: 0.140625 }, { x: 0.453125, y: 0.140625 }, { x: 0.484375, y: 0.140625 }, { x: 0.484375, y: 0.140625 }, { x: 0.515625, y: 0.140625 }, { x: 0.515625, y: 0.140625 }, { x: 0.546875, y: 0.140625 }, { x: 0.546875, y: 0.140625 }, { x: 0.578125, y: 0.140625 }, { x: 0.578125, y: 0.140625 }, { x: 0.609375, y: 0.140625 }, { x: 0.609375, y: 0.140625 }, { x: 0.640625, y: 0.140625 }, { x: 0.640625, y: 0.140625 }, { x: 0.671875, y: 0.140625 }, { x: 0.671875, y: 0.140625 }, { x: 0.703125, y: 0.140625 }, { x: 0.703125, y: 0.140625 }, { x: 0.734375, y: 0.140625 }, { x: 0.734375, y: 0.140625 }, { x: 0.765625, y: 0.140625 }, { x: 0.765625, y: 0.140625 }, { x: 0.796875, y: 0.140625 }, { x: 0.796875, y: 0.140625 }, { x: 0.828125, y: 0.140625 }, { x: 0.828125, y: 0.140625 }, { x: 0.859375, y: 0.140625 }, { x: 0.859375, y: 0.140625 }, { x: 0.890625, y: 0.140625 }, { x: 0.890625, y: 0.140625 }, { x: 0.921875, y: 0.140625 }, { x: 0.921875, y: 0.140625 }, { x: 0.953125, y: 0.140625 }, { x: 0.953125, y: 0.140625 }, { x: 0.984375, y: 0.140625 }, { x: 0.984375, y: 0.140625 }, { x: 0.015625, y: 0.171875 }, { x: 0.015625, y: 0.171875 }, { x: 0.046875, y: 0.171875 }, { x: 0.046875, y: 0.171875 }, { x: 0.078125, y: 0.171875 }, { x: 0.078125, y: 0.171875 }, { x: 0.109375, y: 0.171875 }, { x: 0.109375, y: 0.171875 }, { x: 0.140625, y: 0.171875 }, { x: 0.140625, y: 0.171875 }, { x: 0.171875, y: 0.171875 }, { x: 0.171875, y: 0.171875 }, { x: 0.203125, y: 0.171875 }, { x: 0.203125, y: 0.171875 }, { x: 0.234375, y: 0.171875 }, { x: 0.234375, y: 0.171875 }, { x: 0.265625, y: 0.171875 }, { x: 0.265625, y: 0.171875 }, { x: 0.296875, y: 0.171875 }, { x: 0.296875, y: 0.171875 }, { x: 0.328125, y: 0.171875 }, { x: 0.328125, y: 0.171875 }, { x: 0.359375, y: 0.171875 }, { x: 0.359375, y: 0.171875 }, { x: 0.390625, y: 0.171875 }, { x: 0.390625, y: 0.171875 }, { x: 0.421875, y: 0.171875 }, { x: 0.421875, y: 0.171875 }, { x: 0.453125, y: 0.171875 }, { x: 0.453125, y: 0.171875 }, { x: 0.484375, y: 0.171875 }, { x: 0.484375, y: 0.171875 }, { x: 0.515625, y: 0.171875 }, { x: 0.515625, y: 0.171875 }, { x: 0.546875, y: 0.171875 }, { x: 0.546875, y: 0.171875 }, { x: 0.578125, y: 0.171875 }, { x: 0.578125, y: 0.171875 }, { x: 0.609375, y: 0.171875 }, { x: 0.609375, y: 0.171875 }, { x: 0.640625, y: 0.171875 }, { x: 0.640625, y: 0.171875 }, { x: 0.671875, y: 0.171875 }, { x: 0.671875, y: 0.171875 }, { x: 0.703125, y: 0.171875 }, { x: 0.703125, y: 0.171875 }, { x: 0.734375, y: 0.171875 }, { x: 0.734375, y: 0.171875 }, { x: 0.765625, y: 0.171875 }, { x: 0.765625, y: 0.171875 }, { x: 0.796875, y: 0.171875 }, { x: 0.796875, y: 0.171875 }, { x: 0.828125, y: 0.171875 }, { x: 0.828125, y: 0.171875 }, { x: 0.859375, y: 0.171875 }, { x: 0.859375, y: 0.171875 }, { x: 0.890625, y: 0.171875 }, { x: 0.890625, y: 0.171875 }, { x: 0.921875, y: 0.171875 }, { x: 0.921875, y: 0.171875 }, { x: 0.953125, y: 0.171875 }, { x: 0.953125, y: 0.171875 }, { x: 0.984375, y: 0.171875 }, { x: 0.984375, y: 0.171875 }, { x: 0.015625, y: 0.203125 }, { x: 0.015625, y: 0.203125 }, { x: 0.046875, y: 0.203125 }, { x: 0.046875, y: 0.203125 }, { x: 0.078125, y: 0.203125 }, { x: 0.078125, y: 0.203125 }, { x: 0.109375, y: 0.203125 }, { x: 0.109375, y: 0.203125 }, { x: 0.140625, y: 0.203125 }, { x: 0.140625, y: 0.203125 }, { x: 0.171875, y: 0.203125 }, { x: 0.171875, y: 0.203125 }, { x: 0.203125, y: 0.203125 }, { x: 0.203125, y: 0.203125 }, { x: 0.234375, y: 0.203125 }, { x: 0.234375, y: 0.203125 }, { x: 0.265625, y: 0.203125 }, { x: 0.265625, y: 0.203125 }, { x: 0.296875, y: 0.203125 }, { x: 0.296875, y: 0.203125 }, { x: 0.328125, y: 0.203125 }, { x: 0.328125, y: 0.203125 }, { x: 0.359375, y: 0.203125 }, { x: 0.359375, y: 0.203125 }, { x: 0.390625, y: 0.203125 }, { x: 0.390625, y: 0.203125 }, { x: 0.421875, y: 0.203125 }, { x: 0.421875, y: 0.203125 }, { x: 0.453125, y: 0.203125 }, { x: 0.453125, y: 0.203125 }, { x: 0.484375, y: 0.203125 }, { x: 0.484375, y: 0.203125 }, { x: 0.515625, y: 0.203125 }, { x: 0.515625, y: 0.203125 }, { x: 0.546875, y: 0.203125 }, { x: 0.546875, y: 0.203125 }, { x: 0.578125, y: 0.203125 }, { x: 0.578125, y: 0.203125 }, { x: 0.609375, y: 0.203125 }, { x: 0.609375, y: 0.203125 }, { x: 0.640625, y: 0.203125 }, { x: 0.640625, y: 0.203125 }, { x: 0.671875, y: 0.203125 }, { x: 0.671875, y: 0.203125 }, { x: 0.703125, y: 0.203125 }, { x: 0.703125, y: 0.203125 }, { x: 0.734375, y: 0.203125 }, { x: 0.734375, y: 0.203125 }, { x: 0.765625, y: 0.203125 }, { x: 0.765625, y: 0.203125 }, { x: 0.796875, y: 0.203125 }, { x: 0.796875, y: 0.203125 }, { x: 0.828125, y: 0.203125 }, { x: 0.828125, y: 0.203125 }, { x: 0.859375, y: 0.203125 }, { x: 0.859375, y: 0.203125 }, { x: 0.890625, y: 0.203125 }, { x: 0.890625, y: 0.203125 }, { x: 0.921875, y: 0.203125 }, { x: 0.921875, y: 0.203125 }, { x: 0.953125, y: 0.203125 }, { x: 0.953125, y: 0.203125 }, { x: 0.984375, y: 0.203125 }, { x: 0.984375, y: 0.203125 }, { x: 0.015625, y: 0.234375 }, { x: 0.015625, y: 0.234375 }, { x: 0.046875, y: 0.234375 }, { x: 0.046875, y: 0.234375 }, { x: 0.078125, y: 0.234375 }, { x: 0.078125, y: 0.234375 }, { x: 0.109375, y: 0.234375 }, { x: 0.109375, y: 0.234375 }, { x: 0.140625, y: 0.234375 }, { x: 0.140625, y: 0.234375 }, { x: 0.171875, y: 0.234375 }, { x: 0.171875, y: 0.234375 }, { x: 0.203125, y: 0.234375 }, { x: 0.203125, y: 0.234375 }, { x: 0.234375, y: 0.234375 }, { x: 0.234375, y: 0.234375 }, { x: 0.265625, y: 0.234375 }, { x: 0.265625, y: 0.234375 }, { x: 0.296875, y: 0.234375 }, { x: 0.296875, y: 0.234375 }, { x: 0.328125, y: 0.234375 }, { x: 0.328125, y: 0.234375 }, { x: 0.359375, y: 0.234375 }, { x: 0.359375, y: 0.234375 }, { x: 0.390625, y: 0.234375 }, { x: 0.390625, y: 0.234375 }, { x: 0.421875, y: 0.234375 }, { x: 0.421875, y: 0.234375 }, { x: 0.453125, y: 0.234375 }, { x: 0.453125, y: 0.234375 }, { x: 0.484375, y: 0.234375 }, { x: 0.484375, y: 0.234375 }, { x: 0.515625, y: 0.234375 }, { x: 0.515625, y: 0.234375 }, { x: 0.546875, y: 0.234375 }, { x: 0.546875, y: 0.234375 }, { x: 0.578125, y: 0.234375 }, { x: 0.578125, y: 0.234375 }, { x: 0.609375, y: 0.234375 }, { x: 0.609375, y: 0.234375 }, { x: 0.640625, y: 0.234375 }, { x: 0.640625, y: 0.234375 }, { x: 0.671875, y: 0.234375 }, { x: 0.671875, y: 0.234375 }, { x: 0.703125, y: 0.234375 }, { x: 0.703125, y: 0.234375 }, { x: 0.734375, y: 0.234375 }, { x: 0.734375, y: 0.234375 }, { x: 0.765625, y: 0.234375 }, { x: 0.765625, y: 0.234375 }, { x: 0.796875, y: 0.234375 }, { x: 0.796875, y: 0.234375 }, { x: 0.828125, y: 0.234375 }, { x: 0.828125, y: 0.234375 }, { x: 0.859375, y: 0.234375 }, { x: 0.859375, y: 0.234375 }, { x: 0.890625, y: 0.234375 }, { x: 0.890625, y: 0.234375 }, { x: 0.921875, y: 0.234375 }, { x: 0.921875, y: 0.234375 }, { x: 0.953125, y: 0.234375 }, { x: 0.953125, y: 0.234375 }, { x: 0.984375, y: 0.234375 }, { x: 0.984375, y: 0.234375 }, { x: 0.015625, y: 0.265625 }, { x: 0.015625, y: 0.265625 }, { x: 0.046875, y: 0.265625 }, { x: 0.046875, y: 0.265625 }, { x: 0.078125, y: 0.265625 }, { x: 0.078125, y: 0.265625 }, { x: 0.109375, y: 0.265625 }, { x: 0.109375, y: 0.265625 }, { x: 0.140625, y: 0.265625 }, { x: 0.140625, y: 0.265625 }, { x: 0.171875, y: 0.265625 }, { x: 0.171875, y: 0.265625 }, { x: 0.203125, y: 0.265625 }, { x: 0.203125, y: 0.265625 }, { x: 0.234375, y: 0.265625 }, { x: 0.234375, y: 0.265625 }, { x: 0.265625, y: 0.265625 }, { x: 0.265625, y: 0.265625 }, { x: 0.296875, y: 0.265625 }, { x: 0.296875, y: 0.265625 }, { x: 0.328125, y: 0.265625 }, { x: 0.328125, y: 0.265625 }, { x: 0.359375, y: 0.265625 }, { x: 0.359375, y: 0.265625 }, { x: 0.390625, y: 0.265625 }, { x: 0.390625, y: 0.265625 }, { x: 0.421875, y: 0.265625 }, { x: 0.421875, y: 0.265625 }, { x: 0.453125, y: 0.265625 }, { x: 0.453125, y: 0.265625 }, { x: 0.484375, y: 0.265625 }, { x: 0.484375, y: 0.265625 }, { x: 0.515625, y: 0.265625 }, { x: 0.515625, y: 0.265625 }, { x: 0.546875, y: 0.265625 }, { x: 0.546875, y: 0.265625 }, { x: 0.578125, y: 0.265625 }, { x: 0.578125, y: 0.265625 }, { x: 0.609375, y: 0.265625 }, { x: 0.609375, y: 0.265625 }, { x: 0.640625, y: 0.265625 }, { x: 0.640625, y: 0.265625 }, { x: 0.671875, y: 0.265625 }, { x: 0.671875, y: 0.265625 }, { x: 0.703125, y: 0.265625 }, { x: 0.703125, y: 0.265625 }, { x: 0.734375, y: 0.265625 }, { x: 0.734375, y: 0.265625 }, { x: 0.765625, y: 0.265625 }, { x: 0.765625, y: 0.265625 }, { x: 0.796875, y: 0.265625 }, { x: 0.796875, y: 0.265625 }, { x: 0.828125, y: 0.265625 }, { x: 0.828125, y: 0.265625 }, { x: 0.859375, y: 0.265625 }, { x: 0.859375, y: 0.265625 }, { x: 0.890625, y: 0.265625 }, { x: 0.890625, y: 0.265625 }, { x: 0.921875, y: 0.265625 }, { x: 0.921875, y: 0.265625 }, { x: 0.953125, y: 0.265625 }, { x: 0.953125, y: 0.265625 }, { x: 0.984375, y: 0.265625 }, { x: 0.984375, y: 0.265625 }, { x: 0.015625, y: 0.296875 }, { x: 0.015625, y: 0.296875 }, { x: 0.046875, y: 0.296875 }, { x: 0.046875, y: 0.296875 }, { x: 0.078125, y: 0.296875 }, { x: 0.078125, y: 0.296875 }, { x: 0.109375, y: 0.296875 }, { x: 0.109375, y: 0.296875 }, { x: 0.140625, y: 0.296875 }, { x: 0.140625, y: 0.296875 }, { x: 0.171875, y: 0.296875 }, { x: 0.171875, y: 0.296875 }, { x: 0.203125, y: 0.296875 }, { x: 0.203125, y: 0.296875 }, { x: 0.234375, y: 0.296875 }, { x: 0.234375, y: 0.296875 }, { x: 0.265625, y: 0.296875 }, { x: 0.265625, y: 0.296875 }, { x: 0.296875, y: 0.296875 }, { x: 0.296875, y: 0.296875 }, { x: 0.328125, y: 0.296875 }, { x: 0.328125, y: 0.296875 }, { x: 0.359375, y: 0.296875 }, { x: 0.359375, y: 0.296875 }, { x: 0.390625, y: 0.296875 }, { x: 0.390625, y: 0.296875 }, { x: 0.421875, y: 0.296875 }, { x: 0.421875, y: 0.296875 }, { x: 0.453125, y: 0.296875 }, { x: 0.453125, y: 0.296875 }, { x: 0.484375, y: 0.296875 }, { x: 0.484375, y: 0.296875 }, { x: 0.515625, y: 0.296875 }, { x: 0.515625, y: 0.296875 }, { x: 0.546875, y: 0.296875 }, { x: 0.546875, y: 0.296875 }, { x: 0.578125, y: 0.296875 }, { x: 0.578125, y: 0.296875 }, { x: 0.609375, y: 0.296875 }, { x: 0.609375, y: 0.296875 }, { x: 0.640625, y: 0.296875 }, { x: 0.640625, y: 0.296875 }, { x: 0.671875, y: 0.296875 }, { x: 0.671875, y: 0.296875 }, { x: 0.703125, y: 0.296875 }, { x: 0.703125, y: 0.296875 }, { x: 0.734375, y: 0.296875 }, { x: 0.734375, y: 0.296875 }, { x: 0.765625, y: 0.296875 }, { x: 0.765625, y: 0.296875 }, { x: 0.796875, y: 0.296875 }, { x: 0.796875, y: 0.296875 }, { x: 0.828125, y: 0.296875 }, { x: 0.828125, y: 0.296875 }, { x: 0.859375, y: 0.296875 }, { x: 0.859375, y: 0.296875 }, { x: 0.890625, y: 0.296875 }, { x: 0.890625, y: 0.296875 }, { x: 0.921875, y: 0.296875 }, { x: 0.921875, y: 0.296875 }, { x: 0.953125, y: 0.296875 }, { x: 0.953125, y: 0.296875 }, { x: 0.984375, y: 0.296875 }, { x: 0.984375, y: 0.296875 }, { x: 0.015625, y: 0.328125 }, { x: 0.015625, y: 0.328125 }, { x: 0.046875, y: 0.328125 }, { x: 0.046875, y: 0.328125 }, { x: 0.078125, y: 0.328125 }, { x: 0.078125, y: 0.328125 }, { x: 0.109375, y: 0.328125 }, { x: 0.109375, y: 0.328125 }, { x: 0.140625, y: 0.328125 }, { x: 0.140625, y: 0.328125 }, { x: 0.171875, y: 0.328125 }, { x: 0.171875, y: 0.328125 }, { x: 0.203125, y: 0.328125 }, { x: 0.203125, y: 0.328125 }, { x: 0.234375, y: 0.328125 }, { x: 0.234375, y: 0.328125 }, { x: 0.265625, y: 0.328125 }, { x: 0.265625, y: 0.328125 }, { x: 0.296875, y: 0.328125 }, { x: 0.296875, y: 0.328125 }, { x: 0.328125, y: 0.328125 }, { x: 0.328125, y: 0.328125 }, { x: 0.359375, y: 0.328125 }, { x: 0.359375, y: 0.328125 }, { x: 0.390625, y: 0.328125 }, { x: 0.390625, y: 0.328125 }, { x: 0.421875, y: 0.328125 }, { x: 0.421875, y: 0.328125 }, { x: 0.453125, y: 0.328125 }, { x: 0.453125, y: 0.328125 }, { x: 0.484375, y: 0.328125 }, { x: 0.484375, y: 0.328125 }, { x: 0.515625, y: 0.328125 }, { x: 0.515625, y: 0.328125 }, { x: 0.546875, y: 0.328125 }, { x: 0.546875, y: 0.328125 }, { x: 0.578125, y: 0.328125 }, { x: 0.578125, y: 0.328125 }, { x: 0.609375, y: 0.328125 }, { x: 0.609375, y: 0.328125 }, { x: 0.640625, y: 0.328125 }, { x: 0.640625, y: 0.328125 }, { x: 0.671875, y: 0.328125 }, { x: 0.671875, y: 0.328125 }, { x: 0.703125, y: 0.328125 }, { x: 0.703125, y: 0.328125 }, { x: 0.734375, y: 0.328125 }, { x: 0.734375, y: 0.328125 }, { x: 0.765625, y: 0.328125 }, { x: 0.765625, y: 0.328125 }, { x: 0.796875, y: 0.328125 }, { x: 0.796875, y: 0.328125 }, { x: 0.828125, y: 0.328125 }, { x: 0.828125, y: 0.328125 }, { x: 0.859375, y: 0.328125 }, { x: 0.859375, y: 0.328125 }, { x: 0.890625, y: 0.328125 }, { x: 0.890625, y: 0.328125 }, { x: 0.921875, y: 0.328125 }, { x: 0.921875, y: 0.328125 }, { x: 0.953125, y: 0.328125 }, { x: 0.953125, y: 0.328125 }, { x: 0.984375, y: 0.328125 }, { x: 0.984375, y: 0.328125 }, { x: 0.015625, y: 0.359375 }, { x: 0.015625, y: 0.359375 }, { x: 0.046875, y: 0.359375 }, { x: 0.046875, y: 0.359375 }, { x: 0.078125, y: 0.359375 }, { x: 0.078125, y: 0.359375 }, { x: 0.109375, y: 0.359375 }, { x: 0.109375, y: 0.359375 }, { x: 0.140625, y: 0.359375 }, { x: 0.140625, y: 0.359375 }, { x: 0.171875, y: 0.359375 }, { x: 0.171875, y: 0.359375 }, { x: 0.203125, y: 0.359375 }, { x: 0.203125, y: 0.359375 }, { x: 0.234375, y: 0.359375 }, { x: 0.234375, y: 0.359375 }, { x: 0.265625, y: 0.359375 }, { x: 0.265625, y: 0.359375 }, { x: 0.296875, y: 0.359375 }, { x: 0.296875, y: 0.359375 }, { x: 0.328125, y: 0.359375 }, { x: 0.328125, y: 0.359375 }, { x: 0.359375, y: 0.359375 }, { x: 0.359375, y: 0.359375 }, { x: 0.390625, y: 0.359375 }, { x: 0.390625, y: 0.359375 }, { x: 0.421875, y: 0.359375 }, { x: 0.421875, y: 0.359375 }, { x: 0.453125, y: 0.359375 }, { x: 0.453125, y: 0.359375 }, { x: 0.484375, y: 0.359375 }, { x: 0.484375, y: 0.359375 }, { x: 0.515625, y: 0.359375 }, { x: 0.515625, y: 0.359375 }, { x: 0.546875, y: 0.359375 }, { x: 0.546875, y: 0.359375 }, { x: 0.578125, y: 0.359375 }, { x: 0.578125, y: 0.359375 }, { x: 0.609375, y: 0.359375 }, { x: 0.609375, y: 0.359375 }, { x: 0.640625, y: 0.359375 }, { x: 0.640625, y: 0.359375 }, { x: 0.671875, y: 0.359375 }, { x: 0.671875, y: 0.359375 }, { x: 0.703125, y: 0.359375 }, { x: 0.703125, y: 0.359375 }, { x: 0.734375, y: 0.359375 }, { x: 0.734375, y: 0.359375 }, { x: 0.765625, y: 0.359375 }, { x: 0.765625, y: 0.359375 }, { x: 0.796875, y: 0.359375 }, { x: 0.796875, y: 0.359375 }, { x: 0.828125, y: 0.359375 }, { x: 0.828125, y: 0.359375 }, { x: 0.859375, y: 0.359375 }, { x: 0.859375, y: 0.359375 }, { x: 0.890625, y: 0.359375 }, { x: 0.890625, y: 0.359375 }, { x: 0.921875, y: 0.359375 }, { x: 0.921875, y: 0.359375 }, { x: 0.953125, y: 0.359375 }, { x: 0.953125, y: 0.359375 }, { x: 0.984375, y: 0.359375 }, { x: 0.984375, y: 0.359375 }, { x: 0.015625, y: 0.390625 }, { x: 0.015625, y: 0.390625 }, { x: 0.046875, y: 0.390625 }, { x: 0.046875, y: 0.390625 }, { x: 0.078125, y: 0.390625 }, { x: 0.078125, y: 0.390625 }, { x: 0.109375, y: 0.390625 }, { x: 0.109375, y: 0.390625 }, { x: 0.140625, y: 0.390625 }, { x: 0.140625, y: 0.390625 }, { x: 0.171875, y: 0.390625 }, { x: 0.171875, y: 0.390625 }, { x: 0.203125, y: 0.390625 }, { x: 0.203125, y: 0.390625 }, { x: 0.234375, y: 0.390625 }, { x: 0.234375, y: 0.390625 }, { x: 0.265625, y: 0.390625 }, { x: 0.265625, y: 0.390625 }, { x: 0.296875, y: 0.390625 }, { x: 0.296875, y: 0.390625 }, { x: 0.328125, y: 0.390625 }, { x: 0.328125, y: 0.390625 }, { x: 0.359375, y: 0.390625 }, { x: 0.359375, y: 0.390625 }, { x: 0.390625, y: 0.390625 }, { x: 0.390625, y: 0.390625 }, { x: 0.421875, y: 0.390625 }, { x: 0.421875, y: 0.390625 }, { x: 0.453125, y: 0.390625 }, { x: 0.453125, y: 0.390625 }, { x: 0.484375, y: 0.390625 }, { x: 0.484375, y: 0.390625 }, { x: 0.515625, y: 0.390625 }, { x: 0.515625, y: 0.390625 }, { x: 0.546875, y: 0.390625 }, { x: 0.546875, y: 0.390625 }, { x: 0.578125, y: 0.390625 }, { x: 0.578125, y: 0.390625 }, { x: 0.609375, y: 0.390625 }, { x: 0.609375, y: 0.390625 }, { x: 0.640625, y: 0.390625 }, { x: 0.640625, y: 0.390625 }, { x: 0.671875, y: 0.390625 }, { x: 0.671875, y: 0.390625 }, { x: 0.703125, y: 0.390625 }, { x: 0.703125, y: 0.390625 }, { x: 0.734375, y: 0.390625 }, { x: 0.734375, y: 0.390625 }, { x: 0.765625, y: 0.390625 }, { x: 0.765625, y: 0.390625 }, { x: 0.796875, y: 0.390625 }, { x: 0.796875, y: 0.390625 }, { x: 0.828125, y: 0.390625 }, { x: 0.828125, y: 0.390625 }, { x: 0.859375, y: 0.390625 }, { x: 0.859375, y: 0.390625 }, { x: 0.890625, y: 0.390625 }, { x: 0.890625, y: 0.390625 }, { x: 0.921875, y: 0.390625 }, { x: 0.921875, y: 0.390625 }, { x: 0.953125, y: 0.390625 }, { x: 0.953125, y: 0.390625 }, { x: 0.984375, y: 0.390625 }, { x: 0.984375, y: 0.390625 }, { x: 0.015625, y: 0.421875 }, { x: 0.015625, y: 0.421875 }, { x: 0.046875, y: 0.421875 }, { x: 0.046875, y: 0.421875 }, { x: 0.078125, y: 0.421875 }, { x: 0.078125, y: 0.421875 }, { x: 0.109375, y: 0.421875 }, { x: 0.109375, y: 0.421875 }, { x: 0.140625, y: 0.421875 }, { x: 0.140625, y: 0.421875 }, { x: 0.171875, y: 0.421875 }, { x: 0.171875, y: 0.421875 }, { x: 0.203125, y: 0.421875 }, { x: 0.203125, y: 0.421875 }, { x: 0.234375, y: 0.421875 }, { x: 0.234375, y: 0.421875 }, { x: 0.265625, y: 0.421875 }, { x: 0.265625, y: 0.421875 }, { x: 0.296875, y: 0.421875 }, { x: 0.296875, y: 0.421875 }, { x: 0.328125, y: 0.421875 }, { x: 0.328125, y: 0.421875 }, { x: 0.359375, y: 0.421875 }, { x: 0.359375, y: 0.421875 }, { x: 0.390625, y: 0.421875 }, { x: 0.390625, y: 0.421875 }, { x: 0.421875, y: 0.421875 }, { x: 0.421875, y: 0.421875 }, { x: 0.453125, y: 0.421875 }, { x: 0.453125, y: 0.421875 }, { x: 0.484375, y: 0.421875 }, { x: 0.484375, y: 0.421875 }, { x: 0.515625, y: 0.421875 }, { x: 0.515625, y: 0.421875 }, { x: 0.546875, y: 0.421875 }, { x: 0.546875, y: 0.421875 }, { x: 0.578125, y: 0.421875 }, { x: 0.578125, y: 0.421875 }, { x: 0.609375, y: 0.421875 }, { x: 0.609375, y: 0.421875 }, { x: 0.640625, y: 0.421875 }, { x: 0.640625, y: 0.421875 }, { x: 0.671875, y: 0.421875 }, { x: 0.671875, y: 0.421875 }, { x: 0.703125, y: 0.421875 }, { x: 0.703125, y: 0.421875 }, { x: 0.734375, y: 0.421875 }, { x: 0.734375, y: 0.421875 }, { x: 0.765625, y: 0.421875 }, { x: 0.765625, y: 0.421875 }, { x: 0.796875, y: 0.421875 }, { x: 0.796875, y: 0.421875 }, { x: 0.828125, y: 0.421875 }, { x: 0.828125, y: 0.421875 }, { x: 0.859375, y: 0.421875 }, { x: 0.859375, y: 0.421875 }, { x: 0.890625, y: 0.421875 }, { x: 0.890625, y: 0.421875 }, { x: 0.921875, y: 0.421875 }, { x: 0.921875, y: 0.421875 }, { x: 0.953125, y: 0.421875 }, { x: 0.953125, y: 0.421875 }, { x: 0.984375, y: 0.421875 }, { x: 0.984375, y: 0.421875 }, { x: 0.015625, y: 0.453125 }, { x: 0.015625, y: 0.453125 }, { x: 0.046875, y: 0.453125 }, { x: 0.046875, y: 0.453125 }, { x: 0.078125, y: 0.453125 }, { x: 0.078125, y: 0.453125 }, { x: 0.109375, y: 0.453125 }, { x: 0.109375, y: 0.453125 }, { x: 0.140625, y: 0.453125 }, { x: 0.140625, y: 0.453125 }, { x: 0.171875, y: 0.453125 }, { x: 0.171875, y: 0.453125 }, { x: 0.203125, y: 0.453125 }, { x: 0.203125, y: 0.453125 }, { x: 0.234375, y: 0.453125 }, { x: 0.234375, y: 0.453125 }, { x: 0.265625, y: 0.453125 }, { x: 0.265625, y: 0.453125 }, { x: 0.296875, y: 0.453125 }, { x: 0.296875, y: 0.453125 }, { x: 0.328125, y: 0.453125 }, { x: 0.328125, y: 0.453125 }, { x: 0.359375, y: 0.453125 }, { x: 0.359375, y: 0.453125 }, { x: 0.390625, y: 0.453125 }, { x: 0.390625, y: 0.453125 }, { x: 0.421875, y: 0.453125 }, { x: 0.421875, y: 0.453125 }, { x: 0.453125, y: 0.453125 }, { x: 0.453125, y: 0.453125 }, { x: 0.484375, y: 0.453125 }, { x: 0.484375, y: 0.453125 }, { x: 0.515625, y: 0.453125 }, { x: 0.515625, y: 0.453125 }, { x: 0.546875, y: 0.453125 }, { x: 0.546875, y: 0.453125 }, { x: 0.578125, y: 0.453125 }, { x: 0.578125, y: 0.453125 }, { x: 0.609375, y: 0.453125 }, { x: 0.609375, y: 0.453125 }, { x: 0.640625, y: 0.453125 }, { x: 0.640625, y: 0.453125 }, { x: 0.671875, y: 0.453125 }, { x: 0.671875, y: 0.453125 }, { x: 0.703125, y: 0.453125 }, { x: 0.703125, y: 0.453125 }, { x: 0.734375, y: 0.453125 }, { x: 0.734375, y: 0.453125 }, { x: 0.765625, y: 0.453125 }, { x: 0.765625, y: 0.453125 }, { x: 0.796875, y: 0.453125 }, { x: 0.796875, y: 0.453125 }, { x: 0.828125, y: 0.453125 }, { x: 0.828125, y: 0.453125 }, { x: 0.859375, y: 0.453125 }, { x: 0.859375, y: 0.453125 }, { x: 0.890625, y: 0.453125 }, { x: 0.890625, y: 0.453125 }, { x: 0.921875, y: 0.453125 }, { x: 0.921875, y: 0.453125 }, { x: 0.953125, y: 0.453125 }, { x: 0.953125, y: 0.453125 }, { x: 0.984375, y: 0.453125 }, { x: 0.984375, y: 0.453125 }, { x: 0.015625, y: 0.484375 }, { x: 0.015625, y: 0.484375 }, { x: 0.046875, y: 0.484375 }, { x: 0.046875, y: 0.484375 }, { x: 0.078125, y: 0.484375 }, { x: 0.078125, y: 0.484375 }, { x: 0.109375, y: 0.484375 }, { x: 0.109375, y: 0.484375 }, { x: 0.140625, y: 0.484375 }, { x: 0.140625, y: 0.484375 }, { x: 0.171875, y: 0.484375 }, { x: 0.171875, y: 0.484375 }, { x: 0.203125, y: 0.484375 }, { x: 0.203125, y: 0.484375 }, { x: 0.234375, y: 0.484375 }, { x: 0.234375, y: 0.484375 }, { x: 0.265625, y: 0.484375 }, { x: 0.265625, y: 0.484375 }, { x: 0.296875, y: 0.484375 }, { x: 0.296875, y: 0.484375 }, { x: 0.328125, y: 0.484375 }, { x: 0.328125, y: 0.484375 }, { x: 0.359375, y: 0.484375 }, { x: 0.359375, y: 0.484375 }, { x: 0.390625, y: 0.484375 }, { x: 0.390625, y: 0.484375 }, { x: 0.421875, y: 0.484375 }, { x: 0.421875, y: 0.484375 }, { x: 0.453125, y: 0.484375 }, { x: 0.453125, y: 0.484375 }, { x: 0.484375, y: 0.484375 }, { x: 0.484375, y: 0.484375 }, { x: 0.515625, y: 0.484375 }, { x: 0.515625, y: 0.484375 }, { x: 0.546875, y: 0.484375 }, { x: 0.546875, y: 0.484375 }, { x: 0.578125, y: 0.484375 }, { x: 0.578125, y: 0.484375 }, { x: 0.609375, y: 0.484375 }, { x: 0.609375, y: 0.484375 }, { x: 0.640625, y: 0.484375 }, { x: 0.640625, y: 0.484375 }, { x: 0.671875, y: 0.484375 }, { x: 0.671875, y: 0.484375 }, { x: 0.703125, y: 0.484375 }, { x: 0.703125, y: 0.484375 }, { x: 0.734375, y: 0.484375 }, { x: 0.734375, y: 0.484375 }, { x: 0.765625, y: 0.484375 }, { x: 0.765625, y: 0.484375 }, { x: 0.796875, y: 0.484375 }, { x: 0.796875, y: 0.484375 }, { x: 0.828125, y: 0.484375 }, { x: 0.828125, y: 0.484375 }, { x: 0.859375, y: 0.484375 }, { x: 0.859375, y: 0.484375 }, { x: 0.890625, y: 0.484375 }, { x: 0.890625, y: 0.484375 }, { x: 0.921875, y: 0.484375 }, { x: 0.921875, y: 0.484375 }, { x: 0.953125, y: 0.484375 }, { x: 0.953125, y: 0.484375 }, { x: 0.984375, y: 0.484375 }, { x: 0.984375, y: 0.484375 }, { x: 0.015625, y: 0.515625 }, { x: 0.015625, y: 0.515625 }, { x: 0.046875, y: 0.515625 }, { x: 0.046875, y: 0.515625 }, { x: 0.078125, y: 0.515625 }, { x: 0.078125, y: 0.515625 }, { x: 0.109375, y: 0.515625 }, { x: 0.109375, y: 0.515625 }, { x: 0.140625, y: 0.515625 }, { x: 0.140625, y: 0.515625 }, { x: 0.171875, y: 0.515625 }, { x: 0.171875, y: 0.515625 }, { x: 0.203125, y: 0.515625 }, { x: 0.203125, y: 0.515625 }, { x: 0.234375, y: 0.515625 }, { x: 0.234375, y: 0.515625 }, { x: 0.265625, y: 0.515625 }, { x: 0.265625, y: 0.515625 }, { x: 0.296875, y: 0.515625 }, { x: 0.296875, y: 0.515625 }, { x: 0.328125, y: 0.515625 }, { x: 0.328125, y: 0.515625 }, { x: 0.359375, y: 0.515625 }, { x: 0.359375, y: 0.515625 }, { x: 0.390625, y: 0.515625 }, { x: 0.390625, y: 0.515625 }, { x: 0.421875, y: 0.515625 }, { x: 0.421875, y: 0.515625 }, { x: 0.453125, y: 0.515625 }, { x: 0.453125, y: 0.515625 }, { x: 0.484375, y: 0.515625 }, { x: 0.484375, y: 0.515625 }, { x: 0.515625, y: 0.515625 }, { x: 0.515625, y: 0.515625 }, { x: 0.546875, y: 0.515625 }, { x: 0.546875, y: 0.515625 }, { x: 0.578125, y: 0.515625 }, { x: 0.578125, y: 0.515625 }, { x: 0.609375, y: 0.515625 }, { x: 0.609375, y: 0.515625 }, { x: 0.640625, y: 0.515625 }, { x: 0.640625, y: 0.515625 }, { x: 0.671875, y: 0.515625 }, { x: 0.671875, y: 0.515625 }, { x: 0.703125, y: 0.515625 }, { x: 0.703125, y: 0.515625 }, { x: 0.734375, y: 0.515625 }, { x: 0.734375, y: 0.515625 }, { x: 0.765625, y: 0.515625 }, { x: 0.765625, y: 0.515625 }, { x: 0.796875, y: 0.515625 }, { x: 0.796875, y: 0.515625 }, { x: 0.828125, y: 0.515625 }, { x: 0.828125, y: 0.515625 }, { x: 0.859375, y: 0.515625 }, { x: 0.859375, y: 0.515625 }, { x: 0.890625, y: 0.515625 }, { x: 0.890625, y: 0.515625 }, { x: 0.921875, y: 0.515625 }, { x: 0.921875, y: 0.515625 }, { x: 0.953125, y: 0.515625 }, { x: 0.953125, y: 0.515625 }, { x: 0.984375, y: 0.515625 }, { x: 0.984375, y: 0.515625 }, { x: 0.015625, y: 0.546875 }, { x: 0.015625, y: 0.546875 }, { x: 0.046875, y: 0.546875 }, { x: 0.046875, y: 0.546875 }, { x: 0.078125, y: 0.546875 }, { x: 0.078125, y: 0.546875 }, { x: 0.109375, y: 0.546875 }, { x: 0.109375, y: 0.546875 }, { x: 0.140625, y: 0.546875 }, { x: 0.140625, y: 0.546875 }, { x: 0.171875, y: 0.546875 }, { x: 0.171875, y: 0.546875 }, { x: 0.203125, y: 0.546875 }, { x: 0.203125, y: 0.546875 }, { x: 0.234375, y: 0.546875 }, { x: 0.234375, y: 0.546875 }, { x: 0.265625, y: 0.546875 }, { x: 0.265625, y: 0.546875 }, { x: 0.296875, y: 0.546875 }, { x: 0.296875, y: 0.546875 }, { x: 0.328125, y: 0.546875 }, { x: 0.328125, y: 0.546875 }, { x: 0.359375, y: 0.546875 }, { x: 0.359375, y: 0.546875 }, { x: 0.390625, y: 0.546875 }, { x: 0.390625, y: 0.546875 }, { x: 0.421875, y: 0.546875 }, { x: 0.421875, y: 0.546875 }, { x: 0.453125, y: 0.546875 }, { x: 0.453125, y: 0.546875 }, { x: 0.484375, y: 0.546875 }, { x: 0.484375, y: 0.546875 }, { x: 0.515625, y: 0.546875 }, { x: 0.515625, y: 0.546875 }, { x: 0.546875, y: 0.546875 }, { x: 0.546875, y: 0.546875 }, { x: 0.578125, y: 0.546875 }, { x: 0.578125, y: 0.546875 }, { x: 0.609375, y: 0.546875 }, { x: 0.609375, y: 0.546875 }, { x: 0.640625, y: 0.546875 }, { x: 0.640625, y: 0.546875 }, { x: 0.671875, y: 0.546875 }, { x: 0.671875, y: 0.546875 }, { x: 0.703125, y: 0.546875 }, { x: 0.703125, y: 0.546875 }, { x: 0.734375, y: 0.546875 }, { x: 0.734375, y: 0.546875 }, { x: 0.765625, y: 0.546875 }, { x: 0.765625, y: 0.546875 }, { x: 0.796875, y: 0.546875 }, { x: 0.796875, y: 0.546875 }, { x: 0.828125, y: 0.546875 }, { x: 0.828125, y: 0.546875 }, { x: 0.859375, y: 0.546875 }, { x: 0.859375, y: 0.546875 }, { x: 0.890625, y: 0.546875 }, { x: 0.890625, y: 0.546875 }, { x: 0.921875, y: 0.546875 }, { x: 0.921875, y: 0.546875 }, { x: 0.953125, y: 0.546875 }, { x: 0.953125, y: 0.546875 }, { x: 0.984375, y: 0.546875 }, { x: 0.984375, y: 0.546875 }, { x: 0.015625, y: 0.578125 }, { x: 0.015625, y: 0.578125 }, { x: 0.046875, y: 0.578125 }, { x: 0.046875, y: 0.578125 }, { x: 0.078125, y: 0.578125 }, { x: 0.078125, y: 0.578125 }, { x: 0.109375, y: 0.578125 }, { x: 0.109375, y: 0.578125 }, { x: 0.140625, y: 0.578125 }, { x: 0.140625, y: 0.578125 }, { x: 0.171875, y: 0.578125 }, { x: 0.171875, y: 0.578125 }, { x: 0.203125, y: 0.578125 }, { x: 0.203125, y: 0.578125 }, { x: 0.234375, y: 0.578125 }, { x: 0.234375, y: 0.578125 }, { x: 0.265625, y: 0.578125 }, { x: 0.265625, y: 0.578125 }, { x: 0.296875, y: 0.578125 }, { x: 0.296875, y: 0.578125 }, { x: 0.328125, y: 0.578125 }, { x: 0.328125, y: 0.578125 }, { x: 0.359375, y: 0.578125 }, { x: 0.359375, y: 0.578125 }, { x: 0.390625, y: 0.578125 }, { x: 0.390625, y: 0.578125 }, { x: 0.421875, y: 0.578125 }, { x: 0.421875, y: 0.578125 }, { x: 0.453125, y: 0.578125 }, { x: 0.453125, y: 0.578125 }, { x: 0.484375, y: 0.578125 }, { x: 0.484375, y: 0.578125 }, { x: 0.515625, y: 0.578125 }, { x: 0.515625, y: 0.578125 }, { x: 0.546875, y: 0.578125 }, { x: 0.546875, y: 0.578125 }, { x: 0.578125, y: 0.578125 }, { x: 0.578125, y: 0.578125 }, { x: 0.609375, y: 0.578125 }, { x: 0.609375, y: 0.578125 }, { x: 0.640625, y: 0.578125 }, { x: 0.640625, y: 0.578125 }, { x: 0.671875, y: 0.578125 }, { x: 0.671875, y: 0.578125 }, { x: 0.703125, y: 0.578125 }, { x: 0.703125, y: 0.578125 }, { x: 0.734375, y: 0.578125 }, { x: 0.734375, y: 0.578125 }, { x: 0.765625, y: 0.578125 }, { x: 0.765625, y: 0.578125 }, { x: 0.796875, y: 0.578125 }, { x: 0.796875, y: 0.578125 }, { x: 0.828125, y: 0.578125 }, { x: 0.828125, y: 0.578125 }, { x: 0.859375, y: 0.578125 }, { x: 0.859375, y: 0.578125 }, { x: 0.890625, y: 0.578125 }, { x: 0.890625, y: 0.578125 }, { x: 0.921875, y: 0.578125 }, { x: 0.921875, y: 0.578125 }, { x: 0.953125, y: 0.578125 }, { x: 0.953125, y: 0.578125 }, { x: 0.984375, y: 0.578125 }, { x: 0.984375, y: 0.578125 }, { x: 0.015625, y: 0.609375 }, { x: 0.015625, y: 0.609375 }, { x: 0.046875, y: 0.609375 }, { x: 0.046875, y: 0.609375 }, { x: 0.078125, y: 0.609375 }, { x: 0.078125, y: 0.609375 }, { x: 0.109375, y: 0.609375 }, { x: 0.109375, y: 0.609375 }, { x: 0.140625, y: 0.609375 }, { x: 0.140625, y: 0.609375 }, { x: 0.171875, y: 0.609375 }, { x: 0.171875, y: 0.609375 }, { x: 0.203125, y: 0.609375 }, { x: 0.203125, y: 0.609375 }, { x: 0.234375, y: 0.609375 }, { x: 0.234375, y: 0.609375 }, { x: 0.265625, y: 0.609375 }, { x: 0.265625, y: 0.609375 }, { x: 0.296875, y: 0.609375 }, { x: 0.296875, y: 0.609375 }, { x: 0.328125, y: 0.609375 }, { x: 0.328125, y: 0.609375 }, { x: 0.359375, y: 0.609375 }, { x: 0.359375, y: 0.609375 }, { x: 0.390625, y: 0.609375 }, { x: 0.390625, y: 0.609375 }, { x: 0.421875, y: 0.609375 }, { x: 0.421875, y: 0.609375 }, { x: 0.453125, y: 0.609375 }, { x: 0.453125, y: 0.609375 }, { x: 0.484375, y: 0.609375 }, { x: 0.484375, y: 0.609375 }, { x: 0.515625, y: 0.609375 }, { x: 0.515625, y: 0.609375 }, { x: 0.546875, y: 0.609375 }, { x: 0.546875, y: 0.609375 }, { x: 0.578125, y: 0.609375 }, { x: 0.578125, y: 0.609375 }, { x: 0.609375, y: 0.609375 }, { x: 0.609375, y: 0.609375 }, { x: 0.640625, y: 0.609375 }, { x: 0.640625, y: 0.609375 }, { x: 0.671875, y: 0.609375 }, { x: 0.671875, y: 0.609375 }, { x: 0.703125, y: 0.609375 }, { x: 0.703125, y: 0.609375 }, { x: 0.734375, y: 0.609375 }, { x: 0.734375, y: 0.609375 }, { x: 0.765625, y: 0.609375 }, { x: 0.765625, y: 0.609375 }, { x: 0.796875, y: 0.609375 }, { x: 0.796875, y: 0.609375 }, { x: 0.828125, y: 0.609375 }, { x: 0.828125, y: 0.609375 }, { x: 0.859375, y: 0.609375 }, { x: 0.859375, y: 0.609375 }, { x: 0.890625, y: 0.609375 }, { x: 0.890625, y: 0.609375 }, { x: 0.921875, y: 0.609375 }, { x: 0.921875, y: 0.609375 }, { x: 0.953125, y: 0.609375 }, { x: 0.953125, y: 0.609375 }, { x: 0.984375, y: 0.609375 }, { x: 0.984375, y: 0.609375 }, { x: 0.015625, y: 0.640625 }, { x: 0.015625, y: 0.640625 }, { x: 0.046875, y: 0.640625 }, { x: 0.046875, y: 0.640625 }, { x: 0.078125, y: 0.640625 }, { x: 0.078125, y: 0.640625 }, { x: 0.109375, y: 0.640625 }, { x: 0.109375, y: 0.640625 }, { x: 0.140625, y: 0.640625 }, { x: 0.140625, y: 0.640625 }, { x: 0.171875, y: 0.640625 }, { x: 0.171875, y: 0.640625 }, { x: 0.203125, y: 0.640625 }, { x: 0.203125, y: 0.640625 }, { x: 0.234375, y: 0.640625 }, { x: 0.234375, y: 0.640625 }, { x: 0.265625, y: 0.640625 }, { x: 0.265625, y: 0.640625 }, { x: 0.296875, y: 0.640625 }, { x: 0.296875, y: 0.640625 }, { x: 0.328125, y: 0.640625 }, { x: 0.328125, y: 0.640625 }, { x: 0.359375, y: 0.640625 }, { x: 0.359375, y: 0.640625 }, { x: 0.390625, y: 0.640625 }, { x: 0.390625, y: 0.640625 }, { x: 0.421875, y: 0.640625 }, { x: 0.421875, y: 0.640625 }, { x: 0.453125, y: 0.640625 }, { x: 0.453125, y: 0.640625 }, { x: 0.484375, y: 0.640625 }, { x: 0.484375, y: 0.640625 }, { x: 0.515625, y: 0.640625 }, { x: 0.515625, y: 0.640625 }, { x: 0.546875, y: 0.640625 }, { x: 0.546875, y: 0.640625 }, { x: 0.578125, y: 0.640625 }, { x: 0.578125, y: 0.640625 }, { x: 0.609375, y: 0.640625 }, { x: 0.609375, y: 0.640625 }, { x: 0.640625, y: 0.640625 }, { x: 0.640625, y: 0.640625 }, { x: 0.671875, y: 0.640625 }, { x: 0.671875, y: 0.640625 }, { x: 0.703125, y: 0.640625 }, { x: 0.703125, y: 0.640625 }, { x: 0.734375, y: 0.640625 }, { x: 0.734375, y: 0.640625 }, { x: 0.765625, y: 0.640625 }, { x: 0.765625, y: 0.640625 }, { x: 0.796875, y: 0.640625 }, { x: 0.796875, y: 0.640625 }, { x: 0.828125, y: 0.640625 }, { x: 0.828125, y: 0.640625 }, { x: 0.859375, y: 0.640625 }, { x: 0.859375, y: 0.640625 }, { x: 0.890625, y: 0.640625 }, { x: 0.890625, y: 0.640625 }, { x: 0.921875, y: 0.640625 }, { x: 0.921875, y: 0.640625 }, { x: 0.953125, y: 0.640625 }, { x: 0.953125, y: 0.640625 }, { x: 0.984375, y: 0.640625 }, { x: 0.984375, y: 0.640625 }, { x: 0.015625, y: 0.671875 }, { x: 0.015625, y: 0.671875 }, { x: 0.046875, y: 0.671875 }, { x: 0.046875, y: 0.671875 }, { x: 0.078125, y: 0.671875 }, { x: 0.078125, y: 0.671875 }, { x: 0.109375, y: 0.671875 }, { x: 0.109375, y: 0.671875 }, { x: 0.140625, y: 0.671875 }, { x: 0.140625, y: 0.671875 }, { x: 0.171875, y: 0.671875 }, { x: 0.171875, y: 0.671875 }, { x: 0.203125, y: 0.671875 }, { x: 0.203125, y: 0.671875 }, { x: 0.234375, y: 0.671875 }, { x: 0.234375, y: 0.671875 }, { x: 0.265625, y: 0.671875 }, { x: 0.265625, y: 0.671875 }, { x: 0.296875, y: 0.671875 }, { x: 0.296875, y: 0.671875 }, { x: 0.328125, y: 0.671875 }, { x: 0.328125, y: 0.671875 }, { x: 0.359375, y: 0.671875 }, { x: 0.359375, y: 0.671875 }, { x: 0.390625, y: 0.671875 }, { x: 0.390625, y: 0.671875 }, { x: 0.421875, y: 0.671875 }, { x: 0.421875, y: 0.671875 }, { x: 0.453125, y: 0.671875 }, { x: 0.453125, y: 0.671875 }, { x: 0.484375, y: 0.671875 }, { x: 0.484375, y: 0.671875 }, { x: 0.515625, y: 0.671875 }, { x: 0.515625, y: 0.671875 }, { x: 0.546875, y: 0.671875 }, { x: 0.546875, y: 0.671875 }, { x: 0.578125, y: 0.671875 }, { x: 0.578125, y: 0.671875 }, { x: 0.609375, y: 0.671875 }, { x: 0.609375, y: 0.671875 }, { x: 0.640625, y: 0.671875 }, { x: 0.640625, y: 0.671875 }, { x: 0.671875, y: 0.671875 }, { x: 0.671875, y: 0.671875 }, { x: 0.703125, y: 0.671875 }, { x: 0.703125, y: 0.671875 }, { x: 0.734375, y: 0.671875 }, { x: 0.734375, y: 0.671875 }, { x: 0.765625, y: 0.671875 }, { x: 0.765625, y: 0.671875 }, { x: 0.796875, y: 0.671875 }, { x: 0.796875, y: 0.671875 }, { x: 0.828125, y: 0.671875 }, { x: 0.828125, y: 0.671875 }, { x: 0.859375, y: 0.671875 }, { x: 0.859375, y: 0.671875 }, { x: 0.890625, y: 0.671875 }, { x: 0.890625, y: 0.671875 }, { x: 0.921875, y: 0.671875 }, { x: 0.921875, y: 0.671875 }, { x: 0.953125, y: 0.671875 }, { x: 0.953125, y: 0.671875 }, { x: 0.984375, y: 0.671875 }, { x: 0.984375, y: 0.671875 }, { x: 0.015625, y: 0.703125 }, { x: 0.015625, y: 0.703125 }, { x: 0.046875, y: 0.703125 }, { x: 0.046875, y: 0.703125 }, { x: 0.078125, y: 0.703125 }, { x: 0.078125, y: 0.703125 }, { x: 0.109375, y: 0.703125 }, { x: 0.109375, y: 0.703125 }, { x: 0.140625, y: 0.703125 }, { x: 0.140625, y: 0.703125 }, { x: 0.171875, y: 0.703125 }, { x: 0.171875, y: 0.703125 }, { x: 0.203125, y: 0.703125 }, { x: 0.203125, y: 0.703125 }, { x: 0.234375, y: 0.703125 }, { x: 0.234375, y: 0.703125 }, { x: 0.265625, y: 0.703125 }, { x: 0.265625, y: 0.703125 }, { x: 0.296875, y: 0.703125 }, { x: 0.296875, y: 0.703125 }, { x: 0.328125, y: 0.703125 }, { x: 0.328125, y: 0.703125 }, { x: 0.359375, y: 0.703125 }, { x: 0.359375, y: 0.703125 }, { x: 0.390625, y: 0.703125 }, { x: 0.390625, y: 0.703125 }, { x: 0.421875, y: 0.703125 }, { x: 0.421875, y: 0.703125 }, { x: 0.453125, y: 0.703125 }, { x: 0.453125, y: 0.703125 }, { x: 0.484375, y: 0.703125 }, { x: 0.484375, y: 0.703125 }, { x: 0.515625, y: 0.703125 }, { x: 0.515625, y: 0.703125 }, { x: 0.546875, y: 0.703125 }, { x: 0.546875, y: 0.703125 }, { x: 0.578125, y: 0.703125 }, { x: 0.578125, y: 0.703125 }, { x: 0.609375, y: 0.703125 }, { x: 0.609375, y: 0.703125 }, { x: 0.640625, y: 0.703125 }, { x: 0.640625, y: 0.703125 }, { x: 0.671875, y: 0.703125 }, { x: 0.671875, y: 0.703125 }, { x: 0.703125, y: 0.703125 }, { x: 0.703125, y: 0.703125 }, { x: 0.734375, y: 0.703125 }, { x: 0.734375, y: 0.703125 }, { x: 0.765625, y: 0.703125 }, { x: 0.765625, y: 0.703125 }, { x: 0.796875, y: 0.703125 }, { x: 0.796875, y: 0.703125 }, { x: 0.828125, y: 0.703125 }, { x: 0.828125, y: 0.703125 }, { x: 0.859375, y: 0.703125 }, { x: 0.859375, y: 0.703125 }, { x: 0.890625, y: 0.703125 }, { x: 0.890625, y: 0.703125 }, { x: 0.921875, y: 0.703125 }, { x: 0.921875, y: 0.703125 }, { x: 0.953125, y: 0.703125 }, { x: 0.953125, y: 0.703125 }, { x: 0.984375, y: 0.703125 }, { x: 0.984375, y: 0.703125 }, { x: 0.015625, y: 0.734375 }, { x: 0.015625, y: 0.734375 }, { x: 0.046875, y: 0.734375 }, { x: 0.046875, y: 0.734375 }, { x: 0.078125, y: 0.734375 }, { x: 0.078125, y: 0.734375 }, { x: 0.109375, y: 0.734375 }, { x: 0.109375, y: 0.734375 }, { x: 0.140625, y: 0.734375 }, { x: 0.140625, y: 0.734375 }, { x: 0.171875, y: 0.734375 }, { x: 0.171875, y: 0.734375 }, { x: 0.203125, y: 0.734375 }, { x: 0.203125, y: 0.734375 }, { x: 0.234375, y: 0.734375 }, { x: 0.234375, y: 0.734375 }, { x: 0.265625, y: 0.734375 }, { x: 0.265625, y: 0.734375 }, { x: 0.296875, y: 0.734375 }, { x: 0.296875, y: 0.734375 }, { x: 0.328125, y: 0.734375 }, { x: 0.328125, y: 0.734375 }, { x: 0.359375, y: 0.734375 }, { x: 0.359375, y: 0.734375 }, { x: 0.390625, y: 0.734375 }, { x: 0.390625, y: 0.734375 }, { x: 0.421875, y: 0.734375 }, { x: 0.421875, y: 0.734375 }, { x: 0.453125, y: 0.734375 }, { x: 0.453125, y: 0.734375 }, { x: 0.484375, y: 0.734375 }, { x: 0.484375, y: 0.734375 }, { x: 0.515625, y: 0.734375 }, { x: 0.515625, y: 0.734375 }, { x: 0.546875, y: 0.734375 }, { x: 0.546875, y: 0.734375 }, { x: 0.578125, y: 0.734375 }, { x: 0.578125, y: 0.734375 }, { x: 0.609375, y: 0.734375 }, { x: 0.609375, y: 0.734375 }, { x: 0.640625, y: 0.734375 }, { x: 0.640625, y: 0.734375 }, { x: 0.671875, y: 0.734375 }, { x: 0.671875, y: 0.734375 }, { x: 0.703125, y: 0.734375 }, { x: 0.703125, y: 0.734375 }, { x: 0.734375, y: 0.734375 }, { x: 0.734375, y: 0.734375 }, { x: 0.765625, y: 0.734375 }, { x: 0.765625, y: 0.734375 }, { x: 0.796875, y: 0.734375 }, { x: 0.796875, y: 0.734375 }, { x: 0.828125, y: 0.734375 }, { x: 0.828125, y: 0.734375 }, { x: 0.859375, y: 0.734375 }, { x: 0.859375, y: 0.734375 }, { x: 0.890625, y: 0.734375 }, { x: 0.890625, y: 0.734375 }, { x: 0.921875, y: 0.734375 }, { x: 0.921875, y: 0.734375 }, { x: 0.953125, y: 0.734375 }, { x: 0.953125, y: 0.734375 }, { x: 0.984375, y: 0.734375 }, { x: 0.984375, y: 0.734375 }, { x: 0.015625, y: 0.765625 }, { x: 0.015625, y: 0.765625 }, { x: 0.046875, y: 0.765625 }, { x: 0.046875, y: 0.765625 }, { x: 0.078125, y: 0.765625 }, { x: 0.078125, y: 0.765625 }, { x: 0.109375, y: 0.765625 }, { x: 0.109375, y: 0.765625 }, { x: 0.140625, y: 0.765625 }, { x: 0.140625, y: 0.765625 }, { x: 0.171875, y: 0.765625 }, { x: 0.171875, y: 0.765625 }, { x: 0.203125, y: 0.765625 }, { x: 0.203125, y: 0.765625 }, { x: 0.234375, y: 0.765625 }, { x: 0.234375, y: 0.765625 }, { x: 0.265625, y: 0.765625 }, { x: 0.265625, y: 0.765625 }, { x: 0.296875, y: 0.765625 }, { x: 0.296875, y: 0.765625 }, { x: 0.328125, y: 0.765625 }, { x: 0.328125, y: 0.765625 }, { x: 0.359375, y: 0.765625 }, { x: 0.359375, y: 0.765625 }, { x: 0.390625, y: 0.765625 }, { x: 0.390625, y: 0.765625 }, { x: 0.421875, y: 0.765625 }, { x: 0.421875, y: 0.765625 }, { x: 0.453125, y: 0.765625 }, { x: 0.453125, y: 0.765625 }, { x: 0.484375, y: 0.765625 }, { x: 0.484375, y: 0.765625 }, { x: 0.515625, y: 0.765625 }, { x: 0.515625, y: 0.765625 }, { x: 0.546875, y: 0.765625 }, { x: 0.546875, y: 0.765625 }, { x: 0.578125, y: 0.765625 }, { x: 0.578125, y: 0.765625 }, { x: 0.609375, y: 0.765625 }, { x: 0.609375, y: 0.765625 }, { x: 0.640625, y: 0.765625 }, { x: 0.640625, y: 0.765625 }, { x: 0.671875, y: 0.765625 }, { x: 0.671875, y: 0.765625 }, { x: 0.703125, y: 0.765625 }, { x: 0.703125, y: 0.765625 }, { x: 0.734375, y: 0.765625 }, { x: 0.734375, y: 0.765625 }, { x: 0.765625, y: 0.765625 }, { x: 0.765625, y: 0.765625 }, { x: 0.796875, y: 0.765625 }, { x: 0.796875, y: 0.765625 }, { x: 0.828125, y: 0.765625 }, { x: 0.828125, y: 0.765625 }, { x: 0.859375, y: 0.765625 }, { x: 0.859375, y: 0.765625 }, { x: 0.890625, y: 0.765625 }, { x: 0.890625, y: 0.765625 }, { x: 0.921875, y: 0.765625 }, { x: 0.921875, y: 0.765625 }, { x: 0.953125, y: 0.765625 }, { x: 0.953125, y: 0.765625 }, { x: 0.984375, y: 0.765625 }, { x: 0.984375, y: 0.765625 }, { x: 0.015625, y: 0.796875 }, { x: 0.015625, y: 0.796875 }, { x: 0.046875, y: 0.796875 }, { x: 0.046875, y: 0.796875 }, { x: 0.078125, y: 0.796875 }, { x: 0.078125, y: 0.796875 }, { x: 0.109375, y: 0.796875 }, { x: 0.109375, y: 0.796875 }, { x: 0.140625, y: 0.796875 }, { x: 0.140625, y: 0.796875 }, { x: 0.171875, y: 0.796875 }, { x: 0.171875, y: 0.796875 }, { x: 0.203125, y: 0.796875 }, { x: 0.203125, y: 0.796875 }, { x: 0.234375, y: 0.796875 }, { x: 0.234375, y: 0.796875 }, { x: 0.265625, y: 0.796875 }, { x: 0.265625, y: 0.796875 }, { x: 0.296875, y: 0.796875 }, { x: 0.296875, y: 0.796875 }, { x: 0.328125, y: 0.796875 }, { x: 0.328125, y: 0.796875 }, { x: 0.359375, y: 0.796875 }, { x: 0.359375, y: 0.796875 }, { x: 0.390625, y: 0.796875 }, { x: 0.390625, y: 0.796875 }, { x: 0.421875, y: 0.796875 }, { x: 0.421875, y: 0.796875 }, { x: 0.453125, y: 0.796875 }, { x: 0.453125, y: 0.796875 }, { x: 0.484375, y: 0.796875 }, { x: 0.484375, y: 0.796875 }, { x: 0.515625, y: 0.796875 }, { x: 0.515625, y: 0.796875 }, { x: 0.546875, y: 0.796875 }, { x: 0.546875, y: 0.796875 }, { x: 0.578125, y: 0.796875 }, { x: 0.578125, y: 0.796875 }, { x: 0.609375, y: 0.796875 }, { x: 0.609375, y: 0.796875 }, { x: 0.640625, y: 0.796875 }, { x: 0.640625, y: 0.796875 }, { x: 0.671875, y: 0.796875 }, { x: 0.671875, y: 0.796875 }, { x: 0.703125, y: 0.796875 }, { x: 0.703125, y: 0.796875 }, { x: 0.734375, y: 0.796875 }, { x: 0.734375, y: 0.796875 }, { x: 0.765625, y: 0.796875 }, { x: 0.765625, y: 0.796875 }, { x: 0.796875, y: 0.796875 }, { x: 0.796875, y: 0.796875 }, { x: 0.828125, y: 0.796875 }, { x: 0.828125, y: 0.796875 }, { x: 0.859375, y: 0.796875 }, { x: 0.859375, y: 0.796875 }, { x: 0.890625, y: 0.796875 }, { x: 0.890625, y: 0.796875 }, { x: 0.921875, y: 0.796875 }, { x: 0.921875, y: 0.796875 }, { x: 0.953125, y: 0.796875 }, { x: 0.953125, y: 0.796875 }, { x: 0.984375, y: 0.796875 }, { x: 0.984375, y: 0.796875 }, { x: 0.015625, y: 0.828125 }, { x: 0.015625, y: 0.828125 }, { x: 0.046875, y: 0.828125 }, { x: 0.046875, y: 0.828125 }, { x: 0.078125, y: 0.828125 }, { x: 0.078125, y: 0.828125 }, { x: 0.109375, y: 0.828125 }, { x: 0.109375, y: 0.828125 }, { x: 0.140625, y: 0.828125 }, { x: 0.140625, y: 0.828125 }, { x: 0.171875, y: 0.828125 }, { x: 0.171875, y: 0.828125 }, { x: 0.203125, y: 0.828125 }, { x: 0.203125, y: 0.828125 }, { x: 0.234375, y: 0.828125 }, { x: 0.234375, y: 0.828125 }, { x: 0.265625, y: 0.828125 }, { x: 0.265625, y: 0.828125 }, { x: 0.296875, y: 0.828125 }, { x: 0.296875, y: 0.828125 }, { x: 0.328125, y: 0.828125 }, { x: 0.328125, y: 0.828125 }, { x: 0.359375, y: 0.828125 }, { x: 0.359375, y: 0.828125 }, { x: 0.390625, y: 0.828125 }, { x: 0.390625, y: 0.828125 }, { x: 0.421875, y: 0.828125 }, { x: 0.421875, y: 0.828125 }, { x: 0.453125, y: 0.828125 }, { x: 0.453125, y: 0.828125 }, { x: 0.484375, y: 0.828125 }, { x: 0.484375, y: 0.828125 }, { x: 0.515625, y: 0.828125 }, { x: 0.515625, y: 0.828125 }, { x: 0.546875, y: 0.828125 }, { x: 0.546875, y: 0.828125 }, { x: 0.578125, y: 0.828125 }, { x: 0.578125, y: 0.828125 }, { x: 0.609375, y: 0.828125 }, { x: 0.609375, y: 0.828125 }, { x: 0.640625, y: 0.828125 }, { x: 0.640625, y: 0.828125 }, { x: 0.671875, y: 0.828125 }, { x: 0.671875, y: 0.828125 }, { x: 0.703125, y: 0.828125 }, { x: 0.703125, y: 0.828125 }, { x: 0.734375, y: 0.828125 }, { x: 0.734375, y: 0.828125 }, { x: 0.765625, y: 0.828125 }, { x: 0.765625, y: 0.828125 }, { x: 0.796875, y: 0.828125 }, { x: 0.796875, y: 0.828125 }, { x: 0.828125, y: 0.828125 }, { x: 0.828125, y: 0.828125 }, { x: 0.859375, y: 0.828125 }, { x: 0.859375, y: 0.828125 }, { x: 0.890625, y: 0.828125 }, { x: 0.890625, y: 0.828125 }, { x: 0.921875, y: 0.828125 }, { x: 0.921875, y: 0.828125 }, { x: 0.953125, y: 0.828125 }, { x: 0.953125, y: 0.828125 }, { x: 0.984375, y: 0.828125 }, { x: 0.984375, y: 0.828125 }, { x: 0.015625, y: 0.859375 }, { x: 0.015625, y: 0.859375 }, { x: 0.046875, y: 0.859375 }, { x: 0.046875, y: 0.859375 }, { x: 0.078125, y: 0.859375 }, { x: 0.078125, y: 0.859375 }, { x: 0.109375, y: 0.859375 }, { x: 0.109375, y: 0.859375 }, { x: 0.140625, y: 0.859375 }, { x: 0.140625, y: 0.859375 }, { x: 0.171875, y: 0.859375 }, { x: 0.171875, y: 0.859375 }, { x: 0.203125, y: 0.859375 }, { x: 0.203125, y: 0.859375 }, { x: 0.234375, y: 0.859375 }, { x: 0.234375, y: 0.859375 }, { x: 0.265625, y: 0.859375 }, { x: 0.265625, y: 0.859375 }, { x: 0.296875, y: 0.859375 }, { x: 0.296875, y: 0.859375 }, { x: 0.328125, y: 0.859375 }, { x: 0.328125, y: 0.859375 }, { x: 0.359375, y: 0.859375 }, { x: 0.359375, y: 0.859375 }, { x: 0.390625, y: 0.859375 }, { x: 0.390625, y: 0.859375 }, { x: 0.421875, y: 0.859375 }, { x: 0.421875, y: 0.859375 }, { x: 0.453125, y: 0.859375 }, { x: 0.453125, y: 0.859375 }, { x: 0.484375, y: 0.859375 }, { x: 0.484375, y: 0.859375 }, { x: 0.515625, y: 0.859375 }, { x: 0.515625, y: 0.859375 }, { x: 0.546875, y: 0.859375 }, { x: 0.546875, y: 0.859375 }, { x: 0.578125, y: 0.859375 }, { x: 0.578125, y: 0.859375 }, { x: 0.609375, y: 0.859375 }, { x: 0.609375, y: 0.859375 }, { x: 0.640625, y: 0.859375 }, { x: 0.640625, y: 0.859375 }, { x: 0.671875, y: 0.859375 }, { x: 0.671875, y: 0.859375 }, { x: 0.703125, y: 0.859375 }, { x: 0.703125, y: 0.859375 }, { x: 0.734375, y: 0.859375 }, { x: 0.734375, y: 0.859375 }, { x: 0.765625, y: 0.859375 }, { x: 0.765625, y: 0.859375 }, { x: 0.796875, y: 0.859375 }, { x: 0.796875, y: 0.859375 }, { x: 0.828125, y: 0.859375 }, { x: 0.828125, y: 0.859375 }, { x: 0.859375, y: 0.859375 }, { x: 0.859375, y: 0.859375 }, { x: 0.890625, y: 0.859375 }, { x: 0.890625, y: 0.859375 }, { x: 0.921875, y: 0.859375 }, { x: 0.921875, y: 0.859375 }, { x: 0.953125, y: 0.859375 }, { x: 0.953125, y: 0.859375 }, { x: 0.984375, y: 0.859375 }, { x: 0.984375, y: 0.859375 }, { x: 0.015625, y: 0.890625 }, { x: 0.015625, y: 0.890625 }, { x: 0.046875, y: 0.890625 }, { x: 0.046875, y: 0.890625 }, { x: 0.078125, y: 0.890625 }, { x: 0.078125, y: 0.890625 }, { x: 0.109375, y: 0.890625 }, { x: 0.109375, y: 0.890625 }, { x: 0.140625, y: 0.890625 }, { x: 0.140625, y: 0.890625 }, { x: 0.171875, y: 0.890625 }, { x: 0.171875, y: 0.890625 }, { x: 0.203125, y: 0.890625 }, { x: 0.203125, y: 0.890625 }, { x: 0.234375, y: 0.890625 }, { x: 0.234375, y: 0.890625 }, { x: 0.265625, y: 0.890625 }, { x: 0.265625, y: 0.890625 }, { x: 0.296875, y: 0.890625 }, { x: 0.296875, y: 0.890625 }, { x: 0.328125, y: 0.890625 }, { x: 0.328125, y: 0.890625 }, { x: 0.359375, y: 0.890625 }, { x: 0.359375, y: 0.890625 }, { x: 0.390625, y: 0.890625 }, { x: 0.390625, y: 0.890625 }, { x: 0.421875, y: 0.890625 }, { x: 0.421875, y: 0.890625 }, { x: 0.453125, y: 0.890625 }, { x: 0.453125, y: 0.890625 }, { x: 0.484375, y: 0.890625 }, { x: 0.484375, y: 0.890625 }, { x: 0.515625, y: 0.890625 }, { x: 0.515625, y: 0.890625 }, { x: 0.546875, y: 0.890625 }, { x: 0.546875, y: 0.890625 }, { x: 0.578125, y: 0.890625 }, { x: 0.578125, y: 0.890625 }, { x: 0.609375, y: 0.890625 }, { x: 0.609375, y: 0.890625 }, { x: 0.640625, y: 0.890625 }, { x: 0.640625, y: 0.890625 }, { x: 0.671875, y: 0.890625 }, { x: 0.671875, y: 0.890625 }, { x: 0.703125, y: 0.890625 }, { x: 0.703125, y: 0.890625 }, { x: 0.734375, y: 0.890625 }, { x: 0.734375, y: 0.890625 }, { x: 0.765625, y: 0.890625 }, { x: 0.765625, y: 0.890625 }, { x: 0.796875, y: 0.890625 }, { x: 0.796875, y: 0.890625 }, { x: 0.828125, y: 0.890625 }, { x: 0.828125, y: 0.890625 }, { x: 0.859375, y: 0.890625 }, { x: 0.859375, y: 0.890625 }, { x: 0.890625, y: 0.890625 }, { x: 0.890625, y: 0.890625 }, { x: 0.921875, y: 0.890625 }, { x: 0.921875, y: 0.890625 }, { x: 0.953125, y: 0.890625 }, { x: 0.953125, y: 0.890625 }, { x: 0.984375, y: 0.890625 }, { x: 0.984375, y: 0.890625 }, { x: 0.015625, y: 0.921875 }, { x: 0.015625, y: 0.921875 }, { x: 0.046875, y: 0.921875 }, { x: 0.046875, y: 0.921875 }, { x: 0.078125, y: 0.921875 }, { x: 0.078125, y: 0.921875 }, { x: 0.109375, y: 0.921875 }, { x: 0.109375, y: 0.921875 }, { x: 0.140625, y: 0.921875 }, { x: 0.140625, y: 0.921875 }, { x: 0.171875, y: 0.921875 }, { x: 0.171875, y: 0.921875 }, { x: 0.203125, y: 0.921875 }, { x: 0.203125, y: 0.921875 }, { x: 0.234375, y: 0.921875 }, { x: 0.234375, y: 0.921875 }, { x: 0.265625, y: 0.921875 }, { x: 0.265625, y: 0.921875 }, { x: 0.296875, y: 0.921875 }, { x: 0.296875, y: 0.921875 }, { x: 0.328125, y: 0.921875 }, { x: 0.328125, y: 0.921875 }, { x: 0.359375, y: 0.921875 }, { x: 0.359375, y: 0.921875 }, { x: 0.390625, y: 0.921875 }, { x: 0.390625, y: 0.921875 }, { x: 0.421875, y: 0.921875 }, { x: 0.421875, y: 0.921875 }, { x: 0.453125, y: 0.921875 }, { x: 0.453125, y: 0.921875 }, { x: 0.484375, y: 0.921875 }, { x: 0.484375, y: 0.921875 }, { x: 0.515625, y: 0.921875 }, { x: 0.515625, y: 0.921875 }, { x: 0.546875, y: 0.921875 }, { x: 0.546875, y: 0.921875 }, { x: 0.578125, y: 0.921875 }, { x: 0.578125, y: 0.921875 }, { x: 0.609375, y: 0.921875 }, { x: 0.609375, y: 0.921875 }, { x: 0.640625, y: 0.921875 }, { x: 0.640625, y: 0.921875 }, { x: 0.671875, y: 0.921875 }, { x: 0.671875, y: 0.921875 }, { x: 0.703125, y: 0.921875 }, { x: 0.703125, y: 0.921875 }, { x: 0.734375, y: 0.921875 }, { x: 0.734375, y: 0.921875 }, { x: 0.765625, y: 0.921875 }, { x: 0.765625, y: 0.921875 }, { x: 0.796875, y: 0.921875 }, { x: 0.796875, y: 0.921875 }, { x: 0.828125, y: 0.921875 }, { x: 0.828125, y: 0.921875 }, { x: 0.859375, y: 0.921875 }, { x: 0.859375, y: 0.921875 }, { x: 0.890625, y: 0.921875 }, { x: 0.890625, y: 0.921875 }, { x: 0.921875, y: 0.921875 }, { x: 0.921875, y: 0.921875 }, { x: 0.953125, y: 0.921875 }, { x: 0.953125, y: 0.921875 }, { x: 0.984375, y: 0.921875 }, { x: 0.984375, y: 0.921875 }, { x: 0.015625, y: 0.953125 }, { x: 0.015625, y: 0.953125 }, { x: 0.046875, y: 0.953125 }, { x: 0.046875, y: 0.953125 }, { x: 0.078125, y: 0.953125 }, { x: 0.078125, y: 0.953125 }, { x: 0.109375, y: 0.953125 }, { x: 0.109375, y: 0.953125 }, { x: 0.140625, y: 0.953125 }, { x: 0.140625, y: 0.953125 }, { x: 0.171875, y: 0.953125 }, { x: 0.171875, y: 0.953125 }, { x: 0.203125, y: 0.953125 }, { x: 0.203125, y: 0.953125 }, { x: 0.234375, y: 0.953125 }, { x: 0.234375, y: 0.953125 }, { x: 0.265625, y: 0.953125 }, { x: 0.265625, y: 0.953125 }, { x: 0.296875, y: 0.953125 }, { x: 0.296875, y: 0.953125 }, { x: 0.328125, y: 0.953125 }, { x: 0.328125, y: 0.953125 }, { x: 0.359375, y: 0.953125 }, { x: 0.359375, y: 0.953125 }, { x: 0.390625, y: 0.953125 }, { x: 0.390625, y: 0.953125 }, { x: 0.421875, y: 0.953125 }, { x: 0.421875, y: 0.953125 }, { x: 0.453125, y: 0.953125 }, { x: 0.453125, y: 0.953125 }, { x: 0.484375, y: 0.953125 }, { x: 0.484375, y: 0.953125 }, { x: 0.515625, y: 0.953125 }, { x: 0.515625, y: 0.953125 }, { x: 0.546875, y: 0.953125 }, { x: 0.546875, y: 0.953125 }, { x: 0.578125, y: 0.953125 }, { x: 0.578125, y: 0.953125 }, { x: 0.609375, y: 0.953125 }, { x: 0.609375, y: 0.953125 }, { x: 0.640625, y: 0.953125 }, { x: 0.640625, y: 0.953125 }, { x: 0.671875, y: 0.953125 }, { x: 0.671875, y: 0.953125 }, { x: 0.703125, y: 0.953125 }, { x: 0.703125, y: 0.953125 }, { x: 0.734375, y: 0.953125 }, { x: 0.734375, y: 0.953125 }, { x: 0.765625, y: 0.953125 }, { x: 0.765625, y: 0.953125 }, { x: 0.796875, y: 0.953125 }, { x: 0.796875, y: 0.953125 }, { x: 0.828125, y: 0.953125 }, { x: 0.828125, y: 0.953125 }, { x: 0.859375, y: 0.953125 }, { x: 0.859375, y: 0.953125 }, { x: 0.890625, y: 0.953125 }, { x: 0.890625, y: 0.953125 }, { x: 0.921875, y: 0.953125 }, { x: 0.921875, y: 0.953125 }, { x: 0.953125, y: 0.953125 }, { x: 0.953125, y: 0.953125 }, { x: 0.984375, y: 0.953125 }, { x: 0.984375, y: 0.953125 }, { x: 0.015625, y: 0.984375 }, { x: 0.015625, y: 0.984375 }, { x: 0.046875, y: 0.984375 }, { x: 0.046875, y: 0.984375 }, { x: 0.078125, y: 0.984375 }, { x: 0.078125, y: 0.984375 }, { x: 0.109375, y: 0.984375 }, { x: 0.109375, y: 0.984375 }, { x: 0.140625, y: 0.984375 }, { x: 0.140625, y: 0.984375 }, { x: 0.171875, y: 0.984375 }, { x: 0.171875, y: 0.984375 }, { x: 0.203125, y: 0.984375 }, { x: 0.203125, y: 0.984375 }, { x: 0.234375, y: 0.984375 }, { x: 0.234375, y: 0.984375 }, { x: 0.265625, y: 0.984375 }, { x: 0.265625, y: 0.984375 }, { x: 0.296875, y: 0.984375 }, { x: 0.296875, y: 0.984375 }, { x: 0.328125, y: 0.984375 }, { x: 0.328125, y: 0.984375 }, { x: 0.359375, y: 0.984375 }, { x: 0.359375, y: 0.984375 }, { x: 0.390625, y: 0.984375 }, { x: 0.390625, y: 0.984375 }, { x: 0.421875, y: 0.984375 }, { x: 0.421875, y: 0.984375 }, { x: 0.453125, y: 0.984375 }, { x: 0.453125, y: 0.984375 }, { x: 0.484375, y: 0.984375 }, { x: 0.484375, y: 0.984375 }, { x: 0.515625, y: 0.984375 }, { x: 0.515625, y: 0.984375 }, { x: 0.546875, y: 0.984375 }, { x: 0.546875, y: 0.984375 }, { x: 0.578125, y: 0.984375 }, { x: 0.578125, y: 0.984375 }, { x: 0.609375, y: 0.984375 }, { x: 0.609375, y: 0.984375 }, { x: 0.640625, y: 0.984375 }, { x: 0.640625, y: 0.984375 }, { x: 0.671875, y: 0.984375 }, { x: 0.671875, y: 0.984375 }, { x: 0.703125, y: 0.984375 }, { x: 0.703125, y: 0.984375 }, { x: 0.734375, y: 0.984375 }, { x: 0.734375, y: 0.984375 }, { x: 0.765625, y: 0.984375 }, { x: 0.765625, y: 0.984375 }, { x: 0.796875, y: 0.984375 }, { x: 0.796875, y: 0.984375 }, { x: 0.828125, y: 0.984375 }, { x: 0.828125, y: 0.984375 }, { x: 0.859375, y: 0.984375 }, { x: 0.859375, y: 0.984375 }, { x: 0.890625, y: 0.984375 }, { x: 0.890625, y: 0.984375 }, { x: 0.921875, y: 0.984375 }, { x: 0.921875, y: 0.984375 }, { x: 0.953125, y: 0.984375 }, { x: 0.953125, y: 0.984375 }, { x: 0.984375, y: 0.984375 }, { x: 0.984375, y: 0.984375 }, { x: 0.03125, y: 0.03125 }, { x: 0.03125, y: 0.03125 }, { x: 0.09375, y: 0.03125 }, { x: 0.09375, y: 0.03125 }, { x: 0.15625, y: 0.03125 }, { x: 0.15625, y: 0.03125 }, { x: 0.21875, y: 0.03125 }, { x: 0.21875, y: 0.03125 }, { x: 0.28125, y: 0.03125 }, { x: 0.28125, y: 0.03125 }, { x: 0.34375, y: 0.03125 }, { x: 0.34375, y: 0.03125 }, { x: 0.40625, y: 0.03125 }, { x: 0.40625, y: 0.03125 }, { x: 0.46875, y: 0.03125 }, { x: 0.46875, y: 0.03125 }, { x: 0.53125, y: 0.03125 }, { x: 0.53125, y: 0.03125 }, { x: 0.59375, y: 0.03125 }, { x: 0.59375, y: 0.03125 }, { x: 0.65625, y: 0.03125 }, { x: 0.65625, y: 0.03125 }, { x: 0.71875, y: 0.03125 }, { x: 0.71875, y: 0.03125 }, { x: 0.78125, y: 0.03125 }, { x: 0.78125, y: 0.03125 }, { x: 0.84375, y: 0.03125 }, { x: 0.84375, y: 0.03125 }, { x: 0.90625, y: 0.03125 }, { x: 0.90625, y: 0.03125 }, { x: 0.96875, y: 0.03125 }, { x: 0.96875, y: 0.03125 }, { x: 0.03125, y: 0.09375 }, { x: 0.03125, y: 0.09375 }, { x: 0.09375, y: 0.09375 }, { x: 0.09375, y: 0.09375 }, { x: 0.15625, y: 0.09375 }, { x: 0.15625, y: 0.09375 }, { x: 0.21875, y: 0.09375 }, { x: 0.21875, y: 0.09375 }, { x: 0.28125, y: 0.09375 }, { x: 0.28125, y: 0.09375 }, { x: 0.34375, y: 0.09375 }, { x: 0.34375, y: 0.09375 }, { x: 0.40625, y: 0.09375 }, { x: 0.40625, y: 0.09375 }, { x: 0.46875, y: 0.09375 }, { x: 0.46875, y: 0.09375 }, { x: 0.53125, y: 0.09375 }, { x: 0.53125, y: 0.09375 }, { x: 0.59375, y: 0.09375 }, { x: 0.59375, y: 0.09375 }, { x: 0.65625, y: 0.09375 }, { x: 0.65625, y: 0.09375 }, { x: 0.71875, y: 0.09375 }, { x: 0.71875, y: 0.09375 }, { x: 0.78125, y: 0.09375 }, { x: 0.78125, y: 0.09375 }, { x: 0.84375, y: 0.09375 }, { x: 0.84375, y: 0.09375 }, { x: 0.90625, y: 0.09375 }, { x: 0.90625, y: 0.09375 }, { x: 0.96875, y: 0.09375 }, { x: 0.96875, y: 0.09375 }, { x: 0.03125, y: 0.15625 }, { x: 0.03125, y: 0.15625 }, { x: 0.09375, y: 0.15625 }, { x: 0.09375, y: 0.15625 }, { x: 0.15625, y: 0.15625 }, { x: 0.15625, y: 0.15625 }, { x: 0.21875, y: 0.15625 }, { x: 0.21875, y: 0.15625 }, { x: 0.28125, y: 0.15625 }, { x: 0.28125, y: 0.15625 }, { x: 0.34375, y: 0.15625 }, { x: 0.34375, y: 0.15625 }, { x: 0.40625, y: 0.15625 }, { x: 0.40625, y: 0.15625 }, { x: 0.46875, y: 0.15625 }, { x: 0.46875, y: 0.15625 }, { x: 0.53125, y: 0.15625 }, { x: 0.53125, y: 0.15625 }, { x: 0.59375, y: 0.15625 }, { x: 0.59375, y: 0.15625 }, { x: 0.65625, y: 0.15625 }, { x: 0.65625, y: 0.15625 }, { x: 0.71875, y: 0.15625 }, { x: 0.71875, y: 0.15625 }, { x: 0.78125, y: 0.15625 }, { x: 0.78125, y: 0.15625 }, { x: 0.84375, y: 0.15625 }, { x: 0.84375, y: 0.15625 }, { x: 0.90625, y: 0.15625 }, { x: 0.90625, y: 0.15625 }, { x: 0.96875, y: 0.15625 }, { x: 0.96875, y: 0.15625 }, { x: 0.03125, y: 0.21875 }, { x: 0.03125, y: 0.21875 }, { x: 0.09375, y: 0.21875 }, { x: 0.09375, y: 0.21875 }, { x: 0.15625, y: 0.21875 }, { x: 0.15625, y: 0.21875 }, { x: 0.21875, y: 0.21875 }, { x: 0.21875, y: 0.21875 }, { x: 0.28125, y: 0.21875 }, { x: 0.28125, y: 0.21875 }, { x: 0.34375, y: 0.21875 }, { x: 0.34375, y: 0.21875 }, { x: 0.40625, y: 0.21875 }, { x: 0.40625, y: 0.21875 }, { x: 0.46875, y: 0.21875 }, { x: 0.46875, y: 0.21875 }, { x: 0.53125, y: 0.21875 }, { x: 0.53125, y: 0.21875 }, { x: 0.59375, y: 0.21875 }, { x: 0.59375, y: 0.21875 }, { x: 0.65625, y: 0.21875 }, { x: 0.65625, y: 0.21875 }, { x: 0.71875, y: 0.21875 }, { x: 0.71875, y: 0.21875 }, { x: 0.78125, y: 0.21875 }, { x: 0.78125, y: 0.21875 }, { x: 0.84375, y: 0.21875 }, { x: 0.84375, y: 0.21875 }, { x: 0.90625, y: 0.21875 }, { x: 0.90625, y: 0.21875 }, { x: 0.96875, y: 0.21875 }, { x: 0.96875, y: 0.21875 }, { x: 0.03125, y: 0.28125 }, { x: 0.03125, y: 0.28125 }, { x: 0.09375, y: 0.28125 }, { x: 0.09375, y: 0.28125 }, { x: 0.15625, y: 0.28125 }, { x: 0.15625, y: 0.28125 }, { x: 0.21875, y: 0.28125 }, { x: 0.21875, y: 0.28125 }, { x: 0.28125, y: 0.28125 }, { x: 0.28125, y: 0.28125 }, { x: 0.34375, y: 0.28125 }, { x: 0.34375, y: 0.28125 }, { x: 0.40625, y: 0.28125 }, { x: 0.40625, y: 0.28125 }, { x: 0.46875, y: 0.28125 }, { x: 0.46875, y: 0.28125 }, { x: 0.53125, y: 0.28125 }, { x: 0.53125, y: 0.28125 }, { x: 0.59375, y: 0.28125 }, { x: 0.59375, y: 0.28125 }, { x: 0.65625, y: 0.28125 }, { x: 0.65625, y: 0.28125 }, { x: 0.71875, y: 0.28125 }, { x: 0.71875, y: 0.28125 }, { x: 0.78125, y: 0.28125 }, { x: 0.78125, y: 0.28125 }, { x: 0.84375, y: 0.28125 }, { x: 0.84375, y: 0.28125 }, { x: 0.90625, y: 0.28125 }, { x: 0.90625, y: 0.28125 }, { x: 0.96875, y: 0.28125 }, { x: 0.96875, y: 0.28125 }, { x: 0.03125, y: 0.34375 }, { x: 0.03125, y: 0.34375 }, { x: 0.09375, y: 0.34375 }, { x: 0.09375, y: 0.34375 }, { x: 0.15625, y: 0.34375 }, { x: 0.15625, y: 0.34375 }, { x: 0.21875, y: 0.34375 }, { x: 0.21875, y: 0.34375 }, { x: 0.28125, y: 0.34375 }, { x: 0.28125, y: 0.34375 }, { x: 0.34375, y: 0.34375 }, { x: 0.34375, y: 0.34375 }, { x: 0.40625, y: 0.34375 }, { x: 0.40625, y: 0.34375 }, { x: 0.46875, y: 0.34375 }, { x: 0.46875, y: 0.34375 }, { x: 0.53125, y: 0.34375 }, { x: 0.53125, y: 0.34375 }, { x: 0.59375, y: 0.34375 }, { x: 0.59375, y: 0.34375 }, { x: 0.65625, y: 0.34375 }, { x: 0.65625, y: 0.34375 }, { x: 0.71875, y: 0.34375 }, { x: 0.71875, y: 0.34375 }, { x: 0.78125, y: 0.34375 }, { x: 0.78125, y: 0.34375 }, { x: 0.84375, y: 0.34375 }, { x: 0.84375, y: 0.34375 }, { x: 0.90625, y: 0.34375 }, { x: 0.90625, y: 0.34375 }, { x: 0.96875, y: 0.34375 }, { x: 0.96875, y: 0.34375 }, { x: 0.03125, y: 0.40625 }, { x: 0.03125, y: 0.40625 }, { x: 0.09375, y: 0.40625 }, { x: 0.09375, y: 0.40625 }, { x: 0.15625, y: 0.40625 }, { x: 0.15625, y: 0.40625 }, { x: 0.21875, y: 0.40625 }, { x: 0.21875, y: 0.40625 }, { x: 0.28125, y: 0.40625 }, { x: 0.28125, y: 0.40625 }, { x: 0.34375, y: 0.40625 }, { x: 0.34375, y: 0.40625 }, { x: 0.40625, y: 0.40625 }, { x: 0.40625, y: 0.40625 }, { x: 0.46875, y: 0.40625 }, { x: 0.46875, y: 0.40625 }, { x: 0.53125, y: 0.40625 }, { x: 0.53125, y: 0.40625 }, { x: 0.59375, y: 0.40625 }, { x: 0.59375, y: 0.40625 }, { x: 0.65625, y: 0.40625 }, { x: 0.65625, y: 0.40625 }, { x: 0.71875, y: 0.40625 }, { x: 0.71875, y: 0.40625 }, { x: 0.78125, y: 0.40625 }, { x: 0.78125, y: 0.40625 }, { x: 0.84375, y: 0.40625 }, { x: 0.84375, y: 0.40625 }, { x: 0.90625, y: 0.40625 }, { x: 0.90625, y: 0.40625 }, { x: 0.96875, y: 0.40625 }, { x: 0.96875, y: 0.40625 }, { x: 0.03125, y: 0.46875 }, { x: 0.03125, y: 0.46875 }, { x: 0.09375, y: 0.46875 }, { x: 0.09375, y: 0.46875 }, { x: 0.15625, y: 0.46875 }, { x: 0.15625, y: 0.46875 }, { x: 0.21875, y: 0.46875 }, { x: 0.21875, y: 0.46875 }, { x: 0.28125, y: 0.46875 }, { x: 0.28125, y: 0.46875 }, { x: 0.34375, y: 0.46875 }, { x: 0.34375, y: 0.46875 }, { x: 0.40625, y: 0.46875 }, { x: 0.40625, y: 0.46875 }, { x: 0.46875, y: 0.46875 }, { x: 0.46875, y: 0.46875 }, { x: 0.53125, y: 0.46875 }, { x: 0.53125, y: 0.46875 }, { x: 0.59375, y: 0.46875 }, { x: 0.59375, y: 0.46875 }, { x: 0.65625, y: 0.46875 }, { x: 0.65625, y: 0.46875 }, { x: 0.71875, y: 0.46875 }, { x: 0.71875, y: 0.46875 }, { x: 0.78125, y: 0.46875 }, { x: 0.78125, y: 0.46875 }, { x: 0.84375, y: 0.46875 }, { x: 0.84375, y: 0.46875 }, { x: 0.90625, y: 0.46875 }, { x: 0.90625, y: 0.46875 }, { x: 0.96875, y: 0.46875 }, { x: 0.96875, y: 0.46875 }, { x: 0.03125, y: 0.53125 }, { x: 0.03125, y: 0.53125 }, { x: 0.09375, y: 0.53125 }, { x: 0.09375, y: 0.53125 }, { x: 0.15625, y: 0.53125 }, { x: 0.15625, y: 0.53125 }, { x: 0.21875, y: 0.53125 }, { x: 0.21875, y: 0.53125 }, { x: 0.28125, y: 0.53125 }, { x: 0.28125, y: 0.53125 }, { x: 0.34375, y: 0.53125 }, { x: 0.34375, y: 0.53125 }, { x: 0.40625, y: 0.53125 }, { x: 0.40625, y: 0.53125 }, { x: 0.46875, y: 0.53125 }, { x: 0.46875, y: 0.53125 }, { x: 0.53125, y: 0.53125 }, { x: 0.53125, y: 0.53125 }, { x: 0.59375, y: 0.53125 }, { x: 0.59375, y: 0.53125 }, { x: 0.65625, y: 0.53125 }, { x: 0.65625, y: 0.53125 }, { x: 0.71875, y: 0.53125 }, { x: 0.71875, y: 0.53125 }, { x: 0.78125, y: 0.53125 }, { x: 0.78125, y: 0.53125 }, { x: 0.84375, y: 0.53125 }, { x: 0.84375, y: 0.53125 }, { x: 0.90625, y: 0.53125 }, { x: 0.90625, y: 0.53125 }, { x: 0.96875, y: 0.53125 }, { x: 0.96875, y: 0.53125 }, { x: 0.03125, y: 0.59375 }, { x: 0.03125, y: 0.59375 }, { x: 0.09375, y: 0.59375 }, { x: 0.09375, y: 0.59375 }, { x: 0.15625, y: 0.59375 }, { x: 0.15625, y: 0.59375 }, { x: 0.21875, y: 0.59375 }, { x: 0.21875, y: 0.59375 }, { x: 0.28125, y: 0.59375 }, { x: 0.28125, y: 0.59375 }, { x: 0.34375, y: 0.59375 }, { x: 0.34375, y: 0.59375 }, { x: 0.40625, y: 0.59375 }, { x: 0.40625, y: 0.59375 }, { x: 0.46875, y: 0.59375 }, { x: 0.46875, y: 0.59375 }, { x: 0.53125, y: 0.59375 }, { x: 0.53125, y: 0.59375 }, { x: 0.59375, y: 0.59375 }, { x: 0.59375, y: 0.59375 }, { x: 0.65625, y: 0.59375 }, { x: 0.65625, y: 0.59375 }, { x: 0.71875, y: 0.59375 }, { x: 0.71875, y: 0.59375 }, { x: 0.78125, y: 0.59375 }, { x: 0.78125, y: 0.59375 }, { x: 0.84375, y: 0.59375 }, { x: 0.84375, y: 0.59375 }, { x: 0.90625, y: 0.59375 }, { x: 0.90625, y: 0.59375 }, { x: 0.96875, y: 0.59375 }, { x: 0.96875, y: 0.59375 }, { x: 0.03125, y: 0.65625 }, { x: 0.03125, y: 0.65625 }, { x: 0.09375, y: 0.65625 }, { x: 0.09375, y: 0.65625 }, { x: 0.15625, y: 0.65625 }, { x: 0.15625, y: 0.65625 }, { x: 0.21875, y: 0.65625 }, { x: 0.21875, y: 0.65625 }, { x: 0.28125, y: 0.65625 }, { x: 0.28125, y: 0.65625 }, { x: 0.34375, y: 0.65625 }, { x: 0.34375, y: 0.65625 }, { x: 0.40625, y: 0.65625 }, { x: 0.40625, y: 0.65625 }, { x: 0.46875, y: 0.65625 }, { x: 0.46875, y: 0.65625 }, { x: 0.53125, y: 0.65625 }, { x: 0.53125, y: 0.65625 }, { x: 0.59375, y: 0.65625 }, { x: 0.59375, y: 0.65625 }, { x: 0.65625, y: 0.65625 }, { x: 0.65625, y: 0.65625 }, { x: 0.71875, y: 0.65625 }, { x: 0.71875, y: 0.65625 }, { x: 0.78125, y: 0.65625 }, { x: 0.78125, y: 0.65625 }, { x: 0.84375, y: 0.65625 }, { x: 0.84375, y: 0.65625 }, { x: 0.90625, y: 0.65625 }, { x: 0.90625, y: 0.65625 }, { x: 0.96875, y: 0.65625 }, { x: 0.96875, y: 0.65625 }, { x: 0.03125, y: 0.71875 }, { x: 0.03125, y: 0.71875 }, { x: 0.09375, y: 0.71875 }, { x: 0.09375, y: 0.71875 }, { x: 0.15625, y: 0.71875 }, { x: 0.15625, y: 0.71875 }, { x: 0.21875, y: 0.71875 }, { x: 0.21875, y: 0.71875 }, { x: 0.28125, y: 0.71875 }, { x: 0.28125, y: 0.71875 }, { x: 0.34375, y: 0.71875 }, { x: 0.34375, y: 0.71875 }, { x: 0.40625, y: 0.71875 }, { x: 0.40625, y: 0.71875 }, { x: 0.46875, y: 0.71875 }, { x: 0.46875, y: 0.71875 }, { x: 0.53125, y: 0.71875 }, { x: 0.53125, y: 0.71875 }, { x: 0.59375, y: 0.71875 }, { x: 0.59375, y: 0.71875 }, { x: 0.65625, y: 0.71875 }, { x: 0.65625, y: 0.71875 }, { x: 0.71875, y: 0.71875 }, { x: 0.71875, y: 0.71875 }, { x: 0.78125, y: 0.71875 }, { x: 0.78125, y: 0.71875 }, { x: 0.84375, y: 0.71875 }, { x: 0.84375, y: 0.71875 }, { x: 0.90625, y: 0.71875 }, { x: 0.90625, y: 0.71875 }, { x: 0.96875, y: 0.71875 }, { x: 0.96875, y: 0.71875 }, { x: 0.03125, y: 0.78125 }, { x: 0.03125, y: 0.78125 }, { x: 0.09375, y: 0.78125 }, { x: 0.09375, y: 0.78125 }, { x: 0.15625, y: 0.78125 }, { x: 0.15625, y: 0.78125 }, { x: 0.21875, y: 0.78125 }, { x: 0.21875, y: 0.78125 }, { x: 0.28125, y: 0.78125 }, { x: 0.28125, y: 0.78125 }, { x: 0.34375, y: 0.78125 }, { x: 0.34375, y: 0.78125 }, { x: 0.40625, y: 0.78125 }, { x: 0.40625, y: 0.78125 }, { x: 0.46875, y: 0.78125 }, { x: 0.46875, y: 0.78125 }, { x: 0.53125, y: 0.78125 }, { x: 0.53125, y: 0.78125 }, { x: 0.59375, y: 0.78125 }, { x: 0.59375, y: 0.78125 }, { x: 0.65625, y: 0.78125 }, { x: 0.65625, y: 0.78125 }, { x: 0.71875, y: 0.78125 }, { x: 0.71875, y: 0.78125 }, { x: 0.78125, y: 0.78125 }, { x: 0.78125, y: 0.78125 }, { x: 0.84375, y: 0.78125 }, { x: 0.84375, y: 0.78125 }, { x: 0.90625, y: 0.78125 }, { x: 0.90625, y: 0.78125 }, { x: 0.96875, y: 0.78125 }, { x: 0.96875, y: 0.78125 }, { x: 0.03125, y: 0.84375 }, { x: 0.03125, y: 0.84375 }, { x: 0.09375, y: 0.84375 }, { x: 0.09375, y: 0.84375 }, { x: 0.15625, y: 0.84375 }, { x: 0.15625, y: 0.84375 }, { x: 0.21875, y: 0.84375 }, { x: 0.21875, y: 0.84375 }, { x: 0.28125, y: 0.84375 }, { x: 0.28125, y: 0.84375 }, { x: 0.34375, y: 0.84375 }, { x: 0.34375, y: 0.84375 }, { x: 0.40625, y: 0.84375 }, { x: 0.40625, y: 0.84375 }, { x: 0.46875, y: 0.84375 }, { x: 0.46875, y: 0.84375 }, { x: 0.53125, y: 0.84375 }, { x: 0.53125, y: 0.84375 }, { x: 0.59375, y: 0.84375 }, { x: 0.59375, y: 0.84375 }, { x: 0.65625, y: 0.84375 }, { x: 0.65625, y: 0.84375 }, { x: 0.71875, y: 0.84375 }, { x: 0.71875, y: 0.84375 }, { x: 0.78125, y: 0.84375 }, { x: 0.78125, y: 0.84375 }, { x: 0.84375, y: 0.84375 }, { x: 0.84375, y: 0.84375 }, { x: 0.90625, y: 0.84375 }, { x: 0.90625, y: 0.84375 }, { x: 0.96875, y: 0.84375 }, { x: 0.96875, y: 0.84375 }, { x: 0.03125, y: 0.90625 }, { x: 0.03125, y: 0.90625 }, { x: 0.09375, y: 0.90625 }, { x: 0.09375, y: 0.90625 }, { x: 0.15625, y: 0.90625 }, { x: 0.15625, y: 0.90625 }, { x: 0.21875, y: 0.90625 }, { x: 0.21875, y: 0.90625 }, { x: 0.28125, y: 0.90625 }, { x: 0.28125, y: 0.90625 }, { x: 0.34375, y: 0.90625 }, { x: 0.34375, y: 0.90625 }, { x: 0.40625, y: 0.90625 }, { x: 0.40625, y: 0.90625 }, { x: 0.46875, y: 0.90625 }, { x: 0.46875, y: 0.90625 }, { x: 0.53125, y: 0.90625 }, { x: 0.53125, y: 0.90625 }, { x: 0.59375, y: 0.90625 }, { x: 0.59375, y: 0.90625 }, { x: 0.65625, y: 0.90625 }, { x: 0.65625, y: 0.90625 }, { x: 0.71875, y: 0.90625 }, { x: 0.71875, y: 0.90625 }, { x: 0.78125, y: 0.90625 }, { x: 0.78125, y: 0.90625 }, { x: 0.84375, y: 0.90625 }, { x: 0.84375, y: 0.90625 }, { x: 0.90625, y: 0.90625 }, { x: 0.90625, y: 0.90625 }, { x: 0.96875, y: 0.90625 }, { x: 0.96875, y: 0.90625 }, { x: 0.03125, y: 0.96875 }, { x: 0.03125, y: 0.96875 }, { x: 0.09375, y: 0.96875 }, { x: 0.09375, y: 0.96875 }, { x: 0.15625, y: 0.96875 }, { x: 0.15625, y: 0.96875 }, { x: 0.21875, y: 0.96875 }, { x: 0.21875, y: 0.96875 }, { x: 0.28125, y: 0.96875 }, { x: 0.28125, y: 0.96875 }, { x: 0.34375, y: 0.96875 }, { x: 0.34375, y: 0.96875 }, { x: 0.40625, y: 0.96875 }, { x: 0.40625, y: 0.96875 }, { x: 0.46875, y: 0.96875 }, { x: 0.46875, y: 0.96875 }, { x: 0.53125, y: 0.96875 }, { x: 0.53125, y: 0.96875 }, { x: 0.59375, y: 0.96875 }, { x: 0.59375, y: 0.96875 }, { x: 0.65625, y: 0.96875 }, { x: 0.65625, y: 0.96875 }, { x: 0.71875, y: 0.96875 }, { x: 0.71875, y: 0.96875 }, { x: 0.78125, y: 0.96875 }, { x: 0.78125, y: 0.96875 }, { x: 0.84375, y: 0.96875 }, { x: 0.84375, y: 0.96875 }, { x: 0.90625, y: 0.96875 }, { x: 0.90625, y: 0.96875 }, { x: 0.96875, y: 0.96875 }, { x: 0.96875, y: 0.96875 }, { x: 0.0625, y: 0.0625 }, { x: 0.0625, y: 0.0625 }, { x: 0.0625, y: 0.0625 }, { x: 0.0625, y: 0.0625 }, { x: 0.0625, y: 0.0625 }, { x: 0.0625, y: 0.0625 }, { x: 0.1875, y: 0.0625 }, { x: 0.1875, y: 0.0625 }, { x: 0.1875, y: 0.0625 }, { x: 0.1875, y: 0.0625 }, { x: 0.1875, y: 0.0625 }, { x: 0.1875, y: 0.0625 }, { x: 0.3125, y: 0.0625 }, { x: 0.3125, y: 0.0625 }, { x: 0.3125, y: 0.0625 }, { x: 0.3125, y: 0.0625 }, { x: 0.3125, y: 0.0625 }, { x: 0.3125, y: 0.0625 }, { x: 0.4375, y: 0.0625 }, { x: 0.4375, y: 0.0625 }, { x: 0.4375, y: 0.0625 }, { x: 0.4375, y: 0.0625 }, { x: 0.4375, y: 0.0625 }, { x: 0.4375, y: 0.0625 }, { x: 0.5625, y: 0.0625 }, { x: 0.5625, y: 0.0625 }, { x: 0.5625, y: 0.0625 }, { x: 0.5625, y: 0.0625 }, { x: 0.5625, y: 0.0625 }, { x: 0.5625, y: 0.0625 }, { x: 0.6875, y: 0.0625 }, { x: 0.6875, y: 0.0625 }, { x: 0.6875, y: 0.0625 }, { x: 0.6875, y: 0.0625 }, { x: 0.6875, y: 0.0625 }, { x: 0.6875, y: 0.0625 }, { x: 0.8125, y: 0.0625 }, { x: 0.8125, y: 0.0625 }, { x: 0.8125, y: 0.0625 }, { x: 0.8125, y: 0.0625 }, { x: 0.8125, y: 0.0625 }, { x: 0.8125, y: 0.0625 }, { x: 0.9375, y: 0.0625 }, { x: 0.9375, y: 0.0625 }, { x: 0.9375, y: 0.0625 }, { x: 0.9375, y: 0.0625 }, { x: 0.9375, y: 0.0625 }, { x: 0.9375, y: 0.0625 }, { x: 0.0625, y: 0.1875 }, { x: 0.0625, y: 0.1875 }, { x: 0.0625, y: 0.1875 }, { x: 0.0625, y: 0.1875 }, { x: 0.0625, y: 0.1875 }, { x: 0.0625, y: 0.1875 }, { x: 0.1875, y: 0.1875 }, { x: 0.1875, y: 0.1875 }, { x: 0.1875, y: 0.1875 }, { x: 0.1875, y: 0.1875 }, { x: 0.1875, y: 0.1875 }, { x: 0.1875, y: 0.1875 }, { x: 0.3125, y: 0.1875 }, { x: 0.3125, y: 0.1875 }, { x: 0.3125, y: 0.1875 }, { x: 0.3125, y: 0.1875 }, { x: 0.3125, y: 0.1875 }, { x: 0.3125, y: 0.1875 }, { x: 0.4375, y: 0.1875 }, { x: 0.4375, y: 0.1875 }, { x: 0.4375, y: 0.1875 }, { x: 0.4375, y: 0.1875 }, { x: 0.4375, y: 0.1875 }, { x: 0.4375, y: 0.1875 }, { x: 0.5625, y: 0.1875 }, { x: 0.5625, y: 0.1875 }, { x: 0.5625, y: 0.1875 }, { x: 0.5625, y: 0.1875 }, { x: 0.5625, y: 0.1875 }, { x: 0.5625, y: 0.1875 }, { x: 0.6875, y: 0.1875 }, { x: 0.6875, y: 0.1875 }, { x: 0.6875, y: 0.1875 }, { x: 0.6875, y: 0.1875 }, { x: 0.6875, y: 0.1875 }, { x: 0.6875, y: 0.1875 }, { x: 0.8125, y: 0.1875 }, { x: 0.8125, y: 0.1875 }, { x: 0.8125, y: 0.1875 }, { x: 0.8125, y: 0.1875 }, { x: 0.8125, y: 0.1875 }, { x: 0.8125, y: 0.1875 }, { x: 0.9375, y: 0.1875 }, { x: 0.9375, y: 0.1875 }, { x: 0.9375, y: 0.1875 }, { x: 0.9375, y: 0.1875 }, { x: 0.9375, y: 0.1875 }, { x: 0.9375, y: 0.1875 }, { x: 0.0625, y: 0.3125 }, { x: 0.0625, y: 0.3125 }, { x: 0.0625, y: 0.3125 }, { x: 0.0625, y: 0.3125 }, { x: 0.0625, y: 0.3125 }, { x: 0.0625, y: 0.3125 }, { x: 0.1875, y: 0.3125 }, { x: 0.1875, y: 0.3125 }, { x: 0.1875, y: 0.3125 }, { x: 0.1875, y: 0.3125 }, { x: 0.1875, y: 0.3125 }, { x: 0.1875, y: 0.3125 }, { x: 0.3125, y: 0.3125 }, { x: 0.3125, y: 0.3125 }, { x: 0.3125, y: 0.3125 }, { x: 0.3125, y: 0.3125 }, { x: 0.3125, y: 0.3125 }, { x: 0.3125, y: 0.3125 }, { x: 0.4375, y: 0.3125 }, { x: 0.4375, y: 0.3125 }, { x: 0.4375, y: 0.3125 }, { x: 0.4375, y: 0.3125 }, { x: 0.4375, y: 0.3125 }, { x: 0.4375, y: 0.3125 }, { x: 0.5625, y: 0.3125 }, { x: 0.5625, y: 0.3125 }, { x: 0.5625, y: 0.3125 }, { x: 0.5625, y: 0.3125 }, { x: 0.5625, y: 0.3125 }, { x: 0.5625, y: 0.3125 }, { x: 0.6875, y: 0.3125 }, { x: 0.6875, y: 0.3125 }, { x: 0.6875, y: 0.3125 }, { x: 0.6875, y: 0.3125 }, { x: 0.6875, y: 0.3125 }, { x: 0.6875, y: 0.3125 }, { x: 0.8125, y: 0.3125 }, { x: 0.8125, y: 0.3125 }, { x: 0.8125, y: 0.3125 }, { x: 0.8125, y: 0.3125 }, { x: 0.8125, y: 0.3125 }, { x: 0.8125, y: 0.3125 }, { x: 0.9375, y: 0.3125 }, { x: 0.9375, y: 0.3125 }, { x: 0.9375, y: 0.3125 }, { x: 0.9375, y: 0.3125 }, { x: 0.9375, y: 0.3125 }, { x: 0.9375, y: 0.3125 }, { x: 0.0625, y: 0.4375 }, { x: 0.0625, y: 0.4375 }, { x: 0.0625, y: 0.4375 }, { x: 0.0625, y: 0.4375 }, { x: 0.0625, y: 0.4375 }, { x: 0.0625, y: 0.4375 }, { x: 0.1875, y: 0.4375 }, { x: 0.1875, y: 0.4375 }, { x: 0.1875, y: 0.4375 }, { x: 0.1875, y: 0.4375 }, { x: 0.1875, y: 0.4375 }, { x: 0.1875, y: 0.4375 }, { x: 0.3125, y: 0.4375 }, { x: 0.3125, y: 0.4375 }, { x: 0.3125, y: 0.4375 }, { x: 0.3125, y: 0.4375 }, { x: 0.3125, y: 0.4375 }, { x: 0.3125, y: 0.4375 }, { x: 0.4375, y: 0.4375 }, { x: 0.4375, y: 0.4375 }, { x: 0.4375, y: 0.4375 }, { x: 0.4375, y: 0.4375 }, { x: 0.4375, y: 0.4375 }, { x: 0.4375, y: 0.4375 }, { x: 0.5625, y: 0.4375 }, { x: 0.5625, y: 0.4375 }, { x: 0.5625, y: 0.4375 }, { x: 0.5625, y: 0.4375 }, { x: 0.5625, y: 0.4375 }, { x: 0.5625, y: 0.4375 }, { x: 0.6875, y: 0.4375 }, { x: 0.6875, y: 0.4375 }, { x: 0.6875, y: 0.4375 }, { x: 0.6875, y: 0.4375 }, { x: 0.6875, y: 0.4375 }, { x: 0.6875, y: 0.4375 }, { x: 0.8125, y: 0.4375 }, { x: 0.8125, y: 0.4375 }, { x: 0.8125, y: 0.4375 }, { x: 0.8125, y: 0.4375 }, { x: 0.8125, y: 0.4375 }, { x: 0.8125, y: 0.4375 }, { x: 0.9375, y: 0.4375 }, { x: 0.9375, y: 0.4375 }, { x: 0.9375, y: 0.4375 }, { x: 0.9375, y: 0.4375 }, { x: 0.9375, y: 0.4375 }, { x: 0.9375, y: 0.4375 }, { x: 0.0625, y: 0.5625 }, { x: 0.0625, y: 0.5625 }, { x: 0.0625, y: 0.5625 }, { x: 0.0625, y: 0.5625 }, { x: 0.0625, y: 0.5625 }, { x: 0.0625, y: 0.5625 }, { x: 0.1875, y: 0.5625 }, { x: 0.1875, y: 0.5625 }, { x: 0.1875, y: 0.5625 }, { x: 0.1875, y: 0.5625 }, { x: 0.1875, y: 0.5625 }, { x: 0.1875, y: 0.5625 }, { x: 0.3125, y: 0.5625 }, { x: 0.3125, y: 0.5625 }, { x: 0.3125, y: 0.5625 }, { x: 0.3125, y: 0.5625 }, { x: 0.3125, y: 0.5625 }, { x: 0.3125, y: 0.5625 }, { x: 0.4375, y: 0.5625 }, { x: 0.4375, y: 0.5625 }, { x: 0.4375, y: 0.5625 }, { x: 0.4375, y: 0.5625 }, { x: 0.4375, y: 0.5625 }, { x: 0.4375, y: 0.5625 }, { x: 0.5625, y: 0.5625 }, { x: 0.5625, y: 0.5625 }, { x: 0.5625, y: 0.5625 }, { x: 0.5625, y: 0.5625 }, { x: 0.5625, y: 0.5625 }, { x: 0.5625, y: 0.5625 }, { x: 0.6875, y: 0.5625 }, { x: 0.6875, y: 0.5625 }, { x: 0.6875, y: 0.5625 }, { x: 0.6875, y: 0.5625 }, { x: 0.6875, y: 0.5625 }, { x: 0.6875, y: 0.5625 }, { x: 0.8125, y: 0.5625 }, { x: 0.8125, y: 0.5625 }, { x: 0.8125, y: 0.5625 }, { x: 0.8125, y: 0.5625 }, { x: 0.8125, y: 0.5625 }, { x: 0.8125, y: 0.5625 }, { x: 0.9375, y: 0.5625 }, { x: 0.9375, y: 0.5625 }, { x: 0.9375, y: 0.5625 }, { x: 0.9375, y: 0.5625 }, { x: 0.9375, y: 0.5625 }, { x: 0.9375, y: 0.5625 }, { x: 0.0625, y: 0.6875 }, { x: 0.0625, y: 0.6875 }, { x: 0.0625, y: 0.6875 }, { x: 0.0625, y: 0.6875 }, { x: 0.0625, y: 0.6875 }, { x: 0.0625, y: 0.6875 }, { x: 0.1875, y: 0.6875 }, { x: 0.1875, y: 0.6875 }, { x: 0.1875, y: 0.6875 }, { x: 0.1875, y: 0.6875 }, { x: 0.1875, y: 0.6875 }, { x: 0.1875, y: 0.6875 }, { x: 0.3125, y: 0.6875 }, { x: 0.3125, y: 0.6875 }, { x: 0.3125, y: 0.6875 }, { x: 0.3125, y: 0.6875 }, { x: 0.3125, y: 0.6875 }, { x: 0.3125, y: 0.6875 }, { x: 0.4375, y: 0.6875 }, { x: 0.4375, y: 0.6875 }, { x: 0.4375, y: 0.6875 }, { x: 0.4375, y: 0.6875 }, { x: 0.4375, y: 0.6875 }, { x: 0.4375, y: 0.6875 }, { x: 0.5625, y: 0.6875 }, { x: 0.5625, y: 0.6875 }, { x: 0.5625, y: 0.6875 }, { x: 0.5625, y: 0.6875 }, { x: 0.5625, y: 0.6875 }, { x: 0.5625, y: 0.6875 }, { x: 0.6875, y: 0.6875 }, { x: 0.6875, y: 0.6875 }, { x: 0.6875, y: 0.6875 }, { x: 0.6875, y: 0.6875 }, { x: 0.6875, y: 0.6875 }, { x: 0.6875, y: 0.6875 }, { x: 0.8125, y: 0.6875 }, { x: 0.8125, y: 0.6875 }, { x: 0.8125, y: 0.6875 }, { x: 0.8125, y: 0.6875 }, { x: 0.8125, y: 0.6875 }, { x: 0.8125, y: 0.6875 }, { x: 0.9375, y: 0.6875 }, { x: 0.9375, y: 0.6875 }, { x: 0.9375, y: 0.6875 }, { x: 0.9375, y: 0.6875 }, { x: 0.9375, y: 0.6875 }, { x: 0.9375, y: 0.6875 }, { x: 0.0625, y: 0.8125 }, { x: 0.0625, y: 0.8125 }, { x: 0.0625, y: 0.8125 }, { x: 0.0625, y: 0.8125 }, { x: 0.0625, y: 0.8125 }, { x: 0.0625, y: 0.8125 }, { x: 0.1875, y: 0.8125 }, { x: 0.1875, y: 0.8125 }, { x: 0.1875, y: 0.8125 }, { x: 0.1875, y: 0.8125 }, { x: 0.1875, y: 0.8125 }, { x: 0.1875, y: 0.8125 }, { x: 0.3125, y: 0.8125 }, { x: 0.3125, y: 0.8125 }, { x: 0.3125, y: 0.8125 }, { x: 0.3125, y: 0.8125 }, { x: 0.3125, y: 0.8125 }, { x: 0.3125, y: 0.8125 }, { x: 0.4375, y: 0.8125 }, { x: 0.4375, y: 0.8125 }, { x: 0.4375, y: 0.8125 }, { x: 0.4375, y: 0.8125 }, { x: 0.4375, y: 0.8125 }, { x: 0.4375, y: 0.8125 }, { x: 0.5625, y: 0.8125 }, { x: 0.5625, y: 0.8125 }, { x: 0.5625, y: 0.8125 }, { x: 0.5625, y: 0.8125 }, { x: 0.5625, y: 0.8125 }, { x: 0.5625, y: 0.8125 }, { x: 0.6875, y: 0.8125 }, { x: 0.6875, y: 0.8125 }, { x: 0.6875, y: 0.8125 }, { x: 0.6875, y: 0.8125 }, { x: 0.6875, y: 0.8125 }, { x: 0.6875, y: 0.8125 }, { x: 0.8125, y: 0.8125 }, { x: 0.8125, y: 0.8125 }, { x: 0.8125, y: 0.8125 }, { x: 0.8125, y: 0.8125 }, { x: 0.8125, y: 0.8125 }, { x: 0.8125, y: 0.8125 }, { x: 0.9375, y: 0.8125 }, { x: 0.9375, y: 0.8125 }, { x: 0.9375, y: 0.8125 }, { x: 0.9375, y: 0.8125 }, { x: 0.9375, y: 0.8125 }, { x: 0.9375, y: 0.8125 }, { x: 0.0625, y: 0.9375 }, { x: 0.0625, y: 0.9375 }, { x: 0.0625, y: 0.9375 }, { x: 0.0625, y: 0.9375 }, { x: 0.0625, y: 0.9375 }, { x: 0.0625, y: 0.9375 }, { x: 0.1875, y: 0.9375 }, { x: 0.1875, y: 0.9375 }, { x: 0.1875, y: 0.9375 }, { x: 0.1875, y: 0.9375 }, { x: 0.1875, y: 0.9375 }, { x: 0.1875, y: 0.9375 }, { x: 0.3125, y: 0.9375 }, { x: 0.3125, y: 0.9375 }, { x: 0.3125, y: 0.9375 }, { x: 0.3125, y: 0.9375 }, { x: 0.3125, y: 0.9375 }, { x: 0.3125, y: 0.9375 }, { x: 0.4375, y: 0.9375 }, { x: 0.4375, y: 0.9375 }, { x: 0.4375, y: 0.9375 }, { x: 0.4375, y: 0.9375 }, { x: 0.4375, y: 0.9375 }, { x: 0.4375, y: 0.9375 }, { x: 0.5625, y: 0.9375 }, { x: 0.5625, y: 0.9375 }, { x: 0.5625, y: 0.9375 }, { x: 0.5625, y: 0.9375 }, { x: 0.5625, y: 0.9375 }, { x: 0.5625, y: 0.9375 }, { x: 0.6875, y: 0.9375 }, { x: 0.6875, y: 0.9375 }, { x: 0.6875, y: 0.9375 }, { x: 0.6875, y: 0.9375 }, { x: 0.6875, y: 0.9375 }, { x: 0.6875, y: 0.9375 }, { x: 0.8125, y: 0.9375 }, { x: 0.8125, y: 0.9375 }, { x: 0.8125, y: 0.9375 }, { x: 0.8125, y: 0.9375 }, { x: 0.8125, y: 0.9375 }, { x: 0.8125, y: 0.9375 }, { x: 0.9375, y: 0.9375 }, { x: 0.9375, y: 0.9375 }, { x: 0.9375, y: 0.9375 }, { x: 0.9375, y: 0.9375 }, { x: 0.9375, y: 0.9375 }, { x: 0.9375, y: 0.9375 }];
var wQ = class {
  constructor(e20) {
    var t2, n2, a2, i2;
    r(this, "model"), r(this, "anchors"), r(this, "anchorsTensor"), r(this, "inputSize"), r(this, "inputSizeTensor"), r(this, "doubleInputSizeTensor"), this.model = e20, this.anchors = vQ.map((e21) => [e21.x, e21.y]), this.anchorsTensor = Oc(this.anchors), this.inputSize = (null == (i2 = null == (a2 = null == (n2 = null == (t2 = null == this ? void 0 : this.model) ? void 0 : t2.inputs) ? void 0 : n2[0]) ? void 0 : a2.shape) ? void 0 : i2[2]) || 0, this.inputSizeTensor = Mc([this.inputSize, this.inputSize]), this.doubleInputSizeTensor = Mc([2 * this.inputSize, 2 * this.inputSize]);
  }
  normalizeBoxes(e20) {
    const t2 = {};
    t2.boxOffsets = Jo(e20, [0, 0], [-1, 2]), t2.boxSizes = Jo(e20, [0, 2], [-1, 2]), t2.div = Ao(t2.boxOffsets, this.inputSizeTensor), t2.boxCenterPoints = fo(t2.div, this.anchorsTensor), t2.halfBoxSizes = Ao(t2.boxSizes, this.doubleInputSizeTensor), t2.sub = Lu(t2.boxCenterPoints, t2.halfBoxSizes), t2.startPoints = xo(t2.sub, this.inputSizeTensor), t2.add = fo(t2.boxCenterPoints, t2.halfBoxSizes), t2.endPoints = xo(t2.add, this.inputSizeTensor);
    const n2 = ml([t2.startPoints, t2.endPoints], 1);
    return Object.keys(t2).forEach((e21) => ts(t2[e21])), n2;
  }
  normalizeLandmarks(e20, t2) {
    const n2 = {};
    n2.reshape = Ho(e20, [-1, 7, 2]), n2.div = Ao(n2.reshape, this.inputSizeTensor), n2.landmarks = fo(n2.div, this.anchors[t2] ? this.anchors[t2] : 0);
    const r2 = xo(n2.landmarks, this.inputSizeTensor);
    return Object.keys(n2).forEach((e21) => ts(n2[e21])), r2;
  }
  predict(e20, t2) {
    return __async(this, null, function* () {
      var n2;
      const r2 = {};
      r2.resize = mp.resizeBilinear(e20, [this.inputSize, this.inputSize]), r2.div = Ao(r2.resize, Yq.tf127), r2.image = Lu(r2.div, Yq.tf1), r2.batched = this.model.execute(r2.image), r2.predictions = Rc(r2.batched), r2.slice = Jo(r2.predictions, [0, 0], [-1, 1]), r2.sigmoid = Yo(r2.slice), r2.scores = Rc(r2.sigmoid);
      const a2 = yield r2.scores.data();
      r2.boxes = Jo(r2.predictions, [0, 1], [-1, 4]), r2.norm = this.normalizeBoxes(r2.boxes), r2.nms = yield mp.nonMaxSuppressionAsync(r2.norm, r2.scores, 3 * ((null == (n2 = t2.hand) ? void 0 : n2.maxDetected) || 1), t2.hand.iouThreshold, t2.hand.minConfidence);
      const i2 = yield r2.nms.array(), s2 = [];
      for (const o2 of i2) {
        const t3 = {};
        t3.box = Jo(r2.norm, [o2, 0], [1, -1]), t3.slice = Jo(r2.predictions, [o2, 5], [1, 14]), t3.norm = this.normalizeLandmarks(t3.slice, o2), t3.palmLandmarks = Ho(t3.norm, [-1, 2]);
        const n3 = yield t3.box.data(), i3 = lQ({ startPoint: n3.slice(0, 2), endPoint: n3.slice(2, 4), palmLandmarks: yield t3.palmLandmarks.array(), confidence: a2[o2] }, [(e20.shape[2] || 1) / this.inputSize, (e20.shape[1] || 0) / this.inputSize]);
        s2.push(i3), Object.keys(t3).forEach((e21) => ts(t3[e21]));
      }
      return Object.keys(r2).forEach((e21) => ts(r2[e21])), s2;
    });
  }
};
var kQ = [0, 5, 9, 13, 17, 1, 2];
var NQ = 0;
var CQ = class {
  constructor(e20, t2) {
    var n2, a2, i2;
    r(this, "handDetector"), r(this, "handPoseModel"), r(this, "inputSize"), r(this, "storedBoxes"), r(this, "skipped"), r(this, "detectedHands"), this.handDetector = e20, this.handPoseModel = t2, this.inputSize = (null == (i2 = null == (a2 = null == (n2 = this.handPoseModel) ? void 0 : n2.inputs) ? void 0 : a2[0].shape) ? void 0 : i2[2]) || 0, this.storedBoxes = [], this.skipped = Number.MAX_SAFE_INTEGER, this.detectedHands = 0;
  }
  calculateLandmarksBoundingBox(e20) {
    const t2 = e20.map((e21) => e21[0]), n2 = e20.map((e21) => e21[1]);
    return { startPoint: [Math.min(...t2), Math.min(...n2)], endPoint: [Math.max(...t2), Math.max(...n2)] };
  }
  getBoxForPalmLandmarks(e20, t2) {
    const n2 = e20.map((e21) => xQ([...e21, 1], t2));
    return uQ(dQ(this.calculateLandmarksBoundingBox(n2)), 5);
  }
  getBoxForHandLandmarks(e20) {
    const t2 = uQ(dQ(this.calculateLandmarksBoundingBox(e20)), 1.65);
    t2.palmLandmarks = [];
    for (let n2 = 0; 7 > n2; n2++) t2.palmLandmarks.push(e20[kQ[n2]].slice(0, 2));
    return t2;
  }
  transformRawCoords(e20, t2, n2, r2) {
    const a2 = iQ(t2), i2 = [a2[0] / this.inputSize, a2[1] / this.inputSize, (a2[0] + a2[1]) / this.inputSize / 2], s2 = e20.map((e21) => [i2[0] * (e21[0] - this.inputSize / 2), i2[1] * (e21[1] - this.inputSize / 2), i2[2] * e21[2]]), o2 = AQ(n2, [0, 0]), l2 = s2.map((e21) => [...xQ(e21, o2), e21[2]]), u2 = ((e21) => {
      const t3 = [[e21[0][0], e21[1][0]], [e21[0][1], e21[1][1]]], n3 = [e21[0][2], e21[1][2]], r3 = [-pQ(t3[0], n3), -pQ(t3[1], n3)];
      return [t3[0].concat(r3[0]), t3[1].concat(r3[1]), [0, 0, 1]];
    })(r2), d2 = [...sQ(t2), 1], c2 = [pQ(d2, u2[0]), pQ(d2, u2[1])];
    return l2.map((e21) => [Math.trunc(e21[0] + c2[0]), Math.trunc(e21[1] + c2[1]), Math.trunc(e21[2])]);
  }
  estimateHands(e20, t2) {
    return __async(this, null, function* () {
      let n2, r2 = false;
      const a2 = (t2.hand.skipTime || 0) > xX() - NQ;
      t2.skipAllowed && a2 && (t2.hand.skipFrames || 0) > this.skipped ? this.skipped++ : (n2 = yield this.handDetector.predict(e20, t2), this.skipped = 0), n2 && n2.length > 0 && (n2.length !== this.detectedHands && this.detectedHands !== t2.hand.maxDetected || !t2.hand.landmarks) && (this.detectedHands = 0, this.storedBoxes = [...n2], this.storedBoxes.length > 0 && (r2 = true));
      const i2 = [];
      for (let s2 = 0; this.storedBoxes.length > s2; s2++) {
        const n3 = this.storedBoxes[s2];
        if (n3) if (t2.hand.landmarks) {
          const a3 = t2.hand.rotation ? cQ(n3.palmLandmarks[0], n3.palmLandmarks[2]) : 0, o2 = sQ(n3), l2 = [o2[0] / e20.shape[2], o2[1] / e20.shape[1]], u2 = t2.hand.rotation && _X.kernels.includes("rotatewithoffset") ? mp.rotateWithOffset(e20, a3, 0, l2) : e20.clone(), d2 = AQ(-a3, o2), c2 = r2 ? this.getBoxForPalmLandmarks(n3.palmLandmarks, d2) : n3, h2 = oQ(c2, u2, [this.inputSize, this.inputSize]), p2 = Ao(h2, Yq.tf255);
          ts(h2), ts(u2);
          const [f2, m2] = this.handPoseModel.execute(p2);
          NQ = xX(), ts(p2);
          const A2 = (yield f2.data())[0];
          if (ts(f2), t2.hand.minConfidence / 4 > A2) this.storedBoxes[s2] = null;
          else {
            const e21 = Ho(m2, [-1, 3]), t3 = yield e21.array();
            ts(m2), ts(e21);
            const r3 = this.transformRawCoords(t3, c2, a3, d2), o3 = this.getBoxForHandLandmarks(r3);
            this.storedBoxes[s2] = __spreadProps(__spreadValues({}, o3), { confidence: A2 }), i2.push({ landmarks: r3, confidence: A2, boxConfidence: n3.confidence, fingerConfidence: A2, box: { topLeft: o3.startPoint, bottomRight: o3.endPoint } });
          }
          ts(m2);
        } else {
          const e21 = uQ(dQ(n3), 1.65);
          i2.push({ confidence: n3.confidence, boxConfidence: n3.confidence, fingerConfidence: 0, box: { topLeft: e21.startPoint, bottomRight: e21.endPoint }, landmarks: [] });
        }
      }
      return this.storedBoxes = this.storedBoxes.filter((e21) => null !== e21), this.detectedHands = i2.length, i2.length > t2.hand.maxDetected && (i2.length = t2.hand.maxDetected), i2;
    });
  }
};
var $Q = { thumb: [1, 2, 3, 4], index: [5, 6, 7, 8], middle: [9, 10, 11, 12], ring: [13, 14, 15, 16], pinky: [17, 18, 19, 20], palm: [0] };
function RQ(e20, t2) {
  return __async(this, null, function* () {
    gQ || (() => {
      const e21 = yQ ? new wQ(yQ) : void 0;
      e21 && bQ && (gQ = new CQ(e21, bQ));
    })();
    const n2 = yield gQ.estimateHands(e20, t2);
    if (!n2) return [];
    const r2 = [];
    for (let a2 = 0; n2.length > a2; a2++) {
      const t3 = {};
      if (n2[a2].landmarks) for (const e21 of Object.keys($Q)) t3[e21] = $Q[e21].map((e22) => n2[a2].landmarks[e22]);
      const i2 = n2[a2].landmarks;
      let s2 = [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, 0, 0], o2 = [0, 0, 0, 0];
      if (i2 && i2.length > 0) {
        for (const e21 of i2) s2[0] > e21[0] && (s2[0] = e21[0]), s2[1] > e21[1] && (s2[1] = e21[1]), e21[0] > s2[2] && (s2[2] = e21[0]), e21[1] > s2[3] && (s2[3] = e21[1]);
        s2[2] -= s2[0], s2[3] -= s2[1], o2 = [s2[0] / (e20.shape[2] || 0), s2[1] / (e20.shape[1] || 0), s2[2] / (e20.shape[2] || 0), s2[3] / (e20.shape[1] || 0)];
      } else s2 = n2[a2].box ? [Math.trunc(Math.max(0, n2[a2].box.topLeft[0])), Math.trunc(Math.max(0, n2[a2].box.topLeft[1])), Math.trunc(Math.min(e20.shape[2] || 0, n2[a2].box.bottomRight[0]) - Math.max(0, n2[a2].box.topLeft[0])), Math.trunc(Math.min(e20.shape[1] || 0, n2[a2].box.bottomRight[1]) - Math.max(0, n2[a2].box.topLeft[1]))] : [0, 0, 0, 0], o2 = [n2[a2].box.topLeft[0] / (e20.shape[2] || 0), n2[a2].box.topLeft[1] / (e20.shape[1] || 0), (n2[a2].box.bottomRight[0] - n2[a2].box.topLeft[0]) / (e20.shape[2] || 0), (n2[a2].box.bottomRight[1] - n2[a2].box.topLeft[1]) / (e20.shape[1] || 0)];
      const l2 = QJ(i2);
      r2.push({ id: a2, score: Math.round(100 * n2[a2].confidence) / 100, boxScore: Math.round(100 * n2[a2].boxConfidence) / 100, fingerScore: Math.round(100 * n2[a2].fingerConfidence) / 100, label: "hand", box: s2, boxRaw: o2, keypoints: i2, annotations: t3, landmarks: l2 });
    }
    return r2;
  });
}
var SQ = [null, null];
var IQ = ["StatefulPartitionedCall/Postprocessor/Slice", "StatefulPartitionedCall/Postprocessor/ExpandDims_1"];
var EQ = [[0, 0], [0, 0]];
var TQ = ["hand", "fist", "pinch", "point", "face", "tip", "pinchtip"];
var MQ = Number.MAX_SAFE_INTEGER;
var OQ = 0;
var FQ = [0, 0];
var PQ = { boxes: [], hands: [] };
var zQ = { thumb: [1, 2, 3, 4], index: [5, 6, 7, 8], middle: [9, 10, 11, 12], ring: [13, 14, 15, 16], pinky: [17, 18, 19, 20], base: [0], palm: [0, 17, 13, 9, 5, 1, 0] };
function VQ(e20, t2, n2) {
  return __async(this, null, function* () {
    const r2 = { id: t2.id, score: Math.round(100 * t2.score) / 100, boxScore: Math.round(100 * t2.score) / 100, fingerScore: 0, box: t2.box, boxRaw: t2.boxRaw, label: t2.label, keypoints: [], landmarks: {}, annotations: {} };
    if (e20 && SQ[1] && n2.hand.landmarks && t2.score > (n2.hand.minConfidence || 0)) {
      const a2 = {};
      a2.crop = mp.cropAndResize(e20, [[t2.boxRaw[1], t2.boxRaw[0], t2.boxRaw[3] + t2.boxRaw[1], t2.boxRaw[2] + t2.boxRaw[0]]], [0], [EQ[1][0], EQ[1][1]], "bilinear"), a2.div = Ao(a2.crop, Yq.tf255), [a2.score, a2.keypoints] = SQ[1].execute(a2.div, ["Identity_1", "Identity"]);
      const i2 = (yield a2.score.data())[0], s2 = (100 - Math.trunc(100 / (1 + Math.exp(i2)))) / 100;
      if (s2 >= (n2.hand.minConfidence || 0)) {
        r2.fingerScore = s2, a2.reshaped = Ho(a2.keypoints, [-1, 3]);
        const e21 = (yield a2.reshaped.array()).map((e22) => [e22[0] / EQ[1][1], e22[1] / EQ[1][0], e22[2] || 0]).map((e22) => [e22[0] * t2.boxRaw[2], e22[1] * t2.boxRaw[3], e22[2] || 0]);
        r2.keypoints = e21.map((e22) => [FQ[0] * (e22[0] + t2.boxRaw[0]), FQ[1] * (e22[1] + t2.boxRaw[1]), e22[2] || 0]), r2.landmarks = QJ(r2.keypoints);
        for (const t3 of Object.keys(zQ)) r2.annotations[t3] = zQ[t3].map((e22) => r2.landmarks && r2.keypoints[e22] ? r2.keypoints[e22] : null);
      }
      Object.keys(a2).forEach((e21) => ts(a2[e21]));
    }
    return r2;
  });
}
function _Q(e20, t2) {
  return __async(this, null, function* () {
    var n2, r2;
    if (!((null == (n2 = SQ[0]) ? void 0 : n2.executor) && (null == (r2 = SQ[1]) ? void 0 : r2.executor) && SQ[0].inputs[0].shape && SQ[1].inputs[0].shape)) return [];
    FQ = [e20.shape[2] || 0, e20.shape[1] || 0], MQ++;
    const a2 = (t2.hand.skipTime || 0) > xX() - OQ;
    return t2.skipAllowed && a2 && (t2.hand.skipFrames || 0) > MQ ? PQ.hands : new Promise((n3) => __async(null, null, function* () {
      const r3 = 3 * (t2.hand.skipTime || 0) > xX() - OQ;
      t2.skipAllowed && PQ.hands.length === t2.hand.maxDetected || t2.skipAllowed && r3 && 3 * (t2.hand.skipFrames || 0) > MQ && PQ.hands.length > 0 ? PQ.hands = yield Promise.all(PQ.boxes.map((n4) => VQ(e20, n4, t2))) : (PQ.boxes = yield ((e21, t3) => __async(null, null, function* () {
        const n4 = [];
        if (!e21 || !SQ[0]) return n4;
        const r4 = {}, a4 = (e21.shape[2] || 1) / (e21.shape[1] || 1), i2 = Math.min(8 * Math.round((e21.shape[1] || 0) / 8), 512);
        r4.resize = mp.resizeBilinear(e21, [i2, 8 * Math.round(i2 * a4 / 8)]), r4.cast = co(r4.resize, "int32"), [r4.rawScores, r4.rawBoxes] = yield SQ[0].executeAsync(r4.cast, IQ), r4.boxes = Rc(r4.rawBoxes, [0, 2]), r4.scores = Rc(r4.rawScores, [0]);
        const s2 = Xc(r4.scores, 1);
        ts(s2[4]), s2.splice(4, 1), r4.filtered = Sc(s2, 1), ts(s2), r4.max = tu(r4.filtered, 1), r4.argmax = No(r4.filtered, 1);
        let o2 = 0;
        r4.nms = yield mp.nonMaxSuppressionAsync(r4.boxes, r4.max, (t3.hand.maxDetected || 0) + 1, t3.hand.iouThreshold || 0, t3.hand.minConfidence || 1);
        const l2 = yield r4.nms.data(), u2 = yield r4.max.data(), d2 = yield r4.argmax.data();
        for (const c2 of Array.from(l2)) {
          const e22 = Jo(r4.boxes, c2, 1), t4 = yield e22.data();
          ts(e22);
          const a5 = [t4[1], t4[0], t4[3] - t4[1], t4[2] - t4[0]], i3 = eK(a5, 1.4), s3 = [Math.trunc(a5[0] * FQ[0]), Math.trunc(a5[1] * FQ[1]), Math.trunc(a5[2] * FQ[0]), Math.trunc(a5[3] * FQ[1])], l3 = { id: o2++, score: u2[c2], box: s3, boxRaw: i3, label: TQ[d2[c2]] };
          n4.push(l3);
        }
        return Object.keys(r4).forEach((e22) => ts(r4[e22])), n4.sort((e22, t4) => t4.score - e22.score), n4.length > (t3.hand.maxDetected || 1) && (n4.length = t3.hand.maxDetected || 1), n4;
      }))(e20, t2), OQ = xX(), PQ.hands = yield Promise.all(PQ.boxes.map((n4) => VQ(e20, n4, t2))), MQ = 0);
      const a3 = [...PQ.boxes];
      if (PQ.boxes.length = 0, t2.cacheSensitivity > 0) for (let i2 = 0; PQ.hands.length > i2; i2++) {
        const n4 = QZ(PQ.hands[i2].keypoints, FQ);
        if (n4.box[2] / (e20.shape[2] || 1) > 0.05 && n4.box[3] / (e20.shape[1] || 1) > 0.05 && PQ.hands[i2].fingerScore && PQ.hands[i2].fingerScore > (t2.hand.minConfidence || 0)) {
          const e21 = eK(n4.box, 1.6), t3 = eK(n4.boxRaw, 1.6);
          PQ.boxes.push(__spreadProps(__spreadValues({}, a3[i2]), { box: e21, boxRaw: t3 }));
        }
      }
      for (let e21 = 0; PQ.hands.length > e21; e21++) {
        const t3 = JZ(PQ.hands[e21].keypoints, FQ);
        PQ.hands[e21].box = t3.box, PQ.hands[e21].boxRaw = t3.boxRaw;
      }
      n3(PQ.hands);
    }));
  });
}
var DQ = (e20 = null) => ({ face: [], body: [], hand: [], gesture: [], object: [], persons: [], performance: {}, timestamp: 0, width: 0, height: 0, error: e20 });
var WQ = {};
n(WQ, { connected() {
  return HQ;
}, horizontal() {
  return UQ;
}, kpt() {
  return BQ;
}, relative() {
  return GQ;
}, vertical() {
  return jQ;
} });
var LQ;
var BQ = ["nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle"];
var UQ = [["leftEye", "rightEye"], ["leftEar", "rightEar"], ["leftShoulder", "rightShoulder"], ["leftElbow", "rightElbow"], ["leftWrist", "rightWrist"], ["leftHip", "rightHip"], ["leftKnee", "rightKnee"], ["leftAnkle", "rightAnkle"]];
var jQ = [["leftKnee", "leftShoulder"], ["rightKnee", "rightShoulder"], ["leftAnkle", "leftKnee"], ["rightAnkle", "rightKnee"]];
var GQ = [[["leftHip", "rightHip"], ["leftShoulder", "rightShoulder"]], [["leftElbow", "rightElbow"], ["leftShoulder", "rightShoulder"]]];
var HQ = { leftLeg: ["leftHip", "leftKnee", "leftAnkle"], rightLeg: ["rightHip", "rightKnee", "rightAnkle"], torso: ["leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder"], leftArm: ["leftShoulder", "leftElbow", "leftWrist"], rightArm: ["rightShoulder", "rightElbow", "rightWrist"], head: [] };
var XQ = DQ();
var qQ = 0;
function ZQ(e20) {
  return __async(this, null, function* () {
    return !LQ || _X.initial ? LQ = yield qq(e20.segmentation.modelPath) : e20.debug && AX("cached model:", LQ.modelUrl), LQ;
  });
}
var KQ = {};
function YQ(e20, t2, n2 = { order: 2, multiplier: 25 }) {
  if (!e20 || !e20) return Number.MAX_SAFE_INTEGER;
  let r2 = 0;
  for (let a2 = 0; e20.length > a2; a2++) {
    const i2 = n2.order && 2 !== n2.order ? Math.abs(e20[a2] - t2[a2]) : e20[a2] - t2[a2];
    r2 += n2.order && 2 !== n2.order ? i2 ** n2.order : i2 * i2;
  }
  return Math.round(100 * (n2.multiplier || 20) * r2) / 100;
}
n(KQ, { distance() {
  return YQ;
}, find() {
  return e1;
}, similarity() {
  return QQ;
} });
var JQ = (e20, t2, n2, r2) => 0 === e20 ? 1 : Math.round(100 * Math.max(Math.min((1 - (2 === t2 ? Math.sqrt(e20) : e20 ** (1 / t2)) / 100 - n2) / (r2 - n2), 1), 0)) / 100;
function QQ(e20, t2, n2 = { order: 2, multiplier: 25, min: 0.2, max: 0.8 }) {
  const r2 = YQ(e20, t2, n2);
  return JQ(r2, n2.order || 2, n2.min || 0, n2.max || 1);
}
function e1(e20, t2, n2 = { order: 2, multiplier: 25, threshold: 0, min: 0.2, max: 0.8 }) {
  if (!Array.isArray(e20) || !Array.isArray(t2) || 64 > e20.length || 0 === t2.length) return { index: -1, distance: Infinity, similarity: 0 };
  let r2 = Number.MAX_SAFE_INTEGER, a2 = -1;
  for (let i2 = 0; t2.length > i2; i2++) {
    const s2 = t2[i2].length === e20.length ? YQ(e20, t2[i2], n2) : Number.MAX_SAFE_INTEGER;
    if (r2 > s2 && (r2 = s2, a2 = i2), (n2.threshold || 0) > r2) break;
  }
  return { index: a2, distance: r2, similarity: JQ(r2, n2.order || 2, n2.min || 0, n2.max || 1) };
}
n({}, { Models() {
  return J1;
}, validateModel() {
  return H1;
} });
var t1;
var n1 = { keypoints: [], padding: [[0, 0], [0, 0], [0, 0], [0, 0]] };
function r1(e20) {
  for (const t2 of UQ) {
    const n2 = e20.keypoints.findIndex((e21) => e21.part === t2[0]), r2 = e20.keypoints.findIndex((e21) => e21.part === t2[1]);
    if (e20.keypoints[n2] && e20.keypoints[r2] && e20.keypoints[r2].position[0] > e20.keypoints[n2].position[0]) {
      const t3 = e20.keypoints[n2];
      e20.keypoints[n2] = e20.keypoints[r2], e20.keypoints[r2] = t3;
    }
  }
  for (const t2 of jQ) {
    const n2 = e20.keypoints.findIndex((e21) => e21 && e21.part === t2[0]), r2 = e20.keypoints.findIndex((e21) => e21 && e21.part === t2[1]);
    e20.keypoints[n2] && e20.keypoints[r2] && e20.keypoints[r2].position[1] > e20.keypoints[n2].position[1] && e20.keypoints.splice(n2, 1);
  }
  for (const [t2, n2] of GQ) {
    const r2 = e20.keypoints.findIndex((e21) => e21 && e21.part === t2[0]), a2 = e20.keypoints.findIndex((e21) => e21 && e21.part === t2[1]), i2 = e20.keypoints.findIndex((e21) => e21 && e21.part === n2[0]), s2 = e20.keypoints.findIndex((e21) => e21 && e21.part === n2[1]);
    if (!e20.keypoints[i2] || !e20.keypoints[s2]) continue;
    const o2 = e20.keypoints[r2] ? [Math.abs(e20.keypoints[i2].position[0] - e20.keypoints[r2].position[0]), Math.abs(e20.keypoints[s2].position[0] - e20.keypoints[r2].position[0])] : [0, 0], l2 = e20.keypoints[a2] ? [Math.abs(e20.keypoints[s2].position[0] - e20.keypoints[a2].position[0]), Math.abs(e20.keypoints[i2].position[0] - e20.keypoints[a2].position[0])] : [0, 0];
    if (o2[0] > o2[1] || l2[0] > l2[1]) {
      const t3 = e20.keypoints[r2];
      e20.keypoints[r2] = e20.keypoints[a2], e20.keypoints[a2] = t3;
    }
  }
}
function a1(e20) {
  for (let t2 = 0; e20.length > t2; t2++) if (e20[t2] && n1.keypoints[t2]) {
    const n2 = [Math.abs(e20[t2].positionRaw[0] - n1.keypoints[t2].positionRaw[0]), Math.abs(e20[t2].positionRaw[1] - n1.keypoints[t2].positionRaw[1])];
    5e-3 > n2[0] && 5e-3 > n2[1] ? e20[t2] = n1.keypoints[t2] : n1.keypoints[t2] = e20[t2];
  } else n1.keypoints[t2] = e20[t2];
  return e20;
}
function i1(e20, t2) {
  e20.keypoints = e20.keypoints.filter((e21) => null == e21 ? void 0 : e21.position);
  for (const r2 of e20.keypoints) r2.position = [r2.position[0] * (t2[0] + n1.padding[2][0] + n1.padding[2][1]) / t2[0] - n1.padding[2][0], r2.position[1] * (t2[1] + n1.padding[1][0] + n1.padding[1][1]) / t2[1] - n1.padding[1][0]], r2.positionRaw = [r2.position[0] / t2[0], r2.position[1] / t2[1]];
  const n2 = JZ(e20.keypoints.map((e21) => e21.position), t2);
  return e20.box = n2.box, e20.boxRaw = n2.boxRaw, e20;
}
var s1;
var o1 = 0;
var l1 = Number.MAX_SAFE_INTEGER;
var u1 = { boxes: [], bodies: [], last: 0 };
function d1(e20, t2) {
  return __async(this, null, function* () {
    var n2;
    if (!(null == t1 ? void 0 : t1.executor) || !(null == (n2 = null == t1 ? void 0 : t1.inputs) ? void 0 : n2[0].shape)) return [];
    t2.skipAllowed || (u1.boxes.length = 0), l1++;
    const r2 = (t2.body.skipTime || 0) > xX() - u1.last;
    return t2.skipAllowed && r2 && (t2.body.skipFrames || 0) > l1 ? u1.bodies : new Promise((n3) => __async(null, null, function* () {
      const r3 = {};
      l1 = 0, r3.input = ((e21, t3) => {
        var n4, r4;
        const a3 = {};
        if (!(null == (n4 = null == e21 ? void 0 : e21.shape) ? void 0 : n4[1]) || !(null == (r4 = null == e21 ? void 0 : e21.shape) ? void 0 : r4[2])) return e21;
        n1.padding = [[0, 0], [e21.shape[2] > e21.shape[1] ? Math.trunc((e21.shape[2] - e21.shape[1]) / 2) : 0, e21.shape[2] > e21.shape[1] ? Math.trunc((e21.shape[2] - e21.shape[1]) / 2) : 0], [e21.shape[1] > e21.shape[2] ? Math.trunc((e21.shape[1] - e21.shape[2]) / 2) : 0, e21.shape[1] > e21.shape[2] ? Math.trunc((e21.shape[1] - e21.shape[2]) / 2) : 0], [0, 0]], a3.pad = md(e21, n1.padding), a3.resize = mp.resizeBilinear(a3.pad, [t3, t3]);
        const i2 = co(a3.resize, "int32");
        return Object.keys(a3).forEach((e22) => ts(a3[e22])), i2;
      })(e20, o1), r3.res = null == t1 ? void 0 : t1.execute(r3.input), u1.last = xX();
      const a2 = yield r3.res.array();
      u1.bodies = 17 === r3.res.shape[2] ? ((e21, t3, n4) => {
        const r4 = e21[0][0], a3 = [];
        let i2 = 0;
        for (let d2 = 0; r4.length > d2; d2++) if (i2 = r4[d2][2], i2 > t3.body.minConfidence) {
          const e22 = [r4[d2][1], r4[d2][0]];
          a3.push({ score: Math.round(100 * i2) / 100, part: BQ[d2], positionRaw: e22, position: [Math.round((n4.shape[2] || 0) * e22[0]), Math.round((n4.shape[1] || 0) * e22[1])] });
        }
        i2 = a3.reduce((e22, t4) => t4.score > e22 ? t4.score : e22, 0);
        const s2 = [], o2 = JZ(a3.map((e22) => e22.position), [n4.shape[2], n4.shape[1]]), l2 = {};
        for (const [d2, c2] of Object.entries(HQ)) {
          const e22 = [];
          for (let n5 = 0; c2.length - 1 > n5; n5++) {
            const r5 = a3.find((e23) => e23.part === c2[n5]), i3 = a3.find((e23) => e23.part === c2[n5 + 1]);
            r5 && i3 && r5.score > (t3.body.minConfidence || 0) && i3.score > (t3.body.minConfidence || 0) && e22.push([r5.position, i3.position]);
          }
          l2[d2] = e22;
        }
        const u2 = { id: 0, score: i2, box: o2.box, boxRaw: o2.boxRaw, keypoints: a3, annotations: l2 };
        return r1(u2), s2.push(u2), s2;
      })(a2, t2, e20) : ((e21, t3, n4) => {
        const r4 = [];
        for (let a3 = 0; e21[0].length > a3; a3++) {
          const i2 = e21[0][a3], s2 = Math.round(100 * i2[55]) / 100;
          if (s2 > t3.body.minConfidence) {
            const e22 = [];
            for (let r5 = 0; 17 > r5; r5++) {
              const a4 = i2[3 * r5 + 2];
              if (a4 > t3.body.minConfidence) {
                const t4 = [i2[3 * r5 + 1], i2[3 * r5 + 0]];
                e22.push({ part: BQ[r5], score: Math.round(100 * a4) / 100, positionRaw: t4, position: [Math.round((n4.shape[2] || 0) * t4[0]), Math.round((n4.shape[1] || 0) * t4[1])] });
              }
            }
            const o2 = [i2[52], i2[51], i2[54] - i2[52], i2[53] - i2[51]], l2 = [Math.trunc(o2[0] * (n4.shape[2] || 0)), Math.trunc(o2[1] * (n4.shape[1] || 0)), Math.trunc(o2[2] * (n4.shape[2] || 0)), Math.trunc(o2[3] * (n4.shape[1] || 0))], u2 = {};
            for (const [n5, r5] of Object.entries(HQ)) {
              const a4 = [];
              for (let n6 = 0; r5.length - 1 > n6; n6++) {
                const i3 = e22.find((e23) => e23.part === r5[n6]), s3 = e22.find((e23) => e23.part === r5[n6 + 1]);
                i3 && s3 && i3.score > (t3.body.minConfidence || 0) && s3.score > (t3.body.minConfidence || 0) && a4.push([i3.position, s3.position]);
              }
              u2[n5] = a4;
            }
            const d2 = { id: a3, score: s2, box: l2, boxRaw: o2, keypoints: [...e22], annotations: u2 };
            r1(d2), r4.push(d2);
          }
        }
        return r4.sort((e22, t4) => t4.score - e22.score), r4.length > t3.body.maxDetected && (r4.length = t3.body.maxDetected), r4;
      })(a2, t2, e20);
      for (const t3 of u1.bodies) i1(t3, [e20.shape[2] || 1, e20.shape[1] || 1]), a1(t3.keypoints);
      Object.keys(r3).forEach((e21) => ts(r3[e21])), n3(u1.bodies);
    }));
  });
}
var c1 = [];
var h1 = 0;
var p1 = Number.MAX_SAFE_INTEGER;
var f1 = 0;
var m1 = 2.5;
function A1(e20, t2) {
  return __async(this, null, function* () {
    if (!(null == s1 ? void 0 : s1.executor)) return [];
    const n2 = (t2.object.skipTime || 0) > xX() - h1;
    return t2.skipAllowed && n2 && (t2.object.skipFrames || 0) > p1 && c1.length > 0 ? (p1++, c1) : (p1 = 0, _X.kernels.includes("mod") && _X.kernels.includes("sparsetodense") ? new Promise((n3) => __async(null, null, function* () {
      const r2 = [e20.shape[2] || 0, e20.shape[1] || 0], a2 = mp.resizeBilinear(e20, [f1, f1], false), i2 = Ao(a2, Yq.tf255), s2 = Qc(i2, [0, 3, 1, 2]);
      let o2;
      t2.object.enabled && (o2 = s1.execute(s2)), h1 = xX();
      const l2 = yield ((e21, t3, n4) => __async(null, null, function* () {
        var r3, a3;
        let i3 = 0, s3 = [];
        const o3 = f1;
        for (const c2 of [1, 2, 4]) {
          const l4 = 13 * c2, u3 = Rc(e21.find((e22) => e22.shape[1] === l4 ** 2 && (e22.shape[2] || 0) === hK.length)), d3 = yield u3.array(), h2 = Rc(e21.find((e22) => e22.shape[1] === l4 ** 2 && hK.length > (e22.shape[2] || 0))), p2 = Ho(h2, [-1, 4, ((null == (r3 = h2.shape) ? void 0 : r3[1]) || 0) / 4]), f2 = No(p2, 2), m2 = yield f2.array();
          for (let e22 = 0; u3.shape[0] > e22; e22++) for (let r4 = 0; r4 < ((null == (a3 = u3.shape) ? void 0 : a3[1]) || 0); r4++) {
            const a4 = d3[e22][r4];
            if (a4 > (n4.object.minConfidence || 0) && 61 !== r4) {
              const n5 = (0.5 + Math.trunc(e22 % l4)) / l4, u4 = (0.5 + Math.trunc(e22 / l4)) / l4, d4 = m2[e22].map((e23) => e23 * (l4 / c2 / o3)), [h3, p3] = [n5 - m1 / c2 * d4[0], u4 - m1 / c2 * d4[1]], [f3, A2] = [n5 + m1 / c2 * d4[2] - h3, u4 + m1 / c2 * d4[3] - p3];
              let x2 = [h3, p3, f3, A2];
              x2 = x2.map((e23) => Math.max(0, Math.min(e23, 1)));
              const y2 = [x2[0] * t3[0], x2[1] * t3[1], x2[2] * t3[0], x2[3] * t3[1]], b2 = { id: i3++, score: Math.round(100 * a4) / 100, class: r4 + 1, label: hK[r4].label, box: y2.map((e23) => Math.trunc(e23)), boxRaw: x2 };
              s3.push(b2);
            }
          }
          ts([u3, h2, p2, f2]);
        }
        const l3 = s3.map((e22) => [e22.boxRaw[1], e22.boxRaw[0], e22.boxRaw[3], e22.boxRaw[2]]), u2 = s3.map((e22) => e22.score);
        let d2 = [];
        if (l3 && l3.length > 0) {
          const e22 = yield mp.nonMaxSuppressionAsync(l3, u2, n4.object.maxDetected || 0, n4.object.iouThreshold, n4.object.minConfidence);
          d2 = Array.from(yield e22.data()), ts(e22);
        }
        return s3 = s3.filter((e22, t4) => d2.includes(t4)).sort((e22, t4) => t4.score - e22.score), s3;
      }))(o2, r2, t2);
      c1 = l2, ts([a2, i2, s2, ...o2]), n3(l2);
    })) : c1);
  });
}
var x1 = ["nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle"];
var y1 = x1.length;
var b1 = x1.reduce((e20, t2, n2) => (e20[t2] = n2, e20), {});
var g1 = [["nose", "leftEye"], ["leftEye", "leftEar"], ["nose", "rightEye"], ["rightEye", "rightEar"], ["nose", "leftShoulder"], ["leftShoulder", "leftElbow"], ["leftElbow", "leftWrist"], ["leftShoulder", "leftHip"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["nose", "rightShoulder"], ["rightShoulder", "rightElbow"], ["rightElbow", "rightWrist"], ["rightShoulder", "rightHip"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"]];
function v1(e20) {
  const t2 = e20.reduce(({ maxX: e21, maxY: t3, minX: n2, minY: r2 }, { position: { x: a2, y: i2 } }) => ({ maxX: Math.max(e21, a2), maxY: Math.max(t3, i2), minX: Math.min(n2, a2), minY: Math.min(r2, i2) }), { maxX: -Infinity, maxY: -Infinity, minX: Infinity, minY: Infinity });
  return [t2.minX, t2.minY, t2.maxX - t2.minX, t2.maxY - t2.minY];
}
var w1;
var k1 = class {
  constructor(e20, t2) {
    r(this, "priorityQueue"), r(this, "numberOfElements"), r(this, "getElementValue"), this.priorityQueue = Array(e20), this.numberOfElements = -1, this.getElementValue = t2;
  }
  enqueue(e20) {
    this.priorityQueue[++this.numberOfElements] = e20, this.swim(this.numberOfElements);
  }
  dequeue() {
    const e20 = this.priorityQueue[0];
    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e20;
  }
  empty() {
    return -1 === this.numberOfElements;
  }
  size() {
    return this.numberOfElements + 1;
  }
  all() {
    return this.priorityQueue.slice(0, this.numberOfElements + 1);
  }
  max() {
    return this.priorityQueue[0];
  }
  swim(e20) {
    for (; e20 > 0 && this.less(Math.floor(e20 / 2), e20); ) this.exchange(e20, Math.floor(e20 / 2)), e20 = Math.floor(e20 / 2);
  }
  sink(e20) {
    for (; this.numberOfElements >= 2 * e20; ) {
      let t2 = 2 * e20;
      if (this.numberOfElements > t2 && this.less(t2, t2 + 1) && t2++, !this.less(e20, t2)) break;
      this.exchange(e20, t2), e20 = t2;
    }
  }
  getValueAt(e20) {
    return this.getElementValue(this.priorityQueue[e20]);
  }
  less(e20, t2) {
    return this.getValueAt(e20) < this.getValueAt(t2);
  }
  exchange(e20, t2) {
    const n2 = this.priorityQueue[e20];
    this.priorityQueue[e20] = this.priorityQueue[t2], this.priorityQueue[t2] = n2;
  }
};
function N1(e20, t2, n2, r2) {
  return { y: r2.get(e20, t2, n2), x: r2.get(e20, t2, n2 + y1) };
}
function C1(e20, t2, n2) {
  const { heatmapY: r2, heatmapX: a2, id: i2 } = e20, { y: s2, x: o2 } = N1(r2, a2, i2, n2);
  return { x: e20.heatmapX * t2 + o2, y: e20.heatmapY * t2 + s2 };
}
function $1(e20, t2, n2) {
  return t2 > e20 ? t2 : e20 > n2 ? n2 : e20;
}
function R1(e20, t2) {
  return { x: e20.x + t2.x, y: e20.y + t2.y };
}
var S1;
var I1 = ["MobilenetV1/offset_2/BiasAdd", "MobilenetV1/heatmap_2/BiasAdd", "MobilenetV1/displacement_fwd_2/BiasAdd", "MobilenetV1/displacement_bwd_2/BiasAdd"];
var E1 = 16;
function T1(e20, t2, n2, r2, a2, i2, s2 = 2) {
  const o2 = (e21, t3, n3) => ({ y: $1(Math.round(e21.y / E1), 0, t3 - 1), x: $1(Math.round(e21.x / E1), 0, n3 - 1) }), [l2, u2] = r2.shape, d2 = o2(t2.position, l2, u2), c2 = { y: i2.get((h2 = d2).y, h2.x, e20), x: i2.get(h2.y, h2.x, i2.shape[2] / 2 + e20) };
  var h2;
  let p2 = R1(t2.position, c2);
  for (let A2 = 0; s2 > A2; A2++) {
    const e21 = o2(p2, l2, u2), t3 = N1(e21.y, e21.x, n2, a2);
    p2 = R1({ x: e21.x * E1, y: e21.y * E1 }, { x: t3.x, y: t3.y });
  }
  const f2 = o2(p2, l2, u2), m2 = r2.get(f2.y, f2.x, n2);
  return { position: p2, part: x1[n2], score: m2 };
}
function M1(e20, t2, n2, r2, a2) {
  const i2 = g1.map(([e21, t3]) => [b1[e21], b1[t3]]), s2 = i2.map(([, e21]) => e21), o2 = i2.map(([e21]) => e21), l2 = s2.length, u2 = Array(t2.shape[2]), d2 = C1(e20.part, E1, n2);
  u2[e20.part.id] = { score: e20.score, part: x1[e20.part.id], position: d2 };
  for (let c2 = l2 - 1; c2 >= 0; --c2) {
    const e21 = s2[c2], r3 = o2[c2];
    u2[e21] && !u2[r3] && (u2[r3] = T1(c2, u2[e21], r3, t2, n2, a2));
  }
  for (let c2 = 0; l2 > c2; ++c2) {
    const e21 = o2[c2], a3 = s2[c2];
    u2[e21] && !u2[a3] && (u2[a3] = T1(c2, u2[e21], a3, t2, n2, r2));
  }
  return u2;
}
function O1(e20, t2, n2, r2, a2) {
  const [i2, s2] = a2.shape;
  let o2 = true;
  const l2 = Math.max(n2 - 1, 0), u2 = Math.min(n2 + 1 + 1, i2);
  for (let d2 = l2; u2 > d2; ++d2) {
    const n3 = Math.max(r2 - 1, 0), i3 = Math.min(r2 + 1 + 1, s2);
    for (let r3 = n3; i3 > r3; ++r3) if (a2.get(d2, r3, e20) > t2) {
      o2 = false;
      break;
    }
    if (!o2) break;
  }
  return o2;
}
function F1(e20, { x: t2, y: n2 }, r2) {
  return e20.some(({ keypoints: e21 }) => {
    var a2;
    const i2 = null == (a2 = e21[r2]) ? void 0 : a2.position;
    return !!i2 && 2500 >= ((e22, t3, n3, r3) => {
      const a3 = n3 - e22, i3 = r3 - t3;
      return a3 * a3 + i3 * i3;
    })(n2, t2, i2.y, i2.x);
  });
}
function P1(e20, t2) {
  return t2.reduce((t3, { position: n2, score: r2 }, a2) => (F1(e20, n2, a2) || (t3 += r2), t3), 0) / t2.length;
}
function z1(e20, t2) {
  return __async(this, null, function* () {
    if (!(null == w1 ? void 0 : w1.executor)) return [];
    const n2 = es(() => {
      if (!w1.inputs[0].shape) return [];
      const t3 = mp.resizeBilinear(e20, [w1.inputs[0].shape[2], w1.inputs[0].shape[1]]), n3 = Lu(Ao(co(t3, "float32"), 127.5), 1), r3 = w1.execute(n3, I1).map((e21) => Rc(e21, [0]));
      return r3[1] = Yo(r3[1]), r3;
    }), r2 = yield Promise.all(n2.map((e21) => e21.buffer()));
    for (const i2 of n2) ts(i2);
    const a2 = ((e21, t3, n3, r3, a3, i2) => {
      const s2 = [], o2 = ((e22, t4) => {
        const [n4, r4, a4] = t4.shape, i3 = new k1(n4 * r4 * a4, ({ score: e23 }) => e23);
        for (let s3 = 0; n4 > s3; ++s3) for (let n5 = 0; r4 > n5; ++n5) for (let r5 = 0; a4 > r5; ++r5) {
          const a5 = t4.get(s3, n5, r5);
          e22 > a5 || O1(r5, a5, s3, n5, t4) && i3.enqueue({ score: a5, part: { heatmapY: s3, heatmapX: n5, id: r5 } });
        }
        return i3;
      })(i2, t3);
      for (; a3 > s2.length && !o2.empty(); ) {
        const a4 = o2.dequeue();
        if (F1(s2, C1(a4.part, E1, e21), a4.part.id)) continue;
        let l2 = M1(a4, t3, e21, n3, r3);
        l2 = l2.filter((e22) => e22.score > i2);
        const u2 = P1(s2, l2), d2 = v1(l2);
        u2 > i2 && s2.push({ keypoints: l2, box: d2, score: Math.round(100 * u2) / 100 });
      }
      return s2;
    })(r2[0], r2[1], r2[2], r2[3], t2.body.maxDetected, t2.body.minConfidence);
    return w1.inputs[0].shape ? ((e21, [t3, n3], [r3, a3]) => {
      const i2 = t3 / r3, s2 = n3 / a3;
      return e21.map((e22, t4) => ((e23, t5) => ({ id: t5, score: e23.score, boxRaw: [e23.box[0] / a3, e23.box[1] / r3, e23.box[2] / a3, e23.box[3] / r3], box: [Math.trunc(e23.box[0] * s2), Math.trunc(e23.box[1] * i2), Math.trunc(e23.box[2] * s2), Math.trunc(e23.box[3] * i2)], keypoints: e23.keypoints.map(({ score: e24, part: t6, position: n4 }) => ({ score: e24, part: t6, position: [Math.trunc(n4.x * s2), Math.trunc(n4.y * i2)], positionRaw: [n4.x / r3, n4.y / r3] })), annotations: {} }))(e22, t4));
    })(a2, [e20.shape[1], e20.shape[2]], [w1.inputs[0].shape[2], w1.inputs[0].shape[1]]) : [];
  });
}
var V1 = ["fgr", "pha", "r1o", "r2o", "r3o", "r4o"];
var _1 = {};
var D1 = 0;
function W1(e20) {
  ts([_1.r1i, _1.r2i, _1.r3i, _1.r4i, _1.downsample_ratio]), _1.r1i = Ui(0), _1.r2i = Ui(0), _1.r3i = Ui(0), _1.r4i = Ui(0), _1.downsample_ratio = Ui(D1 = e20.segmentation.ratio || 0.5);
}
function L1(e20) {
  return __async(this, null, function* () {
    return !S1 || _X.initial ? S1 = yield qq(e20.segmentation.modelPath) : e20.debug && AX("cached model:", S1.modelUrl), W1(e20), S1;
  });
}
var B1;
var U1 = (e20) => es(() => {
  const t2 = Rc(e20, [0]), n2 = xo(t2, Yq.tf255);
  return co(n2, "int32");
});
function j1(e20, t2) {
  const n2 = e20 ? U1(e20) : hl([t2.shape[1] || 0, t2.shape[2] || 0, 3], 255, "int32"), r2 = t2 ? U1(t2) : hl([e20.shape[1] || 0, e20.shape[2] || 0, 1], 255, "int32"), a2 = Zo([n2, r2], -1);
  return ts([n2, r2]), a2;
}
function G1(e20) {
  return __async(this, null, function* () {
    return !B1 || _X.initial ? B1 = yield qq(e20.segmentation.modelPath) : e20.debug && AX("cached model:", B1.modelUrl), B1;
  });
}
function H1(e20, t2, n2) {
  var r2, a2;
  if (!t2) return null;
  if (!(null == (r2 = null == e20 ? void 0 : e20.config) ? void 0 : r2.validateModels)) return null;
  const i2 = ["const", "placeholder", "noop", "pad", "squeeze", "add", "sub", "mul", "div"], s2 = ["biasadd", "fusedbatchnormv3", "matmul", "switch", "shape", "merge", "split", "broadcastto"], o2 = [], l2 = [], u2 = t2.modelUrl, d2 = t2.executor;
  if (null == (a2 = null == d2 ? void 0 : d2.graph) ? void 0 : a2.nodes) for (const c2 of Object.values(d2.graph.nodes)) {
    const e21 = c2.op.toLowerCase();
    o2.includes(e21) || o2.push(e21);
  }
  else !d2 && e20.config.debug && AX("model not loaded", n2);
  for (const c2 of o2) i2.includes(c2) || s2.includes(c2) || e20.env.kernels.includes(c2) || e20.env.kernels.includes(c2.replace("_", "")) || e20.env.kernels.includes(c2.replace("native", "")) || e20.env.kernels.includes(c2.replace("v2", "")) || l2.push(c2);
  return e20.config.debug && l2.length > 0 && AX("model validation failed:", n2, l2), l2.length > 0 ? { name: n2, missing: l2, ops: o2, url: u2 } : null;
}
var X1;
var q1;
var Z1;
var K1;
var Y1;
var J1 = class {
  constructor(e20) {
    r(this, "instance"), r(this, "models", {}), this.models = {}, this.instance = e20;
  }
  stats() {
    let e20 = 0, t2 = 0, n2 = 0;
    for (const a2 of Object.values(Xq)) e20 += Number.isNaN(+a2.sizeFromManifest) ? 0 : a2.sizeFromManifest, t2 += Number.isNaN(+a2.sizeLoadedWeights) ? 0 : a2.sizeLoadedWeights, n2 += Number.isNaN(+a2.sizeDesired) ? 0 : a2.sizeDesired;
    const r2 = n2 > 0 ? t2 / n2 : 0;
    return { numLoadedModels: Object.values(Xq).filter((e21) => null == e21 ? void 0 : e21.loaded).length, numDefinedModels: Object.keys(this.models).length, percentageLoaded: r2, totalSizeFromManifest: e20, totalSizeWeights: t2, totalSizeLoading: n2, modelStats: Object.values(Xq) };
  }
  reset() {
    for (const e20 of Object.keys(this.models)) this.models[e20] = null;
  }
  load(e20) {
    return __async(this, null, function* () {
      var t2, n2, r2, a2, i2, s2, o2, l2, u2, d2, c2, h2, p2, f2, m2, A2, x2, y2, b2, g2, v2, w2, k2, N2, C2, $2, R2;
      _X.initial && this.reset(), e20 && (this.instance = e20);
      const S2 = {};
      S2.blazeface = this.instance.config.face.enabled && !this.models.blazeface ? ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && (jK = null), jK ? e21.debug && AX("cached model:", jK.modelUrl) : jK = yield qq(null == (t3 = e21.face.detector) ? void 0 : t3.modelPath), ZK = au(qK = jK.executor && jK.inputs[0].shape ? jK.inputs[0].shape[2] : 256, "int32"), XK = Oc(((e22) => {
          const t4 = 192 === e22 ? { strides: [4], anchors: [1] } : { strides: [e22 / 16, e22 / 8], anchors: [2, 6] }, n3 = [];
          for (let r3 = 0; t4.strides.length > r3; r3++) {
            const a3 = t4.strides[r3], i3 = Math.floor((e22 + a3 - 1) / a3), s3 = Math.floor((e22 + a3 - 1) / a3), o3 = t4.anchors[r3];
            for (let e23 = 0; i3 > e23; e23++) {
              const t5 = a3 * (e23 + 0.5);
              for (let e24 = 0; s3 > e24; e24++) {
                const r4 = a3 * (e24 + 0.5);
                for (let e25 = 0; o3 > e25; e25++) n3.push([r4, t5]);
              }
            }
          }
          return n3;
        })(qK)), jK;
      }))(this.instance.config) : null, S2.antispoof = this.instance.config.face.enabled && (null == (t2 = this.instance.config.face.antispoof) ? void 0 : t2.enabled) && !this.models.antispoof ? ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && ($Y = null), $Y ? e21.debug && AX("cached model:", $Y.modelUrl) : $Y = yield qq(null == (t3 = e21.face.antispoof) ? void 0 : t3.modelPath), $Y;
      }))(this.instance.config) : null, S2.liveness = this.instance.config.face.enabled && (null == (n2 = this.instance.config.face.liveness) ? void 0 : n2.enabled) && !this.models.liveness ? ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && (EY = null), EY ? e21.debug && AX("cached model:", EY.modelUrl) : EY = yield qq(null == (t3 = e21.face.liveness) ? void 0 : t3.modelPath), EY;
      }))(this.instance.config) : null, S2.faceres = this.instance.config.face.enabled && (null == (r2 = this.instance.config.face.description) ? void 0 : r2.enabled) && !this.models.faceres ? ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && (lY = null), lY ? e21.debug && AX("cached model:", lY.modelUrl) : lY = yield qq(null == (t3 = e21.face.description) ? void 0 : t3.modelPath), lY;
      }))(this.instance.config) : null, S2.emotion = this.instance.config.face.enabled && (null == (a2 = this.instance.config.face.emotion) ? void 0 : a2.enabled) && !this.models.emotion ? ((e21) => __async(this, null, function* () {
        var t3, n3, r3;
        return _X.initial && (oY = null), oY ? e21.debug && AX("cached model:", oY.modelUrl) : (oY = yield qq(null == (t3 = e21.face.emotion) ? void 0 : t3.modelPath), bY = 3 === (null == (r3 = null == (n3 = null == oY ? void 0 : oY.inputs) ? void 0 : n3[0].shape) ? void 0 : r3[3]), fY = bY ? ["angry", "disgust", "fear", "happy", "neutral", "sad", "surprise"] : ["angry", "disgust", "fear", "happy", "sad", "surprise", "neutral"]), oY;
      }))(this.instance.config) : null, S2.iris = this.instance.config.face.enabled && (null == (i2 = this.instance.config.face.iris) ? void 0 : i2.enabled) && !(null == (s2 = this.instance.config.face.attention) ? void 0 : s2.enabled) && !this.models.iris ? ((e21) => __async(this, null, function* () {
        var t3, n3;
        return _X.initial && (GK = null), GK ? e21.debug && AX("cached model:", GK.modelUrl) : GK = yield qq(null == (t3 = e21.face.iris) ? void 0 : t3.modelPath), -1 === (YK = (null == GK ? void 0 : GK.executor) && (null == (n3 = GK.inputs) ? void 0 : n3[0].shape) ? GK.inputs[0].shape[2] : 0) && (YK = 64), GK;
      }))(this.instance.config) : null, S2.facemesh = this.instance.config.face.enabled && (null == (o2 = this.instance.config.face.mesh) ? void 0 : o2.enabled) && !this.models.facemesh ? ((e21) => __async(this, null, function* () {
        var t3, n3, r3, a3, i3, s3;
        return _X.initial && (dY = null), (null == (t3 = e21.face.attention) ? void 0 : t3.enabled) && (null == dY ? void 0 : dY.signature) && 6 > Object.keys((null == (n3 = null == dY ? void 0 : dY.signature) ? void 0 : n3.outputs) || {}).length && (dY = null), dY ? e21.debug && AX("cached model:", dY.modelUrl) : dY = (null == (r3 = e21.face.attention) ? void 0 : r3.enabled) ? yield qq(e21.face.attention.modelPath) : yield qq(null == (a3 = e21.face.mesh) ? void 0 : a3.modelPath), cY = dY.executor && (null == (i3 = null == dY ? void 0 : dY.inputs) ? void 0 : i3[0].shape) ? null == (s3 = null == dY ? void 0 : dY.inputs) ? void 0 : s3[0].shape[2] : 256, dY;
      }))(this.instance.config) : null, S2.gear = this.instance.config.face.enabled && (null == (l2 = this.instance.config.face.gear) ? void 0 : l2.enabled) && !this.models.gear ? ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && (zY = null), zY ? e21.debug && AX("cached model:", zY.modelUrl) : zY = yield qq(null == (t3 = e21.face.gear) ? void 0 : t3.modelPath), zY;
      }))(this.instance.config) : null, S2.ssrnetage = this.instance.config.face.enabled && (null == (u2 = this.instance.config.face.ssrnet) ? void 0 : u2.enabled) && !this.models.ssrnetage ? ((e21) => __async(this, null, function* () {
        return _X.initial && (BY = null), BY ? e21.debug && AX("cached model:", BY.modelUrl) : BY = yield qq(e21.face.ssrnet.modelPathAge), BY;
      }))(this.instance.config) : null, S2.ssrnetgender = this.instance.config.face.enabled && (null == (d2 = this.instance.config.face.ssrnet) ? void 0 : d2.enabled) && !this.models.ssrnetgender ? ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && (KY = null), KY ? e21.debug && AX("cached model:", KY.modelUrl) : KY = yield qq(null == (t3 = e21.face.ssrnet) ? void 0 : t3.modelPathGender), KY;
      }))(this.instance.config) : null, S2.mobilefacenet = this.instance.config.face.enabled && (null == (c2 = this.instance.config.face.mobilefacenet) ? void 0 : c2.enabled) && !this.models.mobilefacenet ? ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && (nJ = null), nJ ? e21.debug && AX("cached model:", nJ.modelUrl) : nJ = yield qq(null == (t3 = e21.face.mobilefacenet) ? void 0 : t3.modelPath), nJ;
      }))(this.instance.config) : null, S2.insightface = this.instance.config.face.enabled && (null == (h2 = this.instance.config.face.insightface) ? void 0 : h2.enabled) && !this.models.insightface ? ((e21) => __async(this, null, function* () {
        return _X.initial && (lJ = null), lJ ? e21.debug && AX("cached model:", lJ.modelUrl) : lJ = yield qq(e21.face.insightface.modelPath), lJ;
      }))(this.instance.config) : null, S2.blazepose = this.instance.config.body.enabled && !this.models.blazepose && (null == (p2 = this.instance.config.body.modelPath) ? void 0 : p2.includes("blazepose")) ? ((e21) => __async(this, null, function* () {
        if (_X.initial && (XZ = null), XZ) e21.debug && AX("cached model:", XZ.modelUrl);
        else {
          const t3 = (null == (XZ = yield qq(e21.body.modelPath)) ? void 0 : XZ.executor) ? Object.values(XZ.modelSignature.inputs) : void 0;
          tK = Array.isArray(t3) ? parseInt(t3[0].tensorShape.dim[1].size) : 0;
        }
        return XZ;
      }))(this.instance.config) : null, S2.blazeposedetect = this.instance.config.body.enabled && !this.models.blazeposedetect && this.instance.config.body.detector && this.instance.config.body.detector.modelPath ? ((e21) => __async(this, null, function* () {
        if (_X.initial && (GZ = null), !GZ && e21.body.detector && e21.body.detector.modelPath) {
          const t3 = (null == (GZ = yield qq(e21.body.detector.modelPath)) ? void 0 : GZ.executor) ? Object.values(GZ.modelSignature.inputs) : void 0;
          KZ = Array.isArray(t3) ? parseInt(t3[0].tensorShape.dim[1].size) : 0;
        } else e21.debug && GZ && AX("cached model:", GZ.modelUrl);
        return (() => {
          const e22 = [];
          let t3 = 0;
          for (; 5 > t3; ) {
            let n3 = 0, r3 = t3;
            for (; YZ.length > r3 && YZ[r3] === YZ[t3]; ) n3 += 2, r3++;
            const a3 = YZ[t3], i3 = Math.ceil(KZ / a3), s3 = Math.ceil(KZ / a3);
            for (let t4 = 0; i3 > t4; ++t4) for (let r4 = 0; s3 > r4; ++r4) for (let a4 = 0; n3 > a4; ++a4) e22.push({ x: (r4 + 0.5) / s3, y: (t4 + 0.5) / i3 });
            t3 = r3;
          }
          HZ = { x: Mc(e22.map((e23) => e23.x)), y: Mc(e22.map((e23) => e23.y)) };
        })(), GZ;
      }))(this.instance.config) : null, S2.efficientpose = this.instance.config.body.enabled && !this.models.efficientpose && (null == (f2 = this.instance.config.body.modelPath) ? void 0 : f2.includes("efficientpose")) ? ((e21) => __async(this, null, function* () {
        return _X.initial && (bK = null), bK ? e21.debug && AX("cached model:", bK.modelUrl) : bK = yield qq(e21.body.modelPath), bK;
      }))(this.instance.config) : null, S2.movenet = this.instance.config.body.enabled && !this.models.movenet && (null == (m2 = this.instance.config.body.modelPath) ? void 0 : m2.includes("movenet")) ? ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && (t1 = null), t1 ? e21.debug && AX("cached model:", t1.modelUrl) : (eZ(["size"], e21), t1 = yield qq(e21.body.modelPath)), 64 > (o1 = (null == t1 ? void 0 : t1.executor) && (null == (t3 = null == t1 ? void 0 : t1.inputs) ? void 0 : t3[0].shape) ? t1.inputs[0].shape[2] : 0) && (o1 = 256), _e().flagRegistry.WEBGL_USE_SHAPES_UNIFORMS && _e().set("WEBGL_USE_SHAPES_UNIFORMS", false), t1;
      }))(this.instance.config) : null, S2.posenet = this.instance.config.body.enabled && !this.models.posenet && (null == (A2 = this.instance.config.body.modelPath) ? void 0 : A2.includes("posenet")) ? ((e21) => __async(this, null, function* () {
        return !w1 || _X.initial ? w1 = yield qq(e21.body.modelPath) : e21.debug && AX("cached model:", w1.modelUrl), w1;
      }))(this.instance.config) : null, S2.handtrack = this.instance.config.hand.enabled && !this.models.handtrack && (null == (y2 = null == (x2 = this.instance.config.hand.detector) ? void 0 : x2.modelPath) ? void 0 : y2.includes("handtrack")) ? ((e21) => __async(this, null, function* () {
        var t3;
        if (_X.initial && (SQ[0] = null), SQ[0]) e21.debug && AX("cached model:", SQ[0].modelUrl);
        else {
          eZ(["tensorlistreserve", "enter", "tensorlistfromtensor", "merge", "loopcond", "switch", "exit", "tensorliststack", "nextiteration", "tensorlistsetitem", "tensorlistgetitem", "reciprocal", "shape", "split", "where"], e21), SQ[0] = yield qq(null == (t3 = e21.hand.detector) ? void 0 : t3.modelPath);
          const n3 = SQ[0].executor ? Object.values(SQ[0].modelSignature.inputs) : void 0;
          EQ[0][0] = Array.isArray(n3) ? parseInt(n3[0].tensorShape.dim[1].size) : 0, EQ[0][1] = Array.isArray(n3) ? parseInt(n3[0].tensorShape.dim[2].size) : 0;
        }
        return SQ[0];
      }))(this.instance.config) : null, S2.handskeleton = this.instance.config.hand.enabled && this.instance.config.hand.landmarks && !this.models.handskeleton && (null == (g2 = null == (b2 = this.instance.config.hand.detector) ? void 0 : b2.modelPath) ? void 0 : g2.includes("handtrack")) ? ((e21) => __async(this, null, function* () {
        var t3;
        if (_X.initial && (SQ[1] = null), SQ[1]) e21.debug && AX("cached model:", SQ[1].modelUrl);
        else {
          SQ[1] = yield qq(null == (t3 = e21.hand.skeleton) ? void 0 : t3.modelPath);
          const n3 = SQ[1].executor ? Object.values(SQ[1].modelSignature.inputs) : void 0;
          EQ[1][0] = Array.isArray(n3) ? parseInt(n3[0].tensorShape.dim[1].size) : 0, EQ[1][1] = Array.isArray(n3) ? parseInt(n3[0].tensorShape.dim[2].size) : 0;
        }
        return SQ[1];
      }))(this.instance.config) : null, this.instance.config.hand.enabled && !this.models.handdetect && (null == (w2 = null == (v2 = this.instance.config.hand.detector) ? void 0 : v2.modelPath) ? void 0 : w2.includes("handdetect")) && (S2.handdetect = ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && (yQ = null), yQ ? e21.debug && AX("cached model:", yQ.modelUrl) : yQ = yield qq(null == (t3 = e21.hand.detector) ? void 0 : t3.modelPath), yQ;
      }))(this.instance.config), S2.handskeleton = ((e21) => __async(this, null, function* () {
        var t3;
        return _X.initial && (bQ = null), bQ ? e21.debug && AX("cached model:", bQ.modelUrl) : bQ = yield qq(null == (t3 = e21.hand.skeleton) ? void 0 : t3.modelPath), bQ;
      }))(this.instance.config)), S2.centernet = this.instance.config.object.enabled && !this.models.centernet && (null == (k2 = this.instance.config.object.modelPath) ? void 0 : k2.includes("centernet")) ? ((e21) => __async(this, null, function* () {
        if (_X.initial && (cK = null), cK) e21.debug && AX("cached model:", cK.modelUrl);
        else {
          const t3 = (null == (cK = yield qq(e21.object.modelPath)) ? void 0 : cK.executor) ? Object.values(cK.modelSignature.inputs) : void 0;
          pK = Array.isArray(t3) ? parseInt(t3[0].tensorShape.dim[2].size) : 0;
        }
        return cK;
      }))(this.instance.config) : null, S2.nanodet = this.instance.config.object.enabled && !this.models.nanodet && (null == (N2 = this.instance.config.object.modelPath) ? void 0 : N2.includes("nanodet")) ? ((e21) => __async(this, null, function* () {
        if (!s1 || _X.initial) {
          const t3 = (null == (s1 = yield qq(e21.object.modelPath)) ? void 0 : s1.executor) ? Object.values(s1.modelSignature.inputs) : void 0;
          f1 = Array.isArray(t3) ? parseInt(t3[0].tensorShape.dim[2].size) : 416;
        } else e21.debug && AX("cached model:", s1.modelUrl);
        return s1;
      }))(this.instance.config) : null, S2.selfie = this.instance.config.segmentation.enabled && !this.models.selfie && (null == (C2 = this.instance.config.segmentation.modelPath) ? void 0 : C2.includes("selfie")) ? G1(this.instance.config) : null, S2.meet = this.instance.config.segmentation.enabled && !this.models.meet && (null == ($2 = this.instance.config.segmentation.modelPath) ? void 0 : $2.includes("meet")) ? ZQ(this.instance.config) : null, S2.rvm = this.instance.config.segmentation.enabled && !this.models.rvm && (null == (R2 = this.instance.config.segmentation.modelPath) ? void 0 : R2.includes("rvm")) ? L1(this.instance.config) : null;
      for (const [I2, E2] of Object.entries(S2)) (null == E2 ? void 0 : E2.then) && E2.then((e21) => this.models[I2] = e21);
      yield Promise.all(Object.values(S2));
    });
  }
  list() {
    const e20 = Object.keys(this.models).map((e21) => {
      var t2;
      return { name: e21, loaded: null !== this.models[e21], size: 0, url: this.models[e21] ? null == (t2 = this.models[e21]) ? void 0 : t2.modelUrl : null };
    });
    for (const t2 of e20) {
      const e21 = Object.keys(Xq).find((e22) => e22.startsWith(t2.name));
      e21 && (t2.size = Xq[e21].sizeLoadedWeights, t2.url = Xq[e21].url);
    }
    return e20;
  }
  loaded() {
    return this.list().filter((e20) => e20.loaded).map((e20) => e20.name);
  }
  validate() {
    const e20 = [];
    for (const t2 of Object.keys(this.models)) {
      const n2 = this.models[t2];
      if (!n2) continue;
      const r2 = H1(this.instance, n2, t2);
      r2 && e20.push(r2);
    }
    return e20;
  }
};
var Q1 = "\n/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUA\nAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQu\nbmV0IDQuMi4xMwAA/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxob\nIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgo\nKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgBAAEAAwEhAAIRAQMRAf/E\nAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAE\nEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZH\nSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1\ntre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEB\nAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXET\nIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFla\nY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG\nx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+qaKACigApGOKAML\nXp8xlF5A7V4X8RtYs7PzfNImnx8sa8Kp9z3q2tEgp6angWs62ZZ5CTGoJ6DArGNz5p+UrID6EUrF\nPUlW1EuN0XNW7PQ2L5j3JnoKXN0KijqNP0eYoqXBdgPuuo+ZPeupisWn2Jd4+0r924XgsQOCff3/\nAJ1FzRKxDqGii6m3siiQ8F1XGfXI6YNWLfRbiRQMkcZI9fpTDluT2/h6Qy8gDPbtmtG38JeY480Z\n5zSLUTZg8M28YwYxjAArXtdPt402qgHbpSaLWhma3o0Uqk7Nx9DWLaaVblgPs6qRyds2M/gRSQp9\nzZOni2iWS2hlQ+kjYz9OMGrdjq89vIPPVhj+8M/lQyDq9P1WOYBlMZz1AOD+VdDaTiReOKulK0jO\ntHmi0WDTlr0TyxRVhT8tJjIX+9SUxHXUV553BRQAVBcPhSBTSuxPY86+IGti0s5I7dsORy9fM3i6\n8e8mfDO5P90ZrWWiJicNPpZZtxV/xrW0jQt4DOv6Vk2dEEdTY6BHuB25rpbPSo0QARjP0qTRI17W\nwA/hFaMWmoQMgflQXYsDS142rU9tpqqenfNA7GgtihxkdKuRW6qMY/GkDZY8sY4Ap4hXbyB+VArk\nEtuH4wPyrk/EGkOm+a3jw3suRQLc5i38SX9hJ9nnY+XnBUdPyNdFY6pa3KkkAE9l6f8AfJ/pSJT6\nGhDmI+Zb4ZRycdv6ium0nUhKFydrelTsNnS2829RnrVgV6NKXNG55lWPLIM81Op+WrZkRMfmNNzT\nA7GivPO4KKAEY4XNYWt3vkwPg4OK0giJdjw/xrqhm87Zs8tc7pX5A+leSajf6aHYJ50kn4AZpTep\nrBWRm2Vobm4BXfyehPFdnpmnBFUY5rI2SN63tlToK0YI+KZpFF+3QdavwoKTLtoW0Toaswpk5pCb\nLCxipAhoIuP2dKevHXoaYDylRyxhlwRQI4nxVoCXWZI1GfpXGtbSWjYPGP73+NIGupt6TqMsLruZ\nih4xnP5V09mQ+JLd8gn0xSYJnVaVdkook69K34zuUGunDS3Rx4qOzHVIp4rrOMY3NJQI7GivPO8K\nKAILt9kZrz3xlebYiu8KCCWb0XvW0NFch6ysfO3jLVjfXLIn+pQkKorl7WxNxIPl71g2dUUdpo+l\npBGvHPet23iC8ihFosrxirkHQUFo0IF4FXI1O726CpKLacCrMJoJLYHAPpTwucHpSRJJ5e4AZI9x\nUqpxzVpCuOC8cUpQUMRnXttuB4rjNdsYyeVwfXpmpGmcvcQyafMCFJjPY10eg34BUg4DcZP8jUO4\nHaRq3lLNF+IHet7R7jz7c56rwa2wz9+xhiVeFy/T1PFegeaNPWigDsc0ZrzzvDNIaAM7VpNqdegr\nxL4l6kywyRhseZ19lrdfAZL4jxYg3Fw20d63tJsdrDI5rm3Z3R0R0Mce1eKnQYAplIkWrMJ45oZS\nNO3PHbNXIyfpSGWowSOasxLUiZdjFSqtNEMkUemKlAGKsRJjAppFAiORMjmsTVrNZEO4cfSoZSOD\n1eJ7WXBUzQZ+7nkfSo7e2Ei+ZaMzxntjBX2NSU1Y6/wxqojiEFzkA8KTXYaUoWRyv3W5rSjpNHPX\n+BmpSg8V6J5gUUAdhRXnneFFAGHrTfu5PpXzj8S70/aZtxzztXFbv4DKHxHI+H4GZiz9zxXXW8G3\nGBXMjvLRXAx0oPGPSmMVeOnWrMTYpFI0bcg1fh54xmgovRcD3qxETSIZcRvzp+/BpEkqsBUqsM9K\nq4Em4Gkxk0yRGXrVW6i8yFhkg+tJjRxGsWrxllkUMh9eK5uMz6bcebbnfG33kPcVkay2OntPKuo0\nnhXI67c8qa7Lw3c+adjcEDGK1paSRhVV4s6A0or0jyRRQ1AHX0V553hRQBz+vNtt5z3xXzX8Qbdm\nuic5YnOMdK3l8JnTXvlbwpYl+WySOgrp5YfLOOB9O1c62O7qQkc+9RsKChFPWp4DluOlSykaNruH\nArUgHShFNF2NT1qxGO3NBmyxGcE1N2560CFzjrUysO9JAPDDjFOVuKoQuSRTWouBkazbCa3cd8cV\nwF7IISQccHBzUSWpV9C3o1x5b5GAjdQD1rs9DjC3kckbEhqKfxIzn8LOupRXqnkPccBSkUAzraK8\n87wooA5rxMSI3HqK8B8bQl9Q8sffY5b/AAraXwkUviNrw9pH2W1ViMMRTdRjw4HpWNtDti9TPc4P\nFQs2M5qdyyMHLcfjV63HTAoBGtap0wK0YxigpsuRDtVhVYd6GQydVwwIqdRnqKCR23I5pCMUW6gD\nYNKuetAEise9KTxQBWuFyhrznxNZkXjFeN3I+tTIZg2OqmzmxNF0PO3vXp/g2+hukVl4zyPanTXv\nJmVR+60dpThXpnlPceopWFAbnV0V553hSGgRynjC5FujOey14Ssp1HxNmTnc+a3kvcIpv37HoEYQ\nQmMdVHSsnVbYJF5jVk0dsNzlruVIsl2wKxbjWrVHILjg1CRbZJb+ILHPzyhfStODWLQgFJFYd+el\nUJM27HUIXxhga1Y5lLVLKLkMnoauxnPPrSEx7ShF+Y/n2qrc6xBbhizDAqkK1zJuvG9nbg8ZA681\nly/Ei052RO3uKAsZlx8QGd8xxvt9Aa1NH8dK7AXMcip64zigdkdrZX8F7EJLdwwNXMkrz1qRMRly\nCK4TxmpidWI49felPYSOMmi80NIoOV6qRzXYeA5SskYPfirpfEjGr8LPWVHyD6U4CvQPL3ZItOYc\nUDOoNFeed4Uhpks4H4iE/Z5MeleMeGULeLgjds10S+BGdL+Jc9OSBU2Huc5Nc74yvUtrcDBrJnZF\n63PJdXvLy/lKWw46bvQVz82jXhkLO5Y+9ZlsYthcRnbIjY9R3q3awTRkEM3WmJI6C0ea3dGRsr1x\nXY6TqW9FLHnjrUs0izpLK5DDjofSta3ckH09KRUkZuuTvFGdvPauE1Y3U6Mqbssf/rUxHPTaJPK2\nZmJPbBqzY6DCZh5xJC9s9aBJHU6dpemJjfEmfetJtI0+VPkUr/unFOxdiextHs33W07YHQHk11mk\nXb3KbZ1xIvcd6LEyWho4Nct41sTPYb16ipexCPPZN+wYGCvH1rrPAEJmvkPoc1VL4kZVvgZ6yFwK\ncBXoHkkqinFaVyzo80GuE7WJRQSziPiGdthK5HQV4x4J/wBI8WPIewNdEvgRNL42emO/yj1UHNef\neNpRczbC+I17DvWT2OqJxc0sMK4TCisy41q0hfEkqj8aixdwTXNOlwvmqD9anS9tXH7uVG+hosO4\n/wC0oOhrR0+6G4YNIEzsNEuCxAPNdjZruA4xxUmjINSjURksOlcbqFykbnjFA1sYGoassaknCqO5\nrl7rxhGm7yBnBxuJq0rkSlYpw+NLlsfd5P8AerVsvHEqSBHwPVgcgVpyMyVXU3rXxcHYETAk+hru\n/DWti6ZSTyOKzZqndHaxvvUGq2rQ+dYyqR24qWI8dvbr7LqDxyDAzXpvw6FvIxePGSM06Xxoyr/A\nzviKFHNegeX1J41zUhXioGbuaSuM6wpCaBHG/EcA6HN/exxXjXw2jL67cv8A3Qa6H8CFR+NnoWpO\nI4XI44rxLxrqjQzSEsQM1gdSPM9U1uR1YbmWIdXHf2rmpIb67YS28UrRlsLI3c/jW0VZGUpO5pW1\njfLNOjahawzwReYI5cjzMkDavHJ5/SrVv9uhtPtVxCPLBwzxnlT9KGghLU3tKvvPjHzbl7EGuisJ\nGRxWLOg7nRXJEbDjmvSNK+aFSfSoZr0KutRkphc4NcRrdkVjL9aVio7Hk3iqS8ubhrWzUlsZY9kG\ncZNc5D4aee5MclzJIFTzHAO0MfatqSOWu7bFS1srDUZEis0vIZoUxPvfcC+4/dx2xjr712XiTwXb\nWmlQ6hol3cRhoFd4rlg3zY5wR0GelavQwjq7GD4etdVvSnk2wAB+9v8A8mvcfA2kXiRo0/UdcDis\nZnTTulqeoWqbUAJqWUb42X1FZlnjfjSwlGrr5S/eNdD4RkvLAAQ4yRyaUZcruVKl7TQ9I0G+mnzH\nckFwM8VuIK7ac3KF2eXiKapz5UWYxipNtMyNejNch0jSar3cjR27uoyQCRVRWom9DxTx54gu5fMi\nlbKdMVjfCZPNlv5v9rFbVHpYqjGzbOn8SzFI9o715L4u0r7arYzk+lYdTqSujy7U/C0u4vHk+WwO\nxuh9q3J9dgvbdVukMV1EwbDDgn04rZMwlHoZ+orZ6hfQ3RWVnQYCgZAq+8U0ln5NtBsV2yxYcfgK\nJtW0CnB31LlroVwJ1nQLGDjeP7w+lb0dsFxjrWB0tHS6NuWPJ6A16ToUm63T3Gallr4S7cxiTjrX\nPaxaF7dlVeSMUhxZ5jd+H7qCa4eF3DSE5x3zXN3Wk6jbyeaiFWUY6ZyPStYS5SalPmVipFbX0E4c\nW0alvmPHJrag0rVvEE6LdljGpG2NRtQD+tW5XMI0uU9M8NeFo9PiQhecDIIrtrOMIoG3H4VlJm9t\nC6CB06VPGM1IHLeItGS6uw+ORT7e3jsbQvj7gzUNam0JaWE+HN7NqOqX80n3FO1RXo8YzXdS+BHk\n4z+KyzGPapcU2YIv7qQtiuaxvcaWqG4O6FwfSrS1JbPnrxoxkv7qIfejcitj4V2f2exumI+8+aKn\nxHTT+G5d8Txlm4rjLxMsQwzWT3OiK0Mm6sEkVsAcjFc1d+FEmlGwEDPQVopaEuOpr6f4ZWNAu3tW\nvHpAj5ZQcUFIWaDjGMVUMQ3cVDBmvbhY7QAV2nh+T/R1yeKhlrY31+b61FcQK6nIoJMi401WblRi\nqr6PCw5UYq9y+YgOgWzNkRrx3xWjp+nx2v3FQcelAbmko9anQ4GBUNisPHWr1qMrQhS2K11HvmYV\nhamcxSRZ5xRIqluS/DKAQQXZxyXrvo2FdlL4EeZjH+/ZbjNSZpswLNBrE1Gt7VE4ODVIlnh/j61F\nj4lmeTGyUbq6LwdEqWbeX0YbhSqfEddP4Bddj4JIrhL5d8h7VjI6oLQqKNzelWre3yc4/ClFjaL6\nwqBxxUUxwCKu5BmXRA6c+9ZjP83FSBoQuPs4BrsNBlUW659KmRrDY6G1lyQtW3Hy0lqQ1qVJnAbm\noy3b9KYJCqRj3o4zRctIlhjLHmpSuOBRbQOpLGpPFaES7UqkZzKN1KsEc87/AHUUmvPLTVGv72aQ\nk7WJwKmRrQ3ud74Ltilgz4++2a6iNDXdS0gjyMU71my7GpqTbxSbMki3SViajTTHqkSeR/GeyZmg\nnQHkEE1S+F+oPPavBL96I4/Cia1udVF+4dVrkW+Fq8+v4tjMDWUkdVJ6WM0cNV+F+MVmjUcZgqnP\n1qpNNnkcVRLiZtxIS1UzzIF7mghlxUZpVQdq6nTVdAoAOKzkbQWhvwM6gMM1twOJYx3NOJE11Kt1\nH1/pVVlwBkk+9NocXoOQ45FPj+fkUJFF2NSB700v/hTEty5ZpkjvVyUgcCq6GM9zC14/8Se6GcZQ\n1574Xs5WkI2HBPHFQ1dm1KSSZ7Rotn9l0+KPHIHNacae1dy0Vjxaj5ptlhVp+2s2CJ9ppCKzuWNx\nzSFc1SYrHNeNdIGpaYw25ZeRXmvheyk0jVpEdcLJ0q3ZxNKTa0O3vQHg/DNcHrsJDmsmjspnNzNt\nfFIJ24GazOhC+azDmgZIOOKBsp3J2qSaZodubq58yQ4QAnmhGT3NO18pb7BORmu205LfYpyKVkWp\nOxr5gKYWoIZWgfGfloFq1qTPLubnGO1RPtxg4P0oBAkY/hBz6VNDDkZ6AU0W2WSdqkdKr9ZOaGSj\nVtcLHmnOcgmmYvcz7mBLy3MbdD1q9ouiRK6bUAVeelOC1InPlidSsWMDFOCEdq3uefykqrinYqGy\nrFvApMVka2DAowKAsMkRXQqwyDXn/iWyitNQ3qPl6itIvRoF8RXinW4tQ6HI6GuW8SIVBPalc6qe\n5x9x97r3qruwTjrWZ0ksZ9TUmcDNAmZ9/wAoao63rR0+w22MLPtAzt6mghmfofiB76LdJBJBIp5D\nd/oa7bSdWLIPnpDi9TM8TeKdas51XTbIyxd3J/pXS+E/EFxqNoFu7do5OmD60maHWrnZyDRkn/69\nMlEyOR0xntVoNx+FUgYjPxg4FLCuWDZyKQr2RoRnP0qO+nEFpJITgAUzLqZnhu6+0rknOTXpOmwJ\nFbrt5yMmnHYyr6Oxb2ijaKLnPYMClwKQWK3n0hn+lachHOJ9pNNN0apQFzsY10a4v4hXQh0xpieQ\nMA1XLZNjhK80cT8OdV+3Wl3A7ZZJCw+hrR1qLcjZ/CsbnfHRnFXseHJArOYYbrUs1uPhYbuatqFP\nByfSkMq3UIINYkto+87Tx6GkSxfsDbflGD7CtTw/pk4nzITtPIFMFudsukh4Rxz71paTpKwP5jcn\n0qTRy0NORMDgVCqewoJTJgAoxjntTiTu7fWmFxAcnn1q3EPl+X8KZMi4gKqB1Peob/Tv7Us5bfeU\nyOoq4R5nYxqT5I8xieH9J1DTbvyJELRg8ODwa9Ms5mSFV9BWiptbnNVrKdmif7Q1KLg96XIZc5Is\npNL5pqeUrmMtZs0jzV08phchaY00zH1p2ZNxjS1g+LdJOt6U9ssmxjyGp2urDjLlaZzng/wUPDqz\nTSTmWeTrjpVjVk3Rvjr2rnqQ5dDvo1XUd2cTqSNk9OKxXGCeKxZ1DAxHTr2q5C/y8GokUhsz54qu\nuCxzSQjQ0+FZblR2ro4bZYiMVQ0dBb7Qi5x0qzuG5QOh71LYErDufpSeWrHnimIXbjkUjLkH1Hem\ngGxryc+tXI19KYmWegq9YLiLJ7mtqS945cS7QsWehqxA9dEjz4krPSxyZqbFFhGxUm6smjRM55Lk\nHvSvNxXTY57kLT+9MNwKdhXGm5FIbkU7Bca1wMEVhaiuQcVhXWiZ14R6tHGanGBI2OtYkqEHjgVy\ns9ErEeo6UBsHipKEZs5qpPdRxcbhx70NCSuybTNWihc5brW9Fq6vjMnFSdEIdDRi8RRKygZbHFbu\nm6nb3RA3gMegNJhOm0jbXGOoxTuCc1Rz3FyoGKawz9KaAVcZqeMgCmIkB4FaUTbYwB6V00Fuzixb\n0SFMuDU8Mlbs4UPeXHeiOXkUrDuXYnyKk3cVk0ap6HMxxketSMhrcwRC0dMMZFMQ3yzSeVQAeUaz\n9Vj8uPd271nVV4m+GdpnHX67pCeKyLtBtNcR6xlk9RVeWTb3qRnO6trgttyIfm71z7ai8j7/AJmN\nDNqUVa5Yi1AnjynHuBV+11YJhWWXcP8AZNSzqgmaEerSsf3NtIQP4mGKtRavdRgMIpVI9KjU0a7n\nR6T43uYQI7qN2Tpkqciu503VVuQGAYZHQjFVc4alPlZrpKGAznpTwxOc9+lWjIlUACnM4XApiLNk\nnmvnsK0NvpXZRVonmYqV52GsmanhXitTmFkSiJTSAvwrxUxXIrJ7miOfjf1pzNWxkRlqYWpgJupu\n6gQbuahvIxPA6eo4pNXVioS5WmefakGhndH4INZs5DJXA10PaTurmLO21uKpSZqGMoXGnRzBiyjd\n9Kx5rcQS428fSkjanLoaOliHGZFB56VswW+mtPufcBsGOAfmxz+tFkd8HpoaUx09FAtFY8DO71qb\nSms/Nb7RbecG6AEjFLS5c78t+p0djpVs9wsyQiJAdyr1rW+zqjErzSe559Sbk9S3C+MA1bjbgE1S\nMSXzMVG0vNUI2tPKrAuCMnrVzNd0PhR49W/O2xrHmp4TxVMzQshpIzzQBehqesnuaI5VGzT2bitz\nFEbNTC1ADS1JupgG6l3UAc14s04yR/aYRll+8BXCtLncDXFWjys9TCz5oW7GddH5qqNzWDOgQnC8\nVSuo1kHzAGkPYopEY2+RWxV23Vzj5G/Kg3jWaNazhZuqNXS6TaKhB2c0jR1nJWOlhOxRxU4YkCgx\nY0OQatQyDbyaaFYe8uF4NY3iC9ltbVGj43NTIL3h7WzMihjzXVQXYYDdW9Cf2WcOJpfaRZ3g9KsQ\nmupnCLIabGeaAL0LcVY3cVmzRHIxtUhetzEjZqjLUAIWpN1ArhupwagAfDKQ3Q1594v0c2bm6tx+\n5Y8j+6ayrR5onThp8s7dzkZjuqAAmuBnqC7c0iwgtzSA0rWzjfGRW3ZadDu4AoNYo2rfS4v7orSh\n05UA2r0pDbsTm29KRottBNyJ0wpJ9KhD7f6U0ikNWffIFBz60zVUW52ow4UcUN6EPcx44WsbgOmd\nua7TT5Bd24KHnFKnLlZFSN4koluLdueRWvp14swweG9DXoxldHlTjYtzGoo25qzEvwtUxas2jRPQ\n5CNqkLVsYoYzUzdQA3dSFqBBmnqaBhuqhriCXTpVIzxUz+Fl03aSPI9QTypW2/dz0qKNw3SvOPZR\nMqin8VLKRcs3O4Cuk0w/MDjt1NBtHY6O2IIHY1pxgFaETIRwMkjtVSUEk4570MlFW5bap6dKzWm8\n1tqH8aY+hp2FvGoGayNevVt7/ap4xzUvYjqTLtvLPcvJxSaVcyWsxTnFZlnT2t15xHmCtOBYwQy4\nB9q7cPO+jPPxFO2qLEj5HWo42+aus4HpoX4W4FTF+KlotbHII9SFuK0MUNZqiLUDE3UbqBBupwag\nBc1DefPbyD/ZND2KjujyPWlKzuPesRZjHJXms9lMuw3StjnmphKDSLTJ7OfE3JrpbO4GQc9qlnRA\n3LO82k5NbFvdADkjBoCSHyXIIIzgVQvdRigT7wzjgUzO1jHknlvG7qnp61etYFQDIpCZoqVijzXn\n3iC8EmsOuaCGb/heR/s0ijkVv6fbxy3QMg5xmsnuX0Ldzut3+UYTPWk+2GJSe+M1pFtamcldalmx\n1eO4XaThhWnC+TXqR2PHqL3maUJ4qRjxSEjj42qXdxVmaGs1MJoATfSbqBAG5p6mgAzTJTmNvpQU\ntzzHXY83D/U1zF5FhjgV5r3Pa6FMsV5HWnLe7RhqBRdmTwagN2d2K2rPU1C5LAnPrUs6Iysbdrq6\nf3gK0BrUKj/WClY05iM6xLOcQAj3NT29uznfKSzHuadzNu7NSBFjHNSm5VO9IRnajqoWMhTzXFtA\nbvUfMduSeg702Qz0rS7FbTToQFwzjJqaGTFyfK5PQViyzUuFmuIdgGABya5u/vTaN5cnUHFUmLoZ\nzyskwlgJweSK6zQdUEwVJeGr0aUrxPLxEfe0OrhPAqVjxWhznGRtUwatDK4jNxURbmkAm6jNABup\n6tQAFqhupNtu59qUnZFwV5JHnWsHdIx96w5lz15rzT2uhRmt85xWbcxMnUGmZlB0bdxmrNvFIcfM\n350mWjbs7YkDJY/jW5ZWW4jikWkdNp9mqYJFaJdEHHakUULu/VB1rLn1Ld/FgetMGYd/qWSQmSa0\n/AemS32pfa7piLeLkg9z6UmQtz0W7uQ2cZx0A9BVzR7cAea6j2rPqX0L99KRat5A6Dk1wOoKZ52a\nYfMORTYRLujiGWEq6/NWza2yKQVHNdOHerRy4laJo6TTnbbtb8KuM3Fdh5z3OJjbmpt3FaMxAtUZ\nagBN1GaQBzTwaAAms3VbjERUGsa07RsdeFpuUuY4jUjljWTKK4j02RE4IpJYFk6imQkVl0xWarsO\nmAEcUi0bNnZBR0rWtoguMCkUi21wI161mXuocEKaYXMS4u+pY/hVCSWSY4HT0pEmlouiSahdpEBl\nmOceleiwWcNjClvHgJH97Hc1EmVFFi3Czy7mwIl/WtJbjP7uLgd/apQ2VNVvtsBhiPzdK5S4nAuR\nnqOCaTGi9pcytPlU+XpmumtWII44rah8ZjiNIXRuWeNvvViQ/LXpJWPJbu7nCRvVkNxVsxBmqJmo\nEPiXca0YLMuOlJsuKuPlsSi5IrNuG8s4HWs5VEkbwoOTKsk+FJY4rC1K53k1xTk5O7PSpwVNWRzt\n4cms+WpKICtSLTETQj5q0YeBSGiys23pUguGxQMq3E59ayrm4x3yaAKiRtO2WPHcmhruKFxFajzZ\nScA44qRHoXhuMaLpxaUg6hcDLMf4F9KlhuDeXGASIl+8azZslYma68y48m1+7nFW5rtbRNhb5z1p\niMKbUg0zuW4A4rPgb7VdKXOMmpA7HRbMS7nUYiUda0lkQOBngVrS+JGdbWLRt2bAx5BqeQ/LXpnj\nPQ4GJ+ashuK0MhWaoWcA0AaOmASMK7jRNPWYBmHyiuepO2x10qfcv6vYxCzYqoGK4HVYVTJrmb5l\nc6oaM5TUJ8EgGsG4kLNUHT0M64OaqMMikSRsuKbnFMRLG3zVehOaGNE445NNlnVFpDMu6uie9Vo1\n8z5mOAOST2pDK91cNN+5tsrH3PrW54a06KxT7fdrlh/q1Pc+tJ6IUdZGvHPLezMcnBOWbsPap5r3\nylFtbdT1xUWNWzU0/Zbwlgfmx8zGsHWtRHmMqE59aAMyNifvHPc1f0gtPdqkY5JosJHeNci2tktY\neuPnNY+oXWZEVJNrZ9aun8SIq/CzodHuriIokhDIR1ronbKZr0o6o8ipoz//2Q==";
var e0 = "\n/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsICAoIBwsKCQoNDAsNERwSEQ8PESIZGhQcKSQrKigk\nJyctMkA3LTA9MCcnOEw5PUNFSElIKzZPVU5GVEBHSEX/2wBDAQwNDREPESESEiFFLicuRUVFRUVF\nRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUX/wAARCASwBLADASIA\nAhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAEDAgQFBgf/xABDEAEAAgECBAMECQIDBgUFAQAA\nAQIDBBEFEiExE0FRBiJhcRQjMkJSgZGhsWLBJDNyFSVTY3OSNEPR4fAHFjWCokT/xAAYAQEAAwEA\nAAAAAAAAAAAAAAAAAQIDBP/EACARAQEBAQADAQEBAQEBAAAAAAABAhEDITFBEjJRIhP/2gAMAwEA\nAhEDEQA/APqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAKNTq8OkxzfNkisQC8eb1XtRNbzXT4q7eU2nu0MntRq/D8StMccvW29ZmdvgjsTyvZjxOLj\n+s8WLxn8TFPXs6Oj9oct7c14rkxz22nrB2I49KOdTjelmszfmpMeUxv/AA28OqwZ4icWWtt/SUi4\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmdo3nsPNe0Pt\nFh09Z0+DNWL7+9O/7A3eJcZppsV5raI27esvH6jX5ddM25p79Ilo59VbUZOe2Tm/PeGvfPfT2iKR\nPLv1+DO678XmW/a97U6TtOyzTbTF538/T9WjTNecm9a7126tqk3rSYxY5ta1plRZqZNXGjyZcPXl\nmZmsx+qjBrsuO16xM7eXRt04JrdTltk5OWJnfaWf0a2lty5MdZnfzSn+WOHiOutFpjHa9e8bQ2fp\n+alYy462pk7zXbuxjPesbRS0f6ZZV1ET1tErzXFLHo+A+1ddZf6NrI8PJHa1vN6iJi0bxMTHwfOa\nzhzd61v1846utwniM6DUdb3nBaNrVmd9vjC/ZVePYirBqMWppz4rxaPgtEAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItaK1m09ojcHnvarjM8P0vh49+a/eY8ng9D\nh1fGM1rxjtGPfvbzdbjuTJxHX48cTPNltM/KsS9Dw7S49Jp6UpHaGe2vjz1y9J7LYK13vHWe7bj2\nex1tvM80ekuxW3RnW3Vm6P5jRx8H0+OYmMcb+bapo8GKPdpC6bQwtdHU8JpWkdJ/JweL6e23iU67\nd4dubSqyVi9Zi0bwIs68XGp36TtEq7ZJmZmevzdbifCKWtbJinkt6eTgZPFw32t+sRurbWVzxs1y\nRv6T8V1NZNPtfq0seTm+Kevr+SZuxXjvaPiV8N4viycto9HseG6+uu08W6Rkj7UPmFck1tE1nlmP\nLd3eA8V8HVVi1pjq6Ma/pnqce/ERMTETHaUrKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAADW19+TQ5p/p2bLS4v04Zmt5VjeQeJ4bjnLqsupv+Ka1+ERLv4reTmcNxcuC\nvy3l0qdI2hlr66sT02ot0ZV7qqrInruzrVZLGSZ37JjqgYTG0K5lbaFVhDT1Ub456RPweY4hixWi\neSdpjvD1eWejz3FNHWYtkpvFo9EIseb3tS3SerOms22rfpPqZKzvvHSYUz70TExG6Gdbs2rljeJ/\nMx5L0vEzPaelnOi98c9J2bFNTFpit47+a+PVUvx9T9nOIfT+GV5p3yY/ds67wvsXqpxau+G09Lx+\nr3TqrEAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADV4ljnLw3U0jvO\nO0fs2lWqyUw6XLkyfYrWZkHldBEV09eveG3Fq1mI3jd4vPrOIaid8G9MP3Y38k6fNrt/rMk9Ou8s\ntfXXn49rGWInuy8SO/k5Gl1E3rG/fzbOe94wTy99mbRvTrMOOvNfJWsesywniukrG/jU6fF43WYN\nTmtEeJtEQ06aSmK2+bNtEd+qfSO17unF9Hmvy1y13XWyVmN4tExLxVK8PmNq5NrT58zawam+m/yc\n0Xj8NpRYSvQZ7xEOdqI3rPozxayNRXe0ct/ON03jmrKB5nV4q1yTO20Obmv4c+cx8HoeI6WZpNoj\nq83niYmYscU0r8aJ6T1n49zeJ+Meqm1drb9J+Kd5p136StGVem9l9TbHxLDFp7W7+sS+q1nesT6w\n+PcAzVjiGHftzQ+v4f8AJpv6On8jH9ZgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAABp8VrW/C9TW0ztOO3b5Nxp8VmI4bn37TWYB8f1HFtTfUfR9FWJmsdZ9I7MtJxDX5s\nd8ta1y0xzteaR2277rcuhycP12SceLxMeWNpjttHwlu8I0mfQ1y+D7k5YmJmY36T36Ka43z/AF1t\ncI1ds+qxVj7/AEej19PCw9HJ4NoK4OIU5Y35YmZdzVTGebVZabx5jJS+Tmns81rNLm1Wrzc9rVw4\nYibbem72mXTTS0w0M3BvEta1bWrM95ie5EanY87wXgNOL6XPfxraXLhra/W28bR/dzYzarBqJxRe\nbzE7Rt5vWU9n8mPHOGmS0Ypnea1naJb+k9ncNLR7u2y/WcxXO4TOoyUrN6zD0FaW5Y3hu49FiwUi\nKxCvLMR0hlW0jn6ukWw3iXjOJzbDlneOj3GaN6zDzfFOH+LE7SRGo83XNSZ2lbG2/WfdlvaT2cy6\nrNFInlrv1mfJ37cK4PwTTxOoidRm2+/2/KFuyMp47XB4LivXiunrH2b2iH2qn2K/J8x4fGDNxTSZ\n9Nh8OviRvTyfT6xtWI+DeXs9MNZubypASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAOZx6/LoOWPvWiHTcf2hiZ0e8fc2mf1E5+vP/AEeuSd7RC2uKtI6QjHfeINTfwtPf\nJvty9WPfbt/lucP03gxfJf7d/wBoReYpm97zaNeLb4Ims9Nt94auDjem1Wo5PFi1onylS+1o7l8V\nbxvtupjDMdNkYtXS1+Stt+m63xImEJ4xjHER2ZxMUjeUTO3VRmydBbjLJqPi08mbeVOXJPq1sl5Q\nVbkz9+rRy35rxHqzmZlVEe/Ez5LRlW5iyfR6zffaIjq1OSNZps2a21rZInafSPJhxGMl9LStLRWM\nlorM/A4dkrWbYfLZC2W/7K6eubX6b4RzT+W76K8b7G6X62cu3Sten59nsm3j+OXz3/0ANGIAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0OIYfpOHPijvNNo+fdvtXJO18k/\n/OwPFYbz2ls3jx8VqW6xMdWPEdP9D4lkx/dt79flLLHbkxTPwY6nt2512ORTRzE2x4/dpE7cvkme\nE4IrW3hRMxO8THRtU1FKWtvtvK2upx22rzRCtXkqzh2jtF7ZbT122b01ndnpuWuP3Z3+Ky20qDVv\nfauzVy3mejZzNK8dVjqi87KLRLYtXruqvXzkQp7Qoid88R6rcl+WGlW0/Sa22mfhCZOq2x082ix6\njkm822pO8VrPdr4dNObVeDo8XW3uzMbzK+mvxT7szE27cvnu9j7PcNjSaXx8mOIzZevbrEeic5tN\n+SZnpt8J4fHD9HXHO3PPW0x/DeBtJxx29vaAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAKNRim9Z5e89Nl4DzXtVh5babURHrSf7f3ec1+qnDorWrvvt5Pccb0n0zhmWk\nRvevv1+cPE2rGTFNZU26PFfxwa5dVkjelI2772nZnX6bbrEUq3o0d678u8wmuDL2ittvVjXdneeK\ncGv4jpJ6U56+kS7+j118+GLXpakzHaWlp9NNY3tv+bbiYiNoQy1y30uyZJlrWmZnuym6q1iIJnop\nyW2Te8bdWnnypQqzZOadokiIpSZntWN5lrxki19vNRxrUeBwnNNd+fJEY6/OejXLn3Xe/wDp9wyn\nE8uo4lqqxblv7lJ26T6vpD5X7G8QycKzeBMbzMRM1/FH/wA/h9QwZ6ajDXLitvWzRgsAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeL45w+dDrZvWv1OWd4+E+j2jX\n12jx67TWw5Y6T2nzifU+rZ1y9eHwzDYxxEy18+DJodXfT5o96vafWPVbjyxDn1OOzHudbM0rt2UW\niI69mVtRXZq5tREb9VUoy2iIlRbJ0UX1VZ6btTLrI7V6yk62M2oisT1c7JmtkttVMUyZp6x0beDS\nRWOvdKijDimvWd3G9pNRMfRcNfvZOb9Hpb0itJeP47k/3hgjaZnbaP1XxWW3T0movbNS0W645nbf\n0nrMPpXs3xamoxdJiLbe/X1n8Uf3fKsOTw4jbaXo+EarJhtGTHMxeJ6xH7Sti9Zaj6x3HM4NxXFx\nDS1mtoi8dJrv2l011QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAGjxLhODieOIye7kr9m8d4eM4to9RwjPXFa0ZIvG9bR0fQXmPbDFvTTZPOJmEWS/V8bs9R43NxLL\nG8eFbePg1bajU5/s0l1ceKLx1hbjwRE9mOpx0y2uRTSZsm3PMw2aaKtIjo6kYo9EXpET0hVLXxYK\nxC6MZvyx1lFs0RHfaPiCnU12pLyHGNDbUajBekWma2npWN3p8+opa20e9LSyZLxExTlpM+vdOdcZ\na9tPS8MyUvFrzWlI6727u1pYxYrbVmb7x+TQx6au3Nqcl7/0rcmW9axGnwZJj1novmxnZXV0fFp4\nZxLBPgTGK8xzXr5fOH0bFlpmxVyY7Rato3iYfNuG2x56Wrqa8s2jz+7Lu8O12bS6jkwzN6THNNI6\ntvrN68Y4rxlx1vHa0bskAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAA4XtTTm0OKfTJ/aXdcL2pyRGjwU362yb7fkJz9eTxxyZJjyltRXzUZK7TFtl9Lbwy06YzrHwa+\nfJFd/wCVt8m0bQ0eS2qzcm+1K/an+zNZFL5M1pjFXeI72ky48eGnPkvNp27+TPU6nHpMfLXaIjpE\nerk5dRMxOfN1mPeisfshW1ne1a1577Y6x5R3U0zze31FOWI6ze0byU098kRlzbxM9qrMlPDpyRMR\nMd5Vt/Ihp5898mWZm1pjftE91uCt7fCI7dWeHDEW3t723l6rslqxWZnasR+SYhFbzhnfxJ2jyeq9\nlcGXWZcmW0zWKxHLaI7794eJx5fpfEKabT8t8l5isddo3l9S4VjrwrRUwzSJt3tav3pdOL6Y6dXD\nj8HFWm+/KsU4NRXPvtWazHquWVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAa+fXYNP9u8b+kdZBsDkZOO135cWOZn4y5Wu4xqctbe9y19Kp4njt6vi+PDm8DFMWybbzPlV\n5PiGtz67UxbNbeKTtWIjaIXYpnwuaftT5tXJT3vmi1pMsrU5qIrG1V1a+5DCa7b9GFbRr5J6Wnbt\nCu+Wmk0m8956z8ZWZNorbfzcbX5rZslazPux3hUt41NTntktObJ13+zX1bek01r4/HzVm0bxPXy/\n+bNfDgjVa2uOY92kdfg6ufJOKvLXtttVVSqbcta2vM7zXtHpLQy5ZtMd+vWd+7Zy3mdJHXra3f0c\nvUarw7zFY5rT2hH1Lavnrgx81p3U49Pk4nE5L35MO/StfNRXR5tXnrS8W67WvfyiPSPi7uLHFK1p\njrtSsbR5Lc4RzsXBaYreP4l45esRD2HD9fnw6evvWvO3Tfr0aGk0U55ra0TFInv6uzgrXFXlx0i0\n77RPlC83Yj+JW7oddqr6vHzTTw9/f6dod+L1t9m0T8pcbFSmPHER3892W0zPuz+jSbVvidkcqmfP\nSel7bekrI4n4dZnPWIrHeYnZee2Wpy8dEaml4npNZblw5qzb8M9JbYgAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAABEzFYmZnaI7yCXL1XGa0jJXT0571nbee27DiXEprp8nhbxG20W8\n5cbD0ikfnKO+urTPvjoZdXqctdsmTaPSvRpWmsdZ6yztfaGplvv3lWW1tyRlz1x0vkn7Vo5atTNe\nY0+1o79V2KsZsvX7Ne5mwxnyTNvsx2iGneM/rCdRSuOsTasTt5kRFtpjqmOH4t4nk7estiMNa97R\nHwhna0iuKTEdmGWa4672nZtRele1N59Zlq6vLOSsYorEc07qcW65euzRvtXvPZy52naZ7ujr6fXV\nrWdukREK8+njHgmZmPc67bq6ivVWhxxgxZLztNrT1mZ/SP4VZs0zaOvfp84WUtNsXLvtv3699+rU\nz7+Jtt5qURqMnPpctaR1rMSw4ZoK57eNk6xHaJRh97Ltt7lo5Z+L1HAPZvVauZ2nFTSzMTzeJEz8\nto6xPfvsZntPZ9rXxabmxzefdrv0j1dXh/BcmstW1qxTHHasR3+b0GPhGl+kWmd64dNEVjf73T7X\ny8vy+Ddx6O3iRakxTH5RXrMw1/lX+3Itw2MFIraN48qRHdZi0cUjmmPen9noox1iO0fNzdXEYrTt\nstcmd9aX0bJ+HePmiKTitO8TMLZ1cVjrMfqpz6ys4pjfrPRWZ9rXXptUit6zO+23VyaRHEc05L1/\nw9J9ys/en1ljqdVbwYw452tlnl3jyjzbmmiMeKtYjpEbLeTXPUU8ee/+qjJpsV5rbkrFqzE1tEbT\nDpYNbW21Mnu29fKWna0KbqTdjXXjld0cvQ63ltGHNPSfs2n+HUbS9c2s2UASqAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAOVxPWe99HpP8ArmP4b+r1EabT3yT3iOkesvMVtN7za07zad5l\nXV5GmM9vVfEstvDx0jtaVVMlq+UJ18b5cMRvPeSuK87bUt+i2Z3PtG7zXpjkzXt6R+TXyTMzvM7t\nydHqZ+zhv1+Cv/ZuqvPTHMfOYaTMil1a1K2vHSLTELq2v+KWzThGo84rH5rq8JzedqR+ZeI7WnOS\n34pYTafWXR/2Pln/AMyrKOCWnvmiPyR6O1y9585lhWJvl557Q6eo4T4dYiMvW3b3UanhldHpJtGX\ne09unmjsT7eb1l4trI2t0hsZfrdNO0bzy+nzU20/+NmkzO9esz+TZxWis9dttvPv+Tn21jjaW8zn\n26bTG3mp1M/Wzv3t0jyWXiKZJmsTERaZhXXDbNl8WaztWenxZLstPp5pau8frDtVrNMM5cfTfpMf\n3aunxxbes9d/R09Dp8ebJi09ptFr3jtt2WyrW9wy1Jx132mK+Xq9PotT0iIU19ntLtExa3T47T+q\n6nBaYvsZstZ+cT/LeMnUi0TXffo1s2m8Ws2/OIMWk5Jib5L328rS2t94Sh5TV4ppklpW6PT6rh+P\nNbebTHyas8E081mZy5P2W6OFhjxNTE/hr/LoRO0Kvo9dPqctKzMxEx1la5t3tdnjnMs4noievcrO\nyZjeFF1OSnNV0OG62cn1GWffj7Mz5w05joovzY7xes7TE7w0xrjPeex6Ua+j1UarBFu1o6Wj0lsN\n3JfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrU5o0+nvlt92P3BxuM6nxNRGCs+7Tv8\n2hToxm1r3m9utrTvMsonqyt7XTmcja0u3O6FMfi5t/u0/lzdJM81p9O3zdvHTwsUR5+bfPqOfX1h\ndqV+3O7bs1+T31oqmI3TEM4rvCdkDGIIhlFd2daboS0NXG2bD6bufxXU1vlmu/u4us/N0+L1tTSx\nkr9qk7w89j1FNZMV3jxLzvaJ8mer+LSOZqK2xZotbvljfr/89U453rXt9lse081xZtNjx7TGKu0t\nDHlrevSevaN5Y6+tJ8c7VRNMt63n3ub+6/R54rERMztDYy4a5omclYmfxKcenrjtHLvtPrCnVmdb\neFe3JXmjy6eS/DrMuLVYsta9Mdt++6qLxO+0dEc8UmInr18iUfReHcXrqccb9Z27Q61Lb13eJ9nc\n1Z35rTvE9avY4bTkpG8xEfB05vYxqybc07R281naGMREdoT5JQqy9mply7Q3bV3iXG1eXw7TWSka\nc258t7+tpT5/BjT7MfHqndz12Z+M4lMMKyziUJJiN1WSu9fku23RaOgKNJqbaTU1t9yelo+D0cTE\nxEx1iXmM1Nt3W4PqvFweDaffx9vjDbGvxz+TP66QDRiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAOJxzU73rp6z296zsZMkYsdr2naKxvLyObNOfNfJbvad1dXkaeOdpvsc2yuZVzfbfqybutwu\ns5s8R92J3dvJb3tnO4HSMegtmt3nfZvYp8SZl0z45NfSK7onH1bNcfRFqnUKJr0Y7dVtq7prjEsK\n0XVpEM6028mW20IHK41aPo3J6zs4ODhdcvPnvExFevNXpMOrxi/PlrTee7PLX6Pwa09uaNlKtHg9\ndM3z5d7ReOu02nu0JzZMfblrv5R5uvrcdImZ26T1mYhxs1Os7RH93PZ7axuafNfLitvbaYU3yZYt\nPXs9NwHhui1HBa5LVicsb81onrEuVqNNSuS8Y67dZ6xPZa59Il9uX41vEitImZme3q2Kxbxora0T\nMd/ROSa4Ztkj7c9OafL5LuGYubmyX3iu/TfbdSfVnpvZLT/XZK233+Mbbva1xRXyiPk8pwbH4N6T\nadq5a71n0tD1WDL4tPe6Xr0tDpz8YVnJHWEXYxbqlBedoef4tW0XraO09HdyztSZcbUz43C+ee9b\nSVMaeOfqq7+jGckQ1Yz7+7v2RN/WXPXZPjci2+2yyJaVMuy+uSJlA2d+pNoVRbeDcSxyTE+TDDlt\npdRXLTynrHrDOyiyZeVFnY9TjvXJjres71tG8MnJ4Nqt4tp7T1jrV1nRL1x2cvABKAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAHJ49qfD09cNZ97JPX5PPw2uI6j6Vrsl/ux7tfk1mWr7dOM8iLdm\nvfebREefRsWldw7SxqNbWbR7lPesrn3Vteo7dYjDpMGCvfbeXQ0uLlxRLRxROfUc34p6fCHYrXlr\nEejqrjY8uzCYW7MZjdVKqK9VlaxCYrsnYExBMRMJRPZA8/xPHtmpP9W2xx76vhWOInvt/C7ike7N\nvwzE9kcapGfhlevTaFbFo8RqJ5vy8/RoW09ek0msxHfp3dzNoLzp4zUmZpMbT8HJyYJi20X2n0lh\nZY1li/RaidBF4w2mK3jrHaFGp1lN+tptPp5IjBkid5mIp16TKu0abBPv33vPlM7z+iPdFNcWXU5I\ntkrNce/b1W5db1nTaf3ax9q0fxDW1ebNk2phty1mOu09VOm8W19orEz23j1TwfSeERFuEYMddptW\nd43dvBn21eKJ75KbW+cf/JcTgMxXTb3nbljz+TpcPmc2uyZO1KRtVtGVdi0bx07qJnllsRO6rNTe\nN4XVamsy8mnvPwc3R2jPwe8TPbdlxXNOPSZfhWWpwO85OFzv57qrODkzeHntSe8Sn6Rv0a3EZ218\n8nXekfr1a0ZLVnqx19dWb6demXybOO7lYMvNMdW9S/VVLo0us7tPHdtUtEwJiZU3jq2Jhham8CVG\nPNODNTJXvWd3qcWSubFXJWd4tG8PK3pPd1OB6veLaa89Y61/u2xfxh5c/rsgNHOAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAANLimq+i6O0xPv392rdeZ4rq/pOqnlnelOkIt5F8Z7Wj27I2I6sb25YY\nV1ImY3dbQ08LRc23vZp2j5OJG+XJWle9p2h6HHtbJXFT7OOIpX+7TxT31j5rycdTh+Dpz+XaG/sw\nw18PHWseULN2trBE9UcrJKBhFU7JAQi0dEomegNDUYovM7x3jb5tO1ZvpbaTLtzRExWfWPJ08kbT\nEx5NXWYYyV5omYtHWJieyeDzuizfRs19Jn6TM7Ru1uMcJxZqTkw+5f4ebqa7SV1MR4tdrx2vEfy1\naxqsNOTLjnLXytVXi3Xj8+nmsxTLM16d5npPyUzpekTtSK+U7vS6vQ/SYmK1vWPS1HOn2dvvvvE/\ntDO5XlcO+LbfHSd/W3o6/BdDOXPTnj3Kz38rS6Wm4FNrRyRzTH3p6RH/AKvR8L4dXSzE3jmtHn5I\nmbfqLV+m4dbLSsZInHjr3iI6zLpYaxS01rHuxHRHiT9mv6s67Vj1aqL6326MrWiYa+/Q54BxPaGe\nXRZpj8MquB4+Xg8zPnB7SX30to379GxpK1xcHiKz5IS8xr8PLPixH2bftLTy05o6dHYyVjLhy0t1\nizjZa3pMVv3iO/qz1G2L+NbSajbNyW7xLsY8kTDz+fJXFqKZN4iZnafi6WHL0iYlStI7OO+7axW2\ncrFl7dW9jvE9ULN+J3ZbdFGOy+AYWpEqN7afNXLj+1Wd23KrJVMvCzseh0+auow1yU7WhY4fCdV4\nOadPefcvPuz6S7jol649Tl4AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV581NPhtkvO0R+4NPi2\nr8DB4dJ9+/7Q83Po2NTqLanNbLfvPaPSFDHV66sZ5ET0hRknyW2lTtMyouz0c8usx2n7s7vScKwx\nzc1vu/y85p+maJh6Th+SOWeveXR4/wDLm8v+nX5mUWa9bbrInolmu5jdTNkxYFk2Isr3TuCzeGMz\n+THdEyDDJO9Ja823rt2XWnya946pGvktDXta0ztWu/ybvLE9dkcoOf4GbJPWK1j49VmLh9JtE33v\nMevb9G7WsW8l1ccREISophiJ2jpDYpijbaOjOuOJ8ujOdqxsgVcsUjaETYvbaFFrgu5lVsm0yUtu\nryg43H5m+GIj1XcJzePoL4pnrWGtxmfchr8JvfHS1622if3QljzTTLes+qrNjrkiYtCzPMxnm095\nYZJ6boS5teB49Tqscza97VtvWvlv8V/FOF34RrIxTM2xXjelp/eHoeA6XnzReY3ivX/0dfivDcfE\n9HbDbaLx1pb0lOs+jO7K8Lis3cN+0NKcd9PmthzV5clJ2mF9J9GHHVL108dm1SznYr/Ft0tuhLb8\nmNohFbMhLWy0mJ3rPXvDvcO1karBG8/WV6Wj+7kWrvDDBlvpdRGSnbzj1hpjX4z8mOx6UYYstc2O\nuSk71tG7Ns5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeXneJ62dVl5KT9VTt8Z9W9xbWclPo+O\nfft9qfSHEU1pv48ftYST23ZTDC/p0YtlVuvVjMbM5+LCZjYGWGdrTPxiHY4ffaf3cjTxz1v6xMS6\nOlty2iXVj/Dk8n+ndrkhnGRo1v8AFdW3RCrZ5uiYsqrboncSu508yjmZRYQt50TfowYTbYGVrKrT\nuTZjvukQnYhMIGVY2ZxPVWyrHVCWzXpVXkt3TE7Va+W4K7X3jv1auTNy3jdba0RZpamfroQN7Hk3\n6wr1GTaN2OOJiu6Mu98NvgDi8Wy74d/yZ8PiPAiO2zU4nb6qIn1bugjfFE/ASp1ke9u15mbbRDZ1\nMb823kx0Ontn1OOkedoJCvT8I03gaKsz9q/WW+isRWsVjtHRKyrhe0XCfpWL6Vgr9fjjrEfeh5fF\nfeH0V5Dj3DPoOo+k4a/U5J6xH3ZZ7z3228evytOk7NvFbo0cdols47bSybt7HbddHVqUs2aW3Qnq\nxVeu8LILR3SlZw3V/R8nhXn6u0/pLuPMXjeHT4Zruf6jLPvR9mZ8/g1xrvpz+TH7HUAaMAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAABRq9VXSYJyW79qx6yvmdo3l5viGs+maqYrO+OnSvx+KLeLZz2te1rZL2v\ned7WneZYWnZl5K72YV1xEyxmeqJljzIEWlVkszvbZp5soN3h2SJz3pP3odCnuWmPRxuERfJrZmtZ\nmtY96fR28kbX3dXj/wAuTyf6bmK+9YX1s0cNtm3Sd4LFY2K23W1s16StiUJW7bp22RW3RluBuruz\nmWEgrmCGWyNkoExKE1QlPmsqRDKeyBjaejWy2W3ttDUyz1QKslvehVqKTNosyyTvELabXptIJpaP\nB39Ia2mz+JGpr51jdZefDx2hzuHZObNq58poJaGtjxJ2+LoaKP8ADRPo5+T3skx5OhpOmC0fBNQ0\n5yTbn+bt8A0u9raiY6RHLVwY62mI6zMvaaHBGn0mPHt1iN5+aYVsACBXqMFNTgviyxvW0bSsAeE1\nmkvw7V2w5Ote9besJx2er4rw2nEdNNekZa9aW9JeQjnxZLYskTW9Z2mJY7zz26fHrrdpbZsY7NGt\nmxjvso1b9NmUwpx33XRO4K7VUTE1nmrvEx1bVo2VWiJE/XY4frY1WPlt0y17x6/FuPM0m+HJGTHO\n1qu9pNVXVYt46Xj7VfRtnXXL5MfzexsALsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHM4jxOMFJphmJv529Dq\nZLfjDjPEIx450+K3v2+1MeUOHSOWFc3nJkmZnf4yujpVlqunOeFpV2nctLCZUXRM7MJtsWlRkv3Q\nky5NmpWt9RnrixVm17TtEQnJabXisRMzPSIew9n+CRoccajURvqLx5/chfOest642OGcIpoOG2w7\nROW9d72+LQvXevyejcPUU5M+SvpLeOataraw2a0dLbLqTtK1G3Es4lVWWUSoldFtmcXUbpidgXzK\nGEW3TuCUSncnsDFMMLSms9EC6J6FpVzbZE5ALy0809ZbFr9GtfrEoFMzuuwz0Ueey3HbaBLDXe7i\ntMOfwWnP9I+NZbuttvhs1uBRtXPb4SDm3iIvf57N7Dbl0VrS5+XrltEd+Z1Jx7cNms9N4TURRw3T\n+PrcO3WszEvZOD7P6aYiMlvu16S7y1QAIAABxOPcLnUY/pWCv1tI96I+9DtgmXl68Biy7/NtUu3+\nO8HnFa2s0tfd75KR5fFyMWTdhrPHVnX9R0cd21S3Rzsdm1iuqs256wrmGcT0RYSx5d047X02SMmO\nesd49YRE9WcdSXhZ2O1p89NRji9J+cei1xMc3wXi+KZj1j1dTTaqmor06WjvWW+ddcu8XK8BZmAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAMMmWmKu952UZ9XFZmuP3revlDTtzWnmvO8q3XGmfHb9ZanV3yxtWeWn7y4es\nvPNtDqZJ6Ts5mppvdl/XXRMyfGvSNlu/RVvtOzLfoipLT1VTKbSpvfogRkvtDVyZOhkyvQcA4Dzz\nXV6yvTvTHMfvK+c9U3rkW+zvA/D21urr789cdZ8vi9KDb45rejl8Rry6iJ/FV1HP4vXbBTJEfYt1\n+UpiHM295bXsqrO9l8QkZ0lZEqqLeyBZHZLGvZkhIndADKJ3TMoqWQMZ6pjsxll2jsCLSrmU2lFY\n36gieyu0LJk3jbsga0wdqzK20QpyztQGprL/AFMrOE05NLkt6qdVWZxNrSe5o9vWBLiUjnzXn0vL\nq555dHt8HOwV928/1z/LpzXxbYccRvzTB+jucOwxh0dI22mY3ltIrHLWIjyjZKyoAAAAACJiJjaY\n3iXleM8InR5J1GniZw2n3oj7s/8Ao9Wi9a3rNbRE1mNpifNFnVs65XhcWTdt47bnFuF24dm8TFEz\np7T0/pn0a+HJux1OOrOux08d1ndqY7tillVkzExLOk7yd4YxGwluViJhE45raL0na0dtlWO0+bZr\n1TKi+2zptZGTamT3b/tLacvJjiY3XaTWdYxZZ6/dtPm1zrv1z78fPcbwC7EAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhkyV\nxUm152iAZWtFazNp2iGhm1Vss8uP3aevnKrNntqLdelI7VRHRnrX/HRjx/tZREVjZXeybW6KbWZt\npCZ6S08tN7Nmbb7zCrJtyoS5145bSx5mWafelr3tsKmS/o08uXyhlly7RPV2+AcBnPNdZrK+53pS\nfP4ytnPVda4y4BwHxOXV6uvu96Unz+MvVxG0bQRG0bR2G0nHLb2gCUDX12LxtFmpHeazt82wT1gH\nmMN4tWs+rcr2aEV8DU5sM/cvO3yb+O0csLUTSdrLphRE8tlkZI7Atr2ZMazDJVKTYSCawi7Ksq7z\n1QERvLK3ZGPrKbyCrbdnMcsbeaa18/RhvvM7oGEwTG0JmYYTIML22a2e28xELM19oURPNO4lOem+\nn3ZY5+prVnMc2GYU4/L4A0a15cNf6rz/AC6fC6+NxCPOuOu/5tHJTbHj+F5/l1+BYumXJMd9o3/d\nMRXYASgAAAAAAABhlxUz4rY8lYtS0bTEvH8R4ffhmo6bzhtPu29Pg9mq1Gnx6rDbFmrzVsizq2df\nzXkMWTeIbNL7tbXaHLwzUctvexWn3bmPL8WFnHVL326VZ91MfFVjvvVlz79kLrcf2m7j7bNHH3bl\nJ2SirLQoy4t1++7G0dBC/RanxI8PJPv18/WG241+alovSdrV6w6mDNGfFF4/OPSW2b1zeTPL1aAs\nzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAVZ9RXBTe3WZ7R6iZOpzZq4ac1p+UermZMl89+a/byj0Ra9815ted59PQ32hlrXXRjH\nDpCLX6ML5NlNsm/ZRqstfdXzbsZt06sLZNvNB1Za8RDWyZdo7q8udq5Mu/mIMt4md2lmy7JzZuWJ\ndHgfBL8RvGo1MTXTxPSPx/8AstJ1XWpIs4BwSdbeNVqq/URPu0n73/s9hEREbRG0QUpWlYrWIisR\ntER5JbSccur2gCUAAAAPM8Sry8Uyz67fwuxbzVPGsE49XGbvF42V4M0TEL33ERnktsxpk3sumK2j\nadmFdPFZ33VS2Mdui2J3UU6LYlFSsN2O5NkCyJ6K7T1TEsbAsxdpReerKkTFGMxvYEz0rsqtbbpC\nb2VT1QEzuwtbaGUxspuJU3neWdKoiu8rq12gCI92YatLcublnzbEz1aOptyZqTuDHLfxN6R0+t5X\nqdJhjBp6UiPLeXl9NSMnEKxHa1+bb8nrlvxUAAAAAAAAAAABTqtNj1eC2LLXeto/R43VabJw/VTh\nydY+7b1h7ho8V4dXiGlmvbJXrS3xRZ1fGv5rzeHN02bEW3cys3xZJx5ImtqztMS3MeTeGFjqlb2O\n8btql3NpbZtYsnSBLeiWfdTjtutid+ghherHS5p0+f3vsX6T8Fkw181d4lMvEWdnHaGnw/UeNh5L\nT7+PpPxbjdyWcvAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAo1Oprgr63ntAmTqdRqK4K9etp7Q5d7Wy2m953lNrWyWm953mVd77R0\nZa1104xxlN9lV8qnJl2a9s3xUXX2ybsJyRDWtl3YWydEC+2VRkzeW6q+T4tbJm+KRdfK1cmWZnlr\nvNp7RC/R6HU8SycmCk7ed57Q9ZwvgOn4fEXtHi5/O9o7fJaZ6z1uRyOEezVstq6jiEbV71xevzer\nrWtKxWsRFY6REeSRrJxz22gCUAAAAAANbX6aNVpL0npMRvWfSXlKamsRMVvXm+EvZXjmpaPWHzfL\noNRjzXicfWJ8phfPxFejx72x7xMzK+sXiNoiXlq+Pi6fWV/VfTNqfLJl/WTg9Pji8R70LqvMV1Gq\nj/zcv6yz+lanzzZP1lWpelTET6S81Gp1P/Gyf90s412rjtnyfqql6asREdWM9+jz9eJ6yP8Az7uh\nodZqMt458tpB1JvEViI3/RhzRt13/R1MNaziiZiJn5K9ZNceKZiIiQcu/WekT+iYrWI3lzdTrs+8\n8uW0fJzcur1Np/zsn6g79phVaIeetqNR/wAXJ/3SwnUaj/i5P+6UD0ldonum161h5mNRqP8Ai5P1\nlNtRqJjacuT9Qd22WN5aGeZyZd/KHJy59RHbLf8AVq31Gp/4uT9ZEvS8Lr/vSs2npzRtL1z53wK+\noza/HW2XJNd99pmX0Rb8VAAAAAAAAAAAAAAcHj/C5yV+l4I9+v24jzj1cLFk8nu5jeNpeW41wmdL\nknU6ev1Vp96sfdn/ANFdTrXG+eq1q5F2LLtbZoY8m8d11bbSydErsYsm+zZrO/zcnBm226uhiyRK\nEtrvCrJDOJTeu8A1MWX6Lqq5N/dnpb5O5ExMbx2cPNTeJb/DM/iYPDtPvY+nzhri/jDy5/W6AuwA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAa2p1UYo5adbz+xbxMlvqJ1OqjDHLXree0ejmzNrWm953tPmTPWbWneZ7yoy5YhjrXXTjH8s75N\nmtkyxt0VZM2/m175N1V03yTKubMLXVXybeYLLX2VXy7eam+b0bOg4VquJW+rry4/O9uyZOq3UjVm\n9r25axMzPaIdvhns1kzbZddM0p5Y47z8/R2+HcF03Doi1a8+Xzvbv+TotJnjDXkt+K8ODHp8cY8N\nIpSO0RCwF2YAAAAAAAAACvUZYw6fJkntWN3k8dfHz2vLucdz8mkjFE9bz1+UOZosX1UzPm0nqI/W\nMYo9FlcPNklfFGeH/NshLGun+Cz6PtHZtVZWlRLS+jxPkRpIn7rdoupHTdA5s6SI+7H6Mfo+32Y2\n+To3neSIiZ7A0IjPXpXLePlMotGW3272t85datKzHZjbTVnsDj+FG/2Y/RlGP4R+jo20u7H6N1Ql\no+H8I/REY957R+jpfReiK6eOYHLtj2tttH6KrY/6Y/R2c+kjeJiFVtLG24hxpw7/AHY/RRkw9O37\nO99Hrt1YX0tfOBLjcGp4XF8c+u8fs9c4dcVcGemSI61nd3IneN1orQAAAAAAAAAAAAABFqxes1tE\nTE9JiUgPKcX4RbRXnNgiZwWnrH4XPi28PdXpW9JraImsxtMS8pxXhF9DecuGJtgmf+1TWW2N/la1\nL7N7T5e3Vy6W3hsYcvLbqzbO9jvvCzvDR0+XeO7crO6FmGSvRThy/RtVXJ92elvk2rRvDUzU7pl4\nizsd2J3jeBpcNz+Lg5LT7+Pp+Xk3W7js5eAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs0NTrN96Yp6edkW8Wzm6+LNTq4pvTHO9vOfRoWtt\n1mes95YWvs1s2fZldddOczLPLn2ju0MmebT3YZc2/mpm3qqllN1drsbZIhr3yzvtHf4AsvlYYseb\nV5Yx4KTe0+UQ6nDvZ3UazbJqd8OKeu33peq0eh0+hxcmnxxWPOfOfm0mP+steT/ji8N9mKY9suum\nL37+HHaPm9DSlaVitKxWsdohI0Y22gAgAAAAAAAAAABXnyRhw3yT92Nwef4xm8bVzET0rPJH5d12\nCvLhho3rN9RWs9Z23n5y6O21YhrVYbdGOCfrrLPJRpv863zVS6FS09SvZj3lVZZRdPSqmnSWdrIE\nebOkK4ldTsgW1WKqd1oMZhEVZyRAImOjGI6rJ7IiATNd46qL02bHkiaxaoNGY2n4ImPgtyV2n0Vo\nGvlx7x2beiyTk08RPevSVUxux00+Fn2n7N+n5rRFb4AAAAAAAAAAAAAAACLVres1tETWekxKQHlu\nL8InR2nPp43wz3j8P/s5dLveWrFqzW0bxPeJeV4xwmdFec+CJnDM9Y/CrY1xv8qvTZ+WYdbDk5oh\n5zHk283U0eo3jaZZ2N5XYjrCnLSJhOK+8d1kxvCqzSwZvousrb7k9LfJ3nB1OLeJdLhufx9LEWn3\n6e7LXN9Ofy5/W4AuxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAETaKxMzO0Qi9646Ta07RDmZ9VbPbaOlI7Qi3i+c3TPUaqcu9adKfy0722ZXvFa9\nXO1OrjrESxt66ZJmcjPUanlidmhkzTZVfLN5VWvsC2b7R3U3yqrZZtO1esz2h2+F+zWTUcuXXTNM\nfeKR3n5+iZLVbqRzNJo9TxHLyaekz62ntD1fDOA6fQbZL7Zc/wCKY6R8odLBgxabFGPDSKUjyiFj\nSZkYa3aALKAAAAAAAAAAAAAADQ4pl2pTFH3p3n5Q33E12Tn1eSfKscsLZ+orS00eJqbW+Lfnu1tF\nXaJnZsz3WpCfsyp00fWSvmPdVYOmSUDd8kR3InoQosy7JmUX7MdwZ17ro7KKT1XRPRAsrO0rYndr\n79V1ZBaQiJ6JgCSIJASwrO07MpV2nqBlrv1a1o2bf2qtfLXaQUTO0sb05o3jv3ZXhjS20xEphW5h\nyeJjjf7UdJWNKLziyRePsz0lux1SgAQAAAAAAAAAAAAAADG9K5KTS8Rato2mJZAPIcU4ZbQZuekT\nOC3afT4NXFkmlntc2GmoxWx5K71tG0vHa/RX0GpmlutJ61t6wrY2xr8dXS5uesN+tt4ef0eaa223\n2dnHk3juyreM81OaFGiy/RtZET9jJ7s/2bdutd2jqKeic3iNTsd8a2h1H0jTVtP2o6W+bZbOO+gA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABje9cdJt\nadohGTLXFTmvO0fy52bJfU23t0pHaqLeL5xdK9Rnvqb+cUjtCi94xxvK3JetKuHrdZvaa1ljb10y\ncnIs1Wt3naJc++TmVWvMz1YWybfMGdsm3eWek0mo4jm8PT0mfW3lDf4V7P5tdMZdRviwfvZ6/TaX\nDpMMYsFIpWPTzXmf+steT8jn8L4Dp+HxF77Zc/4pjpHydYGjC3oAAAAAAAAAAAAAAAAADG9opS1p\n7RG7zszN6WtPe0zLua+3Joss/wBOzhzG2OsL5+IrY09dsSyYRijbHEMvOChb7KjF0yS2LQ169Mso\nS24noyrPVXWejNVKbTuw3T3REdQWU6LYlVvsyiUDPfqupPRr79VuOQX1lZEqoZxIMksd0gT2VT0l\nbPZVbuCaW8i8bwr32WxbcGnkjaZa9p2ndv5qbw5+aNugLItF6TEtvTX5sMb969HMpfazc0d9stqe\nvVZDdAQAAAAAAAAAAAAAAAADV1+iprtPOO/2u9bektoB4TJTJpNRbHkja1Z6uto8viVht+0HDvpG\nH6Tjj6zHHvbecONw7Ltfkmeqmo6Ma69DXbbZTkr1mGWO3RneOaGbZRoM30fVzSelMnT83aef1FZ7\nx3h1tBqfpGnjmn369LNc3sc3kzy9bQCzIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAa+q1dNNXr7157VhGp1Xh70x+9f9ocy283m1p5rz3mVbrjXHjt91lz\n5c9+fJ1nyjyhdM8lZlOOIiqrUXikd+kMreunnI5XEdX4dZiZcG+XmtNl/F83PeeWWHDOGanieSKY\nq+5H2rz2hMzWd1Iqx1yajJXHhrNrW6REeb1nCPZumn2z62Ivl7xTyr/6uhwzhGn4Zj2xxzZJ+1kn\nvLoNJnjHW7TbbsAszAAAAAAAAAAAAAAAAAAAAaPFrbaSK/itEOXt0rDf4xb/ACa/GZacRvaF58Q2\nIjasQnzPIhCU92tMbZGzHmotG10C6nZkwpPRmipIllEbMIZIE7solgmJBnCyk9VMM6z1BtVllEqK\nz0WRILYlluriWcSDJVbusV27gwInaSWM9ECyZ3hqamnSWxFmOSOaqRx725bNnSZNs9J+OynVY+WZ\nYYr7TE+nVaIr0Ais81Yn1hKAAAAAAAAAAAAAAAAAABExvG09peU4nov9n66L0j6q/WPg9Y1OJaON\nZpL0+9HWs/EWzeVz9PbmrEtnyc3h9reHy26TWdnSr2YX6657ijLXpLX0+onSamL/AHJ6W+Tbv2aW\nekTv16JzeI1Ox6KJiYiY7Slz+E6jxdN4dp3vj6fl5Og2clnKACAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeQRMxEbzO0Q08uqtkma4ulfO3r8lefUePMxWf\ncjy9WvlzVxV6T1Z61/x0Y8f7Wc7Ur1lqVy+LqOWJ2hp6rXddon5rOF1tfmz5OkT0qzb8dWbxjp1c\nbiuuilJ5Z6r+IcQrixzEy8zl1E6rNt1tMztFY81sztU1eRucN4ffi2p5esRM72n0h7rS6XFo8FcO\nCkVpX082nwXh3+z9FWLxHi36328vg6TZyW9ABAAAAAAAAAAAAAAAAAAAAAADj8Unm1tK/hqppHvw\ny1k8/EMk+m0GOPeafiFpCZYwolnXspvHvLa9mF46gmnZmwozRUiUCBKYYsoBLOFbKAX0llEqqyzi\nQXRLOJVRLOOwLIljZMEgrlhKyYYTAK5nZPN0RZjugUanHzVlz6xtLq361c+9eXItPpXX0dubTU+E\nbL2lw2++O1fSW6m/VYAISAAAAAAAAAAAAAAAAAp1GbwcfTreelYEydcuMcRrM/L9nnlsV6wqpi2r\ntv133mfWVkRyRtEdGFva7MzkYZNoamWN4bV4mYa9qztKIujhVppxGI8r1mJegeZpknBqKZY+7L0t\nLRekWrO8TG8Ns/HJ5ZypAWZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAADS12fp4VJ6z9qVuq1HgUiI+3bpDl589cOKZmevqprXPTbx477rDJlrhr1nq4+s182tMRP\nRqaziXiZJrWekNG17ZbxWJ336M5LXRbI3dLTJrs07RMY6fan1dHLrowY+X7MVjt6N3R6Kul0EbWm\ns7bz8Z+LnabQX43r7Y53php/mXj+Dnv0f1JO1x/8ZxbUzj02O15mfLtD13AvZqnDds+pmMmo26el\nXX0Wh0/D8EYtNjilY7+s/NstpOOTW7QBKgAAAAAAAAAAAAAAAAAAAAAADG88tLW9I3BwJtz6nNf1\nvK/DHVqYJ3pzT5y3MPZeojOWMQylEKpTVjZnDCwkqzYQyRRICATCITAJZQxhMAshnEq4ZQC2srKq\nqrIBZCWNZZgwswmFloVyCu0dFcx1WyrtCBhv5NTPHXds2U5o3hIz4ffbPt+KHUcTSW5c9Jme0u2v\nVYAKpAAAAAAAAAAAAAAAAYZctcVOa35R6tLrltN795/YvknNqrfhpPLH92V5isd9mWq6fHjk6rn0\nZxG8KK5Jm/wbVZiYZtqrmkqL023bkxvCiY3lJHNyRG81mHS4Rn5sNsNp64+3yaWaNrzOzHBl+i6q\nmT7s9J+S+ay8mex6EIneN47SNXKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAImYiJme0JafEs3h6fkidrZOn5eaLeJk7eOdm1Hi2vmtPTry/CHmOJcUvmvOPF1n09Pm\n6HF9ZGm01qxO3R5vSY7XwzmzTy47zzTEd7en5Mfvt2/PURWdo3tvPrPlKymbktFqTtMTvHzbOLDG\nf63JXbFX7FdnoODcDprZpq9TjiMMTvSn4vj8l5fxnrk91saPSa7i2hpOfbTVt5x1m0fLydzR6PDo\ndPGHBXasd585n1lsRERG0dIF5OOe6tAEqgAAAAAAAAAAAAAAAAAAAAAAADX11+TRZrf0y2Gjxe22\ngtH4piP3TPpXKwxtjhuYo9xq442iIblI2pC1RET2ILd9kxCqRjZmwlCSEohIJAQAAJZISDKGUd2M\nMoBnVbVVCyAWVWeSuqyOwIlXZZKue4MJV2WWYT2QKbKL9YlfdRdIo35b7/Hd3KTzUrPrDh27uxpb\nc2mpPwX/ABX9XAKpAAAAAAAAAAAAAACekTIp1eTwtJmv+GkyJn1oafeazbfpMzLR4jq/o8b823zX\n6XNF8ERCvTcNpxLV5LauvPhx9Irv3lhztdtv8TtaWLicXrt03jzjzb2k1nid56ty3s/w+a7Uwzjn\n1raejlarhmbhl/FpbxMO/fzj5p/ixSeXOvTtRfeI280ZI26tfDm3pWe63LaZx7qtGvniJ6tPLvOK\nfOa9WzbJvTbza02jl3n5SSljscK1MajSxWZ96nSW88xw/VfQ9XMT9nfa3yemid43jtLeXsce88qQ\nEqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADia3UTm1l4j7OP3Y/u\n7Vp2rM+kPJW1PhYcmS0+9MzKm/jbwz31weMzbV8UppazPL9q0/BF4rk1GLDSNqxPWPhCnHmnNrtT\nqPKteWPm6U6OdHaZvO+SaRNvhv12Ub/q3FhtrNVj0uKOt56z6R5y9zix1w4qY6RtWsREOJ7L6OKa\nS2rvX6zNM7T6Vh3mmZyOfya7eACzIAAAAAAAAAAAAAAAAAAAAAAAAAAczjVvqMVfW/8AZ03I41bf\nLp6/OVs/UVrY47NyOzUxd4bUJpEbb3Z7IiOrKIVSjZhMLJYyhKIgmGUQSDESIEbJEgQmCITEAmGU\nIiGUAyhZVhDOoM4Wx2VQtqBKuyyWEgqlhKyyuyBVaGtkbNmvk7A15l1eH2300R6TMORPSXT4ZO+O\n8fFefEX63gEAAAAAAAAAAAAAAAq1WPxdLlp+Kkx+y1Fvsz8gjhaDauGK8sx07y3OE3m1tT6RaP4c\nvU6yMNKUx73zT0ilY3l2eF6a+m0kRl/zbzz3+Ez5M8z26fJruW6wzYq5sV8d43raNpZjRzPPaTmx\n5b6bJ9rHO3zb2WJ8GWPEscY9bgzxH2t62n19GWW0eHOzHU5XbjXZ1x8WTnz2iZ7S2M1IjH2+LX0V\nKTqs8zO9ot0j8nUthi1J3UaOFMTfLFo6xMbS9BwHWTqdHOO8+/hnln5eTjYMFo1WTH5VnePzXcIm\n2k4zlpPSmXy/hfF5eMfJns69OA2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAADG/2LfJ874rW845mubliY7bPoto5qzHrDz0+yePNF41OotaJ7RWNtpV1OtfHqZ715fhu\nj8adNpcVfeyzE2/vLuanhOu1nEctIxTTFa/+ZPbZ3eHcF0vDbTfFE2yzG03t32+DokynXl9+leDB\nTTYKYccbUpWIhYCzEAAAAAAAAAAAAAAAAAAAAAAAAAAAAcXjE/4zDH9M/wAu04XF5/3jj/0f3Wz9\nRUYmzDWxS2I7FSyjuzY1ZKpRKEygEwiWUIkGIk2QJNhKQhMIhkCYZQxhlAMoZwwZwgWQshVCyATL\nCWc9ldpBhZXLOVdpQK7NfJPRdaWvknoDVvPvOnwuel4+TlXn3nS4VPvXj4QtEV0wAAAAAAAAAAAA\nAAAAAVV02CmTxK4qRf8AFFeq0AAAanEsfPpZmO9Ji0NDLfkwdOsulrumiyzHlVzJrz4Ovoy26vB8\ncTBa9NffLtMY77Rv8Yegx5ImkKdJoY1HC81Y+3OSbVn0mGGkmbY45u6tnrrTOu2xGO0RxCd+nNVj\nqKxTV1vH2pjaGtnyzXXYdo96ZmGXEMk15b7/AGZiVerWPTYckZcNbx5wzc7hGbnxXxzPWk7x8pdF\n0S9jh1OXgAlUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAcPjEf4/FP9H93ccXjMf4vDP9Mx+62fqKrx+S+GvibEFSsqyYwlVK\nZYsmIMoRKYJQIPIEiQ2ATCUQygCGUIhMAyhnDCGUIFkLIV1ZxIMpVWWSrsCuyqyyyq09ECq8tfJK\n66jJ2Bp5J6upwn7dv9Lk5J951uE/av8AJaIrqAAAAAAAAAAAAAAAAAAAAAAq1Mc2myxPnWf4cmtu\nXT9fR0tffk0WSe28bfq5Wbamm3326MtunwfK6PCv/AxPraZ/dz9PO97/AOqf5dHhdZrw7Dv3mOb9\nXOxRFM+avpe38mvkPHf/AFWlrKba7Tzt99ZxKkfR7euyNXMTrtPHfa0z+zPiM/UR8Zj+Wbdu8HpN\nM2bfzrV13M4dO2pyR61dNvj44/J/oAWZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADj8bj63BPzdhyeNx0wz8ZWz9RWri7Nmv\nVrYu0NmqaRZHZlDGGSiwxZSgCEkCBCQSCQBMJRCYgEsoYx3Z17AlMIhlCBnDOGEM4AlhZZKq4KrK\n7LLKrIFN2vdfZReAaObu6/CO9vk5OePR1uEd7fJeIrqAIAAAAAAAAAAAAAAAAAAAAGtxCk5NFliI\n3mI32+XVyNTyZOHTee946PQKPoeDffw4777eW/yVs60xv+ZxOnr4Okx1t05KRv8Ao41Z5q3yed5m\nXY1szXRZ5jvFJ/hxItP0aOSN9q7yrtr4f2tHFM5+KT16Yq/vK/iGSbXw4vO14UcPx5MGfNbPG18m\n1oj4THRsTw7VanPXVYpi3gzMcnrvCnG11JOupwuN8+a3pEQ6jT4divjxWnJExa09pbjbM5HHu90A\nJUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAHM41H1GOf6nTc/jEf4Ws+lls/UX45uGekNujTwdm5RNIthKIZKLDFlsiQIShIC\nEgCUJ7AmGTGO7IDzZQhMSDJMMYZQgZwzhhDOATuqssmVdgVWVWWyqtCBTeVF19lF+wNLNG7q8I+9\n8nLyupwnt+S8RXUAQAAAAAAAAAAAAAAAAAAAAAAItWL1mto3iY2lyrcLyUxzix2ia2nvPeK+jrCL\nOrTVnxpanhuPPemSs8l6RtE7dJj0ldpNP9GwRSZ3neZmV4cR/Vs4AJQAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHi1d9H\nM+kt5ra+vPoskfDdOfqK4mn7Q3aNHBPZu0W0RdDOGFWcKLCJZeTGQQlCQSgASBsCYZQxhlAJTAmA\nTsmAgGcM4YQyjsgRLC3VnaVcgwsrt3Z2V2QK7tbJ1bN5a9waeWO7p8Knt8nNyebpcK8vkvlFdQBA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK9RXmwZI+ErEWjesx6wQeZwejeo0cccuW8\nelpblJaaRGxVnCuss4ZrMvJEgCAASISCQIBlCYYpieoM0wx8k7gzIRueYM4Z79FcSy3QEsLJmWFp\nBjaVVpZWlXMoGNmvkXXlr3kGtknu6XCf7OXkl1OEdl8orqgIAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAHmskcmtzV/rls0U62OXiWX4zErcc9GmkRfWVkSqqziWayxCPIANwBIhIJSxS\nCRG6dwZwlhEs4BluMdzfqgZxLLdXuy3AmVdpZTKuZBjaVVpWWV2QlhZRdfZRcGpl7urwfrzfJy8r\nrcH61vPyWitdMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHA4nHLxKZ9awnH2ZcY\njbW459aq8fZpfiI2IZwrqzhmsz3Ebm4JN0AMhCQSIASndiAziWUSriWcAyRujc80DM3RCfIETLCW\nUsZEsJYSslXZAwlTddPZTkBp5e7r8Gj6rJPxhx8k9Xa4PG2C8/FaK10QAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAcfjcbZMFvnDWx9m5x2PqcNvS+zSxT7sNPxH62YZQwqzhRZO6UCB\nKUAJTux3SDIRuAncQAmJZRLBMSgZ7iIAZRKd2DICUSlAljLCYWMLIFVukNfI2bNbIDTyT7zu8Ijb\nSz/qcG/2nf4T/wCE/wD2WnxWt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHL9oL\n+Hw2cm28VvEuPptfgyVj6yIn0no7/FtJfW8NzYMe3PaPd39d3iMug1WktNc2C9dvPbeP1aZ9xF+v\nT471tHu2iflK2HkqWmvaZj5Surqc9Ps5bx+alTHqYHm68S1Vf/NmfnC2vGNTXvyT84Ql6A3cSvHM\nsfaxVn5Ssrxyv3sM/lKB1xza8bwT3pePyWV4tpZ+/MfOEjfGrXiGlt2zV/PotrqcN/s5aT/+wLRj\nFontMSlAlKEgndO6IAZQljDIEgeQljLCzOVdkCu/SGrkbF56NPNeKxMzMRHxENe0+89DwuNtHHzl\n5PJr8NcnLW3Pbf7r1nCZm2gpae8zMrz4i/W6AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAETETG0xukB4HVaeMHEtRi26RedvkyjBSfX9W77QYvC4xz7dMlYlrU7M929dWJLFc6aPK0q\n7YLxPS0S22FlP6q38Zac0yR92s/KVc3tHfFf8tpbcsLRvB/dR/8ALLVnU0r9uL1+dZI1mnmdvGpv\n6TOy6ym+Oto2tWJ+cJ/tW+KLK5KW+zes/KU7tG+h01p64qx8Y6NXNo6Y+uPJlp8rLf0rfG7MXtHa\n0x8pZxqs9e2a8f8A7Oj7HaTHn0+f6RWM23LETfr6vRW4PoL99NT8ui7F4+vEdXXtnt+fVbXjGsr/\nAOZE/OsPS29nuH27YrV+VpeV9pdPXhOtw49NG9Mld55+vXcTPd42I47qo7xSfyWV9oM8d8VJ/VxM\nd8l46xWF9cV7en6o/qLfxp2I9ob+eCv/AHMo9op89P8A/wBORGmyT5R+qfo2X8P7n9Q/jTsx7RR5\n6ef+4/8AuHftg/8A6cWcOSO9J/WEbWr3pY7Efzp2Lcfv5YK/9zWy8d1E/ZpSv5Oba1/+Hb9lc+LP\nbFt87I7E/wAabWbiurvEx4nL/pjZzc2bJkn372t85ZXx55/BX85lucC0vPxnTxlnnjm32mOiZqUu\nLJ2p4TwnVavNWaYbRTfre0bQ99pcH0bT0xb78vmtiIiNojaErMwAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAHnfarF7umzRHaZrLjYrdIen9ocPi8JyTt1xzF4eUw23rCm3R4r6bMy\nwt6kdTaWLdjswmNoZontsCm0K5XWjopnuDC0dGpqG5bs08/daKV672MjbSaif6oh6Z5f2LtvptRX\n0tEvUN3Jfo8f7cYve0eX4zV7B5z20xc/C8eSPuZIRficfXlcPaG7ino08HWIbePpLF2NuiyOyrHK\n3fZFSwuovHVfaVF4QK5YWTM9UT0EKry6Ps1Tn4zjn8NZn9nOtLseydObiWW34cf918fWfk+PYANn\nKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq1WKM+ly4p+/WYeBxTNd6zG0xO0\nvobw3FcP0bi2em20Tbmj5Srr418V9sa2Z7qKyzi07MXUylhaU7yjqhLCeiq3ddaFNxFYW7NLNG8t\nzya+WO6Va9J7FW66mvwidnrXiPY3Ny8RyUn71Jj9Ht3RPjk19HK9pMHj8D1ER3rHN+jqqtTjjNps\nuOe16zAifXzfTz7kNyndpYazS9qT0mszDdoxrsi6m8LazMq6zDOsq1ZEyrt1WWlXaUCqyq0rbKbi\nFdp6PReyFd8uqv8ACsfy83aXrPZHHto89/xX2/SP/dpj6y8vx6EBq5gAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAB5n2q03LfDqqx39y39npmlxbS/TOG5se29tuavzgWzeV4mtui2\nO3RRSY2hdVhqO2MvI36iu9lUsrSrvDHn6spnmSiq5jooyV6tq1VV69RC32byTh43h8otMx+r6I+Z\naK/g8TwX7bXh9Mid4iW+fjl8n1ICWb57xLBOm4zqse20Tbmj8+qKdnS9q8PhcTw5tumSm0/OHMxz\n0Za+uzx3sX1t0Zxurr1ZxvspWiZYWZbsbT0QK7KLrZVZJFaqt5vbezNOTg9J/FaZeJns93wCvLwb\nT/GJn92uGHldIBowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuAPA67F9H4l\nqMW20VvO3yRWW97T4fC4rXJHSMtI/WGhVlue3b473K2KzMML4+62tujG9pnozXaOSOVFMnVbmq1t\ntrJRW5E7wwvUxTvCyY6CHOt7moxz6Wh9PxTzYaT61h8x1MbZK/OH0zTf+Fxf6I/htj45vL9WgLMn\nmvbPFvocGWO9L7fq85p5maw9d7VYvE4JkmPu2if3eW0+PasdFNOnxfF1Y2hlykRsmY+LJ0MZjZXa\neq2eyi8oQTO0KLdZWzPRjWu6VaqtHR73g0bcI0sf0Q8Nkq93wqNuFaWP+XDTDDytwBowAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAef9q8HNpcGaI60vtPyl56k9Iew49j8ThGe\nPwxFv0l4zH2U26fDfTYiyJljvsjf4sm6vJ1hrXjq2MkqLdZEVbgbMx0auGdmzNt6iHN1Ub5af6of\nTdPG2nxx6Vj+HzaaTm1+nx/iyVj930ysbViPRrj45vL9SAuyc7j1efguqj+jd4/T33rD3HEcPj8O\n1GP8WOY/Z4TTT7sKadHhbcsZnaCJ3TPZk6VdrKbTutmP0U2nqgrGOsr8deiuI2X09EqKM1dt3uuG\nf/jdN/06/wAPE546S9rwud+Gaaf+XH8NMMPK2wGjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAABrcRp4nDtRWPPHP8PCYusPoWSvNjtX1iYfPuWaXtX8MzCuvjfw32siu8ptXoxi\n0wy5t4YulReqmazu2skbquURWFInddM7VYRGyL291KFnCcfj8e0le/Lbmn8n0N4b2Ur4nHLWmPsY\n5e5a5+OXyXugBZmiY3iY9Xz7NjnTa3Ph/BeYj5PoTxftFg8Hjk2iOmWkW/Psrr418V5WrWd2faFc\nV2jdnEMXWxntupmN7NiYU27iWML6dVMVnddjgVqMsdHr+CW5uE6f4Rt+7yuSsTDv+zWXn0WTHP3L\n/tK+GHl+O0A1c4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8Dn93W56/wDM\nt/L3z59qp24jn+OS38lnpr4r7ZxHQ2TEstt3PXUrt27K57rr1VT0BjKnJPRbMqMs7QlV2fYvHvrd\nVknyrEfu9m8f7FZI8fVU85iJewbT45NfQBKo817W4eulzxHaZrL0rje09ItwqbfhtBVs3leai8RD\nKLw1sduesL606dWFdsZT1jdhNeq6K9DlhCVUU6s4jZnt1YzAhnM71dH2bycmszY/K1d/0c6OzY4R\nfwuK4p8rTstn6z8k7HrwGzkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHz3\nVxvr80/8y38voTwGpj/F5/8AqT/JfjTx/WVeyY6FPspc9dZPVXaOq2WEwIUTVRmjo2rNfLHRI3vZ\nDJycXtX8dZh7t879nsnhcbwz23tt+r6I2nxyb+gCVBzuPY/E4PqI9K7ui19fTxNBnp60n+Aj5/pJ\n3jZu1aOnnltMNussdfXbm+l3ZM9URHREdZVXTuT1Nk7boQiOkJw28PU47/htEp5eivJPLMTCZ9Vv\nx7mJ3iJ9UqNHk8XR4b+tIXuhxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD\nweqjbWZ4/wCZP8vePCaz/wDIaiP+Zb+UX408f0r9lOxWOifJhXWjfyYWllPRXYQxnrCrJHRd3YZI\n6A1NJecHEsN/S0T+76bE7xE+r5dk93LW3pL6ZpMni6PDf8VIn9m2fjm8s9rgFmQxvHNS0esbMiew\nPnHLyai9fS0w2aNfUTtrs3+uf5bGPqy068fF227KtSsdFlKqNGMV6myyY6sbdIQI8tlOWOi6Jhhk\nj3RD0vA8nicMx9etZmHRcT2Zyb6XNT8N9/2dt0T449T2AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAHhdfG3E9TH9cvdPEcXjk4zqI/q3L8aeP6xr2TsxpLOekMK6mFo6qpXSrm\nOqBixvHSVmzC4OfqK7S9/wAByeLwbTW9K7fo8Fqo6Paeyl+fglI/Da0NcMPK7QC7AAB8313TiOf/\nAKk/y2MHWrX4jG3E9R/1Lfyv0/aFNOrHxuU7LI7MMayGTVlHWUXhNe6Z6wIUsb9d1m20q7dkDpez\nN9tRqKT5xEvRvKez9+Xis1/FSYerb5+OTyf6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAB43j9eXjN/jWJ/Z7J5L2mry8Upb8VIF8f6aGOey2eynHvOy7bowrrYSxZSwQJ2YXZ\n92N4BoanrEvVexmTm4blr+HJ/aHltRHSXofYm/1Wrp5RaJaYY+X49WA0c4AD51xONuKan/qW/lbp\n+0MOLRtxbU/9SU4J7KadWPjep2WQrr2WRPRk1TvsndXMpiRCb9FNu0rbTuqvKBscCjfi9PhWZeue\nV9n434rafTHL1TfPxy+T/QAszAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHmv\navHtfTZfnV6VxPajHzcNrf8ABeJFs/XnMcr4no18c+6vr2YadkY2YM57sEDLyY37Mo7MMnYGlqO0\nvQ+xNfqNVb1tEfs87qZ2rL0/sVX/AHdnt65P7Q0wx8vx6UBo5wAHz/jUbcX1PT78qtO2vaCnJxjP\n8Zif2amnnspp04+OjWejKJ6MKdmcMmyJn4m5ZHzEVPMwtJv0VZLbQDqezcb8RzT6Y/7vUPM+ytZt\nn1OTyiIh6Ztn45N/6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABocbxeLw\nnUR5xXm/Rvq8+OMuDJjntaswEeBxT0bNZ6NatZpNqz3rO0rqsdO3PxlaWEMpY+aqWXkryT0ZT2V3\n7A0dVPuy9f7G124NM/iyT/Z4zWT7sw957MYfB4Fp4/FE2/WWmGHldcBowAAeM9qKcvFeb8VIly9P\n0nq7ntbTbVYL+tJj93CwT76unR4/jo0nozhhTsy3Y1sWljM9Ce7HyQIm3RRlttVbaWrnt0Sh6n2U\nx8vD8mSfv3/h3XN4Bi8Lg2nj8Uc36y6TeOPXugCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAPD8RxeBxXUU26Tbmj8+quro+02Lw+I4ssdslNvzhzazvDPbq8d7GW7Dfqz2VzG\n0s2qd+iu/Zn5Ksk9BVztX1mI8930zh2LwOHabH+HHWP2fNYp4+vwYvxXiP3fUqxtWIjyjZtj45/L\nfaQFmQADzftfj3w6fJ6WmHmsP23rvaqnNwqLfhvEvIYZ+sV038bo0noy36MK9oZQxrdMyrlnMbMZ\nQKrS1M07zEestq/RRjr4utwY/wAV4j91p9V18fQdJj8LR4ccfdpEfsuREbREJbuMAAAAAAAAAAAA\nBAJAAAAEAJEAJQAJQAJEAJQAJQAJEACUJAQlAJEAJQAJQJAAAEAJEAJBAAAJAABAJEJAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwvanDzaPFmjvjv8A\ntLztJ3h7HjGHx+FainnFeaPnHV4vFbeIU038VbHeGF+kso7Mb9mTdhKnLK3dRm7SIrHhGPxeP6Sv\n9cT/AHfSnz72Zx+J7Q45/BWZ/Z9BbZ+OXyfQBZQABzeP4/E4NqI9Ii36S8Ng/wAx9C4jTxOH6ivr\njn+Hz3B/mQi/GvjdCnWNlsdI2V07LIlg6USrt2ZzZXMoFV+zPhGLxeOaavpbm/RVltEN72Yx+Jxm\nb7dKUmf7L5+s9/HtRA2cqRACRACRACRACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCQQCRACRACRCQBCQBCQB\nACRACRACRACRACL1i9LVntMbPATTwdRkxT3pea/u+gPE8Xx+DxrPHlaYt+qNfGvjvtXXsi0dOrKk\ndEXjZg6VMtbP2bMtXUdpEV0/Y2nNxbNf8OP+727xvsXH+N1U/wBEfy9k3nxyb+gCVQAGOWvNivX1\nrMPnGGOXNNfOJ2fSZ6w+dZKeHxDPX8N7R+6L8a+L63KdoZ7q6zvEMpnowdKJ6ywmWUyqvIKM0vQ+\nx+D6rU55+9aKx+TzWa36vbezmDwODYenW+95/Nphj5L6dQBo5wAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAEiAAAEoA\nAAAAAAAAAAAAAEAkEAkRuAkQbgkQAkQAkQAkQAl5T2nx8nEMOT8dNv0l6pwfarHvpcGWPu32/WCr\nYvK4mOem6b9mGKd4Z3idmFdka0y1c892zfpMtLPaNpEV6D2Kj/Eauf6YeweQ9ieuTVz8K/3evbT4\n5NfQBKoAA8FxCvJxrUx/XMvevD8Zry8fz/Haf2RfjTx/6RSOnRMyypHu9kXjowrqVSrvPRnZVl6V\nkK0775MsUjvadn0nT4ow6bFijtSsVfPuFYvpPGtNTy54mfy6vorXDm8l9pEC7JIgBIgBIgBIgBIg\nBIgBIhIAgBIhIAgBIgBIIBIAAhIAhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAA\nAAAAAAAAABAJQkAEAAAAAAAAAAjc3BIjdG4Mkbo5kcwMjdhzHMDPc3V8xzAs3N1fMjmBZubq+Y5g\nWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmTzAz3N2HMnmBlu5ftFTx\nOEZJ/DMW/d0t2rxKni8N1FPWkiZ9eS08e7Cy8dGGn6UhZaJljXZGnmc3UT3dPP2cnUT78xCIV6j2\nH/8A9c/6f7vXPI+w8bU1U+vL/d63du5NfUiDcVSIAS8b7RV5eOb/AIqRL2TyXtNX/e2KfXH/AHlF\n+NPH/pr4+2xcxx0hFpY11K7R16KM32ZWz3UaidqSgrc9kcPicWyZJjfw6T+727y3sXh2xarN+K0V\nh6lvPjj3e0ASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAAAkQAkQAkAAAAAAAAAAAAAAA\nEgAAAAAAAAAAAAAAAAAAAAAgAAABKDcAN0bgkY8xzAyRux5kcwM9zdXNkTcFm6OZXzMeYFvMibKu\nZHMC2bo51U2RuC2bom6rc3BZzom6sBZzI52ADPnOdggFnMc6skFnMc6rc3BbznOp3RzAv50c6nml\nHMC/nOf4qOY5wX85zqOc5wbHOc7X5znBsc6edr85zg2ec52vzpi4NjmY5bROG+/bllVzsNTk5dLl\nn0pP8BHmMHWNmzt0aum8obm08vVjfrtnxztR0mXHzTvaZdjVRMTLkZo6yiFen9iZ2pqY/wBP93rN\n3kPY+/LfPX1rE/u9XzN3HfqzdO6vmTuIZ7m7Hc3Bnu8t7TR/vHBP9E/y9Pu837SV31umn+if5Rfi\n/j/01MMb1hjkrtKzBG0bMsmOZY11tOYamr6Und0LUc7XT7u3rJPqL8er9lcPhcFpbzyWm39v7O00\n+FYvA4Zpsc94xxu227jv1IAgAAAAAAAAABKAAAASgASgBIgBIgBIgBIhIAAAAAAAAAAAAAAAAAAC\nUACUJAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAg3AEbomQZbo3YzLGbAz3RNlc3YzcFs2YzdVN2\nM2Bdzom6nmNwW86JurTAMuY3REJ2BB1ZRVMVBhsbSsiqeUFXLucq3lTygp5TlXcpygp5TlXcpygp\n5TlXcqOUFXKjlXcrGYBXysdlswiYBVMdUTCyY6sZBWxlnMMZgGLGZZSwkDdHMiWO4MuY5mEyjcFn\nN1OdVzHMC3nTzqeY5gX85zqOZPMC+Lqdbk20eb/RKOZr8QybaK/XvtH7iZ9aGlp2luzT3fg19NHS\nOjbmPcYX67XH1XSZ9XIzRvMuzrK7zLkZYmYnciunb9lZ5dTk+OP+71cXeP8AZnJ/ip2nf3J/l6iL\n/Fu5L9bMWZczXi6YuIbEWTzKIuyiwLt3nuO25uI4a/hx7/rLuczg8TicvFLbfdpEK6+NPH/phhjo\nstLGkctUWnoxrrU3j1cnWTzZq1jzl1clo5Zcu8c+txR63iP3Tn6pv4+g4o5cVI9IiGe7CJ2iE7t3\nGyN2O6dwSINwSISAlAAlACRAAlAAlACRACRCQAAAAAAAAAASgASISAAAAAAAAAAAAACQAAAAAAAA\nAAAAAASAAAAAAAAAAAAAAAAIAAAQCAJljuljsCJlhMs9mOwMJYys5TkBVsjZdyHICrZPKt5E8oK4\nqmKrOVOwMIqyirPY2Bjyp2ZbAI2NmSARsbMgEbI2ZAMdjZICNkbMkSCNmOzJEgx2YyzljMAwlhKy\nWEwCuWErJhhMArlhLOWEgxljMpljIImWMyTKJA3N0IBO5vux3NwZbnMx3NwZczT4jf3MdPW27a3a\nfJOq1XNP2KdIRfi+J2trSYfcjeF+Wm1OicVeWIiN9kai8xjY12ORqultnI1Ecsujq79XP1FovWYI\nrTgeq+j8QrWZ+3Mx+r2UXeC0WG2Ti2kiN5mL807eUREvbzbaejefHJv62Iv8WUXa0WTFhVtRdlF2\nrz9WUXBtc7jR9dqc2T1ttHyhvZMvJitb0jdq6XHNcNenWVN3028U99WRj6Kb02be3Tq18/SN2Lpc\n3UdN9nOmZrqKX/DaJ/d0svvTLRzV3jomK6+Pd1vvWJj0ZczT0mXxNJht60hfFnQ4qu3N1cWTEgs3\nTur5k7gz3N2O5uDM3Y7m4MtxBuCQASIASIASAAAAAAACRCQAAAAAAAAEoSAAAAAAAAAAAlAAlCQA\nAAAAAAAAAAASAAAAAAAAAAAAIASgAAAEJAQJQCNkbMgGOyOVnsAw5TlZ7GwMOVPKy2NgY7GzIBGx\nskA2AAAAAAAAAAQkBAEghEskAxYzDPZGwK5hjMLJhjMAqmGEwumrCagomFcw2JqqtUFEsLLrV82F\no7gqljKyYYTGwMZRKUSCAQAboJnaN5Bjkneu0d5W4ccViIiOzHFWbTzNumP1Zarr8eeRMbxDW1Mx\nNO67NbkhzNVnmInqzaOZrL93JyZeV0M1++7S02jvxDWxhxx033tPpC8Z6rrezWjmZyazJG2/u03h\n2vFibTHoqvamiwVwY+nLGzV0+SZ1Mx8G0/45tOhzJ5lXMc3UVXRdlF1HP+iYsDPLPPy49/tz1+Te\npSIr0ho6ak5Ms5J8o2q6NImOrHV7XX488ypzTtHXo0s9t6zG7c1G1qz6ubeZiZ3UatXJG3yauSO7\ncvMTEx5tPLb3prPRMVr0HB8vicNxf0+7+kt+LOJwTJyY/Bnz3tH93X36N58cWvq6LSyiyndMSlC7\nmZcymLJiwLosmJVRLKLAtiU7q4lMSCzc3YxJuDMRuAlKAEgAAAlAkAAAAAABKAEgAAAAAJAAAAAA\nAAAAAAAEgAAAAAAAAAAAAAkAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAhIAAACAAAASgAAAAAAEAAAA\nhGzJAImGMwzQDDZjNVuyNgUTVhNGxysZqDVmiu1G5NN2M4waM0+DCaN2cbGcQNGaMZq3JxMJxA1J\nqx2bU4kU09slorWNwa20z02RXHbJbl26QvtFovbHWkxEdJt5y2MOHlr2U1W3jx+1hiw8vSO63lmI\nXRTaEWmtY6snRHO1VpmJ+DjavpSZl2s8b7y4HFcnh0n0gha5ebJN55KRM2mdoiPN6fh+kpwXh0Wy\nRHj5Otp/s5Ps1p62y31+em9aTMYt/OfVfxTiPjZ52naI7fBrI5t66xz5+a1rW7yx0eSL6iZjtEOX\nqNbSletom3lENjh2fbHzbbWt3iVozruc+5ztWubf4M4ybpQ2Oboyrva0Vjza8WdDR4OkXt3n9ldX\nkaePP9VtYqctYhdvt5oivTeCZ2YOxXk6ubqMfV0b9mrljfqlFcq88k7z2U5axeItDa1OPessuC8P\nya7XRWYnwqdbT/ZMilvIu4dpslNdixXja8Y5tt85djZdbDWnGOesRtXFtuw6T27No5Kx2OrKYQlC\nExKJgBnEpiyvdlEgsizKLKollFgWxLKJVRLKJBbEp3VxLKJBnuMWQJEbpBIAAAJAAAABIAAAAAAA\nlAJAAAAAAAAAAAAAASAAAAAAAAAAAAAJAAAABAJABAlAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAA\nAAABAJQAAAAgAABAAI2EoBGyJhkgGPKxmqxAKpownHC+YRMdN5BrTj67R3bOn01o7p01Iv71u89o\nb9a7LfBTfS1vWI2jf12VfQPSW8KX2mas+NC2iv6xMNfJpMnLtEbuuxtMRCtzF55NR5rPps1N/ctP\ny6uHreE6nXZ4pak48X3rT06fB7fNeI33cbX6mI32R/MWu7XF116aDSRhxbRERs8f499bkyZeeKae\nkzE2mdon81/tfxDLGOunwbzlzbx08oaHBvZHJlx48mrvaa94pu04y617576rNGLRRM0397JEd/lu\n9Dw/S3x4qxffo6mm4NjwUiKY4iI9Ib1dHFY6QIaNabbrYrLfrpJtaK1rMzPZb/s+05IpP59OyLeJ\nk7eNfRaOc1ue32I7fGXYpi5Y77M8OGMeOKxHSFsU3Y29deZMzirl6dlVvhLatCjJHeYQv1rXnps1\n8k9/VsW6qLVmZIi1rzitlvFKRvaZ2h6TSaenC9FFY+3brM+sqeG8Prp4+kZ+lvuxPkr1mqm95nfp\nDXM459676a2q1dsV7XietvNno78+CJn1cjX6mOeIm0bR33dfRU5NJjidt9t5afjG/V6JZ7I2QMNh\nnyo2BhsMuVG3wAhMSbbQRAMolnE+iuGUSCyJZRKuGUSCyJZK4llEgyZMYTuCUsYSCQASISAAAlCQ\nAAAAAAEoASCASAAAAAAAAAAAAlACRACQAAAAAAAAAEgCEoASCAAAAAAAAAAAAAAAAAAAAAAABAAA\nAAAAAAAISAIAAAAAAQAAACASgAAAQJAQAAhIDHZhln3do7z0WS18mWsajHjmes7pg3dNi5aRMNqO\nyvDHTpPRaigHZhN4hHRlaVN59JY3zRENLUavaO+yq0iNVlitJ6vNcR1MVi0zO0era1/Ea0rPvbz5\nPM5MWp45qvo2GZrhmfrsnpHpHzTCseEcM/2vrr8Q1Eb4qzy44nziPN63HpYiIiI7LNHoqabBTFii\nIpSNohuVxrKtWMEejPwY9G1FFmHB4mWJn7MdfnIM9JpIx15to5pbUaas/a6rqViI7MxPxqX0UT1r\nO3wVzpbR2hviP5i03Y5s6a879FNtHljydhExCv8AMTPJXBnRZbz0iG5ptFjwe/l96zctMVamTJtE\nyTMibu1VrdTzRMR0j0ed4lr64MVpm0RERvMz5NvX62uOJ69XhOKX1HH9bHDtFvNYnfJeOy0Z2ojX\n6jjnEq6fRUmccTvN/J9H0eKcOnx45neaxEbubwHgOHg+milI3vP2resu3Wu0JQmITsmISDHZHKz2\nJgFc1RMLJhGwK9iIZ7MZgEdgmAEwyiWCdwWRLKJVxKYsC2JTuriWUSDNlEsIlMAySx3SCRCQSIAS\nAAACRACQAAAAAAASIASAAAAAAAAAAAAAAACRACRACQASIAAAAAAAAAAAAAAAAAAAAAAAAQCUAAAA\nAAAAAAIAAAAAAAAQAAAAAACBICBICAAEJAQJQCJcLjuS2ny6fPG/LWdpd1o8T0X07SXx/e7wCdJx\nWa0jmneHQpxPDMdZmJfNtZm49weZrh0/j4o7VtSZ2+Uw0/8A7o49k92vBLc/ntFohFW9PqGXimOI\n6Tu1L8T3eCx6r2t1O3JwvHjifO99v7t/Bwf2l1PXU6rS6eJ8qUm8x+so5TsekzcSjbvs4mt4rzW5\nK2mbT0itesy2cHsvbvqtbmyz5xERWP2jd1tJwrTaONsOKtZ8585+cnDrzmn4Rq+IZObUROHD32n7\nVv8A0ej0uhxaXFGPFSK1j0bkY4jyZRVZVXFGUVWbGwKsk8mObekNrSW3pWf1a2aYjHbm7bNnQ1id\nPW0TvuDdhJEbQABMsLW2R0ZTMQrvfbz2YWzVhpanUxEd0dWkW5c8R5uXxDX1w4pnfr5Q19XxKuOJ\n2neXltVqtVxbV/RdJ715+1bypANfiOu1HENV9C0MTfNeesx2rD1PAeBYuE6aKx72W3W9/WVnBuB4\neF4dqRzZbdb5J72l160WVK02ZxCYhOwI23TsnY2BGxsnYBjsiYZsZBjMMZZSgGEolMsQDdG6NwZ7\npiVe6YkFsSziVMWZRILolMSriWUSCyJTuwhMSDMRCQSI3SAlACRCQAAEoAEoASAAAAAAAAACUACR\nACQAAAAAAAAAAAAASAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAABAAAAAAAAAAAAACBKAAAAAAAQ\nJQAAAhICEbJAYTWJ7wx8KvpC0BV4ceieWGewDHlNmWwCNjZICNhIDmcZredBecdpiY69FXCOLW+i\nUiZidukulmxxlx2paN4mNng+K4+I8Hy2yaTfl37TXetoCPfRxfp1qi3F48ofKMvtvxak8s6LDv61\nrZji9rPaLUf5PC+bfttS0q8q3p9W/wBrRMdpUZuKdN99nzvFqPbTVz7nD8OKs+do2/mW3h4D7Xaq\nZnPrtNpqz35aRaYOHY9Zk4pNt9rR+rl6zi+OnS+WN57Rv1lXp/YrNaYtruL6zNPnGO3hxP6O5w/2\nf0HDuun09Yv55Le9afznqcOvO4tBreMTHu30unnva0bWt8on+70nDuE4OHYYx4Kbesz3tPrMuhGO\nIjpDOKrK9YVpsyiGUQnYGOyUgI2SlAIEmwMWMs9kTAMJYzDOYRMArmGErZhhMArlHmzmGMwDE3Ts\nbAbs4swj5pgFkSziVcM4BZEsolXDKAZwyhjCYBkACQhIAAAAAAAJAAAAAAAAAAAAAAAAAAAShIAA\nAAAAAAJAAAAAAAAAAAAAABAJEAAAAAAAAAAAAAAAIEoBKAAAAAAAAAAAAAAABAlAAAAAAAIAAAAA\nBAkBAkBAkBAlACEgMZjdjbFW8bWrEx8YWANb6Fp+bfwab+vLDKMFK9qxH5L0bAr8OPRPKz2AY7J2\nSbAjYZAI2E7AIEgIEgIEgMdkSy2NgY7MdlmyNoBXsxmFuyNgVTVjNV3KjlBRNTlXTVHKCrlIqt5T\nlBhEMohlFerLlBjEMohMVTEARDKCITsAk2AEgAAAkAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAD/\n2Q==";
var t0 = class {
  constructor(e20) {
    r(this, "version"), r(this, "config"), r(this, "result"), r(this, "state"), r(this, "process"), r(this, "tf"), r(this, "env", _X), r(this, "draw", tZ), r(this, "match", KQ), r(this, "models"), r(this, "events"), r(this, "faceTriangulation"), r(this, "faceUVMap"), r(this, "performance"), s(this, X1), s(this, q1), s(this, Z1), r(this, "analyze", (...e21) => {
      if (!i(this, q1)) return;
      const t3 = this.tf.engine().state.numTensors, n3 = i(this, X1);
      o(this, X1, t3);
      const r2 = t3 - n3;
      0 !== r2 && AX(...e21, r2);
    }), s(this, K1, (e21) => {
      if (!i(this, Z1)) return null;
      if (!e21) return "input is not defined";
      if (this.env.node && !(e21 instanceof ni)) return "input must be a tensor";
      try {
        this.tf.getBackend();
      } catch (t3) {
        return "backend not loaded";
      }
      return null;
    }), r(this, "webcam", new DX()), r(this, "emit", (e21) => {
      var t3;
      (null == (t3 = this.events) ? void 0 : t3.dispatchEvent) && this.events.dispatchEvent(new Event(e21));
    }), s(this, Y1, {});
    const t2 = fX.tfjs.replace(/-(.*)/, "");
    var n2;
    gX.wasmPath = `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${t2}/dist/`, gX.modelBasePath = _X.browser ? "../models/" : "file://models/", this.version = Zq, Object.defineProperty(this, "version", { value: Zq }), this.config = JSON.parse(JSON.stringify(gX)), Object.seal(this.config), this.config.cacheModels = "undefined" != typeof indexedDB, e20 && (this.config = bX(this.config, e20)), Hq.cacheModels = (n2 = this.config).cacheModels, Hq.verbose = n2.debug, Hq.modelBasePath = n2.modelBasePath, this.tf = l, this.state = "idle", o(this, X1, 0), o(this, q1, false), o(this, Z1, false), this.performance = {}, this.events = "undefined" != typeof EventTarget ? new EventTarget() : void 0, this.models = new J1(this), UZ(), this.result = DQ(), this.process = { tensor: null, canvas: null }, this.faceTriangulation = hY, this.faceUVMap = pY, H1(this, null, ""), this.emit("create"), (this.config.debug || this.env.browser) && AX("version: " + this.version), this.config.debug && AX("tfjs version: " + this.tf.version["tfjs-core"]);
    const a2 = JSON.parse(JSON.stringify(this.env));
    delete a2.kernels, delete a2.initial, delete a2.perfadd, this.config.debug && AX("environment:", a2);
  }
  reset() {
    const e20 = this.config.backend;
    this.config = JSON.parse(JSON.stringify(gX)), this.config.backend = e20, FX(), _X.initial = true;
  }
  validate(e20) {
    const t2 = yX(gX, e20 || this.config);
    return 0 === t2.length && (this.config = bX(this.config, e20)), t2;
  }
  now() {
    return xX();
  }
  image(e20, t2 = false) {
    return VX(e20, this.config, t2);
  }
  segmentation(e20, t2) {
    return __async(this, null, function* () {
      var n2, r2, a2;
      if (t2 && (this.config = bX(this.config, t2)), !this.config.segmentation.enabled) return null;
      const i2 = yield VX(e20, this.config);
      if (!i2.tensor) return null;
      let s2 = null;
      return (null == (n2 = this.config.segmentation.modelPath) ? void 0 : n2.includes("rvm")) && (s2 = yield ((e21, t3) => __async(this, null, function* () {
        if (S1 || (S1 = yield L1(t3)), !(null == S1 ? void 0 : S1.executor)) return null;
        _1.src = Ao(e21, 255), D1 !== t3.segmentation.ratio && W1(t3);
        const [n3, r3, a3, i3, s3, o2] = yield S1.executeAsync(_1, V1);
        let l2;
        switch (t3.segmentation.mode || "default") {
          case "default":
            l2 = j1(n3, r3);
            break;
          case "alpha":
            l2 = j1(null, r3);
            break;
          case "foreground":
            l2 = j1(n3, null);
            break;
          case "state":
            u2 = a3, l2 = es(() => {
              const e22 = {};
              return e22.unstack = Xc(u2, -1), e22.concat = Zo(e22.unstack, 1), e22.split = Nc(e22.concat, 4, 1), e22.stack = Zo(e22.split, 2), e22.squeeze = Rc(e22.stack, [0]), e22.expand = hu(e22.squeeze, -1), e22.add = fo(e22.expand, 1), e22.mul = xo(e22.add, 127.5), e22.cast = co(e22.mul, "int32"), e22.tile = fu(e22.cast, [1, 1, 3]), e22.alpha = hl([e22.tile.shape[0] || 0, e22.tile.shape[1] || 0, 1], 255, "int32"), Zo([e22.tile, e22.alpha], -1);
            });
            break;
          default:
            l2 = Ui(0);
        }
        var u2;
        return ts([_1.src, n3, r3, _1.r1i, _1.r2i, _1.r3i, _1.r4i]), [_1.r1i, _1.r2i, _1.r3i, _1.r4i] = [a3, i3, s3, o2], l2;
      }))(i2.tensor, this.config)), (null == (r2 = this.config.segmentation.modelPath) ? void 0 : r2.includes("meet")) && (s2 = yield ((e21, t3) => __async(this, null, function* () {
        var n3;
        if (LQ || (LQ = yield ZQ(t3)), !(null == LQ ? void 0 : LQ.executor) || !(null == (n3 = null == LQ ? void 0 : LQ.inputs) ? void 0 : n3[0].shape)) return null;
        const r3 = {};
        let a3;
        switch (r3.resize = mp.resizeBilinear(e21, [LQ.inputs[0].shape ? LQ.inputs[0].shape[1] : 0, LQ.inputs[0].shape ? LQ.inputs[0].shape[2] : 0], false), r3.norm = Ao(r3.resize, Yq.tf255), r3.res = LQ.execute(r3.norm), r3.squeeze = Rc(r3.res, [0]), [r3.bgRaw, r3.fgRaw] = Xc(r3.squeeze, 2), r3.fg = gc(r3.fgRaw), r3.mul = xo(r3.fg, Yq.tf255), r3.expand = hu(r3.mul, 2), r3.output = mp.resizeBilinear(r3.expand, [e21.shape[1] || 0, e21.shape[2] || 0]), t3.segmentation.mode || "default") {
          case "default":
            r3.input = Rc(e21), r3.concat = Zo([r3.input, r3.output], -1), a3 = co(r3.concat, "int32");
            break;
          case "alpha":
            a3 = co(r3.output, "int32");
            break;
          default:
            a3 = Ui(0);
        }
        return Object.keys(r3).forEach((e22) => ts(r3[e22])), a3;
      }))(i2.tensor, this.config)), (null == (a2 = this.config.segmentation.modelPath) ? void 0 : a2.includes("selfie")) && (s2 = yield ((e21, t3) => __async(this, null, function* () {
        var n3;
        if (B1 || (B1 = yield G1(t3)), !(null == B1 ? void 0 : B1.executor) || !(null == (n3 = null == B1 ? void 0 : B1.inputs) ? void 0 : n3[0].shape)) return null;
        const r3 = {};
        let a3;
        switch (r3.resize = mp.resizeBilinear(e21, [B1.inputs[0].shape ? B1.inputs[0].shape[1] : 0, B1.inputs[0].shape ? B1.inputs[0].shape[2] : 0], false), r3.norm = Ao(r3.resize, Yq.tf255), r3.res = B1.execute(r3.norm), r3.squeeze = Rc(r3.res, [0]), r3.alpha = mp.resizeBilinear(r3.squeeze, [e21.shape[1] || 0, e21.shape[2] || 0]), r3.mul = xo(r3.alpha, Yq.tf255), t3.segmentation.mode || "default") {
          case "default":
            r3.input = Rc(e21), r3.concat = Zo([r3.input, r3.mul], -1), a3 = co(r3.concat, "int32");
            break;
          case "alpha":
            a3 = co(r3.mul, "int32");
            break;
          default:
            a3 = Ui(0);
        }
        return Object.keys(r3).forEach((e22) => ts(r3[e22])), a3;
      }))(i2.tensor, this.config)), ts(i2.tensor), s2;
    });
  }
  compare(e20, t2) {
    return ((e21, t3, n2) => __async(null, null, function* () {
      const r2 = {};
      if (!t3 || !n2 || 4 !== t3.shape.length || t3.shape.length !== n2.shape.length) return e21.debug || AX("invalid input tensor or tensor shapes do not match:", t3.shape, n2.shape), 0;
      if (1 !== t3.shape[0] || 1 !== n2.shape[0] || 3 !== t3.shape[3] || 3 !== n2.shape[3]) return e21.debug || AX("input tensors must be of shape [1, height, width, 3]:", t3.shape, n2.shape), 0;
      r2.input1 = ho(t3), r2.input2 = t3.shape[1] !== n2.shape[1] || t3.shape[2] !== n2.shape[2] ? mp.resizeBilinear(n2, [t3.shape[1], t3.shape[2]]) : ho(n2), r2.diff = Lu(r2.input1, r2.input2), r2.squared = xo(r2.diff, r2.diff), r2.sum = ou(r2.squared);
      const a2 = (yield r2.sum.data())[0] / (t3.shape[1] || 1) / (t3.shape[2] || 1) / 255 / 3;
      return ts([r2.input1, r2.input2, r2.diff, r2.squared, r2.sum]), a2;
    }))(this.config, e20, t2);
  }
  init() {
    return __async(this, null, function* () {
      yield Qq(this, true), yield this.tf.ready(), FX();
    });
  }
  load(e20) {
    return __async(this, null, function* () {
      this.state = "load";
      const t2 = xX(), n2 = Object.values(this.models.models).filter((e21) => e21).length;
      e20 && (this.config = bX(this.config, e20)), this.env.initial && ((yield Qq(this, false)) || AX("error: backend check failed"), yield is(), this.env.browser && (this.config.debug && AX("configuration:", this.config), this.config.debug && AX("tf flags:", this.tf.ENV.flags))), yield this.models.load(this), this.env.initial && this.config.debug && AX("tf engine state:", this.tf.engine().state.numBytes, "bytes", this.tf.engine().state.numTensors, "tensors"), this.env.initial = false, Object.values(this.models.models).filter((e21) => e21).length !== n2 && (this.models.validate(), this.emit("load"));
      const r2 = Math.trunc(xX() - t2);
      r2 > (this.performance.loadModels || 0) && (this.performance.loadModels = this.env.perfadd ? (this.performance.loadModels || 0) + r2 : r2);
    });
  }
  next(e20 = this.result) {
    return ((e21, t2) => {
      var n2, r2, a2, i2, s2, o2, l2, u2, d2, c2, h2, p2, f2, m2, A2, x2, y2, b2, g2, v2, w2, k2, N2, C2, $2, R2;
      const S2 = xX();
      if (!e21) return DQ();
      const I2 = Date.now() - e21.timestamp, E2 = 1e3 > I2 ? 8 - Math.log(I2 + 1) : 1;
      if (e21.canvas && (XQ.canvas = e21.canvas), e21.error && (XQ.error = e21.error), XQ.body && e21.body.length === XQ.body.length) for (let M2 = 0; e21.body.length > M2; M2++) {
        const i3 = e21.body[M2].box.map((e22, t3) => ((E2 - 1) * XQ.body[M2].box[t3] + e22) / E2), s3 = e21.body[M2].boxRaw.map((e22, t3) => ((E2 - 1) * XQ.body[M2].boxRaw[t3] + e22) / E2), o3 = e21.body[M2].keypoints.map((e22, t3) => {
          var n3, r3, a3, i4, s4, o4, l4, u4, d3;
          return { score: e22.score, part: e22.part, position: [XQ.body[M2].keypoints[t3] ? ((E2 - 1) * (XQ.body[M2].keypoints[t3].position[0] || 0) + (e22.position[0] || 0)) / E2 : e22.position[0], XQ.body[M2].keypoints[t3] ? ((E2 - 1) * (XQ.body[M2].keypoints[t3].position[1] || 0) + (e22.position[1] || 0)) / E2 : e22.position[1], XQ.body[M2].keypoints[t3] ? ((E2 - 1) * (XQ.body[M2].keypoints[t3].position[2] || 0) + (e22.position[2] || 0)) / E2 : e22.position[2]], positionRaw: [XQ.body[M2].keypoints[t3] ? ((E2 - 1) * (XQ.body[M2].keypoints[t3].positionRaw[0] || 0) + (e22.positionRaw[0] || 0)) / E2 : e22.positionRaw[0], XQ.body[M2].keypoints[t3] ? ((E2 - 1) * (XQ.body[M2].keypoints[t3].positionRaw[1] || 0) + (e22.positionRaw[1] || 0)) / E2 : e22.positionRaw[1], XQ.body[M2].keypoints[t3] ? ((E2 - 1) * (XQ.body[M2].keypoints[t3].positionRaw[2] || 0) + (e22.positionRaw[2] || 0)) / E2 : e22.positionRaw[2]], distance: [XQ.body[M2].keypoints[t3] ? ((E2 - 1) * ((null == (n3 = XQ.body[M2].keypoints[t3].distance) ? void 0 : n3[0]) || 0) + ((null == (r3 = e22.distance) ? void 0 : r3[0]) || 0)) / E2 : null == (a3 = e22.distance) ? void 0 : a3[0], XQ.body[M2].keypoints[t3] ? ((E2 - 1) * ((null == (i4 = XQ.body[M2].keypoints[t3].distance) ? void 0 : i4[1]) || 0) + ((null == (s4 = e22.distance) ? void 0 : s4[1]) || 0)) / E2 : null == (o4 = e22.distance) ? void 0 : o4[1], XQ.body[M2].keypoints[t3] ? ((E2 - 1) * ((null == (l4 = XQ.body[M2].keypoints[t3].distance) ? void 0 : l4[2]) || 0) + ((null == (u4 = e22.distance) ? void 0 : u4[2]) || 0)) / E2 : null == (d3 = e22.distance) ? void 0 : d3[2]] };
        }), l3 = {};
        let u3 = { connected: {} };
        (null == (n2 = t2.body.modelPath) ? void 0 : n2.includes("efficientpose")) ? u3 = yK : (null == (r2 = t2.body.modelPath) ? void 0 : r2.includes("blazepose")) ? u3 = jZ : (null == (a2 = t2.body.modelPath) ? void 0 : a2.includes("movenet")) && (u3 = WQ);
        for (const [e22, t3] of Object.entries(u3.connected)) {
          const n3 = [];
          for (let e23 = 0; t3.length - 1 > e23; e23++) {
            const r3 = o3.find((n4) => n4.part === t3[e23]), a3 = o3.find((n4) => n4.part === t3[e23 + 1]);
            r3 && a3 && n3.push([r3.position, a3.position]);
          }
          l3[e22] = n3;
        }
        XQ.body[M2] = __spreadProps(__spreadValues({}, e21.body[M2]), { box: i3, boxRaw: s3, keypoints: o3, annotations: l3 });
      }
      else XQ.body = JSON.parse(JSON.stringify(e21.body));
      if (XQ.hand && e21.hand.length === XQ.hand.length) for (let M2 = 0; e21.hand.length > M2; M2++) {
        const t3 = e21.hand[M2].box.map((e22, t4) => ((E2 - 1) * XQ.hand[M2].box[t4] + e22) / E2), n3 = e21.hand[M2].boxRaw.map((e22, t4) => ((E2 - 1) * XQ.hand[M2].boxRaw[t4] + e22) / E2);
        XQ.hand[M2].keypoints.length !== e21.hand[M2].keypoints.length && (XQ.hand[M2].keypoints = e21.hand[M2].keypoints);
        const r3 = e21.hand[M2].keypoints && e21.hand[M2].keypoints.length > 0 ? e21.hand[M2].keypoints.map((e22, t4) => e22.map((e23, n4) => ((E2 - 1) * (XQ.hand[M2].keypoints[t4][n4] || 1) + (e23 || 0)) / E2)) : [];
        let a3 = {};
        if (Object.keys(XQ.hand[M2].annotations).length !== Object.keys(e21.hand[M2].annotations).length) XQ.hand[M2].annotations = e21.hand[M2].annotations, a3 = XQ.hand[M2].annotations;
        else if (e21.hand[M2].annotations) for (const l3 of Object.keys(e21.hand[M2].annotations)) a3[l3] = (null == (o2 = null == (s2 = null == (i2 = e21.hand[M2]) ? void 0 : i2.annotations) ? void 0 : s2[l3]) ? void 0 : o2[0]) ? e21.hand[M2].annotations[l3].map((e22, t4) => e22.map((e23, n4) => ((E2 - 1) * XQ.hand[M2].annotations[l3][t4][n4] + e23) / E2)) : null;
        XQ.hand[M2] = __spreadProps(__spreadValues({}, e21.hand[M2]), { box: t3, boxRaw: n3, keypoints: r3, annotations: a3 });
      }
      else XQ.hand = JSON.parse(JSON.stringify(e21.hand));
      if (XQ.face && e21.face.length === XQ.face.length) for (let M2 = 0; e21.face.length > M2; M2++) {
        const t3 = e21.face[M2].box.map((e22, t4) => ((E2 - 1) * XQ.face[M2].box[t4] + e22) / E2), n3 = e21.face[M2].boxRaw.map((e22, t4) => ((E2 - 1) * XQ.face[M2].boxRaw[t4] + e22) / E2);
        let r3 = e21.face[M2].annotations;
        if (Object.keys(XQ.face[M2].annotations).length !== Object.keys(e21.face[M2].annotations).length) XQ.face[M2].annotations = e21.face[M2].annotations, r3 = XQ.face[M2].annotations;
        else if (e21.face[M2].annotations) for (const a3 of Object.keys(e21.face[M2].annotations)) r3[a3] = (null == (d2 = null == (u2 = null == (l2 = e21.face[M2]) ? void 0 : l2.annotations) ? void 0 : u2[a3]) ? void 0 : d2[0]) ? e21.face[M2].annotations[a3].map((e22, t4) => e22.map((e23, n4) => ((E2 - 1) * XQ.face[M2].annotations[a3][t4][n4] + e23) / E2)) : null;
        if (e21.face[M2].rotation) {
          const a3 = { matrix: [0, 0, 0, 0, 0, 0, 0, 0, 0], angle: { roll: 0, yaw: 0, pitch: 0 }, gaze: { bearing: 0, strength: 0 } };
          a3.matrix = null == (c2 = e21.face[M2].rotation) ? void 0 : c2.matrix, a3.angle = { roll: ((E2 - 1) * ((null == (p2 = null == (h2 = XQ.face[M2].rotation) ? void 0 : h2.angle) ? void 0 : p2.roll) || 0) + ((null == (m2 = null == (f2 = e21.face[M2].rotation) ? void 0 : f2.angle) ? void 0 : m2.roll) || 0)) / E2, yaw: ((E2 - 1) * ((null == (x2 = null == (A2 = XQ.face[M2].rotation) ? void 0 : A2.angle) ? void 0 : x2.yaw) || 0) + ((null == (b2 = null == (y2 = e21.face[M2].rotation) ? void 0 : y2.angle) ? void 0 : b2.yaw) || 0)) / E2, pitch: ((E2 - 1) * ((null == (v2 = null == (g2 = XQ.face[M2].rotation) ? void 0 : g2.angle) ? void 0 : v2.pitch) || 0) + ((null == (k2 = null == (w2 = e21.face[M2].rotation) ? void 0 : w2.angle) ? void 0 : k2.pitch) || 0)) / E2 }, a3.gaze = { bearing: ((E2 - 1) * ((null == (N2 = XQ.face[M2].rotation) ? void 0 : N2.gaze.bearing) || 0) + ((null == (C2 = e21.face[M2].rotation) ? void 0 : C2.gaze.bearing) || 0)) / E2, strength: ((E2 - 1) * ((null == ($2 = XQ.face[M2].rotation) ? void 0 : $2.gaze.strength) || 0) + ((null == (R2 = e21.face[M2].rotation) ? void 0 : R2.gaze.strength) || 0)) / E2 }, XQ.face[M2] = __spreadProps(__spreadValues({}, e21.face[M2]), { rotation: a3, box: t3, boxRaw: n3, annotations: r3 });
        } else XQ.face[M2] = __spreadProps(__spreadValues({}, e21.face[M2]), { box: t3, boxRaw: n3, annotations: r3 });
      }
      else XQ.face = JSON.parse(JSON.stringify(e21.face));
      if (XQ.object && e21.object.length === XQ.object.length) for (let M2 = 0; e21.object.length > M2; M2++) {
        const t3 = e21.object[M2].box.map((e22, t4) => ((E2 - 1) * XQ.object[M2].box[t4] + e22) / E2), n3 = e21.object[M2].boxRaw.map((e22, t4) => ((E2 - 1) * XQ.object[M2].boxRaw[t4] + e22) / E2);
        XQ.object[M2] = __spreadProps(__spreadValues({}, e21.object[M2]), { box: t3, boxRaw: n3 });
      }
      else XQ.object = JSON.parse(JSON.stringify(e21.object));
      if (e21.persons) {
        const t3 = e21.persons;
        if (XQ.persons && t3.length === XQ.persons.length) for (let e22 = 0; t3.length > e22; e22++) XQ.persons[e22].box = t3[e22].box.map((t4, n3) => ((E2 - 1) * XQ.persons[e22].box[n3] + t4) / E2);
        else XQ.persons = JSON.parse(JSON.stringify(t3));
      }
      e21.gesture && (XQ.gesture = e21.gesture), XQ.width = e21.width, XQ.height = e21.height;
      const T2 = xX();
      return qQ = _X.perfadd ? qQ + Math.round(T2 - S2) : Math.round(T2 - S2), e21.performance && (XQ.performance = __spreadProps(__spreadValues({}, e21.performance), { interpolate: qQ })), XQ;
    })(e20, this.config);
  }
  warmup(e20) {
    return __async(this, null, function* () {
      const t2 = xX(), n2 = yield (function(e21, t3) {
        return __async(this, null, function* () {
          yield Qq(e21, false);
          const n3 = xX();
          return e21.state = "warmup", t3 && (e21.config = bX(e21.config, t3)), e21.config.warmup && 0 !== e21.config.warmup.length && "none" !== e21.config.warmup ? new Promise((t4) => __async(null, null, function* () {
            yield e21.models.load(), yield is(), yield ((e22) => __async(null, null, function* () {
              var t5, n4, r4, a3;
              if (!_e().flagRegistry.ENGINE_COMPILE_ONLY) return;
              const i2 = ss(), s2 = cs();
              if ("webgl" !== i2 && "humangl" !== i2 || !(null == s2 ? void 0 : s2.checkCompileCompletion)) return;
              _e().set("ENGINE_COMPILE_ONLY", true);
              const o2 = Yi().state.numTensors, l2 = [];
              for (const [h2, p2] of Object.entries(e22.models.models)) {
                if (!p2) continue;
                const i3 = (null == p2 ? void 0 : p2.modelSignature) && (null == (n4 = null == (t5 = null == p2 ? void 0 : p2.inputs) ? void 0 : t5[0]) ? void 0 : n4.shape) ? [...p2.inputs[0].shape] : [1, 64, 64, 3], s3 = (null == p2 ? void 0 : p2.modelSignature) && (null == (a3 = null == (r4 = null == p2 ? void 0 : p2.inputs) ? void 0 : r4[0]) ? void 0 : a3.dtype) ? p2.inputs[0].dtype : "float32";
                for (let e23 = 0; i3.length > e23; e23++) -1 === i3[e23] && (i3[e23] = 0 === e23 ? 1 : 64);
                const o3 = nd(i3, s3);
                try {
                  const e23 = p2.execute(o3);
                  l2.push(h2), Array.isArray(e23) ? e23.forEach((e24) => ts(e24)) : ts(e23);
                } catch (c2) {
                  e22.config.debug && AX("compile fail model:", h2);
                }
                ts(o3);
              }
              const u2 = yield s2.checkCompileCompletionAsync();
              s2.getUniformLocations(), e22.config.debug && AX("compile pass:", { models: l2, kernels: u2.length }), _e().set("ENGINE_COMPILE_ONLY", false);
              const d2 = Yi().state.numTensors;
              d2 - o2 > 0 && AX("tensor leak:", d2 - o2);
            }))(e21);
            const r3 = yield ((e22) => __async(null, null, function* () {
              let t5;
              return t5 = "function" == typeof createImageBitmap ? yield ((e23) => __async(null, null, function* () {
                const t6 = (e24, t7 = "application/octet-stream") => fetch(`data:${t7};base64,${e24}`).then((e25) => e25.blob());
                let n4, r4;
                switch (e23.config.warmup) {
                  case "face":
                    n4 = yield t6(Q1);
                    break;
                  case "body":
                  case "full":
                    n4 = yield t6(e0);
                    break;
                  default:
                    n4 = null;
                }
                if (n4) {
                  const t7 = yield createImageBitmap(n4);
                  r4 = yield e23.detect(t7, e23.config), t7.close();
                }
                return r4;
              }))(e22) : "undefined" != typeof Image || void 0 !== _X.Canvas ? yield ((e23) => __async(null, null, function* () {
                return new Promise((t6) => {
                  let n4, r4;
                  switch (e23.config.warmup) {
                    case "face":
                      n4 = "data:image/jpeg;base64," + Q1;
                      break;
                    case "full":
                    case "body":
                      n4 = "data:image/jpeg;base64," + e0;
                      break;
                    default:
                      n4 = "";
                  }
                  if ("undefined" != typeof Image) r4 = new Image();
                  else {
                    if (!_X.Image) return void t6(void 0);
                    r4 = new _X.Image();
                  }
                  r4.onload = () => __async(null, null, function* () {
                    const n5 = PX(r4.naturalWidth, r4.naturalHeight);
                    if (n5) {
                      const a3 = n5.getContext("2d");
                      a3 && a3.drawImage(r4, 0, 0);
                      const i2 = yield e23.image(n5, true), s2 = i2.tensor ? yield e23.detect(i2.tensor, e23.config) : void 0;
                      t6(s2);
                    } else AX("Warmup: Canvas not found"), t6(void 0);
                  }), n4 ? r4.src = n4 : t6(void 0);
                });
              }))(e22) : yield ((e23) => __async(null, null, function* () {
                let t6, n4;
                if (t6 = Buffer.from("face" === e23.config.warmup ? Q1 : e0, "base64"), "node" in l && "tensorflow" === ss()) {
                  const r4 = mX.decodeJpeg(t6), a3 = hu(r4, 0);
                  e23.tf.dispose(r4), n4 = yield e23.detect(a3, e23.config), e23.tf.dispose(a3);
                } else e23.config.debug && AX("Warmup tfjs-node not loaded");
                return n4;
              }))(e22), t5;
            }))(e21), a2 = xX();
            e21.config.debug && AX("warmup", e21.config.warmup, Math.round(a2 - n3), "ms"), e21.emit("warmup"), t4(r3);
          })) : DQ();
        });
      })(this, e20), r2 = xX();
      return this.performance.warmup = Math.trunc(r2 - t2), n2;
    });
  }
  profile(e20, t2) {
    return __async(this, null, function* () {
      const n2 = yield this.tf.profile(() => this.detect(e20, t2)), r2 = {};
      let a2 = 0;
      for (const s2 of n2.kernels) {
        const e21 = +s2.kernelTimeMs || 0;
        r2[s2.name] ? r2[s2.name] += e21 : r2[s2.name] = e21, a2 += e21;
      }
      const i2 = [];
      Object.entries(r2).forEach((e21) => i2.push({ kernel: e21[0], time: e21[1], perc: 0 }));
      for (const s2 of i2) s2.perc = Math.round(1e3 * s2.time / a2) / 1e3, s2.time = Math.round(1e3 * s2.time) / 1e3;
      return i2.sort((e21, t3) => t3.time - e21.time), i2.length = 20, i2;
    });
  }
  detect(e20, t2) {
    return __async(this, null, function* () {
      return this.state = "detect", new Promise((n2) => __async(this, null, function* () {
        var r2, a2, s2, o2, l2, u2, d2, c2, h2, p2, f2, m2, A2, x2, y2, b2, g2, v2, w2, k2, N2;
        let C2;
        this.state = "config", this.config = bX(this.config, t2), this.state = "check";
        const $2 = i(this, K1).call(this, e20);
        $2 && (AX($2, e20), this.emit("error"), n2(DQ($2)));
        const R2 = xX();
        yield this.load(), C2 = xX(), this.state = "image";
        const S2 = yield VX(e20, this.config);
        if (this.process = S2, this.performance.inputProcess = this.env.perfadd ? (this.performance.inputProcess || 0) + Math.trunc(xX() - C2) : Math.trunc(xX() - C2), this.analyze("Get Image:"), !S2.tensor) return this.config.debug && AX("could not convert input to tensor"), this.emit("error"), void n2(DQ("could not convert input to tensor"));
        this.emit("image"), C2 = xX(), this.config.skipAllowed = yield ((e21, t3) => __async(this, null, function* () {
          let n3 = false;
          if (0 === e21.cacheSensitivity || !t3.shape || 4 !== t3.shape.length || t3.shape[1] > 3840 || t3.shape[2] > 2160) return n3;
          if (OX.inputTensor) if (OX.inputTensor.shape[1] !== t3.shape[1] || OX.inputTensor.shape[2] !== t3.shape[2]) ts(OX.inputTensor), OX.inputTensor = ho(t3);
          else {
            const r3 = {};
            r3.diff = Lu(t3, OX.inputTensor), r3.squared = xo(r3.diff, r3.diff), r3.sum = ou(r3.squared);
            const a3 = (yield r3.sum.data())[0] / (t3.shape[1] || 1) / (t3.shape[2] || 1) / 255 / 3;
            ts([OX.inputTensor, r3.diff, r3.squared, r3.sum]), OX.inputTensor = ho(t3), n3 = (e21.cacheSensitivity || 0) >= a3;
          }
          else OX.inputTensor = ho(t3);
          return n3;
        }))(this.config, S2.tensor), this.config.filter.autoBrightness = !!this.config.filter.autoBrightness && this.config.skipAllowed, this.performance.totalFrames || (this.performance.totalFrames = 0), this.performance.cachedFrames || (this.performance.cachedFrames = 0), this.performance.totalFrames++, this.config.skipAllowed && this.performance.cachedFrames++, this.performance.cacheCheck = this.env.perfadd ? (this.performance.cacheCheck || 0) + Math.trunc(xX() - C2) : Math.trunc(xX() - C2), this.analyze("Check Changed:");
        let I2 = [], E2 = [], T2 = [], M2 = [];
        this.state = "detect:face", this.config.async ? (I2 = this.config.face.enabled ? vJ(this, S2.tensor) : [], this.performance.face && delete this.performance.face) : (C2 = xX(), I2 = this.config.face.enabled ? yield vJ(this, S2.tensor) : [], this.performance.face = this.env.perfadd ? (this.performance.face || 0) + Math.trunc(xX() - C2) : Math.trunc(xX() - C2)), !this.config.async || -1 !== this.config.body.maxDetected && -1 !== this.config.hand.maxDetected || (I2 = yield I2), this.analyze("Start Body:"), this.state = "detect:body";
        const O2 = -1 === this.config.body.maxDetected ? bX(this.config, { body: { maxDetected: this.config.face.enabled ? 1 * I2.length : 1 } }) : this.config;
        this.config.async ? ((null == (r2 = this.config.body.modelPath) ? void 0 : r2.includes("posenet")) ? E2 = this.config.body.enabled ? z1(S2.tensor, O2) : [] : (null == (a2 = this.config.body.modelPath) ? void 0 : a2.includes("blazepose")) ? E2 = this.config.body.enabled ? dK(S2.tensor, O2) : [] : (null == (s2 = this.config.body.modelPath) ? void 0 : s2.includes("efficientpose")) ? E2 = this.config.body.enabled ? $K(S2.tensor, O2) : [] : (null == (o2 = this.config.body.modelPath) ? void 0 : o2.includes("movenet")) && (E2 = this.config.body.enabled ? d1(S2.tensor, O2) : []), this.performance.body && delete this.performance.body) : (C2 = xX(), (null == (l2 = this.config.body.modelPath) ? void 0 : l2.includes("posenet")) ? E2 = this.config.body.enabled ? yield z1(S2.tensor, O2) : [] : (null == (u2 = this.config.body.modelPath) ? void 0 : u2.includes("blazepose")) ? E2 = this.config.body.enabled ? yield dK(S2.tensor, O2) : [] : (null == (d2 = this.config.body.modelPath) ? void 0 : d2.includes("efficientpose")) ? E2 = this.config.body.enabled ? yield $K(S2.tensor, O2) : [] : (null == (c2 = this.config.body.modelPath) ? void 0 : c2.includes("movenet")) && (E2 = this.config.body.enabled ? yield d1(S2.tensor, O2) : []), this.performance.body = this.env.perfadd ? (this.performance.body || 0) + Math.trunc(xX() - C2) : Math.trunc(xX() - C2)), this.analyze("End Body:"), this.analyze("Start Hand:"), this.state = "detect:hand";
        const F2 = -1 === this.config.hand.maxDetected ? bX(this.config, { hand: { maxDetected: this.config.face.enabled ? 2 * I2.length : 1 } }) : this.config;
        this.config.async ? ((null == (p2 = null == (h2 = this.config.hand.detector) ? void 0 : h2.modelPath) ? void 0 : p2.includes("handdetect")) ? T2 = this.config.hand.enabled ? RQ(S2.tensor, F2) : [] : (null == (m2 = null == (f2 = this.config.hand.detector) ? void 0 : f2.modelPath) ? void 0 : m2.includes("handtrack")) && (T2 = this.config.hand.enabled ? _Q(S2.tensor, F2) : []), this.performance.hand && delete this.performance.hand) : (C2 = xX(), (null == (x2 = null == (A2 = this.config.hand.detector) ? void 0 : A2.modelPath) ? void 0 : x2.includes("handdetect")) ? T2 = this.config.hand.enabled ? yield RQ(S2.tensor, F2) : [] : (null == (b2 = null == (y2 = this.config.hand.detector) ? void 0 : y2.modelPath) ? void 0 : b2.includes("handtrack")) && (T2 = this.config.hand.enabled ? yield _Q(S2.tensor, F2) : []), this.performance.hand = this.env.perfadd ? (this.performance.hand || 0) + Math.trunc(xX() - C2) : Math.trunc(xX() - C2)), this.analyze("End Hand:"), this.analyze("Start Object:"), this.state = "detect:object", this.config.async ? ((null == (g2 = this.config.object.modelPath) ? void 0 : g2.includes("nanodet")) ? M2 = this.config.object.enabled ? A1(S2.tensor, this.config) : [] : (null == (v2 = this.config.object.modelPath) ? void 0 : v2.includes("centernet")) && (M2 = this.config.object.enabled ? xK(S2.tensor, this.config) : []), this.performance.object && delete this.performance.object) : (C2 = xX(), (null == (w2 = this.config.object.modelPath) ? void 0 : w2.includes("nanodet")) ? M2 = this.config.object.enabled ? yield A1(S2.tensor, this.config) : [] : (null == (k2 = this.config.object.modelPath) ? void 0 : k2.includes("centernet")) && (M2 = this.config.object.enabled ? yield xK(S2.tensor, this.config) : []), this.performance.object = this.env.perfadd ? (this.performance.object || 0) + Math.trunc(xX() - C2) : Math.trunc(xX() - C2)), this.analyze("End Object:"), this.state = "detect:await", this.config.async && ([I2, E2, T2, M2] = yield Promise.all([I2, E2, T2, M2])), this.state = "detect:gesture";
        let P2 = [];
        this.config.gesture.enabled && (C2 = xX(), P2 = [...nQ(I2), ...tQ(E2), ...aQ(T2), ...rQ(I2)], this.config.async ? this.performance.gesture && delete this.performance.gesture : this.performance.gesture = this.env.perfadd ? (this.performance.gesture || 0) + Math.trunc(xX() - C2) : Math.trunc(xX() - C2)), this.performance.total = this.env.perfadd ? (this.performance.total || 0) + Math.trunc(xX() - R2) : Math.trunc(xX() - R2);
        const z2 = (null == (N2 = this.process.tensor) ? void 0 : N2.shape) || [0, 0, 0, 0];
        this.result = { face: I2, body: E2, hand: T2, gesture: P2, object: M2, performance: this.performance, canvas: this.process.canvas, timestamp: Date.now(), error: null, width: z2[2], height: z2[1], get persons() {
          return ((e21, t3, n3, r3, a3) => {
            var i2, s3, o3, l3, u3, d3;
            let c3 = 0;
            const h3 = [];
            for (const p3 of e21) {
              const e22 = { id: c3++, face: p3, body: null, hands: { left: null, right: null }, gestures: [], box: [0, 0, 0, 0] };
              for (const n4 of t3) p3.box[0] > n4.box[0] && n4.box[0] + n4.box[2] > p3.box[0] && p3.box[1] + p3.box[3] > n4.box[1] && n4.box[1] + n4.box[3] > p3.box[1] + p3.box[3] && (e22.body = n4);
              if (e22.body) for (const t4 of n3) t4.box[0] + t4.box[2] > e22.body.box[0] && e22.body.box[0] + e22.body.box[2] > t4.box[0] + t4.box[2] && t4.box[1] + t4.box[3] > e22.body.box[1] && e22.body.box[1] + e22.body.box[3] > t4.box[1] + t4.box[3] && e22.hands && (e22.hands.left = t4), e22.body.box[0] + e22.body.box[2] > t4.box[0] && t4.box[0] > e22.body.box[0] && t4.box[1] + t4.box[3] > e22.body.box[1] && e22.body.box[1] + e22.body.box[3] > t4.box[1] + t4.box[3] && e22.hands && (e22.hands.right = t4);
              for (const t4 of r3) (void 0 !== t4.face && t4.face === p3.id || void 0 !== t4.iris && t4.iris === p3.id || void 0 !== t4.body && t4.body === (null == (i2 = e22.body) ? void 0 : i2.id) || void 0 !== t4.hand && t4.hand === (null == (s3 = e22.hands.left) ? void 0 : s3.id) || void 0 !== t4.hand && t4.hand === (null == (o3 = e22.hands.right) ? void 0 : o3.id)) && e22.gestures.push(t4);
              const f3 = [], m3 = [], A3 = (e23) => {
                e23 && 4 === e23.length && (f3.push(e23[0], e23[0] + e23[2]), m3.push(e23[1], e23[1] + e23[3]));
              };
              A3(e22.face.box), A3(null == (l3 = e22.body) ? void 0 : l3.box), A3(null == (u3 = e22.hands.left) ? void 0 : u3.box), A3(null == (d3 = e22.hands.right) ? void 0 : d3.box);
              const x3 = Math.min(...f3), y3 = Math.min(...m3);
              e22.box = [x3, y3, Math.max(...f3) - x3, Math.max(...m3) - y3], (null == a3 ? void 0 : a3[1]) && (null == a3 ? void 0 : a3[2]) && (e22.boxRaw = [e22.box[0] / a3[2], e22.box[1] / a3[1], e22.box[2] / a3[2], e22.box[3] / a3[1]]), h3.push(e22);
            }
            return h3;
          })(I2, E2, T2, P2, z2);
        } }, ts(S2.tensor), this.emit("detect"), this.state = "idle", n2(this.result);
      }));
    });
  }
  sleep(e20) {
    return __async(this, null, function* () {
      return new Promise((t2) => {
        setTimeout(t2, e20);
      });
    });
  }
  video(e20, t2 = true, n2 = 0) {
    return __async(this, null, function* () {
      t2 ? (i(this, Y1)[e20.id] || (this.config.debug && AX("video start", e20.id), i(this, Y1)[e20.id] = true), e20.paused || !i(this, Y1)[e20.id] || 2 > e20.readyState || (yield this.detect(e20)), n2 > 0 && (yield this.sleep(n2)), i(this, Y1)[e20.id] && requestAnimationFrame(() => this.video(e20, t2, n2))) : (this.config.debug && AX("video stop", e20.id), i(this, Y1)[e20.id] = false);
    });
  }
};
X1 = /* @__PURE__ */ new WeakMap(), q1 = /* @__PURE__ */ new WeakMap(), Z1 = /* @__PURE__ */ new WeakMap(), K1 = /* @__PURE__ */ new WeakMap(), Y1 = /* @__PURE__ */ new WeakMap();
var n0 = class _n0 extends EventTarget {
  static detectOptimalBackend() {
    return __async(this, null, function* () {
      if ("undefined" != typeof navigator && navigator.gpu) try {
        const e20 = yield navigator.gpu.requestAdapter();
        if (e20) {
          const t2 = yield e20.requestDevice();
          if (t2) return t2.destroy(), { backend: "webgpu", reason: "WebGPU available and functional", adapterInfo: e20.info || {} };
        }
      } catch (e20) {
        console.log("[HumanSentimentAnalyzer] WebGPU check failed:", e20.message);
      }
      if ("undefined" != typeof document) try {
        const e20 = document.createElement("canvas");
        if (e20.getContext("webgl2")) return { backend: "webgl", reason: "WebGL2 available" };
        if (e20.getContext("webgl") || e20.getContext("experimental-webgl")) return { backend: "webgl", reason: "WebGL1 available" };
      } catch (e20) {
        console.log("[HumanSentimentAnalyzer] WebGL check failed:", e20.message);
      }
      return "undefined" != typeof WebAssembly ? { backend: "wasm", reason: "WebAssembly available, GPU not available" } : { backend: "cpu", reason: "No GPU acceleration available" };
    });
  }
  static isWebGPUAvailable() {
    return __async(this, null, function* () {
      return "webgpu" === (yield _n0.detectOptimalBackend()).backend;
    });
  }
  constructor(e20 = {}) {
    super(), this.options = __spreadValues({ detectionInterval: 100, minConfidence: 0.5, smoothing: true, smoothingFactor: 0.3, debug: false, backend: "auto", wasmPath: "https://cdn.jsdelivr.net/npm/@vladmandic/human/dist/", modelBasePath: "https://cdn.jsdelivr.net/npm/@vladmandic/human/models/", async: true, warmup: "face", deallocate: true, noFaceGracePeriod: 2e3, emitOffFrameEvents: true, engagementWeights: { faceDetection: 0.05, eyeOpenness: 0.35, headPose: 0.25, emotionalExpression: 0.25, faceSize: 0.1 } }, e20), this.yr = null, this.br = null, this.humanConfig = { backend: this.options.backend, wasmPath: this.options.wasmPath, modelBasePath: this.options.modelBasePath, async: this.options.async, warmup: this.options.warmup, deallocate: this.options.deallocate, debug: this.options.debug, face: { enabled: true, detector: { rotation: true, minConfidence: this.options.minConfidence, maxDetected: 1 }, mesh: { enabled: true }, iris: { enabled: true }, emotion: { enabled: true, minConfidence: this.options.minConfidence }, description: { enabled: false }, antispoof: { enabled: false }, liveness: { enabled: false } }, body: { enabled: false }, hand: { enabled: false }, object: { enabled: false }, gesture: { enabled: false }, segmentation: { enabled: false } }, this.initialized = false, this.isAnalyzing = false, this.video = null, this.videoId = null, this.gr = null, this.vr = false, this.human = null, this.wr = this.options.detectionInterval, this.previousEmotions = /* @__PURE__ */ new Map(), this.previousEngagement = /* @__PURE__ */ new Map(), this.kr = true, this.Nr = null;
  }
  initialize() {
    return __async(this, null, function* () {
      if (!this.initialized) try {
        if (this.dispatch("loading", { status: "Detecting optimal backend..." }), "auto" === this.options.backend) {
          const e20 = yield _n0.detectOptimalBackend();
          this.yr = e20.backend, this.br = e20.reason, this.humanConfig.backend = e20.backend;
        } else this.yr = this.options.backend, this.br = "Manually specified";
        this.dispatch("loading", { status: "Initializing Human.js..." }), this.human = new t0(this.humanConfig), this.dispatch("loading", { status: "Loading AI models..." }), yield this.human.load(), yield this.human.warmup(), this.initialized = true, console.log("[Sentiment] Human.js | " + this.yr.toUpperCase()), this.dispatch("ready", { status: "Human.js sentiment analyzer ready", backend: this.yr, reason: this.br });
      } catch (e20) {
        const t2 = Error("Human.js initialization failed: " + e20.message);
        throw t2.code = "HUMAN_INIT_FAILED", t2.details = e20, this.dispatch("error", { error: t2 }), t2;
      }
    });
  }
  getBackendInfo() {
    return { backend: this.yr, reason: this.br, isWebGPU: "webgpu" === this.yr, isGPUAccelerated: ["webgpu", "webgl"].includes(this.yr) };
  }
  validateHumanInstance() {
    return __async(this, null, function* () {
      if (!this.human) throw Error("Human instance not created");
      const e20 = document.createElement("canvas");
      e20.width = 100, e20.height = 100;
      const t2 = e20.getContext("2d");
      t2.fillStyle = "white", t2.fillRect(0, 0, 100, 100);
      try {
        const t3 = yield this.human.detect(e20);
        if (!t3 || "object" != typeof t3) throw Error("Invalid detection result structure");
        this.options.debug && console.log("Human.js validation successful:", { resultKeys: Object.keys(t3), hasFace: Array.isArray(t3.face) });
      } catch (n2) {
        throw Error("Human.js validation failed: " + n2.message);
      }
    });
  }
  analyzeVideo(e20, t2) {
    return __async(this, null, function* () {
      if (!this.initialized) throw Error("HumanVideoSentimentAnalyzer must be initialized before use");
      try {
        this.validateVideoElement(e20);
      } catch (n2) {
        throw this.dispatch("error", { error: n2.message, code: n2.code, details: n2.details, videoId: t2 }), n2;
      }
      this.video = e20, this.videoId = t2, this.isAnalyzing = true, this.startDetection();
    });
  }
  startDetection() {
    const e20 = () => __async(this, null, function* () {
      if (this.isAnalyzing) {
        if (!this.vr) {
          this.vr = true;
          try {
            yield this.detectEmotions();
          } finally {
            this.vr = false;
          }
        }
        this.gr = setTimeout(e20, this.wr);
      }
    });
    e20();
  }
  detectEmotions() {
    return __async(this, null, function* () {
      if (!this.video || !this.isAnalyzing) return;
      const e20 = Date.now();
      try {
        const t2 = yield this.human.detect(this.video);
        if (this.options.debug && console.log("[HumanSentimentAnalyzer] Human.js detection result:", { faceCount: t2.face?.length || 0, sampleFace: t2.face?.[0] ? { hasBox: !(!t2.face[0].box && !t2.face[0].boxRaw), hasEmotion: !!t2.face[0].emotion, hasRotation: !!t2.face[0].rotation, hasGaze: !!t2.face[0].gaze, hasIris: !!t2.face[0].iris, emotionCount: t2.face[0].emotion?.length || 0, rotationData: t2.face[0].rotation, gazeData: t2.face[0].gaze } : null }), !t2.face || 0 === t2.face.length) return void this.handleNoFaceDetected(e20);
        const n2 = this.processHumanResults(t2, e20);
        this.kr || (this.kr = true, this.Nr = null, this.dispatch("faceReturned", { videoId: this.videoId, timestamp: e20 }));
        const r2 = this.generateSummary(n2);
        this.dispatch("emotions", __spreadValues({ videoId: this.videoId, timestamp: e20, participants: n2, summary: r2 }, this.options.debug && { performance: { processingTime: t2.performance?.total || 0, currentInterval: this.wr, faceCount: n2.length, backend: this.human.config.backend } }));
      } catch (t2) {
        this.options.debug && console.error("Human.js detection error:", t2), this.dispatch("error", { error: t2.message, videoId: this.videoId });
      }
    });
  }
  processHumanResults(e20, t2) {
    const n2 = [];
    return e20.face.forEach((e21, t3) => {
      const r2 = this.normalizeEmotions(e21.emotion), a2 = this.calculateEngagement(e21, t3), i2 = this.getDominantEmotion(r2);
      this.options.smoothing && this.applySmoothingToEmotions(r2, t3), n2.push(__spreadValues({ id: t3, emotions: r2, dominantEmotion: i2, confidence: i2.confidence, boundingBox: e21.box || e21.boxRaw, engagement: a2 }, this.options.debug && { age: e21.age, gender: e21.gender, gaze: e21.gaze, mesh: e21.mesh }));
    }), n2;
  }
  normalizeEmotions(e20) {
    const t2 = { angry: 0, disgusted: 0, fearful: 0, happy: 0, sad: 0, surprised: 0, neutral: 0 };
    return e20.forEach(({ emotion: e21, score: n2 }) => {
      const r2 = { angry: "angry", disgust: "disgusted", fear: "fearful", happy: "happy", sad: "sad", surprise: "surprised", neutral: "neutral" }[e21] || e21;
      t2.hasOwnProperty(r2) && (t2[r2] = n2);
    }), t2;
  }
  calculateEngagement(e20, t2 = 0) {
    const n2 = { faceDetection: 1, eyeOpenness: this.calculateEyeOpenness(e20), headPose: this.calculateHeadPoseEngagement(e20), emotionalExpression: this.calculateEmotionalIntensity(e20.emotion), faceSize: this.calculateFaceProximity(e20.box || e20.boxRaw) };
    let r2 = 0;
    return Object.entries(this.options.engagementWeights).forEach(([e21, t3]) => {
      r2 += n2[e21] * t3;
    }), this.options.smoothing && (r2 = this.smoothEngagement(t2, r2)), Math.max(0, Math.min(1, r2));
  }
  calculateEyeOpenness(e20) {
    if (e20.iris && 2 === e20.iris.length) {
      let t2 = 0.7;
      return t2 += e20.iris.reduce((e21, t3) => e21 + (t3 ? t3.length : 0), 0) / 20, e20.mesh && e20.mesh.length > 400 && (t2 += 0.3 * (e20.mesh.length / 468 - 0.8)), Math.min(0.95, Math.max(0.4, t2));
    }
    return e20.iris && 1 === e20.iris.length ? 0.45 + 0.1 * Math.random() : e20.mesh && e20.annotations && e20.annotations.leftEyeUpper0 && e20.annotations.rightEyeUpper0 ? 0.4 + e20.mesh.length / 468 * 0.3 : 0.3;
  }
  calculateHeadPoseEngagement(e20) {
    if (e20.rotation && e20.rotation.angle) {
      const { pitch: t2, yaw: n2 } = e20.rotation.angle;
      if ("number" == typeof t2 && "number" == typeof n2 && !isNaN(t2) && !isNaN(n2)) return Math.max(0.1, Math.min(1, 1 - Math.max(Math.abs(t2 * (180 / Math.PI)) / 15, Math.abs(n2 * (180 / Math.PI)) / 20)));
    }
    if (e20.rotation && e20.rotation.gaze) {
      const { bearing: t2, strength: n2 } = e20.rotation.gaze;
      if ("number" == typeof t2 && "number" == typeof n2 && !isNaN(t2) && !isNaN(n2)) return (1 - Math.min(1, Math.abs(t2) / 180)) * n2;
    }
    if (e20.gaze) {
      const { horizontal: t2, vertical: n2 } = e20.gaze;
      if ("number" == typeof t2 && "number" == typeof n2 && !isNaN(t2) && !isNaN(n2)) return 1 - Math.min(1, Math.sqrt(t2 * t2 + n2 * n2));
    }
    return 0.7;
  }
  calculateEmotionalIntensity(e20) {
    if (!e20 || 0 === e20.length) return 0.5;
    const t2 = e20.filter((e21) => "neutral" !== e21.emotion).reduce((e21, t3) => e21 + t3.score, 0);
    return 0 === t2 ? 0.2 : Math.max(0.1, Math.min(1, 0.1 + 1.5 * t2));
  }
  calculateFaceProximity(e20) {
    if (!e20 || !this.video) return 0.5;
    const t2 = Math.max(0.1, Math.min(1, (e20[2] - e20[0]) * (e20[3] - e20[1]) / (this.video.videoWidth * this.video.videoHeight) * 12));
    return isNaN(t2) ? 0.3 : t2;
  }
  applySmoothingToEmotions(e20, t2) {
    const n2 = `${this.videoId}_${t2}`, r2 = this.previousEmotions.get(n2);
    r2 && Object.keys(e20).forEach((t3) => {
      e20[t3] = r2[t3] * this.options.smoothingFactor + e20[t3] * (1 - this.options.smoothingFactor);
    }), this.previousEmotions.set(n2, __spreadValues({}, e20));
  }
  smoothEngagement(e20, t2) {
    const n2 = `${this.videoId}_${e20}`, r2 = this.previousEngagement.get(n2);
    if (!r2) return this.previousEngagement.set(n2, t2), t2;
    const a2 = r2 * this.options.smoothingFactor + t2 * (1 - this.options.smoothingFactor);
    return this.previousEngagement.set(n2, a2), a2;
  }
  handleNoFaceDetected(e20) {
    if (!this.options.emitOffFrameEvents) return;
    this.options.debug && console.log("No face detected", { videoId: this.videoId, timestamp: e20 }), this.kr && (this.kr = false, this.Nr = e20, this.dispatch("faceLeft", { videoId: this.videoId, timestamp: e20 }));
    const t2 = this.options.noFaceGracePeriod > e20 - this.Nr, n2 = [this.createOffFrameParticipant(e20, t2)], r2 = this.generateSummary(n2);
    if (this.dispatch("emotions", { videoId: this.videoId, timestamp: e20, participants: n2, summary: r2 }), !t2 && this.Nr) {
      const t3 = e20 - this.Nr;
      this.options.noFaceGracePeriod > t3 - this.wr && this.dispatch("userOffFrame", { videoId: this.videoId, timestamp: e20, duration: t3 });
    }
  }
  createOffFrameParticipant(e20, t2) {
    return { id: this.videoId || "off-frame", emotions: { neutral: 0.8, happy: 0.05, sad: 0.05, angry: 0.05, fearful: 0.025, disgusted: 0.025, surprised: 0.025 }, dominantEmotion: { emotion: "neutral", confidence: 0.8 }, confidence: 0.8, boundingBox: null, engagement: t2 ? 0.1 : 0, offFrame: true, gracePeriod: t2, timestamp: e20 };
  }
  getDominantEmotion(e20) {
    let t2 = "neutral", n2 = 0;
    return Object.entries(e20).forEach(([e21, r2]) => {
      r2 > n2 && (n2 = r2, t2 = e21);
    }), { emotion: t2, confidence: n2 };
  }
  generateSummary(e20) {
    if (0 === e20.length) return "No participants detected";
    const t2 = e20.map((e21) => e21.dominantEmotion.emotion).reduce((e21, t3) => (e21[t3] = (e21[t3] || 0) + 1, e21), {}), n2 = Object.entries(t2).sort(([, e21], [, t3]) => t3 - e21)[0][0], r2 = e20.reduce((e21, t3) => e21 + t3.engagement, 0) / e20.length;
    return `${e20.length} participant(s), mood: ${n2}, engagement: ${r2 > 0.7 ? "high" : r2 > 0.4 ? "medium" : "low"}`;
  }
  validateVideoElement(e20) {
    if (!(e20 && e20 instanceof HTMLVideoElement)) {
      const e21 = Error("Invalid video element");
      throw e21.code = "INVALID_VIDEO_ELEMENT", e21;
    }
    if (e20.readyState < HTMLVideoElement.HAVE_METADATA) {
      const e21 = Error("Video not ready");
      throw e21.code = "VIDEO_NOT_READY", e21;
    }
    const t2 = e20.videoWidth || e20.width, n2 = e20.videoHeight || e20.height;
    if (!t2 || !n2 || 10 > t2 || 10 > n2) {
      const e21 = Error("Video dimensions too small");
      throw e21.code = "INVALID_VIDEO_DIMENSIONS", e21;
    }
  }
  dispatch(e20, t2) {
    this.dispatchEvent(new CustomEvent(e20, { detail: t2 }));
  }
  stopAnalysis() {
    this.isAnalyzing = false, this.gr && (clearTimeout(this.gr), this.gr = null), this.video = null, this.videoId = null;
  }
  setDebugMode(e20) {
    this.options.debug = e20, this.human && (this.human.config.debug = e20);
  }
  canDetectFaces(e20 = null) {
    return __async(this, null, function* () {
      const t2 = { possible: true, reasons: [], environment: null, models: null, video: null };
      if (this.human && (t2.environment = this.human.env, t2.environment.webgl || (t2.possible = false, t2.reasons.push("WebGL not available"))), this.initialized ? t2.models = { loaded: true, count: Object.keys(this.human.models).length } : (t2.possible = false, t2.reasons.push("Analyzer not initialized")), e20) try {
        this.validateVideoElement(e20), t2.video = { valid: true };
      } catch (n2) {
        t2.possible = false, t2.video = { valid: false, error: n2.message }, t2.reasons.push("Video issue: " + n2.message);
      }
      return t2;
    });
  }
  getPerformanceStats() {
    return this.human ? { backend: this.yr, backendReason: this.br, isWebGPU: "webgpu" === this.yr, isGPUAccelerated: ["webgpu", "webgl"].includes(this.yr), performance: this.human.performance, models: Object.keys(this.human.models || {}), currentInterval: this.wr, env: this.human.env } : {};
  }
  getModelInfo() {
    if (!this.human) return { initialized: false };
    const e20 = this.human.env || {}, t2 = this.human.config || {}, n2 = this.human.models || {};
    return { initialized: this.initialized, backend: { selected: this.yr, reason: this.br, isWebGPU: "webgpu" === this.yr, isGPUAccelerated: ["webgpu", "webgl"].includes(this.yr), tfjs: e20.tfjs || "unknown" }, environment: { browser: e20.browser || "unknown", platform: e20.platform || "unknown", agent: e20.agent || "unknown", webgl: e20.webgl || false, webgpu: e20.webgpu || false, wasm: e20.wasm || false, cpu: { cores: e20.cores || navigator?.hardwareConcurrency || "unknown" }, gpu: e20.gpu || "unknown", memory: e20.memory || "unknown" }, modelConfig: { basePath: t2.modelBasePath || this.options.modelBasePath, wasmPath: t2.wasmPath || this.options.wasmPath, face: { enabled: t2.face?.enabled || false, detector: t2.face?.detector || {}, mesh: t2.face?.mesh?.enabled || false, iris: t2.face?.iris?.enabled || false, emotion: t2.face?.emotion?.enabled || false } }, loadedModels: Object.entries(n2).map(([e21, t3]) => __spreadValues(__spreadValues({ name: e21, loaded: !!t3 }, t3?.modelUrl && { url: t3.modelUrl }), t3?.inputShape && { inputShape: t3.inputShape })), performance: this.human.performance || {} };
  }
  destroy() {
    this.stopAnalysis(), this.human && (this.human = null), this.previousEmotions.clear(), this.previousEngagement.clear();
  }
};
var r0 = class extends EventTarget {
  constructor(e20 = {}) {
    super(), this.options = __spreadValues({ backend: "auto" }, e20), this.analyzers = /* @__PURE__ */ new Map(), this.initialized = false, this.sharedHuman = null, this.yr = null, this.br = null;
  }
  initialize() {
    return __async(this, null, function* () {
      if (this.initialized) return;
      let e20 = this.options.backend;
      if ("auto" === e20) {
        const t2 = yield n0.detectOptimalBackend();
        e20 = t2.backend, this.yr = t2.backend, this.br = t2.reason;
      } else this.yr = e20, this.br = "Manually specified";
      this.sharedHuman = new t0({ backend: e20, wasmPath: this.options.wasmPath || "https://cdn.jsdelivr.net/npm/@vladmandic/human/dist/", modelBasePath: this.options.modelBasePath || "https://cdn.jsdelivr.net/npm/@vladmandic/human/models/", async: false, deallocate: false, face: { enabled: true, detector: { rotation: false, maxDetected: 1 }, mesh: { enabled: true }, iris: { enabled: true }, emotion: { enabled: true } }, body: { enabled: false }, hand: { enabled: false }, object: { enabled: false }, gesture: { enabled: false }, segmentation: { enabled: false } }), yield this.sharedHuman.load(), yield this.sharedHuman.warmup(), this.initialized = true, console.log("[Sentiment] Human.js (Multi) | " + this.yr.toUpperCase());
    });
  }
  getBackendInfo() {
    return { backend: this.yr, reason: this.br, isWebGPU: "webgpu" === this.yr, isGPUAccelerated: ["webgpu", "webgl"].includes(this.yr) };
  }
  addVideo(e20, t2) {
    return __async(this, null, function* () {
      if (!this.initialized) throw Error("Manager must be initialized before adding videos");
      this.removeVideo(e20);
      const n2 = new n0(this.options);
      n2.human = this.sharedHuman, n2.initialized = true, n2.addEventListener("emotions", (e21) => {
        this.dispatchEvent(new CustomEvent("emotions", { detail: e21.detail }));
      }), n2.addEventListener("error", (e21) => {
        this.dispatchEvent(new CustomEvent("error", { detail: e21.detail }));
      }), n2.addEventListener("faceLeft", (e21) => {
        this.dispatchEvent(new CustomEvent("faceLeft", { detail: e21.detail }));
      }), n2.addEventListener("faceReturned", (e21) => {
        this.dispatchEvent(new CustomEvent("faceReturned", { detail: e21.detail }));
      }), n2.addEventListener("userOffFrame", (e21) => {
        this.dispatchEvent(new CustomEvent("userOffFrame", { detail: e21.detail }));
      }), this.analyzers.set(e20, n2), yield n2.analyzeVideo(t2, e20);
    });
  }
  removeVideo(e20) {
    const t2 = this.analyzers.get(e20);
    t2 && (t2.stopAnalysis(), this.analyzers.delete(e20));
  }
  setDebugMode(e20) {
    this.options.debug = e20, this.analyzers.forEach((t2) => t2.setDebugMode(e20)), this.sharedHuman && (this.sharedHuman.config.debug = e20);
  }
  getPerformanceStats() {
    return { analyzers: this.analyzers.size, backend: this.yr, backendReason: this.br, isWebGPU: "webgpu" === this.yr, isGPUAccelerated: ["webgpu", "webgl"].includes(this.yr), performance: this.sharedHuman?.performance, models: this.sharedHuman ? Object.keys(this.sharedHuman.models) : [] };
  }
  getModelInfo() {
    if (!this.sharedHuman) return { initialized: false };
    const e20 = this.sharedHuman.env || {}, t2 = this.sharedHuman.config || {}, n2 = this.sharedHuman.models || {};
    return { initialized: this.initialized, activeAnalyzers: this.analyzers.size, backend: { selected: this.yr, reason: this.br, isWebGPU: "webgpu" === this.yr, isGPUAccelerated: ["webgpu", "webgl"].includes(this.yr), tfjs: e20.tfjs || "unknown" }, environment: { browser: e20.browser || "unknown", platform: e20.platform || "unknown", agent: e20.agent || "unknown", webgl: e20.webgl || false, webgpu: e20.webgpu || false, wasm: e20.wasm || false, cpu: { cores: e20.cores || ("undefined" != typeof navigator ? navigator.hardwareConcurrency : "unknown") }, gpu: e20.gpu || "unknown", memory: e20.memory || "unknown" }, modelConfig: { basePath: t2.modelBasePath, wasmPath: t2.wasmPath, face: { enabled: t2.face?.enabled || false, detector: t2.face?.detector || {}, mesh: t2.face?.mesh?.enabled || false, iris: t2.face?.iris?.enabled || false, emotion: t2.face?.emotion?.enabled || false } }, loadedModels: Object.entries(n2).map(([e21, t3]) => ({ name: e21, loaded: !!t3 })), performance: this.sharedHuman.performance || {} };
  }
  destroy() {
    this.analyzers.forEach((e20) => e20.stopAnalysis()), this.analyzers.clear(), this.sharedHuman = null, this.initialized = false;
  }
};
export {
  r0 as HumanMultiVideoSentimentManager,
  n0 as HumanVideoSentimentAnalyzer
};
//# sourceMappingURL=HumanSentimentAnalyser-B0jGsjJ0-3V542Z62.js.map

{
  "version": 3,
  "sources": ["../../../../../../node_modules/@angular/core/fesm2022/not_found.mjs", "../../../../../../node_modules/@angular/core/fesm2022/primitives/di.mjs"],
  "sourcesContent": ["/**\n * @license Angular v20.3.16\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector = undefined;\nfunction getCurrentInjector() {\n    return _currentInjector;\n}\nfunction setCurrentInjector(injector) {\n    const former = _currentInjector;\n    _currentInjector = injector;\n    return former;\n}\nfunction inject(token, options) {\n    const currentInjector = getCurrentInjector();\n    if (!currentInjector) {\n        throw new Error('Current injector is not set.');\n    }\n    if (!token.ɵprov) {\n        throw new Error('Token is not an injectable');\n    }\n    return currentInjector.retrieve(token, options);\n}\n\n/**\n * Value returned if the key-value pair couldn't be found in the context\n * hierarchy.\n */\nconst NOT_FOUND = Symbol('NotFound');\n/**\n * Error thrown when the key-value pair couldn't be found in the context\n * hierarchy. Context can be attached below.\n */\nclass NotFoundError extends Error {\n    name = 'ɵNotFound';\n    constructor(message) {\n        super(message);\n    }\n}\n/**\n * Type guard for checking if an unknown value is a NotFound.\n */\nfunction isNotFound(e) {\n    return e === NOT_FOUND || e?.name === 'ɵNotFound';\n}\n\nexport { NOT_FOUND, NotFoundError, getCurrentInjector, inject, isNotFound, setCurrentInjector };\n\n", "/**\n * @license Angular v20.3.16\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nexport { NOT_FOUND, NotFoundError, getCurrentInjector, inject, isNotFound, setCurrentInjector } from '../not_found.mjs';\n\nfunction defineInjectable(opts) {\n    return {\n        token: opts.token,\n        providedIn: opts.providedIn || null,\n        factory: opts.factory,\n        value: undefined,\n    };\n}\nfunction registerInjectable(ctor, declaration) {\n    ctor.ɵprov = declaration;\n    return ctor;\n}\n\nexport { defineInjectable, registerInjectable };\n\n"],
  "mappings": ";AAYA,IAAI,mBAAmB;AACvB,SAAS,qBAAqB;AAC1B,SAAO;AACX;AACA,SAAS,mBAAmB,UAAU;AAClC,QAAM,SAAS;AACf,qBAAmB;AACnB,SAAO;AACX;AACA,SAAS,OAAO,OAAO,SAAS;AAC5B,QAAM,kBAAkB,mBAAmB;AAC3C,MAAI,CAAC,iBAAiB;AAClB,UAAM,IAAI,MAAM,8BAA8B;AAAA,EAClD;AACA,MAAI,CAAC,MAAM,OAAO;AACd,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAChD;AACA,SAAO,gBAAgB,SAAS,OAAO,OAAO;AAClD;AAMA,IAAM,YAAY,OAAO,UAAU;AAKnC,IAAM,gBAAN,cAA4B,MAAM;AAAA,EAC9B,OAAO;AAAA,EACP,YAAY,SAAS;AACjB,UAAM,OAAO;AAAA,EACjB;AACJ;AAIA,SAAS,WAAW,GAAG;AACnB,SAAO,MAAM,aAAa,GAAG,SAAS;AAC1C;;;AC5CA,SAAS,iBAAiB,MAAM;AAC5B,SAAO;AAAA,IACH,OAAO,KAAK;AAAA,IACZ,YAAY,KAAK,cAAc;AAAA,IAC/B,SAAS,KAAK;AAAA,IACd,OAAO;AAAA,EACX;AACJ;AACA,SAAS,mBAAmB,MAAM,aAAa;AAC3C,OAAK,QAAQ;AACb,SAAO;AACX;",
  "names": []
}
